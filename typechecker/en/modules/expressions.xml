<chapter id="expressions">
    <title>Expressions</title>
    
    <para>Ceylon expressions are significantly more powerful than Java, allowing a 
    more declarative style of programming.</para>
    
    <para>Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values, special values, and metamodel references,</para>
        </listitem>
        <listitem>
            <para>enumerated instance references,</para>
        </listitem>
        <listitem>
            <para>method references,</para>
        </listitem>
        <listitem>
            <para>invocation of methods and instantiation of classes,</para> 
        </listitem>
        <listitem>
            <para>evaluation and assignment of attributes,</para>
        </listitem>
        <listitem>
            <para>enumeration of sequences, and</para>
        </listitem>
        <listitem>
            <para>operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>An <emphasis>atom</emphasis> is a literal or special value, an enumerated 
    sequence of expressions, or a parenthesized expression.</para>
    
    <programlisting>Atom := Literal | StringTemplate | SpecialValue | Enumeration | ParExpression</programlisting>
    
    <para>A <emphasis>primary</emphasis> is formed by recursively invoking or evaluating 
    members of an atom or toplevel method or class.</para>
    
    <programlisting>Primary := Atom | EnumeratedInstanceReference | MethodReference | Invocation | Evaluation</programlisting>
    
    <para>More complex expressions are formed by combining expressions using operators, 
    including assignment operators.</para>    
    
    <programlisting>Expression := Primary | Assignment | OperatorExpression | Meta</programlisting>
    
    <para>Parentheses are used for grouping:</para>
    
    <programlisting>ParExpression := "(" Expression ")"</programlisting>
    
    <para>Ceylon expressions are validated for typesafety at compile time.
    To determine whether an expression is assignable to a program element 
    such as an attribute, local or formal parameter, Ceylon considers:</para>
    
    <itemizedlist>
        <listitem>
            <para>the <emphasis>type</emphasis> of the expression (the type of the
            objects that are produced when the expression is evaluated), and</para>
        </listitem>
        <listitem>
            <para>the nullability of the expression (whether it can evaluate to 
            <literal>null</literal>).</para>
        </listitem>
    </itemizedlist>
    
    <para>If an expression can evaluate to <literal>null</literal>, we say it is
    of <literal>optional</literal> type. Otherwise, we say it is of 
    non-<literal>optional</literal> type. For a nullable expression of type 
    <literal>T</literal>, we often say that its type is <literal>optional T</literal>.</para>
    
    <para>An expression is assignable to a program element if:</para>
    
    <itemizedlist>
        <listitem>
            <para>the type of the expression is assignable to the declared type of 
            the program element, and</para>
        </listitem>
        <listitem>
            <para>the expression is non-<literal>optional</literal>, or the program 
            element is declared <literal>optional</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <comment><para>TODO: We need to allow some way to have an expression to be 
    specified as a toplevel element, for DSLs.</para></comment>
    
    <section id="literals">
    <title>Literals</title>
    
    <para><!--Since Ceylon is a language for expressing not only instructions, but also 
    structured data, the language supports parsed literals for dates and times
    in addition to numeric and string datatypes.--> Ceylon supports literal values
    of the following types:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>Natural</literal> and <literal>Float</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Character</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>String</literal>, and</para>
        </listitem>
        <listitem>
            <para><literal>Quoted</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon does not need a special syntax for <literal>Boolean</literal> literal 
    values, since <literal>Boolean</literal> is just a <literal>Selector</literal>
    with the enumerated instances <literal>true</literal> and <literal>false</literal>.</para>
    
    <programlisting>Literal := NaturalLiteral | FloatLiteral | CharacterLiteral | StringLiteral | QuotedLiteral</programlisting>

    <para>All literal values are instances of immutable types. The value of a literal 
    expression is an instance of the type. How this instance is produced is not specified 
    here.</para>
    
    <para>All literal values are expressions of non-<literal>optional</literal> type.</para>
    
    <!--section id="datetime">
        <title><literal>Date</literal> and <literal>Time</literal> literals</title>
        
        <para>A <literal>Date</literal> literal has the form:</para>
        
        <programlisting>DateLiteral := 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <para>A <literal>Time</literal> literal has the form:</para>
        
        <programlisting>TimeLiteral := 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>A <literal>Datetime</literal> may be composed from a <literal>Date</literal> and 
        a <literal>Time</literal> using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <comment><para>TODO: alternatively, we could follow RFC3339-style datetimes, for example:
        <literal>1996-12-19T16:39:57-08:00</literal>.</para></comment>
        
        <comment><para>TODO: should we allow wildcards and ranges, to get cron-style expressions 
        like <literal>'1/*/*' @ '00:00 GMT'</literal>?</para></comment>
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section-->
    
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Natural</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
    <section id="naturalnumber">
        <title>Natural number literals</title>
        
        <para>A natural number literal is an expression of type
        <literal>lang.Natural</literal>.</para>
        
        <programlisting>Natural m = n + 10;</programlisting>
        
        <para>Negative <literal>Integer</literal> values can be 
        produced using the unary <literal>-</literal> operator:</para>
        
        <programlisting>Integer i = -1;</programlisting>
        
    </section>
    
    <section id="floatnumber">
        <title>Floating point number literals</title>
        
        <para>A floating point number literal is an expression of 
        type <literal>lang.Float</literal>.</para>
        
       <programlisting>public Float pi = 3.14159;</programlisting>
        
        <!--
        <para>Equivalent to this Java code:</para>
        
        <programlisting>public final Float pi = new lang.Float(3.14159f);</programlisting>
        -->

    </section>
    
    <section id="character">
        <title>Character literals</title>
        
        <para>A single character literal is an expression of type 
        <literal>lang.Character</literal>.</para>
                
        <programlisting>if ( string[i] == @+ ) { ... }</programlisting>
        
        <!--
        <para>Equivalent to this Java code:</para>
        
        <programlisting>if ( string.at(i).equals( new lang.Character('+') ) ) { ... }</programlisting>
        -->        
        <comment><para>TODO: do we really need character literals?</para></comment>
        
    </section>
    
    <section id="string">
        <title>Character string literals</title>
        
        <para>A character string literal is an expression of type
        <literal>lang.String</literal>.</para>
        
        <programlisting>person.name := "Gavin King";</programlisting>
        
        <programlisting>String multiline = "Strings may
span multiple lines
if you prefer.";</programlisting>

        <programlisting>display("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</programlisting>
        
        <!--
        <para>Equivalent to the following Java code:</para>
        
        <programlisting>person.name().set( new lang.String("Gavin") );</programlisting>
        
        <programlisting>log.info( new lang.String( Time(), " ", message ) );</programlisting>
        
        <programlisting>final lang.String multiline = new lang.String("Strings may\nspan multiple lines\nif you prefer.");</programlisting>
        
        <programlisting>display( new lang.String( "Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n") );</programlisting>
        -->
        
    </section>
    
    <section id="quoted">
        <title>Single quoted literals</title>
        
        <para>Single-quoted strings are used to express literal values for dates, 
        times, regexes and hexadecimal numbers, and even for more domain-specific 
        things like names, cron expressions, internet addresses, and phone numbers.
        This is an important facility since Ceylon is a language for expressing 
        structured data.</para>
        
        <para>A single quoted literal is an expression of type 
        <literal>lang.Quoted</literal>. An extension is responsible for converting 
        it to the appropriate type.</para>
                
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        <programlisting>Boolean isEmail = email.matches( '^\w+@((\w+)\.)+$' );</programlisting>
        <programlisting>Cron schedule = '0 0 23 ? * MON-FRI';</programlisting>
        <programlisting>Color color = 'FF3B66';</programlisting>
        <programlisting>Url url = 'http://jboss.org/ceylon';</programlisting>
        <programlisting>mail.to:='gavin@hibernate.org';</programlisting>
        <programlisting>PhoneNumber ph = '+1 (404) 129 3456';</programlisting>
        <programlisting>Duration duration = '1h 30m';</programlisting>
        
        <para>Extensions that apply to the type <literal>Quoted</literal> are
        evaluated at compile time for single-quoted literals, alowing compile-time
        validation of the contents of the single-quoted string.</para>
        
        <programlisting>public extension Date date(Quoted dateString) { return ... }</programlisting>
        <programlisting>public extension class Regex(Quoted expression) { return ... }</programlisting>
        
        <comment><para>TODO: we should try to support interpolated expressions, 
        just like we do for string literals.</para></comment>
        
        <comment><para>TODO: Quoted literals are used for version numbers and version 
        constraints in the module architecture, for example: <literal>'1.2.3BETA'</literal>.</para></comment>
    
    </section>

    </section>

    <section id="stringtemplates">
        <title>String templates</title>
        
        <para>A character string <emphasis>template</emphasis> contains interpolated 
        expressions, surrounded by character string fragments.</para>
        
        <programlisting>StringTemplate := StringLiteral (Expression? StringLiteral)+</programlisting>
        
        <para>A character string template is an expression of non-<literal>optional</literal> 
        type <literal>StringTemplate</literal>.</para>
        
        <!--
        <programlisting>InterpolatedStringLiteral := LStringLiteral Expression (MStringLiteral Expression)* RStringLiteral</programlisting>
        -->
        
        <programlisting>log.info("Hello, " person.firstName " " person.lastName ", the time is " Time() ".");</programlisting>
        
        <programlisting>log.info("1 + 1 = " 1 + 1 "");</programlisting>
        
        <para>An interpolated expression in a string template may invoke or evaluate:</para>
        
        <itemizedlist>
            <listitem>
                <para>any class member that is visible to the containing scope in 
                which the literal appears, and</para>
            </listitem>
            <listitem>
                <para>any non-<literal>mutable</literal> local, block local attribute 
                getter or block local method declared earlier within the containing 
                scope.</para>
            </listitem>
        </itemizedlist>
        
        <para>An interpolated expression in a string template may not refer to 
        <literal>mutable</literal> locals from the containing scope.</para>
        
        <para>Interpolated expressions are evaluated when the <literal>interpolate()</literal>
        method of <literal>StringTemplate</literal> is called to produce a constant 
        character string.</para>

    </section>
    
    <section id="specialvalues">
        <title><literal>this</literal>, <literal>super</literal>, 
        <literal>null</literal> and <literal>none</literal></title>
        
        <para>The type of the following special values depends upon
        the context in which they appear.</para>
        
        <programlisting>SpecialValue := "this" | "super" | "null" | "none"</programlisting>
        
        <para>The keyword <literal>null</literal> refers to a special
        value that is assignable to all <literal>optional</literal> 
        types, and never to non-<literal>optional</literal> types. The 
        Ceylon language and compiler ensures that this value never
        receives any invocation.</para>
        
        <para>The keyword <literal>super</literal> refers to the
        current instance (the instance that is being invoked), and has
        the same members as the immediate superclass of the class,
        except for <literal>fixed</literal> members. It is an expression 
        of non-<literal>optional</literal> type. Any invocation of this 
        reference is processed by the method or attribute defined or 
        inherited by this superclass, bypassing any method declaration 
        that overrides the method on the current class or any subclass 
        of the current class. Invocation of <literal>fixed</literal> 
        members upon <literal>super</literal> is not allowed. The 
        <literal>super</literal> reference is not assignable to any 
        type.</para>
        
        <para>The keyword <literal>this</literal> refers to the current 
        instance, and is assignable to both the type of the current 
        class (the class which declares the method being invoked), and 
        to the special type <literal>subtype</literal>, representing 
        the concrete type of the current instance. It is an expression 
        of non-<literal>optional</literal> type.</para>
        
        <para>The keyword <literal>none</literal> refers to a special
        value that is assignable to <literal>Sequence</literal>. It is 
        an expression of non-<literal>optional</literal> type. This value 
        has no elements.</para>
        
    </section>
    
    <section id="typemember">
        <title>Metamodel references</title>
        
        <para>The <literal>Type</literal> object for a type, the <literal>Method</literal>
        object for a method, or the <literal>Attribute</literal> object for an attribute
        may be referred to using a special syntax.</para>
        
        <programlisting>Meta := TypeMeta | MemberMeta</programlisting>
        
        <programlisting>TypeMeta := HASH Type</programlisting>
        
        <programlisting>MemberMeta := HASH (Type ".")? MemberName</programlisting>
               
        <para>Metamodel references are compile-time typesafe.</para>
        
        <programlisting>Type&lt;List&lt;String&gt;&gt; stringListType = #List&lt;String&gt;;</programlisting>
        <programlisting>Attribute&lt;Person, String&gt; nameAttribute = #Person.name;</programlisting>
        <programlisting>Method&lt;Person, String&gt;&gt; sayMethod = #Person.say;</programlisting>
        <programlisting>Attribute&lt;Counter, Natural&gt; countAttribute = #count;</programlisting>
        
        <comment><para>TODO: Would it be better to require the <literal>#</literal> 
        before the member name even when qualified by the type, for example, 
        <literal>#Person.#name</literal>?</para></comment>
        
        <comment><para>TODO: According to this, we can "curry" in type arguments of
        the type. We need this. But if so, why can't we curry type arguments of the 
        member?</para></comment>
            
    </section>

    <section id="enumeratedinstancereferences">
        <title>Enumerated instance references</title>
        
        <para>An enumerated instance of a class is identified according to:</para> 
        
        <programlisting>EnumeratedInstanceReference := (Type ".")? MemberName</programlisting>
        
        <para>The value of an enumerated instance reference is the instance of
        the class that was instantiated when the class was loaded by the virtual
        machine.</para>
        
        <programlisting>DayOfWeek sunday = DayOfWeek.sun;</programlisting>
        
        <para>An enumerated instance reference is an expression of non-<literal>optional</literal> 
        type.</para>
        
    </section>
    
    <section id="methodreferences">
        <title>Method references</title>
        
        <para>A <emphasis>method reference</emphasis> is an invocable reference to an 
        instance method, toplevel method, attribute getter or setter or type constructor:</para>
        
        <programlisting>MethodReference := OrdinaryMethodReference | AttributeReference | ConstructorReference</programlisting>

        <para>An ordinary method reference is a reference to an instance or toplevel method.</para>

        <programlisting>OrdinaryMethodReference := Receiver? MemberName</programlisting>

        <para>A <emphasis>constructor reference</emphasis> is a reference to an implicit method 
        with a signature that depends upon the formal parameters of the class. For a class 
        <literal>T</literal>, the constructor method has non-<literal>optional</literal> return 
        type <literal>T</literal> and the same formal parameters as the class.</para>
        
        <programlisting>ConstructorReference := Receiver? Type</programlisting>
         
        <para>A <emphasis>getter or setter method reference</emphasis> is a reference to an 
        implicit method with a signature that depends upon the attribute type. For an attribute 
        of type <literal>T</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>The getter method has no formal parameters, return type
                <literal>T</literal>, and is of <literal>optional</literal> type if and
                only if the attribute is declared <literal>optional</literal>.</para>
            </listitem>
            <listitem>
                <para>If the attribute is <literal>mutable</literal>, the <literal>void</literal> 
                setter method has a single formal parameter of type <literal>T</literal>
                of <literal>optional</literal> type if and only if the attribute is declared 
                <literal>optional</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>AttributeReference := ("set" | "get")? Receiver? MemberName</programlisting>
        
        <para>The keyword <literal>get</literal> or <literal>set</literal> in an attribute 
        reference determines if it is the attribute getter or setter that is referred to.</para>
            
        <comment><para>TODO: Here are a couple of alternative syntax possibilities for attribute
        getter/setter references:</para>
        <itemizedlist>
            <listitem><literal>get(foo.bar)</literal> and <literal>set(foo.bar)</literal></listitem>
            <listitem><literal>foo.get:bar</literal> and <literal>foo.set:bar</literal></listitem>
            <listitem><literal>foo.bar get</literal> and <literal>foo.bar set</literal></listitem>
        </itemizedlist>
        </comment>
        
        <comment><para>TODO: do we even really, truly need attribute references? If we can't find
        an elegant syntax, maybe we can simply live without them...</para></comment>
        
        <section>
            <title>Receiver expressions</title>
        
        <para>Instance method references, attribute getter and setter references, and
        member class constructor references specify a name of a member, an invocation 
        operator, and a <emphasis>receiver expression</emphasis> that evaluates to an 
        instance or <literal>Iterable</literal> set of instances of a type that 
        has a member with that name.</para>
        
        <programlisting>Receiver := Primary InvocationOperator</programlisting>
        
        <para>Otherwise, if no receiver expression is explicitly specified, the reference
        is to a toplevel method or class, or the current object is the receiver.</para>
        
        <!--
        <para>A reference to a block local method, block local type constructor, or local
        getter/setter is a special case. There is no receiving instance or invocation 
        operator.</para>
        -->
        
        <para>When the method reference expression is executed, the receiver expression
        is evaluated and a reference to the resulting value is held with the method 
        reference.</para>
        
        </section>
        
        <section>
            <title>Invocation operators</title>
            
        <para>References to instance methods, attributes, and member classes use one of three 
        different invocation operators.</para>
        
        <programlisting>InvocationOperator := "." | "?." | "*."</programlisting>
        
        <para>The invocation operator depends upon the type of the receiver expression. If 
        <literal>X</literal> is the type that has the instance method, attribute, or member 
        type, the invocation operator must be:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>.</literal> if the expression is of non-<literal>optional</literal> 
                type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>.?</literal> if the expression is of type <literal>optional X</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>.*</literal> if the expression is of non-<literal>optional</literal> 
                type <literal>Iterable&lt;X&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <section>
            <title>Specifying a method reference as a method implementation or functional
            parameter argument</title>
            
        <para>A method reference may be used to define a method using <literal>=</literal>.</para>
        
        <programlisting>Comparison order(X x, Y y) = Order.reverse;</programlisting>
        
        <programlisting>void display(String message) = log.info;</programlisting>
        
        <programlisting>String newString(Character... chars) = String;</programlisting>
        
        <para>Method references may appear as an argument to a functional parameter, either as 
        a positional argument, or as an argument specified using <literal>=</literal> in a named 
        parameter invocation.</para>
        
        <para>This method has a functional parameter:</para>
        
        <programlisting>void sort(List&lt;String&gt; list, Comparison by(String x, String y)) { ... }</programlisting>

        <para>This code passes a reference to a local method with a conforming signature to 
        the method.</para>
        
        <programlisting>Comparison reverseAlpha(String x, String y) { return y&lt;=&gt;x }
sort(names, reverseAlpha);</programlisting>
        
        <para>This class has two functional parameters:</para>
        
        <programlisting>public class TextInput(Natural size=30, String onInit(), void onUpdate(String s)) { ... }</programlisting>
 
        <para>This code instantiates the class, passing references to the getter/setter method 
        pair of an attribute:</para>
        
        <programlisting>TextInput it = TextInput { 
    size=15; 
    onInit = get person.name; 
    onUpdate = set person.name; 
}</programlisting>

        <para>Method references do not, strictly speaking, have types. However, the signature
        of a method reference determines if it can appear to the right of the <literal>=</literal>
        specifier in a method declaration, or as an argument to a functional parameter. In this
        case we say the method reference <emphasis>conforms</emphasis> to the signature of the
        method or functional parameter.</para>

        <para>A method reference <emphasis>conforms</emphasis> to a method or functional parameter 
        signature if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the return type of the method reference is assignable to the declared
                return type of the method or functional parameter,</para>
            </listitem>
            <listitem>
                <para>the method reference is not declared <literal>optional</literal>, unless 
                the method or functional parameter is declared <literal>optional</literal>, 
                and</para>
            </listitem>
            <listitem>
                <para> the method reference has exactly the same number of formal parameters, 
                with the same types, as the method or functional parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>Thus, method signatures are covariant in return type, and nonvariant in parameter 
        types.</para>
        
        <comment><para>TODO: could we make method references contravariant in the parameter
        types? If so, we should use the same rule for overriding.</para></comment>
        
        <comment><para>TODO: does a method with a defaulted parameter conform to a method 
        signature without that parameter?</para></comment>
        
        </section>
        
        <section>
            <title>Returning a method reference from a method</title>
            
        <para>A method reference may be returned by a method with multiple parameter lists.
        The reference must conform to the signature of the method, after elimination of the 
        first parameter list.</para>
        
        <programlisting>Comparison getOrder(Boolean reverse=false)(Natural x, Natural y) {
    if (reverse) {
        Comparison reverse(Natural x, Natural y) { return y&lt;=&gt;x }
        return reverse
    else {
        Comparison natural(Natural x, Natural y) { return x&lt;=&gt;y }
        return natural
    }
}</programlisting>

        <para>This is slightly simpler using type inference:</para>

        <programlisting>Comparison getOrder(Boolean reverse=false)(Natural x, Natural y) {
    if (reverse) {
        local reverse(Natural x, Natural y) { return y&lt;=&gt;x }
        return reverse
    else {
        local natural(Natural x, Natural y) { return x&lt;=&gt;y }
        return natural
    }
}</programlisting>

        <para>Calling a method with multiple parameter lists is similar to the operation of
        "currying" in a functional programming language.</para>
        
        <programlisting>Comparison order(Natural x, Natural y) = getOrder();
Comparison comp = order(1,-1);</programlisting>

        <para>This is even simpler using type inference:</para>

        <programlisting>local order(Natural x, Natural y) = getOrder();
local comp = order(1,-1);</programlisting>

        <para>Of course, more than one argument list may be specified in a single expression:</para>
        
        <programlisting>Comparison comp = getOrder(true)(10, 100);</programlisting>
        
        </section>
        
    </section>

    <section id="invocation">
        <title>Invocation</title>
        
        <para>Methods references are <emphasis>invokable</emphasis>. An 
        <emphasis>invocation</emphasis> consists of an expression that evaluates to a 
        method reference, together with an argument list.</para>
        
        <programlisting>Invocation := Primary TypeArguments? Arguments</programlisting>
            
        <para>An invocation must specify arguments for parameters, either by listing or naming 
        parameter values.</para>
        
        <programlisting>Arguments := PositionalArguments FunctionalArguments? | NamedArguments</programlisting>
        
        <para>Arguments to required parameters must be specified by the caller. Arguments to 
        defaulted parameters and varargs may optionally be specified.</para>
        
        <para>For a required or defaulted formal parameter of declared type <literal>T</literal>, 
        the type of the argument expression must be assignable to <literal>T</literal>. The
        argument expression must be of non-<literal>optional</literal> type, unless the formal
        parameter is annotated <literal>optional</literal>.</para>
        
        <para>For a varargs parameter of declared type <literal>T...</literal>, there may either:</para>
        
        <itemizedlist>
            <listitem>
                <para>be a single argument expression of non-<literal>optional</literal> type 
                assignable to <literal>Iterable&lt;T&gt;</literal>, or</para>
            </listitem>
            <listitem>
                <para>an arbitrary number of argument expressions of non-<literal>optional</literal> 
                type assignable to <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
         
        <para>In the second case, the argument expressions are evaluated and collected into an 
        instance of <literal>Iterable&lt;T&gt;</literal> when the invocation is executed.</para>
        
        <para>When an invocation is executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>each argument is evaluated in turn in the calling context, then</para>
            </listitem>
            <listitem>
                <para>the receiving instance, if any, and the name of the invoked member or
                type is determined by evaluating the receiver expression and obtaining a method 
                reference, and</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the runtime
                type of the receiving instance and the static types of the arguments, and then</para>
            </listitem>
            <listitem>
                <para>execution of the calling context pauses while the body of the method or 
                initializer is executed by the receiving instance with the argument values, 
                then</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the method or initializer ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <section id="methodinvocation">
            <title>Method invocation</title>
            
            <para>A method invocation evaluates to the return value of the method, as specified 
            by the <literal>return</literal> directive. The argument values are passed to the 
            formal parameters of the method, and the body of the method is executed.</para>
            
            <comment><para>TODO: What does a <literal>void</literal> method invocation evaluate to?
            The receiving instance?</para></comment>
                        
            <programlisting>log.info("Hello world!")</programlisting>
            <programlisting>log.info { message = "Hello world!"; }</programlisting>
            <programlisting>printer.print { join = ", "; "Gavin", "Emmanuel", "Max", "Steve" }</programlisting>
            <programlisting>printer.print { "Names: ", from (Person p in people) select (p.name) }</programlisting>
            <programlisting>set person.name("Gavin")</programlisting>
            <programlisting>get process.args()</programlisting>
            
            <programlisting>amounts.sort() by (Float x, Float y) ( x&lt;=&gt;y );</programlisting>
            <programlisting>people.each() perform (Person p) { log.info(p.name); }</programlisting>
            
            <programlisting>hash(default, firstName, initial, lastName)</programlisting>
            <programlisting>hash { algorithm=default; firstName, initial, lastName }</programlisting>
            
            <programlisting>from (people) having (Person p) (p.age>18) select (Person p) (p.name);</programlisting>
            <programlisting>iterate (map) perform (String name->Object value) { log.info("Entry: " name "->" value ""); };</programlisting>
            
            <para>The type of a method invocation expression depends upon the invocation
            operator. If <literal>X</literal> is the declared return type of the method:</para>
            
            <itemizedlist>
                <listitem>
                    <para>If the invocation operator is <literal>.</literal>, the expression
                    is of type <literal>X</literal>. It is of <literal>optional</literal> type
                    if and only if the method is declared <literal>optional</literal>.</para>
                </listitem>
                <listitem>
                    <para>If the invocation operator is <literal>?.</literal>, the expression
                    is of type <literal>optional X</literal>.</para>
                </listitem>
                <listitem>
                    <para>If the invocation operator is <literal>*.</literal>, the expression
                    is of non-<literal>optional</literal> type <literal>Sequence&lt;X&gt;</literal>.</para>
                </listitem>
                <listitem>
                    <para>If no receiver expression is specified, the expression is of type 
                    <literal>X</literal>. It is of <literal>optional</literal> type if and 
                    only if the method is declared <literal>optional</literal>.</para>
                </listitem>
            </itemizedlist>
            
        </section>
        
        <section id="classinstantiation">
            <title>Class instantiation</title>
            
            <para>Invocation of a constructor reference is called <emphasis>instantiation</emphasis> 
            of the type. A class instantiation evaluates to a new instance of the class. The argument 
            values are passed to the initialization parameters of the class, and the initializer
            is executed.</para>
                        
            <programlisting>Map&lt;String, Person&gt;(entries)</programlisting>
            <programlisting>Point { x=1.1; y=-2.3; }</programlisting>
            <programlisting>ArrayList&lt;String&gt; { capacity=10; "gavin", "max", "emmanuel", "steve", "christian" }</programlisting>
            <programlisting>Iterable&lt;String&gt; tokens = input.Tokens();</programlisting>
            
            <programlisting>Panel {
    label = "Hello";
    Input i = Input(),
    Button {
        label = "Hello";
        action() {
            log.info(i.value);
        }
    }
}</programlisting>

            <para>The type of a method invocation expression depends upon the invocation
            operator. If <literal>X</literal> is class:</para>
            
            <itemizedlist>
                <listitem>
                    <para>If the invocation operator is <literal>.</literal>, the expression
                    is of non-<literal>optional</literal> type <literal>X</literal>.</para>
                </listitem>
                <listitem>
                    <para>If the invocation operator is <literal>?.</literal>, the expression
                    is of type <literal>optional X</literal>.</para>
                </listitem>
                <listitem>
                    <para>If the invocation operator is <literal>*.</literal>, the expression
                    is of non-<literal>optional</literal> type <literal>Sequence&lt;X&gt;</literal>.</para>
                </listitem>
                <listitem>
                    <para>If no receiver expression is specified, the expression is of 
                    non-<literal>optional</literal> type <literal>X</literal>.</para>
                </listitem>
            </itemizedlist>
            
        </section>
        
        <section id="positionalarguments">
            <title>Positional arguments</title>
        
        <para>When arguments are listed, the arguments list is enclosed in parentheses.</para>
            
        <programlisting>PositionalArguments := "(" ( Expression ("," Expression)* )? ")"</programlisting>
        
        <para>Positional arguments must be listed in the same order as the corresponding formal
        parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para>First, an argument of each required parameters must be specified, in the 
                order in which the required parameters were declared. There must be at least as 
                many arguments as required formal parameters.</para>
            </listitem>
            <listitem>
                <para>Next, arguments of the first arbitrary number of defaulted parameters may 
                be specified, in the order in which the defaulted parameters were declared. If 
                there are fewer arguments than defaulted parameters, the remaining defaulted 
                parameters are assigned their default values.</para>
            </listitem>
            <listitem>
                <para>Finally, if arguments to all defaulted parameters have been specified,
                and if the method declares a varargs parameter, an arbitrary number of arguments 
                to the varargs parameter may be specified. 
                </para>
            </listitem>
        </itemizedlist>
        
        <para>For example:</para>
        
        <programlisting>(getProduct(id), 1)</programlisting>
                
        </section>
        
        <section id="namedarguments">
            <title>Named arguments</title>
            
        <para>When arguments are named, the argument list is enclosed in braces.</para>
        
        <programlisting>NamedArguments := "{" NamedArgument* VarargArguments? "}"</programlisting>
        
        <para>Named arguments may be listed in a different order to the corresponding formal
        parameters.</para>

        <para>Required and defaulted parameter arguments are specified by name. Varargs are 
        specified by listing them, without specifying a name, at the end of the argument list.</para>

        <para>A named argument either:</para> 
        
        <itemizedlist>
            <listitem>
            <para>specifies its value using <literal>=</literal>, and is terminated by a semicolon, 
            or</para>
            </listitem>
            <listitem>
            <para>only for functional parameters, specifies the type or <literal>local</literal>, a 
            formal parameter list and a block of code (an inline method declaration).</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>NamedArgument := SpecifiedNamedArgument | FunctionalNamedArgument</programlisting>
        
        <programlisting>SpecifiedNamedArgument := ParameterName Specifier ";"</programlisting>
        
        <programlisting>FunctionalNamedArgument := (InferableType | "void") ParameterName FormalParams Block</programlisting>
        
        <para>For example:</para>
        
        <programlisting>{ 
    product = getProduct(id); 
    quantity = 1; 
}</programlisting>
        
        <programlisting>{ 
    label = "Say Hello"; 
    void onClick() { 
        say("Hello"); 
    } 
}</programlisting>
        
        <programlisting>{ 
    Comparison by(X x, X y) { return x&lt;=&gt;y } 
}</programlisting>

        <para>This is simpler using type inference:</para>

        <programlisting>{ 
    local by(X x, X y) { return x&lt;=&gt;y } 
}</programlisting>

        <comment><para>TODO: should the named parameter block be allowed to contain arbitrary statements?
        This is more regular, since you can do it in the body of a class, and attribute/method overriding
        is the model that we are following here. And it could be very useful when defining structured
        data.</para></comment>

        <!--comment><para>TODO: Getter, setter specification for parameters declared <literal>mutable</literal>?</para></comment-->
        
        </section>

        <section id="varargarguments">
            <title>Vararg arguments</title>
            
        <para>Vararg arguments are seperated by commas.</para>

        <programlisting>VarargArguments := VarargArgument ("," VarargArgument)*</programlisting>

        <programlisting>VarargArgument := Expression | InferableVariable Specifier</programlisting>
        
        <para>For example:</para>
        
        <programlisting>(1, 1, 2, 3, 5, 8)</programlisting>
        
        <para>A vararg argument may be a local declaration.</para>
        
        <comment><para>TODO: figure this out. Is this only for varargs in a named parameter
        invocation?</para></comment>
        
        <para>A vararg argument may be an <literal>Iterable</literal> of the parameter type.</para>
        
        <programlisting>( {1, 1, 2, 3, 5, 8} )</programlisting>
        
        </section>
        
        <section id="defaultarguments">
            <title>Default arguments</title>
        
        <para>When no argument is assigned to a defaulted parameter by the caller, the 
        default argument defined by the formal parameter declaration is used. The default
        argument expression is evaluated every time the method is invoked with no argument
        specified for the defaulted parameter.</para>
        
        <para>This class:</para>
        
        <programlisting>public class Counter(Natural initialCount=0) { ... }</programlisting>
        
        <!--
        <para>Is equivalent to a class with three Java constructor declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    public Counter() {
        Counter(0);
    }
    
    public Counter(Natural initialCount) {
        ...;
    }
    
    public Counter(CounterParameters namedParameters) {
        Counter( namedParameters.initialCount );
    }

    public static class CounterParameters {
        private Natural initialCount=0;
        CounterParameters initialCount(Natural initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>
        -->
        
        <para>May be instantiated using any of the following:</para>
        
        <programlisting>Counter()</programlisting>
        <programlisting>Counter(1)</programlisting>
        <programlisting>Counter {}</programlisting>
        <programlisting>Counter { initialCount=10; }</programlisting>
        
        <!--
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>new Counter ( new CounterParameters().initialCount(10) );</programlisting>
        -->
        
            <para>This method:</para>
        
            <programlisting>public class Counter() {
        
    package void init(Natural initialCount=0) {
        count:=initialCount;
    }
    
    ...

}</programlisting>
            <!--
            <para>Is equivalent to three Java method declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    void init() {
        init(0);
    }
    
    void init(Natural initialCount) {
        count=initialCount;
    }
    
    void init(CounterInitParameters namedParameters) {
        init( namedParameters.initialCount );
    }

    static class CounterInitParameters {
        private Natural initialCount=0;
        CounterInitParameters initialCount(Natural initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>
            -->
            
            <para>May be invoked using any of the following:</para>
        
            <programlisting>counter.init()</programlisting>
            <programlisting>counter.init(1)</programlisting>
            <programlisting>counter.init {}</programlisting>
            <programlisting>counter.init { initialCount=10; }</programlisting>
            
            <!--
            <para>Is equivalent to this Java code:</para>
        
            <programlisting>counter.init ( new CounterInitParameters().initialCount(10) );</programlisting>
            -->
 
        </section>
        
        <section id="functionalarguments">
            <title>Functional arguments</title>
            
        <para>After a positional argument list, arguments to functional parameters 
        may be specified with certain punctuation eliminated:</para>
        
        <itemizedlist>
            <listitem>
                <para>the return type is not declared,</para>
            </listitem>
            <listitem>
                <para>if the functional parameter declares no formal parameters, the 
                empty parentheses may be eliminated, and</para>
            </listitem>
            <listitem>
                <para>if the body of the method implementation consists of a single
                <literal>return</literal> directive followed by a parenthesized
                expression, the braces and <literal>return</literal> keyword may be 
                eliminated.</para>
            </listitem>
            <!--listitem>
                <para>formal parameter declarations may omit the explicit type, 
                forcing the compiler to infer it, by specifying the keyword 
                <literal>local</literal> where the type usually appears.</para>
            </listitem-->
        </itemizedlist>
        
        <para>These arguments are called <emphasis>functional arguments</emphasis> of
        a positional parameter invocation.</para>
                
        <programlisting>FunctionalArguments := (ParameterName FunctionalBody)+</programlisting>
        
        <programlisting>FunctionalBody := FormalParameters? ( Block | "(" Expression ")" )</programlisting>
        
        <!--
                
        <programlisting>InferableFormalParameters := "(" (InferableFormalParam ("," InferableFormalParam))? ")"</programlisting>
        
        <programlisting>InferableFormalParam := InferableParam | InferableEntryParamPair | InferableRangeParamPair</programlisting>
        
        <programlisting>InferableParam := Annotation* (InferableType|"void") ParameterName FormalParams*</programlisting>
        
        <programlisting>InferableEntryParamPair := Annotation* InferableType ParameterName "->" Type ParameterName</programlisting>
        
        <programlisting>InferableRangeParamPair := Annotation* InferableType ParameterName ".." ParameterName</programlisting>
        
        -->
        
        <para>For example:</para>
        
        <programlisting>having (Person p) (p.age>18)</programlisting>
        
        <programlisting>by (Float x, Float y) ( x&lt;=&gt;y )</programlisting>
        
        <programlisting>ifTrue (x+1)</programlisting>
        
        <programlisting>each { count+=1; }</programlisting>
        
        <programlisting>perform (Person p) { log.info(p.name); }</programlisting>
        
        <para>Functional arguments are listed without any additional punctuation:</para>
        
        <programlisting>ifTrue (x+1) ifFalse (x-1)</programlisting>
        
        <programlisting>select (Person p) (p.name) having (Person p) (p.age>18)</programlisting>
        
        <para>Arguments must be listed in the same order as the formal parameters are 
        declared by the method declaration.</para>
        
        <comment>
        <para>TODO: should we support type inference for the formal parameters? It 
        gets complicated with method overloading. For example:</para>
        <programlisting>by (local x, local y) ( x&lt;=&gt;y )</programlisting>
        <programlisting>having (local p) (p.age>18)</programlisting>
        </comment>

        </section>
        
        <section id="iteration">
            <title>Iteration</title>
            
        <para>A specialized invocation syntax is provided for toplevel methods which iterate 
        collections. If the first parameter of the method is of type <literal>Iterable&lt;X&gt;</literal>,
        annotated <literal>iterated</literal>, and all remaining parameters are functional
        parameters, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>StaticMethodReference "(" ForIterator ")" FunctionalArguments</programlisting>
        
        <para>And then if a functional parameter has a formal parameter of type 
        <literal>X</literal> annotated <literal>coordinated</literal>, that parameter need 
        not be declared by its argument. Instead, the parameter is declared by the iterator.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public
List&lt;Y&gt; from&lt;X,Y&gt;(iterated Iterable&lt;X&gt; elements, 
                  Boolean having(coordinated X x),
                  Y select(coordinated X x));</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; names = from (Person p in people) having (p>20) select (p.name);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; names = from (people) having (Person p) (p>20) select (Person p) (p.name);</programlisting>
        
        <para>Or, we may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; labels = from (Key key -> Value value in namedValues)
                      having (user.authorized(key)) 
                      select ($key + ": " + $value);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; labels = from (namedValues)
                      having (Key key -> Value value) (user.authorized(key)) 
                      select (Key key -> Value value) ($key + ": " + $value);</programlisting>
        
        <para>Type inference simplifies this further:</para>
        
        <programlisting>local names = from (local p in people) having (p>20) select (p.name);</programlisting>
        
        
        </section>
        
        <section id="localdefinition">
            <title>Variable definition</title>
            
        <para>A specialized invocation syntax is also provided for toplevel methods which define 
        a variable. If the first parameter of the method is of type <literal>X</literal>,
        annotated <literal>specified</literal>, and all remaining parameters are functional
        parameters, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>MethodReference "(" InferableVariable Specifier ")" FunctionalArguments</programlisting>
        
        <para>And then if a functional parameter has a formal parameter of type 
        <literal>X</literal> annotated <literal>coordinated</literal>, that parameter need 
        not be declared by its argument. Instead, the parameter is declared by the variable 
        specifier.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public
Y ifExists&lt;X,Y&gt;(specified optional X value, 
                Y then(coordinated X x), 
                Y otherwise());</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Decimal amount = ifExists(Payment p = order.payment) then (p.amount) otherwise (0.0);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Decimal amount = ifExists(order.payment) then (Payment p) (p.amount) otherwise (0.0);</programlisting>
        
        <para>And for the following method declaration:</para>
        
        <programlisting>public
Y using&lt;X,Y&gt;(specified X resource, 
             Y seek(coordinated X x))
  where X satisfies Usable;</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Order order = using (Session s = Session()) seek (s.get(#Order, oid));</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Order order = using (Session()) seek (Session s) (s.get(#Order, oid));</programlisting>
        
        <para>Type inference simplifies this further:</para>
        
        <programlisting>local amount = ifExists(local p = order.payment) then (p.amount) otherwise (0.0);</programlisting>
        <programlisting>local order = using (local s = Session()) seek (s.get(#Order, oid));</programlisting>
        
        </section>
        
        <!--section id="caseslist">
            <title>Lists of cases</title>
        
        <para>Finally, a specialized invocation syntax is provided for methods which define 
        a list of cases. If the method has a parameter of type 
        <literal>Iterable&lt;Entry&lt;Case&lt;X&gt;, functor Y()&gt;&gt;</literal> annotated 
        <literal>cases</literal>, the parameter may be specified according to:</para>
        
        <programlisting>(case "(" Case ")" SimpleBlockExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public
Y select&lt;X, Y&gt;(X selector,
              cases Entry&lt;Case&lt;X&gt;, functor Y()&gt;... cases);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>return select (payment.type) 
    case (check) payByCheck(payment)
    case (card) payByCard(payment);
</programlisting>
        
        </section-->
        <!--  
        <para>Or, If the method has a parameter of type 
        <literal>Enumeration&lt;functor Y(X x)&gt;</literal> annotated <literal>cases</literal>,
        the parameter value may be specified according to:</para>
        
        <programlisting>(LIdentifier BlockExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public
X attempt&lt;X&gt;(functor X() seek, 
             cases functor X(E e) where E satisfies Exception... except);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>attempt() 
seek { 
    produce doSomething(); 
} 
except (SomethingWrong sw) {
    log.info(sw);
    produce -1;
}
except (SomethingElseWrong sew) {
    log.warn(sew);
    produce -2;
}</programlisting>
        -->

            <section id="resolvingoverloadedmethodsandtypes">
                <title>Resolving overloaded methods and types</title>
                
                <para>For invocations of overloaded methods, and instantiation of overloaded 
                types, the specific overloaded declaration is resolved by the Ceylon compiler at 
                compile time.</para>
                
                <para>Overloaded declarations are resolved by considering the <emphasis>erased
                signature</emphasis> of the method or type declarations.</para> 
                
                <para>The erased signature of a type is a obtained by taking the declared parameter 
                types and:</para>
                
                <itemizedlist>
                    <listitem>
                        <para>if type arguments were explicitly specified by the instantiation, 
                        substituting the type arguments explicitly specified for type parameters 
                        that appear in the parameter types, or, otherwise,</para>
                    </listitem>
                    <listitem>
                        <para>if type arguments were not explicitly specified, substituting the 
                        upper bound of the type parameter for each type parameter that appears 
                        in the parameter types (or <literal>lang.Object</literal> if the type 
                        parameter has no upper bound).</para>
                    </listitem>
                </itemizedlist>
                
                <para>The erased signature of a method is obtained by taking the declared parameter 
                types and:</para>
                
                <itemizedlist>
                    <listitem>
                        <para>first, substituting type arguments of the receiving type for the
                        corresponding type parameter wherever it appears in the method parameter
                        types, and then</para>
                    </listitem>
                    <listitem>
                        <para>if type arguments were explicitly specified by the invocation, 
                        substituting the type arguments explicitly specified for method type 
                        parameters that appear in the parameter types, or, otherwise,</para>
                    </listitem>
                    <listitem>
                        <para>if type arguments were not explicitly specified, substituting the 
                        upper bound of the type parameter for each method type parameter that
                        appears in the parameter types (or <literal>lang.Object</literal> if the
                        type parameter has no upper bound).</para>
                    </listitem>
                </itemizedlist>
                
                <para>An invocation or instantiation resolves to a particular overloaded method
                or type declaration if there is exactly one overloaded declaration of the named 
                method or type with an erased signature to which the given arguments expression
                types are assignable.</para> 
                
                <para>If more than one overloaded declaration has an erased signature to which 
                the arguments are assignable, or if there is no declaration with an erased 
                signature to which the arguments are assignable, the invocation or instantiation 
                is illegal. (Note that Ceylon is stricter and simpler than Java with this rule.)</para>
                
                <para>Note that method references are not resolved to a specific overloaded
                declaration of the method or type except in the context of an invocation of the
                method reference. However, the compiler does check that an appropriate overloaded
                declaration exists before permitting specification of the method reference in the
                declaration of another method or functional argument.</para>
                
                <para>Finally, if type arguments were not explicitly specified, there must be a
                combination of type arguments that can be substituted for the type parameters of
                the method or type, respecting constraints upon the type parameters, that results
                in a method signature such that:</para>
                
                <itemizedlist>
                    <listitem>
                        <para>the given argument expression types are assignable to the method
                        parameter types after substitution of the type arguments, and</para>
                    </listitem>
                    <listitem>
                        <para>the expression type of the invocation or instantiation, after 
                        substitution of the type arguments is assignable to the surrounding
                        context.</para>
                    </listitem>
                </itemizedlist>
                
                <comment><para>TODO: Figure out the details of the type inference implied by this 
                last bit!</para></comment>
                
                <para>If no such combination of type arguments exists, the invocation or 
                instantiation is illegal. (Note that Ceylon is less strict than Java with this 
                rule.)</para>
                
            </section>

        </section>
        
        <section id="enumeration">
            <title>Enumeration</title>
            
            <para>A sequence may be instantiated by enumerating the elements inside
            braces:</para>
            
            <programlisting>Enumeration := "{" ( Expression ("," Expression)* )? "}"</programlisting>
                        
            <para>The value of an enumeration is a new instance of <literal>Sequence</literal>,
            containing the enumerated elements in the given order. When an enumeration is 
            executed, each element expression is evaluated, and the resulting values 
            collected together into an object that implements <literal>Sequence&lt;T&gt;</literal>
            where <literal>T</literal> is a superype of all the enumerated element expression
            types. The concrete type of this object is not specified here.</para>
            
            <programlisting>Sequence&lt;String&gt; names = { "gavin", "max", "emmanuel", "steve", "christian" };</programlisting>
            
            <para>Empty braces <literal>{}</literal> and <literal>none</literal> are synonyms
            for a special value that can be assigned to <literal>Sequence</literal>.</para>
                                    
            <programlisting>OpenList&lt;Connection&gt; connections = {};</programlisting>
            
            <para>An enumeration is an expression of non-<literal>optional</literal> 
            type.</para>
            
            <para>There is no special syntax for constructing lists, sets or maps. However, the 
            <literal>..</literal> and <literal>-></literal> operators, together with the 
            convenient sequence enumeration syntax, and some built-in extensions help us achieve 
            the desired effect.</para>

            <programlisting>List&lt;String&gt; languages = { "Java", "Ceylon", "Smalltalk", "C#" };</programlisting>
            <programlisting>List&lt;Natural&gt; numbers = 1..10;</programlisting>
                
            <para>Sequences are transparently converted to sets or maps, allowing sets 
            and maps to be initialized as follows:</para>
        
            <programlisting>Map&lt;String, String&gt; map = { "Java"->"Boring...", "Scala"->"Difficult :-(", "Ceylon"->"Fun!" };</programlisting>
            <programlisting>Set&lt;String&gt; set = { "Java", "Ceylon", "Scala" };</programlisting>
            <programlisting>OpenList&lt;String&gt; list = {};</programlisting>
            
            <comment><para>TODO: an alternative to this syntax would be to allow a comma-separated
            list of values without braces after <literal>=</literal>, <literal>in</literal> or 
            <literal>return</literal> and after <literal>:=</literal> in an attribute initializer. 
            The disadvantage to this approach is that enumerations would not be allowed in positional 
            parameter invocations, or in expressions. It's also less regular. On the other hand, it 
            is consistent with how we treat varargs.</para>
            <programlisting>Map&lt;String, String&gt; map = "Java"->"Boring...", "Scala"->"Difficult :-(", "Ceylon"->"Fun!";</programlisting>
            <programlisting>for (String lang in "Java", "Ceylon", "Scala", "C#") { ... }</programlisting>
            <programlisting>join { sep=", "; strings=firstName, initial, lastName; };</programlisting>
            </comment>
        
            
    </section>
    
        <!--  
        <section>
            <title>Attribute initialization</title>
            
            <para>Attribute initialization follows the following schema.</para>
            
            <programlisting>AttributeInitialization := Instantiation "{" Initialization* "}"</programlisting>
            
            <para>For example:</para>
            
            <programlisting>Person me = Person() { firstName="Gavin"; initial='A'; lastName="King"; }</programlisting>
            
            <para>The value of an attribute initialization is the instance being initialized.
            The named parameter values are assigned to uninitialized attributes of the instance.</para>
            
            <para>All non-<literal>optional</literal> attributes of a class must be explicitly
            initialized when the class is instantiated, either in the body of the class, or using
            attribute initialization. Uninitialized <literal>optional</literal> attributes are 
            implicitly initialized to <literal>null</literal> if not explicitly initialized.</para>
            
            <comment><para>TODO: is this the right thing to say? Should we require explicit 
            initialization even for <literal>optional</literal> attributes?</para></comment>
                        
        </section>
        -->
        
    <!--section id="inlineclassesliteralobjectsenumerations">
        <title>Literal objects, inline classes, and enumerations</title>
    
        <para>Three additional kinds of expressions exist for inline instantiation of an object.</para>
        
        <itemizedlist>
            <listitem>
                <para>Literal objects allow instantiation and initialization of a class without 
                execution of the constructor.</para>
            </listitem>
            <listitem>
                <para>Inline classes allow inline instantiation of an anonymous subclass of a
                certain class.</para>
            </listitem>
            <listitem>
                <para>Enumerations allow instantiation of a collection via a simplified syntax.</para>
            </listitem>
        </itemizedlist>
        
        <para>A literal object or inline class specification may bypass the constructor of the 
        class or superclass. In this case, the literal object or inline class specification takes 
        on responsibility for initialization of simple attributes of the class or superclass. This 
        means that a literal object or inline class specification which bypasses the constructor 
        must exist in a scope in which all attributes of the class or superclass are visible. Use 
        of this feature does not bypass language level accessibility checks.</para>
    
    <section id="literalobjects">
        <title>Literal objects</title>
        
        <para>A literal object is specified according to:</para>
        
        <programlisting>LiteralObject := "new" Type PositionalArguments? "{" (Assignment | Specification)* "}"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Calculator calc = new Calculator() { currentValue := 1.0; };</programlisting>
        
        <programlisting>Person gavin = new Person { 
    firstName = "Gavin";
    initial = 'A';
    lastName = "King";
    address := new Address { ... };
    birthdate = new Date { day = 25; month = MARCH; year = ... };
    employer := jboss;
};</programlisting>

        <para>A literal object must be of a concrete class and must either:</para>
        
        <itemizedlist>
            <listitem>
                <para>specify initialization parameters, and then an arbitrary list of
                mutable attribute assignments, or</para>
            </listitem>
            <listitem>
                <para>specify no initialization parameters, and specify values for each 
                simple attribute of the class, including private attributes, except 
                attributes annotated <literal>transient</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Literal objects which specify no initialization parameters are created without 
        execution of the body of the class to which they belong. Literal objects may refer to 
        immutable locals and members of the containing class in the attribute initializer 
        expressions. They may not refer to mutable locals.</para>
        
        <para>The value of a literal object expression is a new instance of the class.</para>
            
        <comment><para>TODO: are you allowed to have arbitrary code inside a literal object 
        specification?</para></comment>

        <comment><para>TODO: is there some kind of solution for getting around access 
        restrictions if you want to use a literal object specification for a class that
        extends a superclass in another package/module?</para></comment>

        <para>The classes <literal>Serializer</literal> and <literal>Deserializer</literal>
        provide the ability to serialize and deserialize any object to its 
        <emphasis>canonical literal form</emphasis>.</para>
        
        <programlisting>Person person = ...;
Serializer&lt;Person&gt; srlz = Serializer(person);
String serializedPerson = srlz; //using built-in converter
Deserializer&lt;Person&gt; dsrlz = Deserializer&lt;Person&gt;(serializedPerson);
Person deserialized = dsrlz; //using built-in converter</programlisting>

    </section>
    
        <section id="inlineclasses">
            <title>Inline classes</title>
            
            <para>Inline classes may be specified according to:</para>
            
            <programlisting>InlineClass := "new" Annotation* Type PositionalArguments? Interfaces "{" Statement* "}"</programlisting>

            <para>For example:</para>
            
            <programlisting>Task task = new Task() {
    timeout := 1000;
    override void run() { ... }
    override void fail(Exception e) { ... }
};</programlisting>

            <programlisting>return new transactional Database 
        satisfies Resource {
    url = "jdbc:hsqldb:.";
    username = "gavin";
    password = "foobar";
    override void create() { open(); }
    override void destroy() { close(); }
};</programlisting>
            
            <para>An inline class is a literal object expression which may additionally:</para>
            
            <itemizedlist>
                <listitem>
                    <para>include arbitrary code to be executed when the inline class is
                    evaluated,</para>
                </listitem>
                <listitem>
                    <para>declare and override members, and</para>
                </listitem>
                <listitem>
                    <para>declare annotations.</para>
                </listitem>
            </itemizedlist>
            
            <para>The superclass of an inline class may be an abstract class. The inline
            class itself must be concrete.</para>
            
            <para>The value of an inline class expression is a new instance of the inline 
            class.</para>
            
        </section>
        
    </section-->
    
    <section id="attributeevaluation">
        <title>Evaluation</title>
            
        <para>An attribute evaluation consists of an attribute name, an evaluation operator,
        and a <emphasis>receiver expression</emphasis> that evaluates to an instance or 
        <literal>Iterable</literal> set of instances of a type that has an attribute with
        that name.</para>
            
        <para>If no receiver expression is explicitly specified, the current object is
        the receiver.</para>
            
        <para>Evaluation of a local is a special case. There is no receiving instance or
        evaluation operator.</para>
        
        <programlisting>Evaluation := Receiver? MemberName</programlisting>
        
        <!--para>The evaluation operator depends upon the type of the receiver expression. If 
        <literal>X</literal> is the type that has the attribute, the evaluation operator 
        must be:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>.</literal> if the expression is of non-<literal>optional</literal>
                type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>.?</literal> if the expression is of type <literal>optional X</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>.*</literal> if the expression is of non-<literal>optional</literal> 
                type <literal>Iterable&lt;X&gt;</literal>.</para>
            </listitem>
        </itemizedlist-->
        
        <para>When an attribute evaluation is executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>the receiving instance is determined by evaluating the receiver 
                expression, and</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the 
                runtime type of the receiving instance, and then</para>
            </listitem>
            <listitem>
                <para>if the member is a simple attribute, the current value of the 
                simple attribute is retrieved from the recieving instance, or</para>
            </listitem>
            <listitem>
                <para>otherwise, execution of the calling context pauses while the body 
                of the attribute getter is executed by the receiving instance, then</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the method or initializer ends without 
                a thrown exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>The value of the attribute evaluation is the current value of the simple
        attribute or the return value of the attribute getter, as specified by the 
        <literal>return</literal> directive.</para>
        
        <programlisting>String name = person.name;</programlisting>
        
        <para>The value of the local evaluation is the current value of the local.</para>
        
        <!--
        <para>is equivalent to the following Java code:</para>

        <programlisting>String name = person.name().get();</programlisting>
        -->
        
        <para>The type of an attribute invocation expression depends upon the evaluation
        operator. If <literal>X</literal> is the declared type of the attribute:</para>
            
        <itemizedlist>
            <listitem>
                <para>If the evaluation operator is <literal>.</literal>, the expression
                is of type <literal>X</literal>. It is of <literal>optional</literal> type
                if and only if the attribute is <literal>optional</literal>.</para>
            </listitem>
            <listitem>
                <para>If the evaluation operator is <literal>?.</literal>, the expression
                is of type <literal>optional X</literal>.</para>
            </listitem>
            <listitem>
                <para>If the evaluation operator is <literal>*.</literal>, the expression
                is of non-<literal>optional</literal> type <literal>Sequence&lt;X&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>If no receiver expression is specified, the expression is of type 
                <literal>X</literal>. It is of <literal>optional</literal> type if and 
                only if the attribute is <literal>optional</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The type of a local evaluation expression is the type of the local. It is of 
        <literal>optional</literal> type if and only if the local is <literal>optional</literal>.</para>
        
    </section>
        
    <section id="assignment">
        <title>Assignment</title>
        
        <para>Certain expressions are <emphasis>assignable</emphasis>. An assignable
        expression may appear to the left of the <literal>:=</literal> (assign) operator,
        and possibly, depending upon the type of the expression, to the left of the 
        numeric, logical or bitwise compound assignment operators 
        <literal>+=, -=, *=, /=, %=, &amp;=, |=, ^=, &amp;&amp;=, ||=, ?=</literal> or 
        as the subject of the increment and decrement operators <literal>++, --</literal>,
        or apply operator <literal>.=</literal>.</para>
        
        <para>For example, the following expressions are assignable:</para>
        
        <itemizedlist>
            <listitem>
                <para>a local declared <literal>mutable</literal>, for example 
                <literal>count := 0</literal>,</para>
            </listitem>
            <listitem>
                <para>any attribute expression where the underlying attribute has a setter
                or is a simple attribute declared <literal>mutable</literal>, for example 
                <literal>person.name := "Gavin"</literal>,</para>
            </listitem>
            <listitem>
                <para>element expressions for the type <literal>OpenCorrespondence</literal>, 
                for example <literal>order.lineItems[0] := lineItem</literal>, and</para>
            </listitem>
            <listitem>
                <para>range expressions for the type <literal>OpenSequence</literal>, 
                for example <literal>fibonacci[0..1] := {0,1}</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <section>
            <title>Assignable expressions</title>
            
        <para>An assignable expression consists of an attribute name, and, optionally, in
        the case of an attribute of type <literal>OpenCorrespondence</literal>, a 
        specification of the element keys to be assigned to, together with a receiver 
        expression that evaluates to an instance of a type with an attribute with that 
        name.</para>
        
        <para>If no receiver expression is explicitly specified, the current object is the 
        receiver.</para>
            
        <para>Assignment to a local is a special case. There is no receiving instance.</para>
        
        <programlisting>AssignableExpression := (Primary ".")? MemberName ElementSpec?</programlisting>
        
        <para>When an assignment expression or unary assignment expression is executed, the 
        new value to be assigned is computed, the receiving object is obtained by evaluating 
        the receiver expression, the actual member to be invoked is determined by considering 
        the runtime type of the receiving instance, and then:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the assignable expression is a simple attribute or local, the value 
                of the simple attribute of local is set to the new value,</para>
            </listitem>
            <listitem>
                <para>if the assignable expression is an attribute with a setter, execution 
                of the calling context pauses while the body of the attribute setter is executed 
                by the receiving instance with the new value, and then, when execution of the
                setterends without a thrown exception, execution of the calling context resumes, 
                or</para>
            </listitem>
            <listitem>
                <para>if the assignable expression is an attribute of type 
                <literal>OpenCorrespondence</literal> together with an element key specification,
                the key expression is evaluates, and the <literal>define()</literal> method is
                invoked with the resulting key and the new value.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <section>
            <title>Assignment</title>
            
        <para>An assignment consists of an assignable expression, an assignment operator
        and an expression to be assigned.</para>
        
        <programlisting>Assignment := AssignableExpression AssignmentOperator Expression</programlisting>
        
        <programlisting>AssignmentOperator := 
":=" | 
NumericAssignmentOperator | 
BitwiseAssignmentOperator | 
LogicalAssignmentOperator | 
DefaultAssignmentOperator</programlisting>
        
        <programlisting>NumericAssignmentOperator := "+=" | "-=" | "*=" | "/=" | "%="</programlisting>
        
        <programlisting>BitwiseAssignmentOperator := "&amp;=" | "|=" | "^="</programlisting>
        
        <programlisting>LogicalAssignmentOperator := "&amp;&amp;=" | "||="</programlisting>
        
        <programlisting>DefaultAssignmentOperator := "?="</programlisting>
        
        <para>The assignment operator might be <literal>:=</literal>, which simply evaluates 
        the expression to be assigned and assigns the resulting value to the assignable 
        expression, or it might be a compound assignment operator, which evaluates both
        expressions, computes a single value from the two resulting values, and assigns this
        value to the assignable expression.</para>
        
        <para>This statement sets the value of an attribute:</para>
        
        <programlisting>person.name := "Gavin";</programlisting>
        
        <!--
        <para>is equivalent to the following Java code:</para>

        <programlisting>person.name().set("Gavin");</programlisting>
        -->
        
        <para>This statement assigns to a keyed element of a <literal>Sequence</literal>, resulting 
        in a call to the <literal>define()</literal> method of <literal>OpenCorrespondence</literal>:</para>
        
        <programlisting>order.lineItems[0] := LineItem { product = prod; quantity = 1; };</programlisting>
        
        <!--
        <para>Is equivalent to the Java:</para>
        
        <programlisting>order.lineItems.define( 0, new LineItem(prod, 1) );</programlisting>
        -->
        
        <para>The following rules must be satisfied:</para>
        
        <itemizedlist>
            <listitem>
                <para>the assignable expression must be a <literal>mutable</literal>
                attribute with no element key specification, or an attribute of type 
                <literal>OpenCorrespondence</literal> together with an element key 
                specification,</para>
            </listitem>
            <listitem>
                <para>the receiver expression must not be of <literal>optional</literal> 
                type,</para>
            </listitem>
            <listitem>
                <para>the type of the expression to be assigned must be assignable to 
                the type of the assignable expression, and</para>
            </listitem>
            <listitem>
                <para>if the expression to be assigned is of <literal>optional</literal> 
                type, then the assignable expression must be of <literal>optional</literal> 
                type,</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: fix to account for range assignment!</para></comment>
        
        <para>The whole assignment construct is itself an expression. The type of the assignment 
        expression is the type of the assignable expression. The assignment expression is of 
        <literal>optional</literal> type if and only if the expression to be assigned is of
        <literal>optional</literal> type.</para>
        
        <para>When the assignment is executed, the assignment expression evaluates to the new 
        value that was assigned.</para>
        
        </section>
        
        <section>
            <title>Unary assignment</title>
            
        <para>Unary increment and decrement and the apply aperator <literal>.=</literal> 
        are also considered a kind of assignment, called <emphasis>unary assignment</emphasis>.</para>
        
        <programlisting>IncrementOrDecrement := PrefixIncrementOrDecrement | PostfixIncrementOrDecrement | Apply</programlisting>
        
        <programlisting>PrefixIncrementOrDecrement := IncrementOrDecrementOperator AssignableExpression</programlisting>
        <programlisting>PostfixIncrementOrDecrement := AssignableExpression IncrementOrDecrementOperator</programlisting>
        
        <programlisting>IncrementOrDecrementOperator := "++" | "--"</programlisting>
        
        <programlisting>Apply := AssignableExpression ".=" MemberName Arguments?</programlisting>
        
        <para>Unary assignment evaluates the assignable expression, computes a new value by
        applying an operation to the result, and then assigns this new value to the assignable
        expression.</para>
        
        <para>The following rules must be satisfied:</para>
        
        <itemizedlist>
            <listitem>
                <para>the assignable expression must be a <literal>mutable</literal>
                attribute with no element key specification, or an attribute of type 
                <literal>OpenCorrespondence</literal> together with an element key 
                specification,</para>
            </listitem>
            <listitem>
                <para>the receiver expression must not be of <literal>optional</literal> 
                type, and</para>
            </listitem>
            <listitem>
                <para>the assignable expression must not be of <literal>optional</literal>
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The whole unary assignment construct is itself an expression. The type of the 
        unary assignment expression is the type of the assignable expression. The unary 
        assignment expression is of non-<literal>optional</literal> type.</para>
        
         <para>When the assignment is executed, the unary assignment expression evaluates to 
         the new value that was assigned, except in the case of postfix increment or decrement, 
         in which case the unary assignment expression evaluates to the previous value of the
         assignable expression, before the unary assignment was executed.</para>
        
        </section>
        
    </section>
    
    <section id="operators">
    <title>Operators</title>
    
    <para>Operators are syntactic shorthand for more complex expressions
    involving method invocation or attribute access. Each operator is defined 
    for a particular type. There is no support for user-defined operator 
    <emphasis>overloading</emphasis>. However, the semantics of an operator 
    may be customized by the implementation of the type that the operator
    applies to. This is called <emphasis>operator polymorphism</emphasis>.</para>
    
    <para>Some examples:</para>
    
    <programlisting>Float z = x * y + 1.0;</programlisting>
    
    <programlisting>even := n % 2 == 0;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>if ( x > 100 || x &lt; 0 ) { ... }</programlisting>
    
    <programlisting>optional User gavin = users["Gavin"];</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = list[0..20];</programlisting>
    
    <programlisting>for ( Natural n in 1..10 ) { ... }</programlisting>
    
    <programlisting>if (char in @A..@Z) { ... }</programlisting>
    
    <programlisting>List&lt;Day&gt; nonworkDays = days[{0,7}];</programlisting>
    
    <programlisting>Natural lastIndex = getLastIndex() ? sequence.lastIndex;</programlisting>

    <programlisting>if ( exists name => name == "Gavin" ) { return ... }</programlisting>
    
    <programlisting>log.info( "Hello " + $person + "!")</programlisting>
    
    <programlisting>List&lt;String&gt; names = { person1, person2 }*.name;</programlisting>
    
    <programlisting>optional String name = person?.name;</programlisting>
    
    <programlisting>this.total += item.price;</programlisting>
    
    <programlisting>if ( nonempty args[i] &amp;&amp; !args[i].first == @- ) { ... }</programlisting>
    
    <programlisting>Float vol = length**3;</programlisting>
    
    <programlisting>map.define(person.name->person);</programlisting>
    
    <!--para>Are equivalent to the following (Ceylon) code:</para>
    
    <programlisting>Float z = x.times(y);</programlisting>
    
    <programlisting>count := count.successor;</programlisting>
    
    <programlisting>Integer j := ( i := i.successor ).predecessor;</programlisting>
    
    <programlisting>if ( x.compare(100).larger ) { ... }</programlisting>
    
    <programlisting>User gavin = users.value("Gavin");</programlisting>
        
    <programlisting>List&lt;Item&gt; firstPage = list.range(0..20);</programlisting>
    
    <programlisting>for ( Natural n in Range(1,10) ) { ... }</programlisting>

    <programlisting>if ( nullsafeEquals(name, value) ) return ... ;</programlisting>
       
    <programlisting>log.info( "Hello ".join(person.string).join("!") )</programlisting>
    
    <programlisting>List&lt;String&gt; names = 
    Spread&lt;String&gt; { 
        lhs = Chain&lt;String&gt; { 
            lhs = Chain&lt;String&gt; { 
                lhs = ArrayList(); 
                override void call() { lhs.append(person1); } }.lhs
            }
            override void call() { lhs.append(person2); } }.lhs
        }
        override void call(String element) { element.name; } 
    }.result;</programlisting>
    
    <programlisting>optional String name = if (exists person) person.name else null;</programlisting>
    
    <programlisting>List&lt;Day&gt; nonworkDays = days.values(Enumeration(0,7));</programlisting-->

       <para>This table defines operator precedence from highest to lowest,
        along with associativity rules:</para>
        
    <table>
    <tgroup cols="4">
        <colspec colnum="1" colwidth="2.5*" align="center"/>
        <colspec colnum="2" colwidth="2.0*" align="center"/>
        <colspec colnum="3" colwidth="1.0*" align="center"/>
        <colspec colnum="4" colwidth="0.7*" align="center"/>
    <thead>
        <row>
            <entry>Operations</entry>
            <entry>Operators</entry>
            <entry>Type</entry>
            <entry>Associativity</entry>
        </row>
    </thead>
    <tbody>
    
            <row>
                <entry>Member invocation and lookup, subrange,
                postfix increment, postfix decrement:</entry>
                <entry>
                <literal>.</literal>,
                <literal>*.</literal>, 
                <literal>?.</literal>, 
                <literal>(,,)</literal>,
                <literal>{;;;}</literal>,
                <literal>[]</literal>,
                <literal>?[]</literal>,
                <literal>[..]</literal>, 
                <literal>[...]</literal>,
                <literal>++</literal>, 
                <literal>--</literal></entry>
                <entry>Binary / ternary / N-ary / unary postfix</entry>
                <entry>Left</entry>
            </row>
            
            <row>
                <entry>Prefix increment, prefix decrement,
                negation, render, bitwise complement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>, 
                <literal>-</literal>, 
                <literal>$</literal>,
                <literal>~</literal> 
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            <!--  
            <row>
                <entry>Exponentiation, shift:</entry>
                <entry>
                <literal>**</literal>,
                <literal>&lt;&lt;</literal>, 
                <literal>>></literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            -->
            <row>
                <entry>Multiplication, division, remainder,
                bitwise and:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal>,
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Addition, subtraction, bitwise or,
                bitwise xor, list concatenation:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal>, 
                <literal>|</literal>, 
                <literal>^</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <!--row>
                <entry>Date/time composition:</entry> 
                <entry><literal>@</literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row-->
            <row>
                <entry>Range<!--, interval--> and entry construction:</entry> 
                <entry><literal>..</literal>, <literal>-></literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <!--
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>?</literal>, <literal>??</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            -->
            <row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>

            <row>
                <entry>Comparison, <!--set comparison,--> containment,
                assignability:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <!--<literal>~></literal>,
                <literal>!~></literal>,
                <literal>*~></literal>-->
                <literal>in</literal>,
                <literal>is</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality:</entry>
                <entry>
                <literal>==</literal>, 
                <literal>!=</literal>, 
                <literal>===</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry>Logical not:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Logical and:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical or:</entry>
                <entry>
                <literal>||</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical implication:</entry>
                <entry>
                <literal>=></literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            
            <row>
                <entry>Assignment:</entry> 
                <entry>
                <literal>:=</literal>, 
                <literal>.=</literal>,
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>,
                <literal>?=</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: should <literal>?</literal> have a higher precedence?</para></comment>
    
    <comment><para>TODO: should <literal>^</literal> have a higher precedence than
    <literal>|</literal> like in C and Java?</para></comment>
    
    <comment><para>TODO: should <literal>^,|,&amp;</literal> have a lower precedence
    than <literal>+,-,*,/</literal> like in Ruby?</para></comment>
    
    <comment><para>Note: if we decide to add <literal>&lt;&lt;</literal> and 
    <literal>&gt;&gt;</literal> later, we could give them the same precedence
    as <literal>**</literal>.</para></comment>
    
    
    <para>The following tables define the semantics of the Ceylon operators:</para>
    
    <section id="basic">
    <title>Basic invocation and assignment operators</title>
    
    <para>These operators support method invocation and attribute evaluation and
    assignment. The <literal>$</literal> operator is a shortcut for converting
    any expression to a <literal>String</literal>.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Member invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>.</literal></entry>
            <entry><literal>lhs.member</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>X</literal> or type <literal>X</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry>Member type</entry>
        </row>
        <row>
            <entry><literal>?.</literal></entry>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe invoke</entry>
            <entry><literal>if (exists lhs) lhs.member else null</literal></entry>
            <entry><literal>optional X</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry><literal>optional</literal> member type</entry>
        </row>
        
        <row>
            <entry><literal>*.</literal></entry>
            <entry><literal>lhs*.member</literal></entry>
            <entry>spread invoke</entry>
            <entry><literal>for (X x in lhs) x.member</literal></entry>
            <entry><literal>Iterable&lt;X&gt;</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry><literal>Sequence</literal> of member type</entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>:=</literal></entry>
            <entry><literal>lhs := rhs</literal></entry>
            <entry>assign</entry>
            <entry><literal>Object.assign(set lhs,rhs)</literal></entry>
            <entry><literal>X</literal> or <literal>optional X</literal></entry>
            <entry><literal>X</literal> or <literal>optional X</literal></entry>
            <entry><literal>X</literal> or <literal>optional X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Render</emphasis></entry></row>
        
        <row>
            <entry><literal>$</literal></entry>
            <entry><literal>$rhs</literal></entry>
            <entry>render</entry>
            <entry><literal>this.string(rhs)</literal></entry>
            <entry></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>String</literal></entry>
        </row>
    
        <row><entry namest="first" nameend="last"><emphasis>Compound invocation assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>.=</literal></entry>
            <entry><literal>lhs.=member</literal></entry>
            <entry>apply</entry>
            <entry><literal>Object.assign(set lhs,lhs.member)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry>Member of <literal>X</literal>, of
            type <literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Type or method argument specification</emphasis></entry></row>
        
        <row>
            <entry><literal>(,,)</literal> or {;;;}</entry>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs { a=x; b=y; c=z; }</literal></entry>
            <entry>arguments</entry>
            <entry><literal></literal></entry>
            <entry>Type or method</entry>
            <entry>Parameter types of type or method</entry>
            <entry>Type or return type of method</entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: do we really need the <literal>$</literal> operator?</para></comment>
    
    </section>
        
    <section id="equalitycomparison">
    <title>Equality and comparison operators</title>
    
    <para>These operators compare values for equality, order, magnitude, or membership,
    producing boolean values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Equality</emphasis></entry></row>
        
        <row>
            <entry><literal>===</literal></entry>
            <entry><literal>lhs === rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal>Object.identical(lhs, rhs)</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>==</literal></entry>
            <entry><literal>lhs == rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>if (exists lhs) lhs.equals(rhs) else if (exists rhs) false else true</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>!=</literal></entry>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>if (exists lhs) lhs.equals(rhs).complement else if (exists rhs) true else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=&gt;</literal></entry>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>lhs.compare(rhs).smaller</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>lhs.compare(rhs).larger</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>lhs.compare(rhs).smallAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>lhs.compare(rhs).largeAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>in</literal></entry>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>lhs.in(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Category</literal> or <literal>Iterable&lt;Object&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignability</emphasis></entry></row>
        
        <row>
            <entry><literal>is</literal></entry>
            <entry><literal>lhs is Rhs</literal></entry>
            <entry>is</entry>
            <entry><literal>lhs.instanceOf(#Rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry>Any type</entry>
            <entry><literal>Boolean</literal></entry>
        </row>
                
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: should we really have the equality operators accept null
    values?</para></comment>
    
    </section>
                
    <section id="logical">
    <title>Logical operators</title>
    
    <para>These are the usual logical operations for boolean values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Logical operations</emphasis></entry></row>
        
        <row>
            <entry><literal>!</literal></entry>
            <entry><literal>!rhs</literal></entry>
            <entry>not</entry>
            <entry><literal>if (rhs) false else true</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>||</literal></entry>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;&amp;</literal></entry>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>=></literal></entry>
            <entry><literal>lhs => rhs</literal></entry>
            <entry>implication</entry>
            <entry><literal>if (lhs) rhs else true</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>||=</literal></entry>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else Object.assign(set lhs,rhs)</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>&amp;&amp;=</literal></entry>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) Object.assign(set lhs,rhs) else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="nullvalues">
    <title>Operators for handling null values</title>
    
    <para>These operators make it easy to work with <literal>optional</literal>
    types.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Existence</emphasis></entry></row>
        
        <row>
            <entry><!--<literal>?</literal> or --><literal>exists</literal></entry>
            <entry><!--<<literal>lhs?</literal> or --><literal>lhs exists</literal></entry>
            <entry>exists</entry>
            <entry><literal>if (exists lhs) true else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal><!--??-->nonempty</literal></entry>
            <entry><literal><!--??-->lhs nonempty</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (exists lhs) lhs.empty.complement else false</literal></entry>
            <entry><literal>optional Container</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Default</emphasis></entry></row>
        
        <row>
            <entry><literal>?</literal></entry>
            <entry><literal>lhs ? rhs</literal></entry>
            <entry>default</entry>
            <entry><literal>if (exists lhs) lhs else rhs</literal></entry>
            <entry><literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Default assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>?=</literal></entry>
            <entry><literal>lhs ?= rhs</literal></entry>
            <entry>default assignment</entry>
            <entry><literal>if (exists lhs) lhs else Object.assign(set lhs,rhs)</literal></entry>
            <entry><literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>

    <section id="listmap">
    <title>Correspondence and sequence operators</title>
    
    <para>These operators provide a simplified syntax for accessing values 
    of a <literal>Correspondence</literal>, and for joining and obtaining
    subranges of <literal>Sequences</literal>s.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Keyed element access</emphasis></entry></row>
        
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.value(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>optional Y</literal></entry>
        </row>
        <row>
            <entry><literal>?[]</literal></entry>
            <entry><literal>lhs?[index]</literal></entry>
            <entry>nullsafe lookup</entry>
            <entry><literal>if (exists lhs) lhs.value(index) else null</literal></entry>
            <entry><literal>optional Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>optional Y</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>list lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>Sequence&lt;X&gt;</literal></entry>
            <entry><literal>Sequence&lt;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>set lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Iterable&lt;Y&gt;</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Sequence subranges</emphasis></entry></row>
        
        <row>
            <entry><literal>[..]</literal></entry>
            <entry><literal>lhs[x..y]</literal></entry>
            <entry>subrange</entry>
            <entry><literal>range(lhs,x,y)</literal></entry>
            <entry><literal>S where S(X... elements) satisfies Sequence&lt;X&gt;</literal></entry>
            <entry>Two <literal>Natural</literal> values</entry>
            <entry><literal>S</literal></entry>
        </row>
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[x...]</literal></entry>
            <entry>upper range</entry>
            <entry><literal>range(lhs,x)</literal></entry>
            <entry><literal>S where S(X... elements) satisfies Sequence&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>S</literal></entry>
        </row>
        <!--
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[...y]</literal></entry>
            <entry>lower range</entry>
            <entry><literal>lhs.range(0,y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        -->

        <row><entry namest="first" nameend="last"><emphasis>Sequence concatenation</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>join</entry>
            <entry><literal>join(lhs, rhs)</literal></entry>
            <entry><literal>S where S>=Sequence&lt;X&gt; &amp; S(X... elements)</literal></entry>
            <entry><literal>S</literal></entry>
            <entry><literal>S</literal></entry>
        </row>

        <!--  
        
        <row><entry namest="first" nameend="last"><emphasis>Shift</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;&lt;</literal></entry>
            <entry><literal>lhs &lt;&lt; rhs</literal></entry>
            <entry>left shift</entry>
            <entry><literal>lhs.shiftLeft(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>>></literal></entry>
            <entry><literal>lhs >> rhs</literal></entry>
            <entry>right shift</entry>
            <entry><literal>lhs.shiftRight(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set operations</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs.union(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs.intersection(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>cartesian product</entry>
            <entry><literal>lhs.product(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;Pair&lt;X,Y&gt;&gt;</literal></entry>
        </row>
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>subset</entry>
            <entry><literal>lhs.subset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>superset</entry>
            <entry><literal>lhs.superset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>proper subset</entry>
            <entry><literal>lhs.properSubset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>proper superset</entry>
            <entry><literal>lhs.properSuperset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        -->
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should we overload <literal>*</literal> for sequences, like
    in some other languages? It is nice to be able to do stuff like 
    <literal>"-"*n</literal>.</para></comment>
    
    <comment><para>TODO: Should we have operators for set union/intersection/complement
    and set comparison?</para></comment>
    
    </section>
    
    <section id="constructors">
    <title>Operators for constructing objects</title>
    
    <para>These operators simplify the syntax for constructing certain commonly 
    used built-in types.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Range and entry constructors</emphasis></entry></row>

        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>T where T &gt;= Ordinal &amp; T &gt;= Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>-></literal></entry>
            <entry><literal>lhs -> rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Datetime and interval constructors</emphasis></entry></row>

        <row>
            <entry><literal>@</literal></entry>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>T where T satisfies Instant</literal></entry>
            <entry><literal>Instant&lt;T&gt;</literal></entry>
            <entry><literal>Interval&lt;T&gt;</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should we have operators for performing arithmetic with
    datetimes and durations, constructing intervals and combining dates and 
    times?</para></comment>
    
    </section>
    
    <section id="arithmetic">
    <title>Arithmetic operators</title>
    
    <para>These are the usual mathematical operations for all kinds of
    numeric values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>++rhs</literal></entry>
            <entry>successor</entry>
            <entry><literal>Object.assign(set rhs,rhs.successor)</literal></entry>
            <entry></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>--rhs</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>Object.assign(set rhs,rhs.predecessor)</literal></entry>
            <entry></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>lhs++</literal></entry>
            <entry>increment</entry>
            <entry><literal>(Object.assign(set lhs,lhs.successor)).predecessor</literal></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>lhs--</literal></entry>
            <entry>decrement</entry>
            <entry><literal>(Object.assign(set lhs,lhs.predecessor)).successor</literal></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operations</emphasis></entry></row>
        
        <!-- Unary negative -->
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.inverse</literal></entry>
            <entry></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <!-- Numeric -->
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.plus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.minus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.divided(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>%</literal></entry>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.remainder(rhs)</literal></entry>
            <entry><literal>Integral&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>**</literal></entry>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>power</entry>
            <entry><literal>lhs.power(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>+=</literal></entry>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>Object.assign(set lhs,lhs.plus(rhs))</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>-=</literal></entry>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>Object.assign(set lhs,lhs.minus(rhs))</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        <row>
            <entry><literal>*=</literal></entry>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>Object.assign(set lhs,lhs.times(rhs))</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>/=</literal></entry>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>Object.assign(set lhs,lhs.divided(rhs))</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>%=</literal></entry>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>Object.assign(set lhs,lhs.remainder(rhs))</literal></entry>
            <entry><literal>Integral&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Duration arithmetic</emphasis></entry></row>
                
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>extend</entry>
            <entry><literal>lhs.extend(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>curtail</entry>
            <entry><literal>lhs.curtail(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs.divide(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        -->
                
    </tbody>
    </tgroup>
    </table>
    
        <para>Built-in converters allow for type promotion of numeric values used in 
        expressions. Coverters exist for the following numeric types:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>lang.Natural</literal> to <literal>lang.Integer</literal>,
                <literal>lang.Float</literal>, <literal>lang.Whole</literal> and 
                <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Integer</literal> to <literal>lang.Float</literal>,
                <literal>lang.Whole</literal> and <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Float</literal> to <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Whole</literal> to <literal>lang.Decimal</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>This means that <literal>x + y</literal> is defined for any combination 
        of numeric types <literal>X</literal> and <literal>Y</literal>, except for 
        the combination <literal>Float</literal> and <literal>Whole</literal>, and that
        <literal>x + y</literal> always produces the same value, with the same type, as
        <literal>y + x</literal>.</para>
        
    </section>
    
    <section id="bitwise">
    <title>Bitwise operators</title>
    
    <para>These are C-style bitwise operations for bit strings (unsigned integers).
    A <literal>Boolean</literal> is considered a bit string of length one, so these
    operators also apply to <literal>Boolean</literal> values. Note that in Ceylon
    these operators have a higher precedence than they have in C or Java. There are
    no bitshift operators in Ceylon.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Bitwise operations</emphasis></entry></row>
        
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>~rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>rhs.complement</literal></entry>
            <entry></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>|</literal></entry>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>lhs.or(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;</literal></entry>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>lhs.and(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>^</literal></entry>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>lhs.xor(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        
        <row><entry namest="first" nameend="last"><emphasis>Bitwise assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>|=</literal></entry>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>Object.assign(set lhs,lhs.or(rhs))</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;=</literal></entry>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>Object.assign(set lhs,lhs.and(rhs))</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>^=</literal></entry>
            <entry><literal>lhs ^= rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>Object.assign(set lhs,lhs.xor(rhs))</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    </section>
    
</chapter>