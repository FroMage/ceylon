<chapter id="expressions">
    <title>Expressions</title>
    
    <para>Ceylon expressions are significantly more powerful than Java, allowing a more
    declarative style of programming.</para>
    
    <para>Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values,</para>
        </listitem>
        <listitem>
            <para>invocations of methods, attributes and functors, and instantiations
            of classes and enumerations,</para>
        </listitem>
        <listitem>
            <para>operators, and</para>
        </listitem>
        <listitem>
            <para>functor expressions.</para>
        </listitem>
    </itemizedlist>
    
    <section id="literals">
    <title>Literals</title>
    
    <para>Ceylon supports a special literal value syntax for each of the following types: 
    <!--literal>Boolean</literal--> <literal>Date</literal>, <literal>Time</literal>
    <literal>Integer</literal>, <literal>Float</literal>, <literal>Character</literal>, 
    <literal>String</literal> and <literal>Regex</literal>.
    </para>
    
    <programlisting>Literal :=
DateLiteral | TimeLiteral
NaturalLiteral | FloatLiteral |
CharacterLiteral | StringLiteral | RegexLiteral |
TypeLiteral | MemberLiteral |
SpecialValue</programlisting>

    <section id="specialvalues">
        <title><literal>this</literal>, <literal>super</literal>, 
        <literal>null</literal> and <literal>subtype</literal></title>
        
        <programlisting>SpecialValue := "this" | "super" | "null" | "none"</programlisting>
        
        <para>The keyword <literal>null</literal> refers to a special
        value that is assignable to all <literal>optional</literal> 
        types, and to no non-<literal>optional</literal> types. The
        Ceylon language and compiler ensures that this value never
        receives any invocation.</para>
        
        <para>The keyword <literal>super</literal> refers to the
        current instance (the instance that is being invoked), and 
        is of the same type as the immediate superclass of the class. 
        Any invocation of this reference is processed by the method 
        defined or inherited by this superclass, bypassing any method 
        declaration that overrides the method on the current class or 
        any subclass of the current class.</para>
        
        <para>The keyword <literal>this</literal> refers to the
        current instance, and is assignable to both the type of the 
        current class (the class which declares the method being 
        invoked), and to the special type <literal>subtype</literal>, 
        representing the concrete type of the current instance.</para>
        
        <para>The keyword <literal>none</literal> refers to a special
        value that is assignable to all types that extend 
        <literal>Enumeration</literal>. This value has no elements.</para>
        
    </section>
    
    <section id="datetime">
        <title><literal>Date</literal> and <literal>Time</literal> literals</title>
        
        <para>A <literal>Date</literal> literal has the form:</para>
        
        <!--
        <programlisting>DatetimeLiteral := "now"</programlisting>
        -->
        
        <programlisting>DateLiteral := 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <para>A <literal>Time</literal> literal has the form:</para>
        
        <programlisting>TimeLiteral := 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <!--
        <programlisting>Datetime datetime = now;</programlisting>
        -->
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>A <literal>Datetime</literal> may be composed from a <literal>Date</literal> and 
        a <literal>Time</literal> using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <comment><para>TODO: should we allow wildcards and ranges, to get cron-style expressions 
        like <literal>'1/*/*' @ '00:00 GMT'</literal>?</para></comment>
        
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Integer</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section>
    
    <section id="naturalnumber">
        <title>Natural number literals</title>
        
        <para>A <literal>Natural</literal> literal has this form:</para>
        
        <programlisting>NaturalLiteral = 
Digit+ | 
"'" ( HexDigit{4} | HexDigit{8} ) "'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Natural i = i + 10;</programlisting>
        
        <programlisting>panel.backgroundColor = 'FF33';</programlisting>
        
        <para>Negative integer values can be produced using the unary
        <literal>-</literal> operator:</para>
        
        <programlisting>Integer j = -1;</programlisting>
        
    </section>
    
    <section id="floatnumber">
        <title>Floating point number literals</title>
        
        <para>A <literal>Float</literal> literal has this form:</para>
        
        <programlisting>FloatLiteral := 
Digit+ "." Digit+ 
( ("E"|"e")? ("+"|"-")? Digit+ )?</programlisting>
        
        <para>For example:</para>
        
        <programlisting>public static Float pi = 3.14159;</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>public static final Float pi = new lang.Float(3.14159f);</programlisting>

    </section>
    
    <section id="string">
        <title>String literals</title>
        
        <para>A <literal>String</literal> literal has this form:</para>
        
        <programlisting>StringLiteral = "&quot;" ( Character+ | "${" Expression "}" )* "&quot;"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>person.name = "Gavin";</programlisting>
        
        <programlisting>log.info("${Time()} ${message}");</programlisting>
        
        <programlisting>String multilineString = "Strings may
span multiple lines
if you prefer.";</programlisting>
        
        <para>The first example is equivalent to this Java code:</para>
        
        <programlisting>person.name().set( new lang.String("Gavin") );</programlisting>
        
        <comment><para>TODO: we need to support that the embedded expressions
        are evaluated lazily when the string literal appears as a method 
        parameter. This is important for log messages and assertions. So 
        should <literal>"${Time()} ${message}"</literal> actually be a
        <literal>functor String()</literal> instead of a <literal>String</literal>?
        (And we would have a built-in converter to do implicit conversion to
        <literal>String</literal>.)</para></comment>

    </section>
    
    <section id="character">
        <title>Character literals</title>
        
        <para>A <literal>Character</literal> literal has this form:</para>
        
        <programlisting>CharacterLiteral := "'" Character "'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>if ( string[i] == '+' ) { ... }</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>if ( string.at(i).equals( new lang.Character('+') ) ) { ... }</programlisting>
        
        <comment><para>TODO: do we really need character literals??</para></comment>
        
    </section>
    
    <!--section>
        <title>Byte literals</title>
        
        <para>A byte literal has this form:</para>
        
        <programlisting>ByteLiteral := "'" ( BinaryDigit{8} | HexDigit{2} ) "'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Byte masked = b &amp; '01101001';</programlisting>
        
        <programlisting>Byte byte = 'A0';</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>Byte masked = b.and( new lang.Byte("01101001") );</programlisting>
        
        <programlisting>Byte byte = new lang.Byte("A0")</programlisting>
        
    </section-->
    
    <section id="regex">
        <title>Regex literals</title>
        
        <para>A <literal>Regex</literal> literal has this form:</para>
        
        <programlisting>RegexLiteral := "`" RegularExpression "`"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Boolean isEmail = email.matches( `^\w+@((\w+)\.)+$` );</programlisting>
        
        <programlisting>Integer quotedWords = `\W"w+"\W`.matcher(text).count();</programlisting>
        
        <para>The second example is equivalent to this Java code:</para>
        
        <programlisting>Integer quotedWords = new lang.Regex("\\W\"w+\"\\W").matcher(text).count();</programlisting>
        
    </section>
    
    <!--
    <section>
        <title>Enumeration literals</title>
        
        <para>The following literal is supported, representing an empty enumeration:</para>
        
        <programlisting>"none"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Enumeration&lt;String&gt; enum = none;</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>Enumeration&lt;String&gt; enum = collections.Enumeration.emptyEnumeration&lt;String&gt;();</programlisting>

        <comment><para>TODO: is this really a special literal, or is it just the single
        enumerated instance of the <literal>EmptyEnumeration</literal> class,
        which has a converter to <literal>Enumeration&lt;X&gt;</literal>?</para></comment>

    </section>
    -->

    <section id="typemember">
        <title>Type and member literals</title>
        
        <para>The <literal>Type</literal> object for a type, the <literal>Method</literal>
        object for a method, or the <literal>Attribute</literal> object for an attribute
        may be referred to using a special literal syntax:</para>
        
        <programlisting>TypeLiteral := HASH Type</programlisting>
        
        <programlisting>MemberLiteral := (Type)? HASH MemberName</programlisting>
               
        <para>For example:</para>
        
        <programlisting>Type&lt;List&lt;String&gt;&gt; stringListType = #List&lt;String&gt;;</programlisting>
        <programlisting>Attribute&lt;Person, String&gt; nameAttribute = Person#name;</programlisting>
        <programlisting>Method&lt;Person, functor void(String)&gt;&gt; sayMethod = Person#say;</programlisting>
        
        <para>Note that the <literal>#</literal> curry operator may also be applied to an 
        arbitrary expression, to obtain a <literal>Callable&lt;functor R(P p, Q q,...)&gt;</literal> 
        where <literal>P p, Q q,...</literal> are the method parameter types and <literal>R</literal> 
        is the method return type, or a <literal>Value&lt;T&gt;</literal> or 
        <literal>OpenValue&lt;T&gt;</literal> where <literal>T</literal> is the attribute 
        type.</para>
        
        
    </section>

    </section>

    <section id="objectscollections">
        <title>Objects and collections</title>
        
        <para>There are no true literals for user-defined classes. Rather, there is a 
        nice syntax for calling the class constructor. For example:</para>
        
        <programlisting>Person gavin = Person { 
    firstName = "Gavin";
    initial = 'A';
    lastName = "King";
    address = Address { ... };
    birthdate = Date { day = 25; month = MARCH; year = ... }
    employer = jboss;
};</programlisting>

<!--  
        <para>A similar syntax is supported for specifying the values of uninitialized 
        attributes of a class at instantiation time.</para>

        <programlisting>Person gavin = Person(jboss) { 
    firstName = "Gavin";
    initial = 'A';
    lastName = "King";
    address = Address { ... };
    birthdate = Date { day = 25; month = MARCH; year = ... }
};</programlisting>
-->

        <para>Likewise, there are no true literals for lists, sets or maps. However, 
        the <literal>..</literal> and <literal>-></literal> operators, together with
        the convenient enumeration constructor syntax, and some built-in extensions 
        help us achieve the desired effect.</para>

        <programlisting>List&lt;Integer&gt; numbers = 1..10;</programlisting>
        <programlisting>List&lt;String&gt; languages = { "Java", "Ceylon", "Smalltalk" };</programlisting>
                
        <para>Enumerations are transparently converted to sets or maps,
        allowing sets and maps to be initialized as follows:</para>
        
        <programlisting>Map&lt;String, String&gt; map = { "Java"->"Boring...", "Scala"->"Difficult :-(", "Ceylon"->"Fun!" };</programlisting>
        <programlisting>Set&lt;String&gt; set = { "Java", "Ceylon", "Scala" };</programlisting>
        <programlisting>OpenList&lt;String&gt; list = {};</programlisting>
        
    </section>
    
    <section id="invocations">
        <title>Invocations</title>
        
        <para>Methods, classes, class instances and functors are <emphasis>invokable</emphasis>.
        Invocation of a class is called <emphasis>instantiation</emphasis>. Invocation of a
        class instance is called <emphasis>attribute configuration</emphasis>.</para>
        
        <para>Any invocation must specify values for parameters, either by listing or naming 
        parameter values.</para>
        
        <programlisting>Arguments := PositionalArguments | NamedArguments</programlisting>
        
        <para>Required parameters must be specified. Defaulted parameters and varargs may also be 
        specified.</para>
        
        <para>When parameter values are listed, required parameters are assigned first, in the order
        in which they were declared, followed by defaulted parameters, in the order they were declared.
        If there are any remaining defaulted parameters, they will be assigned their default values.
        On the other hand, if any parameter values are unassigned, they will be treated as varargs.</para>
            
        <programlisting>PositionalArguments := "(" ( Expression ("," Expression)* )? ")"</programlisting>
                
        <para>When parameter values are named, required and defaulted parameter values are specified 
        by name. Vararg parameter values are specified by listing them.</para>

        <programlisting>NamedArguments := "{" NamedArgument* VarargArguments? "}"</programlisting>

        <para>Named arguments are followed by semicolons.</para>

        <programlisting>NamedArgument := ParameterName Specifier ";"</programlisting>
        
        <comment><para>TODO: should we allow a comma-separated list of values to be specified here,
        thereby allowing the braces around an enumeration instantiation to be omitted?</para></comment>

        <para>Vararg arguments are seperated by commas.</para>

        <programlisting>VarargArguments := VarargArgument ("," VarargArgument)*</programlisting>

        <programlisting>VarargArgument := Expression | Variable Specifier</programlisting>
        
        <para>A vararg argument may be a local declaration.</para>
        
        <para>A vararg argument may be an <literal>Iterable</literal>.</para>
        
        <section id="methodinvocation">
            <title>Method invocation</title>
            
            <para>Method invocations follow the following schema.</para>
            
            <programlisting>MethodInvocation := MemberReference TypeArguments? Arguments</programlisting>
            
            <programlisting>MemberReference := (Expression DOT)? MemberName</programlisting>
            
            <para>For example:</para>
            
            <programlisting>log.info("Hello world!")</programlisting>
            <programlisting>log.info { message = "Hello world!"; }</programlisting>
            <programlisting>printer.print { join = ", "; "Gavin", "Emmanuel", "Max", "Steve" }</programlisting>
            <programlisting>printer.print { "Names: ", from (Person p in people) select p.name }</programlisting>
            
            <para>The value of a method invocation is the return value of the method.
            The parameter values are passed to the formal parameters of the method.</para>
            
            <para>Methods may not be invoked using the <literal>.</literal> operator on an 
            expression of type <literal>optional</literal>. They may be invoked using 
            <literal>?.</literal>.</para>
            
        </section>
        
        <section id="staticmethodinvocation">
            <title>Static method invocation</title>
            
            <para>Static method invocations follow the following schema.</para>
            
            <programlisting>StaticMethodInvocation := (RegularType DOT)? MemberName TypeArguments? Arguments</programlisting>
            
            <para>For example:</para>
            
            <programlisting>HashCode.calculate(default, firstName, initial, lastName)</programlisting>
            <programlisting>HashCode.calculate { algorithm=default; firstName, initial, lastName }</programlisting>
            
            <para>The value of a static method invocation is the return value of the static method.
            The parameter values are passed to the formal parameters of the method.</para>
            
        </section>
        
        <section id="classinstantiation">
            <title>Class instantiation</title>
            
            <para>Classes may be instantiated according to the following schema:</para>
            
            <programlisting>Instantiation := RegularType TypeArguments? Arguments</programlisting>
            
            <para>For example:</para>
            
            <programlisting>Map&lt;String, Person&gt;(entries)</programlisting>
            <programlisting>Point { x=1.1; y=-2.3; }</programlisting>
            <programlisting>ArrayList&lt;String&gt; { capacity=10; "gavin", "max", "emmanuel", "steve", "christian" }</programlisting>
            
            <programlisting>Panel {
    label = "Hello";
    Input i = Input(),
    Button {
        label = "Hello";
        action = () {
            log.info(i.value);
        }
    }
}</programlisting>
            
            <para>The value of a class instantiation is a new instance of the class.
            The parameter values are passed to the initialization parameters of the 
            class. If the class has no initialization parameters, they are assigned
            directly to attributes of the class (in this case, named parameters must 
            be used).</para>
            
        </section>
        
        <section id="functorinvocation">
            <title>Functor invocation</title>
            
            <para>Functor invocations follow the following schema.</para>
            
            <programlisting>FunctorInvocation := Expression Arguments</programlisting>
            
            <para>For example:</para>
            
            <programlisting>compare("AAA", "aaa")</programlisting>
            <programlisting>compare { x = "AAA"; y = "aaa"; }</programlisting>
            
            <para>The value of a functor invocation is the return value of the functor.
            The parameter values are passed to the formal parameters of the functor
            implementation.</para>
            
        </section>
        
        <!--  
        <section>
            <title>Attribute initialization</title>
            
            <para>Attribute initialization follows the following schema.</para>
            
            <programlisting>AttributeInitialization := Instantiation "{" Initialization* "}"</programlisting>
            
            <para>For example:</para>
            
            <programlisting>Person me = Person() { firstName="Gavin"; initial='A'; lastName="King"; }</programlisting>
            
            <para>The value of an attribute initialization is the instance being initialized.
            The named parameter values are assigned to uninitialized attributes of the instance.</para>
            
            <para>All non-<literal>optional</literal> attributes of a class must be explicitly
            initialized when the class is instantiated, either in the body of the class, or using
            attribute initialization. Uninitialized <literal>optional</literal> attributes are 
            implicitly initialized to <literal>null</literal> if not explicitly initialized.</para>
            
            <comment><para>TODO: is this the right thing to say? Should we require explicit 
            initialization even for <literal>optional</literal> attributes?</para></comment>
                        
        </section>
        -->
        
        <section id="attributeevaluationassignment">
            <title>Attribute evaluation and assignment</title>
            
            <para>Attribute evaluation follows this schema:</para>
            
            <programlisting>AttributeGet := MemberReference</programlisting>
            
            <para>This attribute evaluation:</para>
        
            <programlisting>String name = person.name;</programlisting>
        
            <para>is equivalent to the following Java code:</para>

            <programlisting>String name = person.name().get();</programlisting>
        
            <para>Attribute assignment follows the following schema:</para>
            
            <programlisting>AttributeSet := MemberReference AssignmentOperator Expression</programlisting>
            
            <para>This attribute assignment:</para>
        
            <programlisting>person.name := "Gavin";</programlisting>
        
            <para>is equivalent to the following Java code:</para>

            <programlisting>person.name().set("Gavin");</programlisting>
                        
            <para>If getter code is specified, and <literal>assign</literal> is not specified,
            the attribute is not settable, and any attempt to assign to the attribute will
            result in a compiler error.</para>
        
            <para>Attributes may not be accessed using the <literal>.</literal> operator when 
            the expression is of type <literal>optional</literal>. They may be accessed using 
            <literal>?.</literal>.</para>
            
            <para>Attributes may not be assigned when the expression of type 
            <literal>optional</literal>.</para>
            
        </section>
        
    </section>
    
        <section id="inlineclasses">
            <title>Inline classes</title>
            
            <para>Inline classes may be instantiated according to:</para>
            
            <programlisting>InlineClass := "new" Annotation* Instantiation Interfaces "{" Statement* "}"</programlisting>

            <para>For example:</para>
            
            <programlisting>Task task = new Task() {
    timeout := 1000;
    override void run() { ... }
    override void fail(Exception e) { ... }
}</programlisting>

            <programlisting>return new transactional Database() 
        satisfies Resource {
    url := "jdbc:hsqldb:.";
    username := "gavin";
    password = "foobar";
    override void create() { open(); }
    override void destroy() { close(); }
};</programlisting>
            
            <para>The value of an inline class instantiation is a new instance of the inline class.
            The block may contain method and attribute declarations and arbitrary code.<!-- and may 
            initialize uninitialized attributes of the superclass.--></para>
            
        </section>
        
        <section id="enumerationinstantiation">
            <title>Enumeration instantiation</title>
            
            <para>Enumerations may be instantiated according to the following 
            simplified syntax:</para>
            
            <programlisting>EnumerationInstantiation := "{" ( Expression ("," Expression)* )? "}"</programlisting>
            
            <para>In this case, there is no need to explicitly specify the type.</para>
            
            <para>For example:</para>
            
            <programlisting>Enumeration&lt;String&gt; names = { "gavin", "max", "emmanuel", "steve", "christian" };</programlisting>
            
            <programlisting>OpenList&lt;Connection&gt; connections = {};</programlisting>
            
            <para>Empty braces <literal>{}</literal> and <literal>none</literal> are synonyms
            for a special value that can be assigned to any enumeration type.</para>
            
            <comment><para>Note: <literal>none</literal> can appear as a functor body, but 
            <literal>{ ... }</literal> cannot (unless surrounded by parentheses).</para></comment>
                        
        </section>
            
    <section id="assignableexpressions">
        <title>Assignable expressions</title>
        
        <para>Certain expressions are <emphasis>assignable</emphasis>. An assignable
        expression may appear as the LHS of the <emphasis>:=</emphasis> (assign) operator,
        and possibly, depending upon the type of the expression, as the LHS of the 
        numeric or logical assignment operators <literal>=, +=, -=, *=, /=, %=, &amp;=, 
        |=, ^=, &amp;&amp;=, ||=</literal> or as the subject of the increment or decrement
        operators <literal>++, --</literal>.</para>
        
        <para>The following expressions are assignable:</para>
        
        <itemizedlist>
            <listitem>
                <para>a local declared <literal>mutable</literal>, for example 
                <literal>count</literal>,</para>
            </listitem>
            <listitem>
                <para>any attribute expression where the underlying attribute has a setter
                or is a simple attribute declared <literal>mutable</literal>, for example 
                <literal>person.name</literal>, and</para>
            </listitem>
            <listitem>
                <para>element expressions for the type <literal>OpenCorrespondence</literal>, 
                for example <literal>order.lineItems[0]</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>When an assignment expression is executed, the value of the local or
        attribute is set to the new value, or the <literal>define()</literal> method of
        <literal>OpenCorrespondence</literal> is called.</para>
        
        <para>Thus, the following statement:</para>
        
        <programlisting>order.lineItems[0] := LineItem { product = prod; quantity = 1; };</programlisting>
        
        <para>Is equivalent to the Java:</para>
        
        <programlisting>order.lineItems.define( 0, new LineItem(prod, 1) );</programlisting>
        
        
    </section>
    
    <section id="operators">
    <title>Operators</title>
            
    <para>Operators are syntactic shorthand for more complex expressions
    involving method invocation or attribute access. Each operator is defined 
    for a particular type. There is support for user-defined operator 
    <emphasis>overloading</emphasis>. However, the semantics of an operator 
    may be customized by the implementation of the type that the operator
    applies to.</para>
    
    <para>For example, the following Ceylon code examples:</para>
    
    <programlisting>Float z = x * y;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>x -= 2;</programlisting>
    
    <programlisting>if ( x > 100 ) { ... }</programlisting>
    
    <programlisting>User gavin = users["Gavin"];</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = list[0..20];</programlisting>
    
    <programlisting>for ( Integer i in 1..10 ) { ... }</programlisting>

    <programlisting>if ( name == value ) return ... ;</programlisting>
    
    <programlisting>log.info( "Hello " + $person + "!")</programlisting>
    
    <programlisting>List&lt;String&gt; names = ArrayList&lt;Person&gt;()^.append(person1)^.append(person2)*.name;</programlisting>
    
    <programlisting>optional String name = person?.name;</programlisting>
    
    
    <para>Are equivalent to the following (Ceylon) code:</para>
    
    <programlisting>Float z = x.times(y);</programlisting>
    
    <programlisting>count := count.successor;</programlisting>
    
    <programlisting>Integer j := ( i := i.successor ).predecessor;</programlisting>
    
    <programlisting>z := z.minus(2);</programlisting>
    
    <programlisting>if ( x.compare(100).larger ) { ... }</programlisting>
    
    <programlisting>User gavin = users.value("Gavin");</programlisting>
        
    <programlisting>List&lt;Item&gt; firstPage = list.range(0..20);</programlisting>
    
    <programlisting>for ( Integer i in Range(1,10) ) { ... }</programlisting>

    <programlisting>if ( nullsafeEquals(name, value) ) return ... ;</programlisting>
       
    <programlisting>log.info( "Hello ".join(person.string).join("!") )</programlisting>
    
    <programlisting>List&lt;String&gt; names = 
    Spread&lt;String&gt; { 
        lhs = Chain&lt;String&gt; { 
            lhs = Chain&lt;String&gt; { 
                lhs = ArrayList(); 
                override void call() { lhs.append(person1); } }.lhs
            }
            override void call() { lhs.append(person2); } }.lhs
        }
        override void call(String element) { element.name; } 
    }.result;</programlisting>
    
    <programlisting>optional String name = if (exists person) person.name else null;</programlisting>
    
    <section id="operatorlist">
        <title>List of operators</title>
    
        <para>The following tables define the semantics of the Ceylon operators:</para>
    
    <section id="basic">
    <title>Basic invocation and assignment operators</title>
    
    <para>These operators support method invocation and attribute evaluation and
    assignment. The <literal>$</literal> operator is a shortcut for converting
    any expression to a <literal>String</literal>.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>:=</literal></entry>
            <entry><literal>lhs := rhs</literal></entry>
            <entry>assign</entry>
            <entry></entry>
            <entry><literal>X</literal> or <literal>optional X</literal></entry>
            <entry><literal>X</literal> or <literal>optional X</literal></entry>
            <entry><literal>X</literal> or <literal>optional X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Member reference</emphasis></entry></row>

        <row>
            <entry><literal>#</literal></entry>
            <entry><literal>lhs#member</literal></entry>
            <entry>curry</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry><literal>Callable&lt;functor R(P p, Q q,...)&gt;</literal>, 
            <literal>Value&lt;T&gt;</literal> or
            <literal>OpenValue&lt;T&gt;</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Member invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>.</literal></entry>
            <entry><literal>lhs.member</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry>Member type</entry>
        </row>
        <row>
            <entry><literal>^.</literal></entry>
            <entry><literal>lhs^.member</literal></entry>
            <entry>chain invoke</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>?.</literal></entry>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe invoke</entry>
            <entry><literal>if (exists lhs) lhs.member else null</literal></entry>
            <entry><literal>optional X</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry><literal>optional</literal> member type</entry>
        </row>
        
        <row>
            <entry><literal>*.</literal></entry>
            <entry><literal>lhs*.member</literal></entry>
            <entry>spread invoke</entry>
            <entry><literal>for (X x in lhs) x.member</literal></entry>
            <entry><literal>Iterable&lt;X&gt;</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry><literal>List</literal> of member type</entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Render</emphasis></entry></row>
        
        <row>
            <entry><literal>$</literal></entry>
            <entry><literal>$rhs</literal></entry>
            <entry>render</entry>
            <entry><literal>if (exists rhs) rhs.string else ""</literal></entry>
            <entry></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>String</literal></entry>
        </row>
    
        <row><entry namest="first" nameend="last"><emphasis>Compound invocation assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>.=</literal></entry>
            <entry><literal>lhs.=member</literal></entry>
            <entry>apply</entry>
            <entry>lhs := lhs.member</entry>
            <entry><literal>X</literal></entry>
            <entry>Member of <literal>X</literal>, of
            type <literal>X</literal></entry>
            <entry>X</entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Type, method or functor argument specification</emphasis></entry></row>
        
        <row>
            <entry><literal>(,,)</literal> or {;;;}</entry>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs { a=x; b=y; c=z; }</literal></entry>
            <entry>arguments</entry>
            <entry><literal></literal></entry>
            <entry>Type, method or functor</entry>
            <entry>Parameter types of type, method or functor</entry>
            <entry>Type or return type of method or functor</entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: do we really want the <literal>.=</literal>
    operator?</para></comment>
    
    </section>
        
    <section id="equalitycomparison">
    <title>Equality and comparison operators</title>
    
    <para>These operators compare values for equality, order, magnitude, or membership,
    producing boolean values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Equality</emphasis></entry></row>
        
        <row>
            <entry><literal>===</literal></entry>
            <entry><literal>lhs === rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal>Object.identical(lhs, rhs)</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>==</literal></entry>
            <entry><literal>lhs == rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>if (exists lhs) lhs.equals(rhs) else if (exists rhs) false else true</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>!=</literal></entry>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>if (exists lhs) lhs.equals(rhs).complement else if (exists rhs) true else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=&gt;</literal></entry>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>lhs.compare(rhs).smaller</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>lhs.compare(rhs).larger</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>lhs.compare(rhs).smallAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>lhs.compare(rhs).largeAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>in</literal></entry>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>lhs.in(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Category</literal> or <literal>Iterable&lt;Object&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignability</emphasis></entry></row>
        
        <row>
            <entry><literal>is</literal></entry>
            <entry><literal>lhs is Rhs</literal></entry>
            <entry>is</entry>
            <entry><literal>lhs.instanceOf(#Rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry>Any type</entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <!--  
        <row>
            <entry><literal>~></literal> or <literal>in</literal></entry>
            <entry><literal>lhs ~> rhs</literal> or <literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>lhs.in(rhs)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Category&lt;X&gt;</literal> or <literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row>
            <entry><literal>!~></literal></entry>
            <entry><literal>lhs !~> rhs</literal></entry>
            <entry>not in</entry>
            <entry><literal>lhs.in(rhs).negation</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Category&lt;X&gt;</literal> or <literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row>
            <entry><literal>*~></literal></entry>
            <entry><literal>lhs *~> rhs</literal></entry>
            <entry>all in</entry>
            <entry><literal>for (X x in lhs: !x.in(rhs)) found false fail true</literal></entry>
            <entry><literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Category&lt;X&gt; or <literal>Iterable&lt;X&gt;</literal></literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: should we really have the equality operators accept null
    values?</para></comment>
    
    </section>
                
    <section id="logical">
    <title>Logical operators</title>
    
    <para>These are the usual logical operations for boolean values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Logical operations</emphasis></entry></row>
        
        <row>
            <entry><literal>!</literal></entry>
            <entry><literal>!rhs</literal></entry>
            <entry>not</entry>
            <entry><literal>if (rhs) false else true</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>||</literal></entry>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;&amp;</literal></entry>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>=></literal></entry>
            <entry><literal>lhs => rhs</literal></entry>
            <entry>implication</entry>
            <entry><literal>if (lhs) rhs else true</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>||=</literal></entry>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else lhs:=rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>&amp;&amp;=</literal></entry>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) lhs:=rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="nullvalues">
    <title>Operators for handling null values</title>
    
    <para>These operators make it easy to work with <literal>optional</literal>
    types.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Existence</emphasis></entry></row>
        
        <row>
            <entry><!--<literal>?</literal> or --><literal>exists</literal></entry>
            <entry><!--<<literal>lhs?</literal> or --><literal>lhs exists</literal></entry>
            <entry>exists</entry>
            <entry><literal>if (exists lhs) true else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal><!--??-->nonempty</literal></entry>
            <entry><literal><!--??-->lhs nonempty</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (exists lhs) lhs.empty.complement else false</literal></entry>
            <entry><literal>optional Container</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Default</emphasis></entry></row>
        
        <row>
            <entry><literal>?</literal></entry>
            <entry><literal>lhs ? rhs</literal></entry>
            <entry>default</entry>
            <entry><literal>if (exists lhs) lhs else rhs</literal></entry>
            <entry><literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Default assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>?=</literal></entry>
            <entry><literal>lhs ?= rhs</literal></entry>
            <entry>default assignment</entry>
            <entry><literal>if (exists lhs) lhs else lhs:=rhs</literal></entry>
            <entry><literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>

    <section id="listmap">
    <title>List and map operators</title>
    
    <para>These operators provide a simplified syntax for accessing values 
    of a <literal>Correspondence</literal>, and for joining <literal>List</literal>s.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Concatenation</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>join</entry>
            <entry><literal>lhs.join(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Keyed element access</emphasis></entry></row>
        
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.value(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>?[]</literal></entry>
            <entry><literal>lhs?[index]</literal></entry>
            <entry>nullsafe lookup</entry>
            <entry><literal>if (exists lhs) lhs.value(index) else null</literal></entry>
            <entry><literal>optional Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>optional Y</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>List&lt;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[,,]</literal></entry>
            <entry><literal>lhs[x, y, z]</literal></entry>
            <entry>enumerated lookup</entry>
            <entry><literal>{lhs.value(x), lhs.value(y), lhs.value(z)}</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry>Multiple <literal>X</literal> values</entry>
            <entry><literal>Enumeration&lt;Y&gt;</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Subranges</emphasis></entry></row>
        
        <row>
            <entry><literal>[..]</literal></entry>
            <entry><literal>lhs[x..y]</literal></entry>
            <entry>subrange</entry>
            <entry><literal>lhs.range(x,y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry>Two <literal>Integer</literal> values</entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[x...]</literal></entry>
            <entry>upper range</entry>
            <entry><literal>lhs.range(x)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[...y]</literal></entry>
            <entry>lower range</entry>
            <entry><literal>lhs.range(0,y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        <!--  
        
        <row><entry namest="first" nameend="last"><emphasis>Shift</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;&lt;</literal></entry>
            <entry><literal>lhs &lt;&lt; rhs</literal></entry>
            <entry>left shift</entry>
            <entry><literal>lhs.shiftLeft(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>>></literal></entry>
            <entry><literal>lhs >> rhs</literal></entry>
            <entry>right shift</entry>
            <entry><literal>lhs.shiftRight(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set operations</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs.union(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs.intersection(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>cartesian product</entry>
            <entry><literal>lhs.product(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;Pair&lt;X,Y&gt;&gt;</literal></entry>
        </row>
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>subset</entry>
            <entry><literal>lhs.subset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>superset</entry>
            <entry><literal>lhs.superset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>proper subset</entry>
            <entry><literal>lhs.properSubset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>proper superset</entry>
            <entry><literal>lhs.properSuperset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        -->
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should we overload <literal>*</literal> for lists, like
    in some other languages? It is nice to be able to do stuff like 
    <literal>"-"*n</literal>.</para></comment>
    
    </section>
    
    <section id="constructors">
    <title>Operators for constructing objects</title>
    
    <para>These operators simplify the syntax for constructing certain commonly 
    used built-in types.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Range and entry constructors</emphasis></entry></row>

        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>T where T &gt;= Ordinal &amp; T &gt;= Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>-></literal></entry>
            <entry><literal>lhs -> rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Datetime and interval constructors</emphasis></entry></row>

        <row>
            <entry><literal>@</literal></entry>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>T where T >= Instant</literal></entry>
            <entry><literal>Instant&lt;T&gt;</literal></entry>
            <entry><literal>Interval&lt;T&gt;</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="arithmetic">
    <title>Arithmetic operators</title>
    
    <para>These are the usual mathematical operations for all kinds of
    numeric values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>++rhs</literal></entry>
            <entry>successor</entry>
            <entry><literal>rhs := rhs.successor</literal></entry>
            <entry></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>--rhs</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>rhs := rhs.predecessor</literal></entry>
            <entry></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>lhs++</literal></entry>
            <entry>increment</entry>
            <entry><literal>(lhs := lhs.successor).predecessor</literal></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>lhs--</literal></entry>
            <entry>decrement</entry>
            <entry><literal>(lhs := lhs.predecessor).successor</literal></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operations</emphasis></entry></row>
        
        <!-- Unary negative -->
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.inverse</literal></entry>
            <entry></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <!-- Numeric -->
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.plus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.minus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.divided(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>%</literal></entry>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.remainder(rhs)</literal></entry>
            <entry><literal>Integral&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>**</literal></entry>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>power</entry>
            <entry><literal>lhs.power(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>+=</literal></entry>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>lhs := lhs.plus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>-=</literal></entry>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>lhs := lhs.minus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        <row>
            <entry><literal>*=</literal></entry>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs := lhs.times(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>/=</literal></entry>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs := lhs.divided(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>%=</literal></entry>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs := lhs.remainder(rhs)</literal></entry>
            <entry><literal>Integral&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Duration arithmetic</emphasis></entry></row>
                
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>extend</entry>
            <entry><literal>lhs.extend(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>curtail</entry>
            <entry><literal>lhs.curtail(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs.divide(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Bitwise operations</emphasis></entry></row>
        
        <row>
            <entry><literal>|||</literal></entry>
            <entry><literal>lhs ||| rhs</literal></entry>
            <entry>bitwise or</entry>
            <entry><literal>lhs.or(rhs)</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;&amp;&amp;</literal></entry>
            <entry><literal>lhs &amp;&amp;&amp; rhs</literal></entry>
            <entry>bitwise and</entry>
            <entry><literal>lhs.and(rhs)</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        <row>
            <entry><literal>^^^</literal></entry>
            <entry><literal>lhs ^^^ rhs</literal></entry>
            <entry>bitwise xor</entry>
            <entry><literal>lhs.xor(rhs)</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>~rhs</literal></entry>
            <entry>bitwise not</entry>
            <entry><literal>rhs.not</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
        <para>Built-in converters allow for type promotion of numeric values used in 
        expressions. Coverters exist for the following numeric types:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>lang.Natural</literal> to <literal>lang.Integer</literal>,
                <literal>lang.Float</literal>, <literal>lang.Whole</literal> and 
                <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Integer</literal> to <literal>lang.Float</literal>,
                <literal>lang.Whole</literal> and <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Float</literal> to <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Whole</literal> to <literal>lang.Decimal</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>This means that <literal>x + y</literal> is defined for any combination 
        of numeric types <literal>X</literal> and <literal>Y</literal>, except for 
        the combination <literal>Float</literal> and <literal>Whole</literal>, and that
        <literal>x + y</literal> always produces the same value, with the same type, as
        <literal>y + x</literal>.</para>
        
    </section>
    
    <section id="bitwise">
    <title>Bitwise operators</title>
    
    <para>These are C-style bitwise operations for bit strings (unsigned integers).
    A <literal>Boolean</literal> is considered a bit string of length one, so these
    operators also apply to <literal>Boolean</literal> values. Note that in Ceylon
    these operators have a higher precedence than they have in C or Java. There are
    no bitshift operators in Ceylon.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Bitwise operations</emphasis></entry></row>
        
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>~rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>rhs.complement</literal></entry>
            <entry></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>|</literal></entry>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>lhs.or(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;</literal></entry>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>lhs.and(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>^</literal></entry>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>lhs.xor(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        
        <row><entry namest="first" nameend="last"><emphasis>Bitwise assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>|=</literal></entry>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>lhs := lhs.or(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;=</literal></entry>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>lhs := lhs.and(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>^=</literal></entry>
            <entry><literal>lhs ^= rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>lhs := lhs.xor(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    </section>
    
    <section id="operatorprecedence">
        <title>Operator precedence and associativity</title>
        
        <para>This table defines operator precedence from highest to lowest,
        along with associativity rules:</para>
        
    <table>
    <tgroup cols="4">
        <colspec colnum="1" colwidth="2.5*" align="center"/>
        <colspec colnum="2" colwidth="2.0*" align="center"/>
        <colspec colnum="3" colwidth="1.0*" align="center"/>
        <colspec colnum="4" colwidth="0.7*" align="center"/>
    <thead>
        <row>
            <entry>Operations</entry>
            <entry>Operators</entry>
            <entry>Type</entry>
            <entry>Associativity</entry>
        </row>
    </thead>
    <tbody>
    
            <row>
                <entry>Member invocation and lookup, subrange, reflection,
                postfix increment, postfix decrement:</entry>
                <entry>
                <literal>.</literal>, 
                <literal>^.</literal>, 
                <literal>*.</literal>, 
                <literal>?.</literal>, 
                <literal>(,,)</literal>,
                <literal>{;;;}</literal>,
                <literal>[]</literal>, 
                <literal>[..]</literal>, 
                <literal>[...]</literal>, 
                <literal>[,,]</literal>,
                <literal>#</literal>,
                <literal>++</literal>, 
                <literal>--</literal></entry>
                <entry>Binary / ternary / N-ary / unary postfix</entry>
                <entry>Left</entry>
            </row>
            
            <row>
                <entry>Prefix increment, prefix decrement,
                negation, render, bitwise complement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>, 
                <literal>-</literal>, 
                <literal>$</literal>,
                <literal>~</literal> 
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            <!--  
            <row>
                <entry>Exponentiation, shift:</entry>
                <entry>
                <literal>**</literal>,
                <literal>&lt;&lt;</literal>, 
                <literal>>></literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            -->
            <row>
                <entry>Multiplication, division, remainder,
                bitwise and:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal>,
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Addition, subtraction, bitwise or,
                bitwise xor, list concatenation:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal>, 
                <literal>|</literal>, 
                <literal>^</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Date/time composition:</entry> 
                <entry><literal>@</literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Range, interval and entry construction:</entry> 
                <entry><literal>..</literal>, <literal>-></literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <!--
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>?</literal>, <literal>??</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            -->
            <row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>

            <row>
                <entry>Comparison, <!--set comparison,--> containment,
                assignability:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <!--<literal>~></literal>,
                <literal>!~></literal>,
                <literal>*~></literal>-->
                <literal>in</literal>,
                <literal>is</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality:</entry>
                <entry>
                <literal>==</literal>, 
                <literal>!=</literal>, 
                <literal>===</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry>Logical not:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Logical and:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical or:</entry>
                <entry>
                <literal>||</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical implication:</entry>
                <entry>
                <literal>=></literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            
            <row>
                <entry>Assignment:</entry> 
                <entry>
                <literal>:=</literal>, 
                <literal>.=</literal>,
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>,
                <literal>?=</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: should <literal>?</literal> have a higher precedence?</para></comment>
    
    <comment><para>TODO: should <literal>^</literal> have a higher precedence than
    <literal>|</literal> like in C and Java?</para></comment>
    
    <comment><para>TODO: should <literal>^,|,&amp;</literal> have a lower precedence
    than <literal>+,-,*,/</literal> like in Ruby?</para></comment>
    
    <comment><para>Note: if we decide to add <literal>&lt;&lt;</literal> and 
    <literal>&gt;&gt;</literal> later, we could give them the same precedence
    as <literal>**</literal>.</para></comment>
    
    </section>
    
    </section>

    <section id="functorexpressions">
        <title>Functor expressions</title>
        
        <para>A functor expression has this form:</para>
        
        <programlisting>FunctorExpression := FunctorHeader? FormalParams FunctorBody</programlisting>
        
        <para>Functor expressions must specify a formal parameter list.</para>
        
        <para>A functor expression may optionally specify annotations and/or return type. 
        In this case, the keyword <literal>functor</literal> is required.</para>
        
        <para>A functor body may be a single expression, or a block.</para>
        
        <programlisting>FunctorBody = Expression | Block</programlisting>
        
        <para>If the body of a non-<literal>void</literal> functor is a block, the value of 
        the functor, when executed, is determined by the <literal>produce</literal> directive. 
        A functor body may not contain a <literal>return</literal> directive.</para>
                
        <para>For example:</para>
        
        <programlisting>functor Comparison(Float x, Float y) order = functor Comparison(Float x, Float y) { produce x&lt;=&gt;y };</programlisting>
        
        <para>The keyword <literal>functor</literal>, and the return type may be omitted:</para>

        <programlisting>functor Comparison(Float x, Float y) order = (Float x, Float y) { produce x&lt;=&gt;y };</programlisting>
        
        <para>The braces around the functor body and the <literal>produce</literal> keyword 
        may be omitted.</para>
        
        <programlisting>people.sort( (Person x, Person y) y.name &lt;=&gt; x.name );</programlisting>
               
        <programlisting>people.select( (Person p) p.age>18 )
    .collect( (Person p) p.name );</programlisting>
    
        <para>The braces are required for a <literal>void</literal> functor.</para>
        
        <programlisting>namedValues.each( (String name->Object value) { log.info("${name} ${value}"); } );</programlisting>
                 
        <para>A functor expression can only appear as the right side of an assignment, initializer
        or specifier, as an argument, in a control directive, as an element of an enumeration
        instantiation, or surrounded by parentheses.</para>
                        
        <para>Consider the following functor expression:</para>
        
        <programlisting>functor Comparison(String x, String y) order = (String x, String y) { produce x &lt;=&gt; y }</programlisting>
        
        <para>Or, equivalently:</para>
        
        <programlisting>functor Comparison(String x, String y) order = (String x, String y) x &lt;=&gt; y;</programlisting>
        
        <para>These expressions are both equivalent to this Java code:</para>

        <programlisting>F2&lt;String,String,Comparison&gt; order = 
    new F2&lt;String,String,Comparison&gt;() {
        public Comparison call(String x, String y) { 
            return Comparison.compare(x,y); 
        }
    };</programlisting>
        
        <para>And this functor invocation:</para>
        
        <programlisting>Comparison result = order("Gavin", "Emmanuel");</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Comparison result = order.call("Gavin", "Emmanuel");</programlisting>
        
        <para>Functors may refer to immutable locals and members of the
        containing class. They may not refer to mutable locals.</para>
    
        <para>The following code:</para>
        
        <programlisting>(0..10).each( (Integer num) { log.info(num); } );</programlisting>
        
        <para>Is equivalent to:</para>
        
        <programlisting>new Range&lt;Integer&gt;(0, 10).each( 
    new F1&lt;Integer,Boolean&gt;() {
        @Override Boolean call(Integer x) { 
            ParentClass.this.log.info(num); 
        } 
    } );</programlisting>
    
        <para>This code:</para>
        
        <programlisting>Integer min = 0;
Integer max = 10;
List list = list.select( (Integer x) x &gt; min &amp;&amp; x &lt; max );</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>final Integer min = 0; 
final Integer max = 10; 
List list = list.select( new F1&lt;Integer,Boolean&gt;() { 
        @Override Boolean call(Integer x) { 
            return x > min &amp;&amp; x &lt; max; 
        } 
    } );</programlisting>
    
    </section>
               
    <section id="smalltalkprotocol">
        <title>Smalltalk-style method invocation</title>
        
        <para>For parameters of a method which are of functor type, Ceylon provides a 
        special method invocation protocol, inspired by Smalltalk:</para>
        
        <programlisting>PartialMethodInvocation FunctorArguments | FunctorInvocation FunctorArguments?</programlisting>
        
        <para>The protocol begins with either:</para>

        <itemizedlist>
            <listitem>
                <para>a normal method invocation with a period before the method name 
                and an ordered list of parameters surrounded be parentheses, where
                there must be at least one parameter, or</para>
            </listitem>
            <listitem>
                <para>a special method invocation with a functor argument, which omits 
                the period and parentheses, where the functor parameter list may be 
                omitted for functors with no parameters.</para>
            </listitem>
        </itemizedlist>
        
        <para>In neither case are all parameters of the method required.</para>
        
        <programlisting>PartialMethodInvocation := MemberReference TypeArguments? "(" Expression ("," Expression)* ")"</programlisting>
        
        <programlisting>FunctorInvocation := Expression ParameterName SimpleFunctorExpression</programlisting>
        
        <para>For example:</para>
        
        <programlisting>namedValues each (String name->Object value) { 
    log.info("${name} ${value}"); 
};</programlisting>
        
        <programlisting>Set&lt;People&gt; adults = people elements (Person p) p.age>18;</programlisting>

        <programlisting>int index = lineItems firstIndex (LineItem li) !li.product.available;</programlisting>
        
        <programlisting>amounts sort (Float x, Float y) { produce x&lt;=&gt;y };</programlisting>
        
        <programlisting>people sort (Person p, Person q) p.name&lt;=&gt;q.name;</programlisting>
        
        <programlisting>optional String label = x>10 isTrue "big";</programlisting>
        
        <para>Next, a named list of functor parameters may be specified:</para>
        
        <programlisting>FunctorArguments := (ParameterName SimpleFunctorExpression)+</programlisting>
        
        <para>The identifiers listed after the ordered parameter values are names of method 
        parameters of functor type, in the order in which they appear in the method declaration. 
        Each of these arguments is a functor expression, where the functor parameter list may 
        be omitted for functors with no parameters:</para>
        
        <programlisting>SimpleFunctorExpression := FormalParams? FunctorBody</programlisting>
        
        <para>For example:</para>
        
        <programlisting>String label = x>10 isTrue "big" isFalse "little";</programlisting>
        
        <programlisting>people select (Person p) p.name having (Person p) p.age>18;</programlisting>

        <programlisting>optional specialPerson = search (people) findFirst (Person p) p.special orIfNoneFound null;</programlisting>
        
        <programlisting>x>10
isTrue {
    log.debug("big");
    big(x);
}
isFalse {
    log.debug("little");
    little(x);
};</programlisting>

        <comment><para>TODO: there is a small problem here. In <literal>x.foo(y) bar z</literal>, 
        is <literal>bar</literal> the name of a method or of a parameter of 
        <literal>foo()</literal>?</para> That's not such a big deal for the compiler, but
        for the human reader I guess it's going to get confusing occasionally. So should we
        play it safe and require the form <literal>x.foo(y).bar() baz z</literal> in the case 
        that <literal>bar</literal> is the method name?</comment>

        <comment><para>TODO: On the other hand, if we don't want to play things safe, should 
        we allow this invocation protocol for methods with no parameters, or with arguments 
        which are not functors (I have checked that this can be parsed), for example:</para></comment>
        
        <programlisting>Integer x = y integer;</programlisting>
        <programlisting>log info "Hello World";</programlisting>
        <programlisting>log.info(", " join org.employees*.name);</programlisting>

        <section id="iteration">
            <title>Iteration</title>
            
        <para>A specialized invocation syntax is provided for methods which iterate 
        collections. If the first parameter of the method is of type <literal>Iterable&lt;X&gt;</literal>,
        annotated <literal>iterated</literal>, and all remaining parameters are of functor 
        type, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>MemberReference "(" ForIterator ")" FunctorArguments</programlisting>
        
        <para>And each functor expression for a parameter annotated <literal>coordinated</literal>
        of type <literal>functor Y(X x)</literal> or <literal>functor void(X x)</literal> need not 
        declare its parameter. Instead, its parameter is declared by the iterator.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
List&lt;Y&gt; from&lt;X,Y&gt;(iterated Iterable&lt;X&gt; elements,
                  coordinated functor Boolean(X x) having,
                  coordinated functor Y(X x) select);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; names = from (Person p in people) having p>20 select p.name;</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; names = from (people) having (Person p) p>20 select (Person p) p.name;</programlisting>
        
        <para>Or, we may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; labels = from (Key key -> Value value in namedValues)
                      having user.authorized(key) 
                      select "${key} ${value}";</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; labels = from (namedValues)
                      having (Key key -> Value value) user.authorized(key) 
                      select (Key key -> Value value) "${key} ${value}";</programlisting>
                      
        </section>
        
        <section id="localdefinition">
            <title>Local definition</title>
            
        <para>A specialized invocation syntax is also provided for methods which define 
        a local. If the first parameter of the method is of type <literal>X</literal>,
        annotated <literal>specified</literal>, and all remaining parameters are of functor 
        type, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>MemberReference "(" Variable Specifier ")" FunctorArguments</programlisting>
        
        <para>And each functor expression for a parameter annotated <literal>coordinated</literal>
        of type <literal>functor Y(X x)</literal> or <literal>functor void(X x)</literal> need not 
        declare its parameter. Instead, its parameter is declared by the specifier.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
Y ifExists&lt;X,Y&gt;(specified optional X value,
                coordinated functor Y(X x) then, 
                functor Y() otherwise);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Decimal amount = ifExists(Payment p = order.payment) then p.amount otherwise 0.0;</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Decimal amount = ifExists(order.payment) then (Payment p) p.amount otherwise 0.0;</programlisting>
        
         <para>And for the following method declaration:</para>
        
        <programlisting>public static
Y using&lt;X,Y&gt;(specified X resource, 
             coordinated functor Y(X x) seek)
  where X >= Usable;</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Order order = using (Session s = Session()) seek s.get(#Order, oid);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Order order = using (Session()) seek (Session s) s.get(#Order, oid);</programlisting>
        
        </section>
        
        <section id="caseslist">
            <title>Lists of cases</title>
        
        <para>Finally, a specialized invocation syntax is provided for methods which define 
        a list of cases. If the method has a parameter of type 
        <literal>Iterable&lt;Entry&lt;Case&lt;X&gt;, functor Y()&gt;&gt;</literal> annotated 
        <literal>cases</literal>, the parameter may be specified according to:</para>
        
        <programlisting>(case "(" Case ")" SimpleFunctorExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
Y select&lt;X, Y&gt;(X selector,
              cases Entry&lt;Case&lt;X&gt;, functor Y()&gt;... cases);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>return select (payment.type) 
    case (check) payByCheck(payment)
    case (card) payByCard(payment);
</programlisting>
        
        </section>
        <!--  
        <para>Or, If the method has a parameter of type 
        <literal>Enumeration&lt;functor Y(X x)&gt;</literal> annotated <literal>cases</literal>,
        the parameter value may be specified according to:</para>
        
        <programlisting>(LIdentifier FunctorExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
X attempt&lt;X&gt;(functor X() seek, 
             cases functor X(E e) where E>=Exception... except);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>attempt() 
seek { 
    produce doSomething(); 
} 
except (SomethingWrong sw) {
    log.info(sw);
    produce -1;
}
except (SomethingElseWrong sew) {
    log.warn(sew);
    produce -2;
}</programlisting>
        -->
        
    </section>
    
        <!--
        <section>
        <title>TODO: assignment to local variables from surrounding scope</title>
    
        <para>The following code:</para>
        
        <programlisting>Integer min = 0;
Integer max = 0;
Integer count = 0;
Integer size = list.each(Integer x) { 
    if ( x > min ) count++; 
    if ( x > max) max = x; 
};</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>Integer min = 0; 
Integer max = 0;
Integer count = 0;
final List list$1 = list;
final F1&lt;Integer,Boolean&gt; functor$1 = 
    new F1&lt;Integer,Boolean&gt;(min, max, count) { 
        Integer min = (Integer) locals[0];
        Integer max = (Integer) locals[1];
        Integer count = (Integer) locals[2];
        @Override Boolean call(Integer x) { 
            if ( x > min ) count++; 
            if ( x > max) max = x; 
            locals[0] = min;
            locals[1] = max;
            locals[2] = count;
        }
    };
final Integer result$1 = list$1.each(functor$1);
final Object[] locals$1 = functor$1.locals();
min = (Integer) locals[0];
max = (Integer) locals[1];
count = (Integer) locals[2];
Integer size = result$1;</programlisting>

        <para>Or, perhaps:</para>
    
        <programlisting>Integer min = 0; 
Integer max = 0;
Integer count = 0;
final List list$1 = list;
final F1&lt;Integer,Boolean&gt; functor$1 = 
    new F1&lt;Integer,Boolean&gt;(min, max, count) { 
        @Override Boolean call(Integer x) { 
            if ( x > locals[0] ) locals[3]++; 
            if ( x > locals[1] ) locals[1] = x; 
        }
    };
final Integer result$1 = list$1.each(functor$1);
final Object[] locals$1 = functor$1.locals();
min = (Integer) locals[0];
max = (Integer) locals[1];
count = (Integer) locals[2];
Integer size = result$1;</programlisting>

        </section>
    -->
    
</chapter>