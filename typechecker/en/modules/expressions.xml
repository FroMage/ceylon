<chapter id="expressions">
    <title>Expressions</title>
    
    <para>Ceylon expressions are significantly more powerful than Java, allowing a 
    more declarative style of programming.</para>
    
    <para>Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values, special values, and metamodel references,</para>
        </listitem>
        <listitem>
            <para>enumerated instance references,</para>
        </listitem>
        <listitem>
            <para>callable references,</para>
        </listitem>
        <listitem>
            <para>invocation of methods and instantiation of classes,</para> 
        </listitem>
        <listitem>
            <para>evaluation and assignment of attributes,</para>
        </listitem>
        <listitem>
            <para>enumeration of sequences, and</para>
        </listitem>
        <listitem>
            <para>operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>An <emphasis>atom</emphasis> is a literal or special value, an enumerated 
    sequence of expressions, or a parenthesized expression.</para>
    
    <programlisting>Atom := Literal | StringTemplate | SelfReference | Enumeration | ParExpression</programlisting>
    
    <para>A <emphasis>primary</emphasis> is formed by recursively invoking or evaluating 
    members of an atom or toplevel method or class.</para>
    
    <programlisting>Primary := Atom | Meta | EnumeratedInstanceReference | CallableReference | Invocation | Evaluation</programlisting>
    
    <para>More complex expressions are formed by combining expressions using operators, 
    including assignment operators.</para>    
    
    <programlisting>Expression := Primary | Assignment | OperatorExpression</programlisting>
    
    <para>Parentheses are used for grouping:</para>
    
    <programlisting>ParExpression := "(" Expression ")"</programlisting>
    
    <para>Ceylon expressions are validated for typesafety at compile time.
    To determine whether an expression is assignable to a program element 
    such as an attribute, local or formal parameter, Ceylon considers the 
    <emphasis>type</emphasis> of the expression (the type of the objects 
    that are produced when the expression is evaluated). An expression is 
    assignable to a program element if the type of the expression is 
    assignable to the declared type of the program element.</para>
    
    <comment><para>TODO: We need to allow some way to have an expression to be 
    specified as a toplevel element, for DSLs.</para></comment>
    
    <comment><para>TODO: Do we need a definition of "constant expression"? We
    might use it for:</para>
    <itemizedlist>
    <listitem><literal>case</literal> expressions (when are these evaluated?),</listitem>
    <listitem>annotations available at compile time,</listitem>
    <listitem>default parameter values (when are these evaluated?), and</listitem>
    <listitem>initializer/specifier expressions in second part of class body.</listitem>
    </itemizedlist>
    <para>For example, a constant expression might be anything formed from
    literals, enumerated instance references, metamodel references, the 
    <literal>..</literal> and <literal>-></literal> operators and sequence
    enumerations.</para>
    </comment>
    
    <section>
        <title>Object instances, identity, and reference passing</title>
        
        <para>An <emphasis>object</emphasis> is a unique identifier, together with a 
        reference to a class, and a value for each simple attribute of the class 
        (including inherited simple attributes). The object is said to be an 
        <emphasis>instance</emphasis> of the class.</para>
        
        <para>A <emphasis>value</emphasis> is a reference to an object (a copy of its 
        unique identifier). At a particular point in the execution of the program, 
        every attribute of every object that exists, and every initialized local of 
        every method or initializer that is currently executing has a value. Furthermore, 
        every time an expression is executed, it produces a value.</para>
        
        <para>Two values are said to be <emphasis>identical</emphasis> if they are
        references to the same object&mdash;if they hold the same unique identifier. The 
        program may determine the if two values are identical using the <literal>===</literal> 
        operator. It may not directly obtain the unique identifier (which is a purely 
        abstract construct).</para>
        
        <para>Invocation of a method or class initializer results in execution of the 
        method with formal parameter values that are copies of the value produced by 
        executing the argument expressions of the invocation, and a reference to the 
        receiving instance that is a copy of the value produced by executing the receiver
        expression. The value produced by the invocation expression is a copy of the value 
        produced by execution of the <literal>return</literal> directive expression.</para>
        
        <programlisting>Person myself(Person me) { return me }
Person p = ...;
assert() that (myself(p)===p); //assertion never fails</programlisting>

        <programlisting>Semaphore s = Semaphore();
this.semaphore = s;
assert() that (semaphore===s) //assertion never fails</programlisting>
        
        <para>A new object is produced by execution of a class instantiation expression.
        The Ceylon compiler guarantees that if execution of a class initializer terminates
        with no uncaught exception, then every simple attribute of the object has been
        initialized. The value of an non-<literal>mutable</literal> simple attribute or 
        local is initialized for the first time by execution of a specifier. Every class 
        instantiation expression results in an object with a new unique identifier shared 
        by no other existing object. The object exists from the point at which execution 
        of its initializer terminates. <emphasis>Conceptually</emphasis>, the object exists 
        until execution of the program terminates.</para>
        
        <para>In practice, the object exists at least until the point at which it is not 
        reachable by recursively following references from a local in a method or
        initializer currently being executed, or from an expression in a statement 
        currently being executed. At this point, its simple attribute values are no 
        longer accessible to expressions which subsequently execute and the object may 
        be destroyed by the virtual machine. There is no way for the program to determine
        that an object has been destroyed by the virtual machine (unlike Java, Ceylon
        does not provide object finalizers).</para>
        
        <para>A a special exception to the rules defined above:</para>
        
        <itemizedlist>
        <listitem>
            <para>The compiler is permitted to emit bytecode that unexpectedly creates or avoids 
            creating an actual instance of the erasable type <literal>lang.Optional</literal>, 
            of <literal>lang.Referenceable</literal>, or of <literal>lang.Assignable</literal>,
            when an expression is evaluated, as long as this does not affect the execution of 
            the program. (Therefore, the <literal>===</literal> operator is undefined for these 
            types.)</para>
        </listitem>
        <listitem>
            <para>The compiler is permitted to emit bytecode that produces a new instance of one 
            of the the built-in numeric types, of <literal>lang.Range</literal>, of 
            <literal>lang.Entry</literal>, or of <literal>lang.String</literal> without execution 
            of the initializer of the class, whenever any expression is evaluated. Furthermore, 
            it is permitted to use such a newly-produced instance as the value of the expression, 
            as long as the newly-produced instance is equal to the value expected according to 
            the rules above, as determined using the <literal>==</literal> operator. Therefore, 
            the <literal>===</literal> operator is unreliable for the listed types.</para>
        </listitem>
        </itemizedlist>
        
        <programlisting>Boolean identical(Natural x, Natural y) { return x==y }
Natural n = 1;
assert() that (identical(n,n)); //assertion may fail!</programlisting>
        

        <programlisting>String name = "Gavin";
person.name := name;
assert() that (person.name===name) //assertion may fail!</programlisting>
        
        <para>The execution of a Ceylon program complies with the rules laid out by the Java 
        programming language's execution model (Chapter 17 of the Java Language Specification).
        Ceylon attributes and locals are considered <emphasis>variables</emphasis> in the 
        sense of the JLS. Evaluation is considered a <emphasis>use</emphasis> operation, 
        and assignment is considered an <emphasis>assign</emphasis> operation, again in 
        terms of the JLS.</para>
        
    </section>

    <section id="literals">
        <title>Literals</title>
    
    <para>Ceylon supports literal values of the following types:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>Natural</literal> and <literal>Float</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Character</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>String</literal>, and</para>
        </listitem>
        <listitem>
            <para><literal>Quoted</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon does not need a special syntax for <literal>Boolean</literal> literal 
    values, since <literal>Boolean</literal> is just a <literal>Selector</literal>
    with the enumerated instances <literal>true</literal> and <literal>false</literal>.
    The <literal>null</literal> value is just the enumerated instance of the class
    <literal>Null</literal>.</para>
    
    <programlisting>Literal := NaturalLiteral | FloatLiteral | CharacterLiteral | StringLiteral | QuotedLiteral</programlisting>

    <para>All literal values are instances of immutable types. The value of a literal 
    expression is an instance of the type. How this instance is produced is not specified 
    here.</para>
    
    <!--section id="datetime">
        <title><literal>Date</literal> and <literal>Time</literal> literals</title>
        
        <para>A <literal>Date</literal> literal has the form:</para>
        
        <programlisting>DateLiteral := 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <para>A <literal>Time</literal> literal has the form:</para>
        
        <programlisting>TimeLiteral := 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>A <literal>Datetime</literal> may be composed from a <literal>Date</literal> and 
        a <literal>Time</literal> using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <comment><para>TODO: alternatively, we could follow RFC3339-style datetimes, for example:
        <literal>1996-12-19T16:39:57-08:00</literal>.</para></comment>
        
        <comment><para>TODO: should we allow wildcards and ranges, to get cron-style expressions 
        like <literal>'1/*/*' @ '00:00 GMT'</literal>?</para></comment>
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section-->
    
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Natural</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
    <section id="naturalnumber">
        <title>Natural number literals</title>
        
        <para>A natural number literal is an expression of type
        <literal>lang.Natural</literal>.</para>
        
        <programlisting>Natural m = n + 10;</programlisting>
        
        <para>Negative <literal>Integer</literal> values can be 
        produced using the unary <literal>-</literal> operator:</para>
        
        <programlisting>Integer i = -1;</programlisting>
        
    </section>
    
    <section id="floatnumber">
        <title>Floating point number literals</title>
        
        <para>A floating point number literal is an expression of 
        type <literal>lang.Float</literal>.</para>
        
       <programlisting>public Float pi = 3.14159;</programlisting>
        
        <!--
        <para>Equivalent to this Java code:</para>
        
        <programlisting>public final Float pi = new lang.Float(3.14159f);</programlisting>
        -->

    </section>
    
    <section id="character">
        <title>Character literals</title>
        
        <para>A single character literal is an expression of type 
        <literal>lang.Character</literal>.</para>
                
        <programlisting>if ( string[i] == @+ ) { ... }</programlisting>
        
        <!--
        <para>Equivalent to this Java code:</para>
        
        <programlisting>if ( string.at(i).equals( new lang.Character('+') ) ) { ... }</programlisting>
        -->        
        <comment><para>TODO: do we really need character literals?</para></comment>
        
    </section>
    
    <section id="string">
        <title>Character string literals</title>
        
        <para>A character string literal is an expression of type
        <literal>lang.String</literal>.</para>
        
        <programlisting>person.name := "Gavin King";</programlisting>
        
        <programlisting>String multiline = "Strings may
span multiple lines
if you prefer.";</programlisting>

        <programlisting>display("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</programlisting>
        
        <!--
        <para>Equivalent to the following Java code:</para>
        
        <programlisting>person.name().set( new lang.String("Gavin") );</programlisting>
        
        <programlisting>log.info( new lang.String( Time(), " ", message ) );</programlisting>
        
        <programlisting>final lang.String multiline = new lang.String("Strings may\nspan multiple lines\nif you prefer.");</programlisting>
        
        <programlisting>display( new lang.String( "Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n") );</programlisting>
        -->
        
    </section>
    
    <section id="quoted">
        <title>Single quoted literals</title>
        
        <para>Single-quoted strings are used to express literal values for dates, 
        times, regexes and hexadecimal numbers, and even for more domain-specific 
        things like names, cron expressions, internet addresses, and phone numbers.
        This is an important facility since Ceylon is a language for expressing 
        structured data.</para>
        
        <para>A single quoted literal is an expression of type 
        <literal>lang.Quoted</literal>. An extension is responsible for converting 
        it to the appropriate type.</para>
                
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        <programlisting>Boolean isEmail = email.matches( '^\w+@((\w+)\.)+$' );</programlisting>
        <programlisting>Cron schedule = '0 0 23 ? * MON-FRI';</programlisting>
        <programlisting>Color color = 'FF3B66';</programlisting>
        <programlisting>Url url = 'http://jboss.org/ceylon';</programlisting>
        <programlisting>mail.to:='gavin@hibernate.org';</programlisting>
        <programlisting>PhoneNumber ph = '+1 (404) 129 3456';</programlisting>
        <programlisting>Duration duration = '1h 30m';</programlisting>
        
        <para>Extensions that apply to the type <literal>Quoted</literal> are
        evaluated at compile time for single-quoted literals, alowing compile-time
        validation of the contents of the single-quoted string.</para>
        
        <programlisting>public extension Date date(Quoted dateString) { return ... }</programlisting>
        <programlisting>public extension class Regex(Quoted expression) { return ... }</programlisting>
        
        <comment><para>TODO: we should try to support interpolated expressions, 
        just like we do for string literals.</para></comment>
        
        <comment><para>TODO: Quoted literals are used for version numbers and version 
        constraints in the module architecture, for example: <literal>'1.2.3BETA'</literal>.</para></comment>
    
    </section>

    </section>

    <section id="stringtemplates">
        <title>String templates</title>
        
        <para>A character string <emphasis>template</emphasis> contains interpolated 
        expressions, surrounded by character string fragments.</para>
        
        <programlisting>StringTemplate := StringLiteral (Expression? StringLiteral)+</programlisting>
        
        <para>A character string template is an expression of type <literal>StringTemplate</literal>.</para>
        
        <!--
        <programlisting>InterpolatedStringLiteral := LStringLiteral Expression (MStringLiteral Expression)* RStringLiteral</programlisting>
        -->
        
        <programlisting>log.info("Hello, " person.firstName " " person.lastName ", the time is " Time() ".");</programlisting>
        
        <programlisting>log.info("1 + 1 = " 1 + 1 "");</programlisting>
        
        <para>An interpolated expression in a string template may invoke or evaluate:</para>
        
        <itemizedlist>
            <listitem>
                <para>any class member that is visible to the containing scope in 
                which the literal appears, and</para>
            </listitem>
            <listitem>
                <para>any non-<literal>mutable</literal> local, block local attribute 
                getter or block local method declared earlier within the containing 
                scope.</para>
            </listitem>
        </itemizedlist>
        
        <para>An interpolated expression in a string template may not refer to 
        <literal>mutable</literal> locals from the containing scope.</para>
        
        <para>Interpolated expressions are evaluated when the <literal>interpolate()</literal>
        method of <literal>StringTemplate</literal> is called to produce a constant 
        character string.</para>

    </section>
    
    <section id="specialvalues">
        <title>Self references</title>
        
        <para>The type of the following special values depends upon
        the context in which they appear.</para>
        
        <programlisting>SelfReference := "this" | "super"</programlisting>

        <para>The keyword <literal>super</literal> refers to the
        current instance (the instance that is being invoked), and has
        the same members as the immediate superclass of the class, except 
        for <literal>fixed</literal> members. Any invocation of this 
        reference is processed by the method or attribute defined or 
        inherited by this superclass, bypassing any method declaration 
        that overrides the method on the current class or any subclass 
        of the current class. Invocation of <literal>fixed</literal> 
        members upon <literal>super</literal> is not allowed. The 
        <literal>super</literal> reference is not assignable to any 
        type.</para>
        
        <para>The keyword <literal>this</literal> refers to the current 
        instance, and is assignable to both the type of the current 
        class (the class which declares the method being invoked), and 
        to the special type <literal>subtype</literal>, representing 
        the concrete type of the current instance.</para>
        
    </section>
    
    <section id="metamodelreferences">
        <title>Metamodel references</title>
        
        <para>The metamodel object representing a type or program element may be obtained
        using a completely typesafe syntax.</para>
        
        <programlisting>Meta := TypeMeta | MemberMeta | FunctionMeta</programlisting>
        
        <para>Metamodel references are compile-time typesafe.</para>
        
        <programlisting>Type&lt;List&lt;String&gt;&gt; stringListType = List&lt;String&gt;;</programlisting>
        
        <programlisting>Class&lt;Person,Name&gt; personClass = Person;</programlisting>
        
        <programlisting>Method&lt;Log, Void, String&gt; infoMethod = Log.info;</programlisting>
        
        <programlisting>Attribute&lt;Person, Name&gt; nameAttribute = Person.name;</programlisting>
                
        <section>
            <title>Interface and class metamodel references</title>
            
        <para>The <literal>Type</literal> object may be obtained by specifying the full
        type, with type arguments. A <literal>Class</literal> or <literal>Interface</literal> 
        object may be obtained by specifying a class or interface name, without arguments.</para>
        
        <programlisting>TypeMeta := Type</programlisting>
        
        <para>The metamodel expression, <literal>X</literal>, for a type, class or interface is:</para>
        
        <itemizedlist>
             <listitem>
                <para>of type <literal>Type&lt;X&gt;</literal> where 
                <literal>X</literal> is the type, with type arguments, or</para>
            </listitem>
             <listitem>
                <para>of type <literal>Interface&lt;X&gt;</literal> where 
                <literal>X</literal> is the interface, or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>Class&lt;X,P...&gt;</literal> where 
                <literal>X</literal> is the toplevel class and <literal>P...</literal> 
                are the types of the formal parameter list of the class, for every
                overloaded version of the class, or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>MemberClass&lt;X,Y,P...&gt;</literal> where 
                <literal>Y</literal> is the member class and <literal>P...</literal> 
                are the types of the formal parameter list of the class, for every
                overloaded version of the class.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel class <literal>X</literal>, the expression <literal>X</literal>
        is both a metamodel reference and a callable reference. This is consistent, since
        <literal>Class&lt;X,P...&gt;</literal> is a subtype of <literal>Callable&lt;X,P...&gt;</literal>.</para>
        
        <comment><para>TODO: what happens to the type parameters of the class or interface?
        Do they get replaced by their upper bounds?</para></comment>
        
        </section>
        
        <section>
            <title>Toplevel method metamodel references</title>
            
        <para>A <literal>Function</literal> object representing a toplevel method may be 
        obtained by specifying the method name.</para>
        
        <programlisting>FunctionMeta := MemberName</programlisting>
               
        <para>The metamodel expression, <literal>method</literal>, for a toplevel method 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignable to <literal>Function&lt;R,P...&gt;</literal> where 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first formal parameter list of the method, and 
                <literal>P...</literal> are the types of the first formal parameter 
                lists of the method, for every overloaded version of the method.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that for a toplevel method <literal>x()</literal>, the expression <literal>x</literal>
        is both a metamodel reference and a callable reference. This is consistent, since
        <literal>Function&lt;X,P...&gt;</literal> is a subtype of <literal>Callable&lt;X,P...&gt;</literal>.</para>
           
        </section>
        
        <section>
            <title>Method and attribute metamodel references</title>
            
        <para>A <literal>Method</literal> or <literal>Attribute</literal> object 
        representing a member may be obtained by specifying the type and member name.</para>
        
        <programlisting>MemberMeta := Type "." MemberName</programlisting>
               
        <para>The metamodel expression, <literal>X.member</literal>, for a member method 
        or attribute is:</para>
        
        <itemizedlist>
            <listitem>
                <para>of type <literal>Attribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                unless the attribute is declared <literal>mutable</literal>, or</para>
            </listitem>
            <listitem>
                <para>of type <literal>MutableAttribute&lt;X,T&gt;</literal> where 
                <literal>X</literal> is the type that defines the attribute, 
                and <literal>T</literal> is the declared type of the attribute,
                if the attribute is declared <literal>mutable</literal>, or</para>
            </listitem>
            <listitem>
                <para>assignable to <literal>Method&lt;X,R,P...&gt;</literal> where 
                <literal>X</literal> is the type that defines the method, and 
                <literal>R</literal> is the callable type of a method produced by 
                removing the first formal parameter list of the method, and 
                <literal>P...</literal> are the types of the first formal parameter 
                lists of the method, for every overloaded version of the method.</para>
            </listitem>
        </itemizedlist>
         
        </section>
        
        <section>
            <title>Using the metamodel</title>
            
        <para>The metamodel object for a type allows its members to be iterated:</para>
        
        <programlisting>Type&lt;Object&gt; t = ...;
for (Attribute&lt;Object,String&gt; a in t.attributes(String)) {
    log.info(a.name + "=" + a(person));
}
for (Method&lt;Object,String&gt; m in t.methods(Callable&lt;String&gt;)) {
    log.info(m.name + "=" + m(person)());
}</programlisting>
        
        <para>The metamodel object for a class, attribute or method implements 
        <literal>Callable</literal> and is therefore invokable.</para>
        
        <programlisting>Class&lt;ArrayList&lt;String&gt;,Iterable&lt;String&gt;&gt; arrayListClass = ArrayList&lt;String&gt;;
        
List list = arrayListClass("foo", "bar", "baz);</programlisting>
        
        <programlisting>Attribute&lt;Person, String&gt; nameAttribute = Person.name;
        
String personName = nameAttribute(person);</programlisting>
        
        <programlisting>Method&lt;Person, String&gt; sayMethod = Person.say;
        
String result = sayMethod(person)();</programlisting>

        <programlisting>MutableAttribute&lt;Counter, Natural&gt; countAttribute = Counter.count;

countAttribute(this)++;</programlisting>        

        <para>The metamodel object for a class, attribute or method supports registration 
        of a listener, which intercepts invocations.</para>
        
        <programlisting>MutableAttribute&lt;Counter, Natural&gt; countAttribute = Counter.count;

countAttribute.addListener() 
    onGet (Counter c, Natural proceed()) {
        log.debug("getting");
        return proceed()
    };
    
countAttribute.addListener() 
    onSet (Counter c, Natural proceed(Natural n), Natural value) {
        log.debug("setting");
        return proceed(value)
    };</programlisting>

        <programlisting>Method&lt;Order,Item,Product,Natural&gt; createItemMethod = Order.createItem;
        
createItemMethod.addListener(currentOrder) 
    onInvoke (Item proceed(Product p, Natural n),  
              Product product, Natural quantity) {
        log.debug("invoking in transaction");
        try (Transaction()) {
            return proceed(product,quantity)
        }
    };</programlisting>
    
        </section>
    
        <comment><para>TODO: According to this, we can "curry" in type arguments of
        the type. We need this. But if so, why can't we curry type arguments of the 
        member? It's not a problem from the grammar point of view.</para></comment>
        
    </section>

    <section id="enumeratedinstancereferences">
        <title>Enumerated instance references</title>
        
        <para>An enumerated instance of a class is identified according to:</para> 
        
        <programlisting>EnumeratedInstanceReference := (Type ".")? MemberName</programlisting>
        
        <para>The type is required unless the enumerated instance was explicitly 
        imported or is a member of a containing class.</para>
        
        <para>The type of the enumerated instance reference is the class of which
        the enumerated instance is a member.</para>
        
        <para>The value of an enumerated instance reference is the instance of
        the class that was instantiated when the class was loaded by the virtual
        machine.</para>
        
        <programlisting>DayOfWeek sunday = DayOfWeek.sun;</programlisting>
        
    </section>
    
    <section id="callablereferences">
        <title>Callable references</title>
        
        <para>A <emphasis>callable reference</emphasis> is a reference to 
        something&mdash;a method or class&mdash;that can be <emphasis>invoked</emphasis>
        by specifying a list of arguments.</para>
        
        <programlisting>CallableReference := MethodReference | ConstructorReference</programlisting>
        
        <para>A callable reference may be invoked immediately, or it may be passed 
        to other code which may invoke the reference. A callable reference captures 
        the return type and formal parameter lists of the method, callable parameter, 
        or class it refers to, allowing compile-time validation of argument types when 
        the callable reference is invoked.</para>
        
        <para>A callable reference expression is assignable to 
        <literal>Callable&lt;T,P...&gt;</literal> where <literal>T</literal> and 
        <literal>P...</literal> depend upon the schema of the method or class.</para>
        
        <para>If the callable reference specifies a method name (or callable 
        parameter name), it is called a <emphasis>method reference</emphasis>.</para>

        <programlisting>MethodReference := (Receiver ".")? MemberName</programlisting>        

        <para>The type of a method reference expression is assignable to the callable 
        type of every overloaded version of the method. Calling the callable reference 
        results in execution of the method.</para>

        <para>If the callable reference specifies a class name, it is called a 
        <emphasis>constructor reference</emphasis>.</para>
        
        <programlisting>ConstructorReference := (Receiver ".")? TypeName</programlisting>
        
        <para>The type of a constructor reference expression is assignable to the 
        callable type of every overloaded version of the class. Calling the constructor 
        reference results in instantiation of the class.</para>
        
        <para>A callable reference may specify a receiver expression. When a callable 
        reference with a receiver expression is executed, the receiver expresson is 
        evaluated and a reference to the resulting value is held as part of the 
        callable reference.</para>
        
        <section>
            <title>Receiver expressions</title>
        
        <para>The <emphasis>receiver expression</emphasis> produces the instance upon 
        which a member is invoked or evaluated. The type of the receiver expression 
        must declare a member with the specified name.</para>
        
        <programlisting>Receiver := Primary InvocationOperator</programlisting>
        
        <para>A receiver expression must be explicitly specified, unless:</para>
        
        <itemizedlist>
            <listitem>
                <para>the reference is to a toplevel method or class,</para>
            </listitem>
            <listitem>
                <para>the reference is to a local or formal parameter, or</para>
            </listitem>
            <listitem>
                <para>the current instance of a containing class is the receiver.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <!--
        <section>
            <title>Method reference typing</title>
        
        <para>Method references do not, strictly speaking, have types. However, the schema
        of a method reference determines if it can appear to the right of the <literal>=</literal>
        specifier in a method declaration, or as an argument to a functional parameter. In this
        case we say the method reference <emphasis>conforms</emphasis> to the schema of the
        method or functional parameter.</para>

        <para>A method reference schema <emphasis>conforms</emphasis> to a method or functional 
        parameter schema if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the return type of the method reference is assignable to the declared
                return type of the method or functional parameter, and</para>
            </listitem>
            <listitem>
                <para> the method reference has exactly the same number of formal parameters, 
                with the same types, as the method or functional parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>Thus, method schemas are covariant in return type, and nonvariant in parameter 
        types.</para>
        
        <para>The schema also restricts the the argument list that can be specified when the
        method reference is invoked.</para>
        
        <para>Additionally, method references are assignable to <literal>Callable&lt;X&gt;</literal>
        where <literal>X</literal> is the return type. Note that <literal>Callable</literal>
        does not capture formal parameter types, and so references of type 
        <literal>Callable&lt;X&gt;</literal> are therefore not method references.</para>
        
        <comment><para>TODO: could we make method references contravariant in the parameter
        types? If so, we should use the same rule for overriding.</para></comment>
        
        <comment><para>TODO: does a method schema with a defaulted parameter conform to a method 
        schema without that parameter?</para></comment>
        
        </section>
         -->
         
        <section>
            <title>Callable objects as method implementations</title>
            
        <para>An expression of type <literal>Callable</literal> may be used to define a 
        method using <literal>=</literal>. The expression type must be assignable to the 
        callable type of the method being defined.</para>
        
        <programlisting>Comparison order(X x, Y y) = Order.reverse;</programlisting>
        
        <programlisting>void display(String message) = log.info;</programlisting>
        
        <programlisting>String newString(Character... chars) = String;</programlisting>
        
        </section>
        
        <section>
            <title>Callable objects as callable parameter arguments</title>
            
        <para>An expression of type <literal>Callable</literal> may appear as an argument 
        to a callable parameter, either as a positional argument, or as an argument 
        specified using <literal>=</literal> in a named parameter invocation. The expression 
        type must be assignable to the callable type of the callable parameter.</para>
        
        <para>This method has a callable parameter:</para>
        
        <programlisting>void sort(List&lt;String&gt; list, Comparison by(String x, String y)) { ... }</programlisting>

        <para>This code passes a reference to a local method to the method.</para>
        
        <programlisting>Comparison reverseAlpha(String x, String y) { return y&lt;=&gt;x }
sort(names, reverseAlpha);</programlisting>
        
        <para>This class has two callable parameters:</para>
        
        <programlisting>public class TextInput(Natural size=30, String onInit(), String onUpdate(String s)) { ... }</programlisting>
 
        <para>This code instantiates the class, passing references to the <literal>getIt()</literal> 
        and <literal>setIt()</literal> methods of the <literal>Assignable</literal> for 
        the attribute <literal>person.name</literal>:</para>
        
        <programlisting>TextInput it = TextInput { 
    size=15; 
    onInit = person.name.getIt;
    onUpdate = person.name.setIt;
}</programlisting>
        
        </section>
        
        <section>
            <title>Callable objects as method return values</title>
            
        <para>An expression of type <literal>Callable</literal> may be returned by a method 
        with multiple parameter lists. The expression must be assignable to the callable 
        type of a method formed by eliminating the first parameter list of the method.</para>
        
        <programlisting>Comparison getOrder(Boolean reverse=false)(Natural x, Natural y) {
    if (reverse) {
        Comparison reverse(Natural x, Natural y) { return y&lt;=&gt;x }
        return reverse
    else {
        Comparison natural(Natural x, Natural y) { return x&lt;=&gt;y }
        return natural
    }
}</programlisting>

        <para>This is slightly simpler using type inference:</para>

        <programlisting>Comparison getOrder(Boolean reverse=false)(Natural x, Natural y) {
    if (reverse) {
        local reverse(Natural x, Natural y) { return y&lt;=&gt;x }
        return reverse
    else {
        local natural(Natural x, Natural y) { return x&lt;=&gt;y }
        return natural
    }
}</programlisting>

        <para>Calling a method with multiple parameter lists is similar to the operation 
        of "currying" in a functional programming language.</para>
        
        <programlisting>Comparison order(Natural x, Natural y) = getOrder();
Comparison comp = order(1,-1);</programlisting>

        <para>This is even simpler using type inference:</para>

        <programlisting>local order(Natural x, Natural y) = getOrder();
local comp = order(1,-1);</programlisting>

        <para>Of course, more than one argument list may be specified in a single expression:</para>
        
        <programlisting>Comparison comp = getOrder(true)(10, 100);</programlisting>
        
        </section>
        
    </section>

    <section id="invocation">
        <title>Invocation</title>
        
        <para>A callable object&mdash;anything that implements <literal>Callable</literal>&mdash;is 
        <emphasis>invokable</emphasis>. An <emphasis>invocation</emphasis> consists of an 
        <emphasis>invoked expression</emphasis> of type <literal>Callable&lt;T,P...&gt;</literal>, 
        together with an argument list and, optionally, an explicit type argument list.</para>
        
        <programlisting>Invocation := Primary TypeArguments? Arguments</programlisting>
            
        <para>Any invocation expression where the invoked expression is a callable reference 
        expression is called a <emphasis>direct invocation</emphasis> of the method, callable
        parameter, or class. In the case of a direct invocation, the compiler has additional 
        information about the schema of the method or class that is not reified by the 
        <literal>Callable</literal> interface. The compiler is aware of:</para>
        
        <itemizedlist>
            <listitem>
                <para>all the overloaded versions of the method (the various
                <literal>Callable</literal> types to which the callable reference
                expression is assignable),</para>
            </listitem>
            <listitem>
                <para>the names of the formal parameters of the method or class,</para>
            </listitem>
            <listitem>
                <para>which formal parameters are defaulted, and their default
                values, and</para>
            </listitem>
            <listitem>
                <para>whether the last formal parameter in the list is a varargs
                parameter.</para>
            </listitem>
        </itemizedlist>
                
        <para>An invocation must specify arguments for parameters of the callable object, 
        either by listing parameter values in order or, in the case of a direct invocation, 
        listing named parameter values.</para>
        
        <programlisting>Arguments := PositionalArguments FunctionalArguments? | NamedArguments</programlisting>
        
        <para>Arguments to required parameters must be specified. If the invocation is a 
        direct invocation, arguments to defaulted parameters may optionally be specified, 
        and one or more arguments to a varargs parameter may optionally be specified. 
        Otherwise, an argument must be specified for each defaulted parameter, and a 
        single argument must be specified for the varargs parameter.</para>
        
        <para>For a required or defaulted formal parameter of type <literal>T</literal>, 
        the type of the corresponding argument expression must be assignable to 
        <literal>T</literal>.</para>
        
        <para>For a tuple parameter of psuedo-type <literal>P...</literal>, the type of the 
        corresponding argument expression must be <literal>P...</literal>. (That is, it
        must be a tuple parameter of declared type <literal>P...</literal>.)</para>
        
        <para>For a varargs parameter of type <literal>T...</literal>, there may 
        either:</para>
        
        <itemizedlist>
            <listitem>
                <para>be a single argument expression of type assignable to 
                <literal>Iterable&lt;T&gt;</literal>, or</para>
            </listitem>
            <listitem>
                <para>in the case of a direct invocation, an arbitrary number of argument 
                expressions of type assignable to <literal>T</literal>.</para>
            </listitem>
        </itemizedlist>
         
        <para>In the second case, the argument expressions are evaluated and collected into an 
        instance of <literal>Iterable&lt;T&gt;</literal> when the invocation is executed.</para>
        
        <para>When a invocation expression of a callable reference is executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>each argument is evaluated in turn in the calling context, then</para>
            </listitem>
            <listitem>
                <para>the actual member to be invoked is determined by considering the runtime
                type of the receiving instance and the static types of the arguments, and then</para>
            </listitem>
            <listitem>
                <para>execution of the calling context pauses while the body of the method or 
                initializer is executed by the receiving instance with the argument values, 
                then</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the method or initializer ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>When an invocation expression of any other invoked expression is executed, the 
        <literal>call()</literal> method of <literal>Callable</literal> is invoked.</para>
        
        <para>The type of an invocation expression is the type argument to the second type parameter
        of the expression type <literal>Callable</literal> (the return type). Thus, the type of a 
        method invocation is the return type of the method and the type of a class instantation is 
        the class. The type of a <literal>void</literal> method invocation is <literal>Void</literal>.</para>
                        
        <section id="methodinvocation">
            <title>Method invocation</title>
            
            <para>A method invocation evaluates to the return value of the method, as specified 
            by the <literal>return</literal> directive. The argument values are passed to the 
            formal parameters of the method, and the body of the method is executed.</para>
            
            <para>The actual value that invocation of a <literal>void</literal> method returns
            is not specified here. However, the <literal>is T</literal> operator always evaluates
            to <literal>false</literal> for any type <literal>T</literal> other than 
            <literal>Void</literal> when applied to the return value of an invocation of a 
            <literal>void</literal> method.</para>
            
            <programlisting>log.info("Hello world!")</programlisting>
            <programlisting>log.info { message = "Hello world!"; }</programlisting>
            <programlisting>printer.print { join = ", "; "Gavin", "Emmanuel", "Max", "Steve" }</programlisting>
            <programlisting>printer.print { "Names: ", from (Person p in people) select (p.name) }</programlisting>
            <programlisting>set person.name("Gavin")</programlisting>
            <programlisting>get process.args()</programlisting>
            
            <programlisting>amounts.sort() by (Float x, Float y) ( x&lt;=&gt;y );</programlisting>
            <programlisting>people.each() perform (Person p) { log.info(p.name); }</programlisting>
            
            <programlisting>hash(default, firstName, initial, lastName)</programlisting>
            <programlisting>hash { algorithm=default; firstName, initial, lastName }</programlisting>
            
            <programlisting>from (people) having (Person p) (p.age>18) select (Person p) (p.name);</programlisting>
            <programlisting>iterate (map) perform (String name->Object value) { log.info("Entry: " name "->" value ""); };</programlisting>
            
        </section>
        
        <section id="classinstantiation">
            <title>Class instantiation</title>
            
            <para>Invocation of a constructor reference is called <emphasis>instantiation</emphasis> 
            of the type. A class instantiation evaluates to a new instance of the class. The argument 
            values are passed to the initialization parameters of the class, and the initializer
            is executed.</para>
                        
            <programlisting>Map&lt;String, Person&gt;(entries)</programlisting>
            <programlisting>Point { x=1.1; y=-2.3; }</programlisting>
            <programlisting>ArrayList&lt;String&gt; { capacity=10; "gavin", "max", "emmanuel", "steve", "christian" }</programlisting>
            <programlisting>Iterable&lt;String&gt; tokens = input.Tokens();</programlisting>
            
            <programlisting>Panel {
    label = "Hello";
    Input i = Input(),
    Button {
        label = "Hello";
        action() {
            log.info(i.value);
        }
    }
}</programlisting>
            
        </section>
        
        <section id="positionalarguments">
            <title>Positional arguments</title>
        
        <para>When arguments are listed, the arguments list is enclosed in parentheses.</para>
            
        <programlisting>PositionalArguments := "(" ( Expression ("," Expression)* )? ")"</programlisting>
        
        <para>Positional arguments must be listed in the same order as the corresponding formal
        parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para>First, an argument of each required parameters must be specified, in the 
                order in which the required parameters were declared. There must be at least as 
                many arguments as required formal parameters.</para>
            </listitem>
            <listitem>
                <para>Next, arguments of the first arbitrary number of defaulted parameters may 
                be specified, in the order in which the defaulted parameters were declared. If 
                there are fewer arguments than defaulted parameters, the remaining defaulted 
                parameters are assigned their default values.</para>
            </listitem>
            <listitem>
                <para>Finally, if arguments to all defaulted parameters have been specified,
                and if the method declares a varargs parameter, an arbitrary number of arguments 
                to the varargs parameter may be specified. 
                </para>
            </listitem>
        </itemizedlist>
        
        <para>For example:</para>
        
        <programlisting>(getProduct(id), 1)</programlisting>
                
        </section>
        
        <section id="namedarguments">
            <title>Named arguments</title>
            
        <para>When arguments are named, the argument list is enclosed in braces.</para>
        
        <programlisting>NamedArguments := "{" NamedArgument* VarargArguments? "}"</programlisting>
        
        <para>Named arguments may be listed in a different order to the corresponding formal
        parameters.</para>

        <para>Required and defaulted parameter arguments are specified by name. Varargs are 
        specified by listing them, without specifying a name, at the end of the argument list.</para>

        <para>A named argument either:</para> 
        
        <itemizedlist>
            <listitem>
            <para>specifies its value using <literal>=</literal>, and is terminated by a semicolon, 
            or</para>
            </listitem>
            <listitem>
            <para>only for callable parameters, specifies the type or <literal>local</literal>, a 
            formal parameter list and a block of code (an inline method declaration).</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>NamedArgument := SpecifiedNamedArgument | FunctionalNamedArgument</programlisting>
        
        <programlisting>SpecifiedNamedArgument := ParameterName Specifier ";"</programlisting>
        
        <programlisting>FunctionalNamedArgument := (InferableType | "void") ParameterName FormalParams Block</programlisting>
        
        <para>For example:</para>
        
        <programlisting>{ 
    product = getProduct(id); 
    quantity = 1; 
}</programlisting>
        
        <programlisting>{ 
    label = "Say Hello"; 
    void onClick() { 
        say("Hello"); 
    } 
}</programlisting>
        
        <programlisting>{ 
    Comparison by(X x, X y) { return x&lt;=&gt;y } 
}</programlisting>

        <para>This is simpler using type inference:</para>

        <programlisting>{ 
    local by(X x, X y) { return x&lt;=&gt;y } 
}</programlisting>

        <comment><para>TODO: should the named parameter block be allowed to contain arbitrary statements?
        This is more regular, since you can do it in the body of a class, and attribute/method overriding
        is the model that we are following here. And it could be very useful when defining structured
        data.</para></comment>

        <!--comment><para>TODO: Getter, setter specification for parameters declared <literal>mutable</literal>?</para></comment-->
        
        </section>

        <section id="varargarguments">
            <title>Vararg arguments</title>
            
        <para>Vararg arguments are seperated by commas.</para>

        <programlisting>VarargArguments := VarargArgument ("," VarargArgument)*</programlisting>

        <programlisting>VarargArgument := Expression | InferableVariable Specifier</programlisting>
        
        <para>For example:</para>
        
        <programlisting>(1, 1, 2, 3, 5, 8)</programlisting>
        
        <para>A vararg argument may be a local declaration.</para>
        
        <comment><para>TODO: figure this out. Is this only for varargs in a named parameter
        invocation?</para></comment>
        
        <para>A vararg argument may be an <literal>Iterable</literal> of the parameter type.</para>
        
        <programlisting>( {1, 1, 2, 3, 5, 8} )</programlisting>
        
        </section>
        
        <section id="defaultarguments">
            <title>Default arguments</title>
        
        <para>When no argument is assigned to a defaulted parameter by the caller, the 
        default argument defined by the formal parameter declaration is used. The default
        argument expression is evaluated every time the method is invoked with no argument
        specified for the defaulted parameter.</para>
        
        <para>This class:</para>
        
        <programlisting>public class Counter(Natural initialCount=0) { ... }</programlisting>
        
        <!--
        <para>Is equivalent to a class with three Java constructor declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    public Counter() {
        Counter(0);
    }
    
    public Counter(Natural initialCount) {
        ...;
    }
    
    public Counter(CounterParameters namedParameters) {
        Counter( namedParameters.initialCount );
    }

    public static class CounterParameters {
        private Natural initialCount=0;
        CounterParameters initialCount(Natural initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>
        -->
        
        <para>May be instantiated using any of the following:</para>
        
        <programlisting>Counter()</programlisting>
        <programlisting>Counter(1)</programlisting>
        <programlisting>Counter {}</programlisting>
        <programlisting>Counter { initialCount=10; }</programlisting>
        
        <!--
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>new Counter ( new CounterParameters().initialCount(10) );</programlisting>
        -->
        
            <para>This method:</para>
        
            <programlisting>public class Counter() {
        
    package void init(Natural initialCount=0) {
        count:=initialCount;
    }
    
    ...

}</programlisting>
            <!--
            <para>Is equivalent to three Java method declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    void init() {
        init(0);
    }
    
    void init(Natural initialCount) {
        count=initialCount;
    }
    
    void init(CounterInitParameters namedParameters) {
        init( namedParameters.initialCount );
    }

    static class CounterInitParameters {
        private Natural initialCount=0;
        CounterInitParameters initialCount(Natural initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>
            -->
            
            <para>May be invoked using any of the following:</para>
        
            <programlisting>counter.init()</programlisting>
            <programlisting>counter.init(1)</programlisting>
            <programlisting>counter.init {}</programlisting>
            <programlisting>counter.init { initialCount=10; }</programlisting>
            
            <!--
            <para>Is equivalent to this Java code:</para>
        
            <programlisting>counter.init ( new CounterInitParameters().initialCount(10) );</programlisting>
            -->
 
        </section>
        
        <section id="callablearguments">
            <title>Inline callable arguments</title>
            
        <para>After a positional argument list, arguments to callable parameters 
        may be specified with certain punctuation eliminated:</para>
        
        <itemizedlist>
            <listitem>
                <para>the return type is not declared,</para>
            </listitem>
            <listitem>
                <para>if the callable parameter has an empty formal parameter list, 
                the empty parentheses may be eliminated, and</para>
            </listitem>
            <listitem>
                <para>if the body of the method implementation consists of a single
                <literal>return</literal> directive followed by a parenthesized
                expression, the braces and <literal>return</literal> keyword may be 
                eliminated.</para>
            </listitem>
            <!--listitem>
                <para>formal parameter declarations may omit the explicit type, 
                forcing the compiler to infer it, by specifying the keyword 
                <literal>local</literal> where the type usually appears.</para>
            </listitem-->
        </itemizedlist>
        
        <para>These arguments are called an <emphasis>inline callable arguments</emphasis> 
        of a positional parameter invocation.</para>
                
        <programlisting>FunctionalArguments := (ParameterName FunctionalBody)+</programlisting>
        
        <programlisting>FunctionalBody := FormalParameters? ( Block | "(" Expression ")" )</programlisting>
        
        <!--
                
        <programlisting>InferableFormalParameters := "(" (InferableFormalParam ("," InferableFormalParam))? ")"</programlisting>
        
        <programlisting>InferableFormalParam := InferableParam | InferableEntryParamPair | InferableRangeParamPair</programlisting>
        
        <programlisting>InferableParam := Annotation* (InferableType|"void") ParameterName FormalParams*</programlisting>
        
        <programlisting>InferableEntryParamPair := Annotation* InferableType ParameterName "->" Type ParameterName</programlisting>
        
        <programlisting>InferableRangeParamPair := Annotation* InferableType ParameterName ".." ParameterName</programlisting>
        
        -->
        
        <para>For example:</para>
        
        <programlisting>having (Person p) (p.age>18)</programlisting>
        
        <programlisting>by (Float x, Float y) ( x&lt;=&gt;y )</programlisting>
        
        <programlisting>ifTrue (x+1)</programlisting>
        
        <programlisting>each { count+=1; }</programlisting>
        
        <programlisting>perform (Person p) { log.info(p.name); }</programlisting>
        
        <para>Inline callable arguments are listed without any additional punctuation:</para>
        
        <programlisting>ifTrue (x+1) ifFalse (x-1)</programlisting>
        
        <programlisting>select (Person p) (p.name) having (Person p) (p.age>18)</programlisting>
        
        <para>Arguments must be listed in the same order as the formal parameters are 
        declared by the method declaration.</para>
        
        <comment>
        <para>TODO: should we support type inference for the formal parameters? It 
        gets complicated with method overloading. For example:</para>
        <programlisting>by (local x, local y) ( x&lt;=&gt;y )</programlisting>
        <programlisting>having (local p) (p.age>18)</programlisting>
        </comment>

        </section>
        
        <section id="iteration">
            <title>Iteration</title>
            
        <para>A specialized invocation syntax is provided for toplevel methods which iterate 
        collections. If the first parameter of the method is of type <literal>Iterable&lt;X&gt;</literal>,
        annotated <literal>iterated</literal>, and all remaining parameters are callable
        parameters, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>Primary "(" ForIterator ")" FunctionalArguments</programlisting>
        
        <para>And then if a callable parameter has a formal parameter of type 
        <literal>X</literal> annotated <literal>coordinated</literal>, that parameter need 
        not be declared by its argument. Instead, the parameter is declared by the iterator.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public
List&lt;Y&gt; from&lt;X,Y&gt;(iterated Iterable&lt;X&gt; elements, 
                  Boolean having(coordinated X x),
                  Y select(coordinated X x));</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; names = from (Person p in people) having (p>20) select (p.name);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; names = from (people) having (Person p) (p>20) select (Person p) (p.name);</programlisting>
        
        <para>Or, we may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; labels = from (Key key -> Value value in namedValues)
                      having (user.authorized(key)) 
                      select ($key + ": " + $value);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; labels = from (namedValues)
                      having (Key key -> Value value) (user.authorized(key)) 
                      select (Key key -> Value value) ($key + ": " + $value);</programlisting>
        
        <para>Type inference simplifies this further:</para>
        
        <programlisting>local names = from (local p in people) having (p>20) select (p.name);</programlisting>
        
        
        </section>
        
        <section id="localdefinition">
            <title>Variable definition</title>
            
        <para>A specialized invocation syntax is also provided for toplevel methods which define 
        a variable. If the first parameter of the method is of type <literal>X</literal>,
        annotated <literal>specified</literal>, and all remaining parameters are callable
        parameters, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>Primary "(" InferableVariable Specifier ")" FunctionalArguments</programlisting>
        
        <para>And then if a callable parameter has a formal parameter of type 
        <literal>X</literal> annotated <literal>coordinated</literal>, that parameter need 
        not be declared by its argument. Instead, the parameter is declared by the variable 
        specifier.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public
Y ifExists&lt;X,Y&gt;(specified X? value, 
                Y then(coordinated X x), 
                Y otherwise());</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Decimal amount = ifExists(Payment p = order.payment) then (p.amount) otherwise (0.0);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Decimal amount = ifExists(order.payment) then (Payment p) (p.amount) otherwise (0.0);</programlisting>
        
        <para>And for the following method declaration:</para>
        
        <programlisting>public
Y using&lt;X,Y&gt;(specified X resource, 
             Y seek(coordinated X x))
  where X satisfies Usable;</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Order order = using (Session s = Session()) seek (s.get(Order, oid));</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Order order = using (Session()) seek (Session s) (s.get(Order, oid));</programlisting>
        
        <para>Type inference simplifies this further:</para>
        
        <programlisting>local amount = ifExists(local p = order.payment) then (p.amount) otherwise (0.0);</programlisting>
        <programlisting>local order = using (local s = Session()) seek (s.get(Order, oid));</programlisting>
        
        </section>
        
        <!--section id="caseslist">
            <title>Lists of cases</title>
        
        <para>Finally, a specialized invocation syntax is provided for methods which define 
        a list of cases. If the method has a parameter of type 
        <literal>Iterable&lt;Entry&lt;Case&lt;X&gt;, functor Y()&gt;&gt;</literal> annotated 
        <literal>cases</literal>, the parameter may be specified according to:</para>
        
        <programlisting>(case "(" Case ")" SimpleBlockExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public
Y select&lt;X, Y&gt;(X selector,
              cases Entry&lt;Case&lt;X&gt;, functor Y()&gt;... cases);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>return select (payment.type) 
    case (check) payByCheck(payment)
    case (card) payByCard(payment);
</programlisting>
        
        </section-->
        <!--  
        <para>Or, If the method has a parameter of type 
        <literal>Enumeration&lt;functor Y(X x)&gt;</literal> annotated <literal>cases</literal>,
        the parameter value may be specified according to:</para>
        
        <programlisting>(LIdentifier BlockExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public
X attempt&lt;X&gt;(functor X() seek, 
             cases functor X(E e) where E satisfies Exception... except);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>attempt() 
seek { 
    produce doSomething(); 
} 
except (SomethingWrong sw) {
    log.info(sw);
    produce -1;
}
except (SomethingElseWrong sew) {
    log.warn(sew);
    produce -2;
}</programlisting>
        -->

            <section id="resolvingoverloadedmethodsandtypes">
                <title>Resolving direct invocations of overloaded methods and classes</title>
                
                <para>A direct invocation is resolved to a specific toplevel declaration or 
                member of the receiving type at compile time, even if the method or class 
                it refers to is overloaded.</para>
                
        <para>The <emphasis>initial signature</emphasis> of a method or class in a direct
        invocation is formed by:</para>
        
        <itemizedlist>
            <listitem>
                <para>taking the signature of the formal parameter list of the member class, 
                or of the first formal parameter list of the method, and</para>
            </listitem>
            <!--listitem>
                <para>replacing each occurrence of any type alias in the signature with the
                aliased type, and</para>
            </listitem-->
            <listitem>
                <para>replacing each occurrence of any type parameter of the receiving type
                in the signature with the type argument of that parameter in the callable 
                object expression type, and</para>
            </listitem>
            <listitem>
                <para>replacing each occurrence of any type parameter of the method or class 
                in the signature with the explicitly specified type argument, if type arguments 
                were specified, or with the first declared upper bound of the type parameter, 
                or <literal>lang.Void</literal> if the type parameter has no declared upper 
                bound.</para>
            </listitem>
        </itemizedlist>
        
                <para>A direct invocation is <emphasis>resolveable</emphasis> if there is 
                exactly one method, callable parameter, or class declaration which:</para>
                
                <itemizedlist>
                    <listitem>
                        <para>has the specified name,</para>
                    </listitem>
                    <listitem>
                        <para>has the same number of parameters as specified argument expressions,</para>
                    </listitem>
                    <listitem>
                        <para>has a type parameter list to which the type argument list conforms, 
                        if type arguments were explicitly specified,</para>
                    </listitem>
                    <listitem>
                        <para>specifies generic type constraints which are satisfied by the type 
                        arguments, if type arguments were explicitly specified, and which</para>
                    </listitem>
                    <listitem>
                        <para>has an initial signature to which the given argument expression types 
                        are assignable.</para>
                    </listitem>
                </itemizedlist>
                
                <para>In the case of a method with multiple formal parameter lists, only the first
                formal parameter list is considered.</para>
                
                <para>If more than one overloaded declaration has an initial signature to which 
                the arguments are assignable, or if there is no declaration with an initial 
                signature to which the arguments are assignable, the invocation or instantiation 
                is illegal. (Note that Ceylon is stricter and simpler than Java with this rule.)</para>
                                
                <para>Finally, if type arguments were not explicitly specified, there must be a
                combination of type arguments that can be substituted for the type parameters of
                the method or type, respecting constraints upon the type parameters, that results
                in a method schema such that:</para>
                
                <itemizedlist>
                    <listitem>
                        <para>the given argument expression types are assignable to the method
                        parameter types after substitution of the type arguments, and</para>
                    </listitem>
                    <listitem>
                        <para>the expression type of the invocation or instantiation, after 
                        substitution of the type arguments, is assignable to the surrounding
                        context.</para>
                    </listitem>
                </itemizedlist>
                
                <comment><para>TODO: Figure out the details of the type inference implied by this 
                last bit!</para></comment>
                
                <para>If no such combination of type arguments exists, the invocation or 
                instantiation is illegal. (Note that Ceylon is less strict than Java with this 
                rule.)</para>
                
            </section>

        </section>
        
        <!--  
        <section>
            <title>Attribute initialization</title>
            
            <para>Attribute initialization follows the following schema.</para>
            
            <programlisting>AttributeInitialization := Instantiation "{" Initialization* "}"</programlisting>
            
            <para>For example:</para>
            
            <programlisting>Person me = Person() { firstName="Gavin"; initial='A'; lastName="King"; }</programlisting>
            
            <para>The value of an attribute initialization is the instance being initialized.
            The named parameter values are assigned to uninitialized attributes of the instance.</para>
                                   
        </section>
        -->
        
    <!--section id="inlineclassesliteralobjectsenumerations">
        <title>Literal objects, inline classes, and enumerations</title>
    
        <para>Three additional kinds of expressions exist for inline instantiation of an object.</para>
        
        <itemizedlist>
            <listitem>
                <para>Literal objects allow instantiation and initialization of a class without 
                execution of the constructor.</para>
            </listitem>
            <listitem>
                <para>Inline classes allow inline instantiation of an anonymous subclass of a
                certain class.</para>
            </listitem>
            <listitem>
                <para>Enumerations allow instantiation of a collection via a simplified syntax.</para>
            </listitem>
        </itemizedlist>
        
        <para>A literal object or inline class specification may bypass the constructor of the 
        class or superclass. In this case, the literal object or inline class specification takes 
        on responsibility for initialization of simple attributes of the class or superclass. This 
        means that a literal object or inline class specification which bypasses the constructor 
        must exist in a scope in which all attributes of the class or superclass are visible. Use 
        of this feature does not bypass language level accessibility checks.</para>
    
    <section id="literalobjects">
        <title>Literal objects</title>
        
        <para>A literal object is specified according to:</para>
        
        <programlisting>LiteralObject := "new" Type PositionalArguments? "{" (Assignment | Specification)* "}"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Calculator calc = new Calculator() { currentValue := 1.0; };</programlisting>
        
        <programlisting>Person gavin = new Person { 
    firstName = "Gavin";
    initial = 'A';
    lastName = "King";
    address := new Address { ... };
    birthdate = new Date { day = 25; month = MARCH; year = ... };
    employer := jboss;
};</programlisting>

        <para>A literal object must be of a concrete class and must either:</para>
        
        <itemizedlist>
            <listitem>
                <para>specify initialization parameters, and then an arbitrary list of
                mutable attribute assignments, or</para>
            </listitem>
            <listitem>
                <para>specify no initialization parameters, and specify values for each 
                simple attribute of the class, including private attributes, except 
                attributes annotated <literal>transient</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Literal objects which specify no initialization parameters are created without 
        execution of the body of the class to which they belong. Literal objects may refer to 
        immutable locals and members of the containing class in the attribute initializer 
        expressions. They may not refer to mutable locals.</para>
        
        <para>The value of a literal object expression is a new instance of the class.</para>
            
        <comment><para>TODO: are you allowed to have arbitrary code inside a literal object 
        specification?</para></comment>

        <comment><para>TODO: is there some kind of solution for getting around access 
        restrictions if you want to use a literal object specification for a class that
        extends a superclass in another package/module?</para></comment>

        <para>The classes <literal>Serializer</literal> and <literal>Deserializer</literal>
        provide the ability to serialize and deserialize any object to its 
        <emphasis>canonical literal form</emphasis>.</para>
        
        <programlisting>Person person = ...;
Serializer&lt;Person&gt; srlz = Serializer(person);
String serializedPerson = srlz; //using built-in converter
Deserializer&lt;Person&gt; dsrlz = Deserializer&lt;Person&gt;(serializedPerson);
Person deserialized = dsrlz; //using built-in converter</programlisting>

    </section>
    
        <section id="inlineclasses">
            <title>Inline classes</title>
            
            <para>Inline classes may be specified according to:</para>
            
            <programlisting>InlineClass := "new" Annotation* Type PositionalArguments? Interfaces "{" Statement* "}"</programlisting>

            <para>For example:</para>
            
            <programlisting>Task task = new Task() {
    timeout := 1000;
    override void run() { ... }
    override void fail(Exception e) { ... }
};</programlisting>

            <programlisting>return new transactional Database 
        satisfies Resource {
    url = "jdbc:hsqldb:.";
    username = "gavin";
    password = "foobar";
    override void create() { open(); }
    override void destroy() { close(); }
};</programlisting>
            
            <para>An inline class is a literal object expression which may additionally:</para>
            
            <itemizedlist>
                <listitem>
                    <para>include arbitrary code to be executed when the inline class is
                    evaluated,</para>
                </listitem>
                <listitem>
                    <para>declare and override members, and</para>
                </listitem>
                <listitem>
                    <para>declare annotations.</para>
                </listitem>
            </itemizedlist>
            
            <para>The superclass of an inline class may be an abstract class. The inline
            class itself must be concrete.</para>
            
            <para>The value of an inline class expression is a new instance of the inline 
            class.</para>
            
        </section>
        
    </section-->
    
    <section id="attributereferences">
        <title>Attribute references, evaluation, and assignment</title>
        
        <para>An <emphasis>attribute reference</emphasis> is a reference to an attribute
        of some object. A <emphasis>local reference</emphasis> is a reference to a 
        local.</para> 
        
        <programlisting>AttributeReference := (Receiver ".")? MemberName</programlisting>
        
        <para>An attribute reference or local reference may be transparently converted to 
        the actual current value of the attribute, or it may be passed, as a reference, 
        to other code, which may invoke the reference to <emphasis>evaluate</emphasis> 
        the current value of the attribute or local. A reference to a <literal>mutable</literal> 
        attribute or local may be invoked to <emphasis>assign</emphasis> a new value to 
        the attribute or local.</para>
        
        <para>An attribute reference may specify a receiver expression. When an attribute 
        reference is executed, the receiver expression, if any, is evaluated and a reference 
        to the resulting value is held as part of the attribute reference.</para>
        
        <para>The type of an attribute reference or local reference for an attribute or
        local of declared type <literal>X</literal> is:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>X</literal>, if <literal>X</literal> is assignable
                to <literal>Referenceable&lt;Object&gt;</literal>, or, otherwise,</para>
            </listitem>
            <listitem>
                <para><literal>Referenceable&lt;X&gt;</literal>, if the attribute or 
                local is not <literal>mutable</literal>, or if the setter is not visible
                to the block containing the attribute or local reference, or</para>
            </listitem>
            <listitem>
                <para><literal>Assignable&lt;X&gt;</literal>, if the attribute or local 
                is <literal>mutable</literal> and the setter, if any, is visible to the 
                block containing the attribute or local reference.</para>
            </listitem>
        </itemizedlist>
                    
        <comment><para>TODO: an alternative solution to the "recursion" problem would
        be to require an explicit call to <literal>reference</literal> defined by an
        intermediate interface to obtain the <literal>Referenceable</literal> instead 
        of making it an extension, perhaps hiding the call behind a <literal>&amp;</literal>
        operator. That would allow us to pass references to references. Yet another
        alternative is let the method of an extended type "underride" the method of
        the introduced type.</para></comment>
        
        <para>The <literal>Referenceable</literal> object representing a <literal>mutable</literal> 
        local may not be assigned to an attribute, passed as a method argument, passed to
        a control directive, enumerated as the value of a sequence enumeration, or referred 
        to by a nested method or class. It may be assigned to a local, or invoked directly 
        inside the block that obtained it.</para>
        
        <comment><para>TODO: nail down these rules a little better.</para></comment>
        
    <section id="evaluation">
        <title>Evaluation</title>
        
        <para>Invocation of the <literal>getIt()</literal> method of an attribute reference
        or local reference evaluates the attribute or local. The <literal>getIt()</literal> 
        method is declared <literal>extension</literal>, so it does not need to be called 
        explicitly.</para>
        
        <programlisting>String name = person.name;</programlisting>
        
        <programlisting>Referenceable&lt;String&gt; nameRef = person.name;
String name = nameRef.name;</programlisting>

        <programlisting>String getName() = person.name.getIt;</programlisting>
                        
        <para>When a local evaluation is executed, the current value of the local is 
        immediately obtained. The resulting value is the current value of the local.</para>
                
        <para>When an attribute evaluation is executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>the actual member to be invoked is determined by considering the 
                runtime type of the receiving instance, and then</para>
            </listitem>
            <listitem>
                <para>if the member is a simple attribute, the current value of the 
                simple attribute is retrieved from the recieving instance, or</para>
            </listitem>
            <listitem>
                <para>otherwise, execution of the calling context pauses while the body 
                of the attribute getter is executed by the receiving instance, then,</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the getter ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>The resulting value is the current value of the simple attribute or the 
        return value of the attribute getter, as specified by the <literal>return</literal> 
        directive.</para>

        <para>Note that the <literal>value()</literal> method of <literal>Correspondence</literal>
        is also defined to return a <literal>Referenceable</literal>.</para>
        
        <programlisting>Person person = people[index];</programlisting>
        
        <programlisting>Referenceable&lt;Person&gt; personRef = person[index];
Person person = person;</programlisting>

        <programlisting>Person getPerson() = people.[index].getIt;</programlisting>
        
    </section>
    
    <section id="assignment">
        <title>Assignment</title>
            
        <para>Invocation of the <literal>setIt()</literal> method of an attribute reference
        of type <literal>Assignable</literal> assigns of the attribute or local. We usually 
        use an assignment operator instead of invoking <literal>setIt()</literal> directly.</para>
        
        <programlisting>person.name := "Gavin";</programlisting>
        
        <programlisting>Assignable&lt;String&gt; nameRef = person.name;
nameRef := "Gavin";</programlisting>

        <programlisting>String setName(String name) = person.name.setIt;</programlisting>
        
        <para>When an attribute value is assigned:</para>
        
        <itemizedlist>
            <listitem>
                <para>the actual member to be invoked is determined by considering the 
                runtime type of the receiving instance, and then</para>
            </listitem>
            <listitem>
                <para>if the member is a simple attribute or local, the value of the 
                simple attribute of local is set to the new value,</para>
            </listitem>
            <listitem>
                <para>otherwise, execution of the calling context pauses while the body 
                of the attribute setter is executed by the receiving instance with the 
                new value, then,</para>
            </listitem>
            <listitem>
                <para>finally, when execution of the setter ends without a thrown 
                exception, execution of the calling context resumes.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that the <literal>value()</literal> method of <literal>OpenCorrespondence</literal>
        is also defined to return an <literal>Assignable</literal>.</para>
        
        <programlisting>people[index] := person;</programlisting>
        
        <programlisting>Assignable&lt;Person&gt; personRef = people[index];
personRef := person;</programlisting>
        
        <programlisting>Person setPerson(Person p) = people[index].setIt;</programlisting>
    </section>
    
    </section>
    
    <section id="enumeration">
        <title>Enumeration</title>
        
        <para>A sequence may be instantiated by enumerating the elements inside braces:</para>
        
        <programlisting>Enumeration := "{" ( Expression ("," Expression)* )? "}"</programlisting>
                    
        <para>The value of an enumeration is a new instance of <literal>Sequence</literal>,
        containing the enumerated elements in the given order. When an enumeration is 
        executed, each element expression is evaluated, and the resulting values collected 
        together into an object that implements <literal>Sequence&lt;T&gt;</literal> where 
        <literal>T</literal> is a superype of all the enumerated element expression types. 
        The concrete type of this object is not specified here.</para>
        
        <programlisting>String[] names = { "gavin", "max", "emmanuel", "steve", "christian" };</programlisting>
        
        <para>Empty braces <literal>{}</literal> are an abbreviation of <literal>None.none</literal>.</para>
                                
        <programlisting>OpenList&lt;Connection&gt; connections = {};</programlisting>
        
        <para>There is no special syntax for constructing lists, sets or maps. However, the 
        <literal>..</literal> and <literal>-></literal> operators, together with the 
        convenient sequence enumeration syntax, and some built-in extensions help us achieve 
        the desired effect.</para>

        <programlisting>List&lt;String&gt; languages = { "Java", "Ceylon", "Smalltalk", "C#" };</programlisting>
        <programlisting>List&lt;Natural&gt; numbers = 1..10;</programlisting>
            
        <para>Sequences are transparently converted to sets or maps, allowing sets and maps 
        to be initialized as follows:</para>
    
        <programlisting>Map&lt;String, String&gt; map = { "Java"->"Boring...", "Scala"->"Difficult :-(", "Ceylon"->"Fun!" };</programlisting>
        <programlisting>Set&lt;String&gt; set = { "Java", "Ceylon", "Scala" };</programlisting>
        <programlisting>OpenList&lt;String&gt; list = {};</programlisting>
        
        <comment><para>TODO: an alternative to this syntax would be to allow a comma-separated
        list of values without braces after <literal>=</literal>, <literal>in</literal> or 
        <literal>return</literal> and after <literal>:=</literal> in an attribute initializer. 
        The disadvantage to this approach is that enumerations would not be allowed in 
        positional parameter invocations, or in expressions. It's also less regular. On the 
        other hand, it is consistent with how we treat varargs.</para>
        <programlisting>Map&lt;String, String&gt; map = "Java"->"Boring...", "Scala"->"Difficult :-(", "Ceylon"->"Fun!";</programlisting>
        <programlisting>for (String lang in "Java", "Ceylon", "Scala", "C#") { ... }</programlisting>
        <programlisting>join { sep=", "; strings=firstName, initial, lastName; };</programlisting>
        </comment>
            
    </section>
    
    <section id="operators">
    <title>Operators</title>
    
    <para>Operators are syntactic shorthand for more complex expressions
    involving method invocation or attribute access. Each operator is defined 
    for a particular type. There is no support for user-defined operator 
    <emphasis>overloading</emphasis>. However, the semantics of an operator 
    may be customized by the implementation of the type that the operator
    applies to. This is called <emphasis>operator polymorphism</emphasis>.</para>
    
    <para>Some examples:</para>
    
    <programlisting>Float z = x * y + 1.0;</programlisting>
    
    <programlisting>even := n % 2 == 0;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>if ( x > 100 || x &lt; 0 ) { ... }</programlisting>
    
    <programlisting>User? gavin = users["Gavin"];</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = list[0..20];</programlisting>
    
    <programlisting>for ( Natural n in 1..10 ) { ... }</programlisting>
    
    <programlisting>if (char in @A..@Z) { ... }</programlisting>
    
    <programlisting>List&lt;Day&gt; nonworkDays = days[{0,7}];</programlisting>
    
    <programlisting>Natural lastIndex = getLastIndex() ? sequence.lastIndex;</programlisting>

    <programlisting>if ( exists name => name == "Gavin" ) { return ... }</programlisting>
    
    <programlisting>log.info( "Hello " + $person + "!")</programlisting>
    
    <programlisting>List&lt;String&gt; names = { person1, person2, person3 }[].name;</programlisting>
    
    <programlisting>String? name = person?.name;</programlisting>
    
    <programlisting>this.total += item.price;</programlisting>
    
    <programlisting>if ( nonempty args[i] &amp;&amp; !args[i].first == @- ) { ... }</programlisting>
    
    <programlisting>Float vol = length**3;</programlisting>
    
    <programlisting>map.define(person.name->person);</programlisting>
    
    <programlisting>order.lineItems[index] := LineItem { product = prod; quantity = 1; };</programlisting>
    
    <para>In all operator expressions, the arguments of the operator
    must be evaluated from left to right when the expression is executed. In
    certain cases, depending upon the definition of the operator, evaluation 
    of the leftmost argument expression results in a value that causes the final
    value of the operator expression to be produced immediately without evaluation
    of the remaining argument expressions. Optimizations performed by the
    Ceylon compiler must not alter these behaviours.</para>
    
    <section>
        <title>Operator precedence</title>
        
    <para>This table defines the relative precedence of the various operators, 
    from highest to lowest, along with associativity rules:</para>
        
    <table>
    <tgroup cols="4">
        <colspec colnum="1" colwidth="2.5*" align="center"/>
        <colspec colnum="2" colwidth="2.0*" align="center"/>
        <colspec colnum="3" colwidth="1.0*" align="center"/>
        <colspec colnum="4" colwidth="0.7*" align="center"/>
    <thead>
        <row>
            <entry>Operations</entry>
            <entry>Operators</entry>
            <entry>Type</entry>
            <entry>Associativity</entry>
        </row>
    </thead>
    <tbody>
    
            <row>
                <entry>Member invocation and lookup, subrange,
                postfix increment, postfix decrement:</entry>
                <entry>
                <literal>.</literal>,
                <literal>[].</literal>, 
                <literal>?.</literal>, 
                <literal>()</literal>,
                <literal>{}</literal>,
                <literal>[]</literal>,
                <literal>?[]</literal>,
                <literal>[..]</literal>, 
                <literal>[...]</literal>,
                <literal>++</literal>, 
                <literal>--</literal></entry>
                <entry>Binary / ternary / N-ary / unary postfix</entry>
                <entry>Left</entry>
            </row>
            
            <row>
                <entry>Prefix increment, prefix decrement,
                negation, render, bitwise complement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>, 
                <literal>-</literal>, 
                <literal>$</literal>,
                <literal>~</literal> 
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            <!--  
            <row>
                <entry>Exponentiation, shift:</entry>
                <entry>
                <literal>**</literal>,
                <literal>&lt;&lt;</literal>, 
                <literal>>></literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            -->
            <row>
                <entry>Multiplication, division, remainder,
                bitwise and:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal>,
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Addition, subtraction, bitwise or,
                bitwise xor, list concatenation:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal>, 
                <literal>|</literal>, 
                <literal>^</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <!--row>
                <entry>Date/time composition:</entry> 
                <entry><literal>@</literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row-->
            <row>
                <entry>Range<!--, interval--> and entry construction:</entry> 
                <entry><literal>..</literal>, <literal>-></literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <!--
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>?</literal>, <literal>??</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            -->
            <row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>

            <row>
                <entry>Comparison, <!--set comparison,--> containment,
                assignability:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <!--<literal>~></literal>,
                <literal>!~></literal>,
                <literal>*~></literal>-->
                <literal>in</literal>,
                <literal>is</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality:</entry>
                <entry>
                <literal>==</literal>, 
                <literal>!=</literal>, 
                <literal>===</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry>Logical not:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Logical and:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical or:</entry>
                <entry>
                <literal>||</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical implication:</entry>
                <entry>
                <literal>=></literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            
            <row>
                <entry>Assignment:</entry> 
                <entry>
                <literal>:=</literal>, 
                <literal>.=</literal>,
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>,
                <literal>?=</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: should <literal>?</literal> have a higher precedence?</para></comment>
    
    <comment><para>TODO: should <literal>^</literal> have a higher precedence than
    <literal>|</literal> like in C and Java?</para></comment>
    
    <comment><para>TODO: should <literal>^,|,&amp;</literal> have a lower precedence
    than <literal>+,-,*,/</literal> like in Ruby?</para></comment>
    
    <comment><para>Note: if we decide to add <literal>&lt;&lt;</literal> and 
    <literal>&gt;&gt;</literal> later, we could give them the same precedence
    as <literal>**</literal>.</para></comment>
    
    </section>
    
    <section>
        <title>Operator definition</title>
        
    <para>The following tables define the semantics of the Ceylon operators. There 
    are four basic operators which do not have a definition in terms of other 
    operators or invocations:</para>
    
    <itemizedlist>
        <listitem>
            <para>the <emphasis>member selection</emphasis> operator
            <literal>.</literal> separates the receiver expression and member 
            name in a callable reference expression or attribute reference 
            expression,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>argument specification</emphasis> operators
            <literal>()</literal> and <literal>{}</literal> specify the 
            argument list of an invocation,</para>
        </listitem>
        <listitem>
            <para>the <emphasis>identity</emphasis> operator
            <literal>===</literal> evaluates to <literal>true</literal> if 
            its argument expressions evaluate to references to the same 
            object, and <literal>false</literal> otherwise, and</para>
        </listitem>
        <listitem>
            <para>the <emphasis>assignability</emphasis> operator
            <literal>is</literal> evaluates to <literal>true</literal> if 
            its argument expression evaluates to an instance of a class
            assignable to the specified type, and <literal>false</literal> 
            otherwise.</para>
        </listitem>
    </itemizedlist>
    
    <para>The argument expressions of the identity operator must be of type
    <literal>lang.Object</literal>. The argument expression of the assignability 
    operator may be of any type, not limited to types assignable to 
    <literal>Object</literal>.</para>
    
    <para>All other operators are defined in terms of other operators and/or
    invocations.</para>
    
    <para>In the tables, the following pseudo-code is used, which is not legal
    Ceylon syntax:</para>
    
    <para>First,</para>
    
    <programlisting>if (b) then x else y   //pseudocode</programlisting>
    
    <!--
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>X result; if (b) { result=x } else { result=y }</programlisting>
    -->
    
    <para>means the same value produced by the Ceylon library method 
    <literal>ifTrue()</literal>:</para>
    
    <programlisting>ifTrue (b) then (x) else (y)</programlisting>
    
    <para>Second,</para>
    
    <programlisting>if (exists o) then x else y   //pseudocode</programlisting>
    
    <para>means the same value produced by the Ceylon library method 
    <literal>ifExists()</literal>:</para>
    
    <programlisting>ifExists (o) then (x) else (y)</programlisting>
    
    <para>Third,</para>
    
    <programlisting>for (X x in c) e      //pseudocode</programlisting>
    
    <!--
    <para>means the value of <literal>result</literal> after execution of the
    following:</para>
    
    <programlisting>OpenList&lt;E&gt; result = none; for (X x in c) { result.add(e); }</programlisting>
    -->
    
    <para>means the same value produced by the Ceylon library method 
    <literal>from()</literal>:</para>
    
    <programlisting>from (X x in c) select (e)</programlisting>
    
    <para>The tables define semantics only. The compiler is permitted to emit equivalent 
    bytecode that produces the same value as the pseudo-code that defines the operator, 
    without actually executing any invocation, for the following operators:</para>
    
    <itemizedlist>
        <listitem>
            <para>all arithmetic operators,</para>
        </listitem>
        <listitem>
            <para>all bitwise operators,</para>
        </listitem>
        <listitem>
            <para>the comparison and equality operators <literal>=</literal>,
            <literal>!=</literal>, <literal>&lt;=&gt;</literal>, <literal>&lt;</literal>,
            <literal>&gt;</literal>, <literal>&lt;=</literal>, <literal>&gt;=</literal>
            when the argument expression types are built-in numeric types,</para>
        </listitem>
        <listitem>
            <para>the <literal>Range</literal> and <literal>Entry</literal> construction 
            operators <literal>..</literal> and <literal>-></literal>,</para>
        </listitem>
        <listitem>
            <para>the sequence concatenation operator <literal>+</literal>, and</para>
        </listitem>
        <listitem>
            <para>all assignment and compound assignment operators.</para>
        </listitem>
    </itemizedlist>
    
    <para>Therefore, listeners registered for the method invocations and class instantiations 
    that define these operators may not be called when the operator expressions are executed.</para>
    
    </section>
    
    <section id="basic">
    <title>Basic invocation and assignment operators</title>
    
    <para>These operators support method invocation and attribute evaluation and
    assignment. The <literal>$</literal> operator is a shortcut for converting
    any expression to a <literal>String</literal>.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="7.0*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="4.0*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>.</literal></entry>
            <entry><literal>lhs.member</literal></entry>
            <entry>member</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Member&lt;X,T&gt;</literal></entry>
            <entry><literal>Referenceable&lt;T&gt;</literal> or
            <literal>T</literal></entry>
        </row>
        
        <row>
            <entry><literal>()</literal> or <literal>{}</literal></entry>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>Callable&lt;T,P...&gt;</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Reference</emphasis></entry></row>
        
        <row>
            <entry><literal>&amp;</literal></entry>
            <entry><literal>&amp;rhs</literal></entry>
            <entry>rhs.reference</entry>
            <entry></entry>
            <entry></entry>
            <entry><literal>Referenceable&lt;X,V&gt;</literal></entry>
            <entry><literal>Value&lt;X&gt;</literal>
            or <literal>MutableValue&lt;X&gt;</literal></entry>
        </row>
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>:=</literal></entry>
            <entry><literal>lhs := rhs</literal></entry>
            <entry>assign</entry>
            <entry><literal>lhs.setIt(rhs)</literal></entry>
            <entry><literal>Assignable&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Render</emphasis></entry></row>
        
        <row>
            <entry><literal>$</literal></entry>
            <entry><literal>$rhs</literal></entry>
            <entry>render</entry>
            <entry><literal>this.string(rhs)</literal></entry>
            <entry></entry>
            <entry><literal>Object?</literal></entry>
            <entry><literal>String</literal></entry>
        </row>
    
        <row><entry namest="first" nameend="last"><emphasis>Compound invocation assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>.=</literal></entry>
            <entry><literal>lhs.=member</literal></entry>
            <entry>follow</entry>
            <entry><literal>lhs:=lhs.member</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Attribute&lt;X,X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        <row>
            <entry><literal>.=</literal></entry>
            <entry><literal>lhs.=member(x,y,z)</literal></entry>
            <entry>apply</entry>
            <entry><literal>lhs:=lhs.member(x,y,z)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Method&lt;X,X,P..&gt;</literal>,
            together with arguments <literal>P...</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

     </tbody>
    </tgroup>
    </table>
        
        <comment><para>TODO: we could perhaps move the member selection operator <literal>.</literal>
        down to <literal>Object</literal> from <literal>Void</literal> if we somehow turned
        <literal>getIt()</literal> and <literal>setIt()</literal> into basic operators. Not
        sure if this would be advantageous.</para></comment>
        
        <comment><para>TODO: do we really need the <literal>$</literal> operator?</para></comment>
        
        <!--
        <para>Member specification uses one of three different member specification operators:
        <literal>.</literal>, <literal>.?</literal> or <literal>.*</literal>.</para>
        
        <para>The member specification operator depends upon the type of the receiver expression. 
        If <literal>X</literal> is the type that declares the member, the invocation operator must 
        be:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>.</literal> if the expression is of type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>.?</literal> if the expression is of type <literal>Optional&lt;X&gt;</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>.*</literal> if the expression is of type <literal>Iterable&lt;X&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
                
        <para>The type of an invocation (argument specification) expression depends upon the type of 
        the receiver expression:</para>
            
        <itemizedlist>
            <listitem>
                <para><literal>T</literal> if the receiver expression is of type 
                <literal>Callable&lt;T&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>T?</literal> if the expression is of type 
                <literal>Callable&lt;T&gt;?</literal>,
                or</para>
            </listitem>
            <listitem>
                <para><literal>Sequence&lt;T&gt;</literal> if the expression is of type 
                <literal>Iterable&lt;Callable&lt;T&gt;&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The arguments specified in the argument specification must be assignable to the formal
        parameters of the method reference.</para>
        -->
        
    </section>
        
    <section id="equalitycomparison">
    <title>Equality and comparison operators</title>
    
    <para>These operators compare values for equality, order, magnitude, or membership,
    producing boolean values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Equality</emphasis></entry></row>
        
        <row>
            <entry><literal>===</literal></entry>
            <entry><literal>lhs === rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal></literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>==</literal></entry>
            <entry><literal>lhs == rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>if (exists lhs) lhs.equals(rhs) else if (exists rhs) false else true</literal></entry>
            <entry><literal>Object?</literal></entry>
            <entry><literal>Object?</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>!=</literal></entry>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>if (exists lhs) lhs.equals(rhs).complement else if (exists rhs) true else false</literal></entry>
            <entry><literal>Object?</literal></entry>
            <entry><literal>Object?</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=&gt;</literal></entry>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>(lhs&lt;=&gt;rhs).smaller</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>(lhs&lt;=&gt;rhs).larger</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>(lhs&lt;=&gt;rhs).smallAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>(lhs&lt;=&gt;rhs).largeAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>in</literal></entry>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>lhs.in(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Category</literal> or <literal>Iterable&lt;Object&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignability</emphasis></entry></row>
        
        <row>
            <entry><literal>is</literal></entry>
            <entry><literal>lhs is Rhs</literal></entry>
            <entry>is</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
                
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: should we really have the equality operators accept null
    values?</para></comment>
    
    </section>
                
    <section id="logical">
    <title>Logical operators</title>
    
    <para>These are the usual logical operations for boolean values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Logical operations</emphasis></entry></row>
        
        <row>
            <entry><literal>!</literal></entry>
            <entry><literal>!rhs</literal></entry>
            <entry>not</entry>
            <entry><literal>if (rhs) false else true</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>||</literal></entry>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;&amp;</literal></entry>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>=></literal></entry>
            <entry><literal>lhs => rhs</literal></entry>
            <entry>implication</entry>
            <entry><literal>if (lhs) rhs else true</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>||=</literal></entry>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else lhs:=rhs</literal></entry>
            <entry><literal>Assignable&lt;Boolean&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>&amp;&amp;=</literal></entry>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) lhs:=rhs else false</literal></entry>
            <entry><literal>Assignable&lt;Boolean&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="nullvalues">
    <title>Operators for handling null values</title>
    
    <para>These operators make it easy to work with <literal>Optional</literal>
    values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Existence</emphasis></entry></row>
        
        <row>
            <entry><!--<literal>?</literal> or --><literal>exists</literal></entry>
            <entry><!--<<literal>lhs?</literal> or --><literal>lhs exists</literal></entry>
            <entry>exists</entry>
            <entry><literal>lhs is Something&lt;Object&gt;</literal></entry>
            <entry><literal>Object?</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal><!--??-->nonempty</literal></entry>
            <entry><literal><!--??-->lhs nonempty</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (exists lhs) !lhs.empty else false</literal></entry>
            <entry><literal>Container?</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Default</emphasis></entry></row>
        
        <row>
            <entry><literal>?</literal></entry>
            <entry><literal>lhs ? rhs</literal></entry>
            <entry>default</entry>
            <entry><literal>if (exists lhs) lhs else rhs</literal></entry>
            <entry><literal>T?</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Default assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>?=</literal></entry>
            <entry><literal>lhs ?= rhs</literal></entry>
            <entry>default assignment</entry>
            <entry><literal>if (exists lhs) lhs else lhs:=rhs</literal></entry>
            <entry><literal>Assignable&lt;T?&gt;</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
            <entry><literal>T</literal> or <literal>T?</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Nullafe invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>?.</literal></entry>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe member</entry>
            <entry><literal>if (exists lhs) lhs.member else null</literal></entry>
            <entry><literal>X?</literal></entry>
            <entry><literal>Member&lt;X,T&gt;</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>

        <row>
            <entry><literal>()</literal> or <literal>{}</literal></entry>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>nullsafe invoke</entry>
            <entry><literal>if (exists lhs) lhs(x,y,z) else null</literal></entry>
            <entry><literal>Callable&lt;T,P...&gt;?</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T?</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>

    <section id="listmap">
    <title>Correspondence and sequence operators</title>
    
    <para>These operators provide a simplified syntax for accessing values 
    of a <literal>Correspondence</literal>, and for joining and obtaining
    subranges of <literal>Sequences</literal>s.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Keyed element access</emphasis></entry></row>
        
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.value(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y?</literal></entry>
        </row>
        <row>
            <entry><literal>?[]</literal></entry>
            <entry><literal>lhs?[index]</literal></entry>
            <entry>nullsafe lookup</entry>
            <entry><literal>if (exists lhs) lhs[index] else null</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;?</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y?</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>list lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Y[]</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>set lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Iterable&lt;Y&gt;</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Sequence subranges</emphasis></entry></row>
        
        <row>
            <entry><literal>[..]</literal></entry>
            <entry><literal>lhs[x..y]</literal></entry>
            <entry>subrange</entry>
            <entry><literal>range(lhs,x,y)</literal></entry>
            <entry><literal>S where S(X... elements) satisfies X[]</literal></entry>
            <entry>Two <literal>Natural</literal> values</entry>
            <entry><literal>S</literal></entry>
        </row>
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[x...]</literal></entry>
            <entry>upper range</entry>
            <entry><literal>range(lhs,x)</literal></entry>
            <entry><literal>S where S(X... elements) satisfies X[]</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>S</literal></entry>
        </row>
        <!--
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[...y]</literal></entry>
            <entry>lower range</entry>
            <entry><literal>lhs.range(0,y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        -->

        <row><entry namest="first" nameend="last"><emphasis>Sequence concatenation</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>join</entry>
            <entry><literal>join(lhs, rhs)</literal></entry>
            <entry><literal>S(X... elements) where S satisfies X[]</literal></entry>
            <entry><literal>S</literal></entry>
            <entry><literal>S</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Spread invocation</emphasis></entry></row>

        <row>
            <entry><literal>[].</literal></entry>
            <entry><literal>lhs[].member</literal></entry>
            <entry>spread member</entry>
            <entry><literal>for (X x in lhs) x.member</literal></entry>
            <entry><literal>X[]</literal></entry>
            <entry><literal>Member&lt;X,T&gt;</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        
        <row>
            <entry><literal>()</literal> or <literal>{}</literal></entry>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs{a=x;b=y;}</literal></entry>
            <entry>spread invoke</entry>
            <entry><literal>for (C c in lhs) c(x,y,z)</literal></entry>
            <entry><literal>Iterable&lt;Callable&lt;T,P...&gt;&gt;</literal></entry>
            <entry><literal>P...</literal></entry>
            <entry><literal>T[]</literal></entry>
        </row>
        <!--  
        
        <row><entry namest="first" nameend="last"><emphasis>Shift</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;&lt;</literal></entry>
            <entry><literal>lhs &lt;&lt; rhs</literal></entry>
            <entry>left shift</entry>
            <entry><literal>lhs.shiftLeft(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>>></literal></entry>
            <entry><literal>lhs >> rhs</literal></entry>
            <entry>right shift</entry>
            <entry><literal>lhs.shiftRight(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set operations</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs.union(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs.intersection(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>cartesian product</entry>
            <entry><literal>lhs.product(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;Pair&lt;X,Y&gt;&gt;</literal></entry>
        </row>
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>subset</entry>
            <entry><literal>lhs.subset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>superset</entry>
            <entry><literal>lhs.superset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>proper subset</entry>
            <entry><literal>lhs.properSubset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>proper superset</entry>
            <entry><literal>lhs.properSuperset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        -->
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should we have operators for set union/intersection/complement
    and set comparison?</para></comment>
    
    </section>
    
    <section id="constructors">
    <title>Operators for constructing objects</title>
    
    <para>These operators simplify the syntax for constructing certain commonly 
    used built-in types.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Range and entry constructors</emphasis></entry></row>

        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>T where T &gt;= Ordinal &amp; T &gt;= Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>-></literal></entry>
            <entry><literal>lhs -> rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Datetime and interval constructors</emphasis></entry></row>

        <row>
            <entry><literal>@</literal></entry>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>T where T satisfies Instant</literal></entry>
            <entry><literal>Instant&lt;T&gt;</literal></entry>
            <entry><literal>Interval&lt;T&gt;</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should we have operators for performing arithmetic with
    datetimes and durations, constructing intervals and combining dates and 
    times?</para></comment>
    
    </section>
    
    <section id="arithmetic">
    <title>Arithmetic operators</title>
    
    <para>These are the usual mathematical operations for all kinds of
    numeric values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>++rhs</literal></entry>
            <entry>successor</entry>
            <entry><literal>rhs:=rhs.successor</literal></entry>
            <entry></entry>
            <entry><literal>Assignable&lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>--rhs</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>rhs:=rhs.predecessor</literal></entry>
            <entry></entry>
            <entry><literal>Assignable&lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>lhs++</literal></entry>
            <entry>increment</entry>
            <entry><literal>(++lhs).predecessor</literal></entry>
            <entry><literal>Assignable&lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>lhs--</literal></entry>
            <entry>decrement</entry>
            <entry><literal>(--lhs).successor</literal></entry>
            <entry><literal>Assignable&lt;Ordinal&lt;T&gt;&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operations</emphasis></entry></row>
        
        <!-- Unary negative -->
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.inverse</literal></entry>
            <entry></entry>
            <entry><literal>Invertable&lt;I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <!-- Numeric -->
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.plus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.minus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.divided(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>%</literal></entry>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.remainder(rhs)</literal></entry>
            <entry><literal>Integral&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>**</literal></entry>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>power</entry>
            <entry><literal>lhs.power(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>+=</literal></entry>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>lhs:=lhs+rhs</literal></entry>
            <entry><literal>Assignable&lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>-=</literal></entry>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>lhs:=lhs-rhs</literal></entry>
            <entry><literal>Assignable&lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>*=</literal></entry>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs:=lhs*rhs</literal></entry>
            <entry><literal>Assignable&lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>/=</literal></entry>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs:=lhs/rhs</literal></entry>
            <entry><literal>Assignable&lt;Numeric&lt;N&gt;&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>%=</literal></entry>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs:=lhs%rhs</literal></entry>
            <entry><literal>Assignable&lt;Integral&lt;N&gt;&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Duration arithmetic</emphasis></entry></row>
                
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>extend</entry>
            <entry><literal>lhs.extend(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>curtail</entry>
            <entry><literal>lhs.curtail(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs.divide(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        -->
                
    </tbody>
    </tgroup>
    </table>
    
        <para>Built-in converters allow for type promotion of numeric values used in 
        expressions. Coverters exist for the following numeric types:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>lang.Natural</literal> to <literal>lang.Integer</literal>,
                <literal>lang.Float</literal>, <literal>lang.Whole</literal> and 
                <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Integer</literal> to <literal>lang.Float</literal>,
                <literal>lang.Whole</literal> and <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Float</literal> to <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Whole</literal> to <literal>lang.Decimal</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>This means that <literal>x + y</literal> is defined for any combination 
        of numeric types <literal>X</literal> and <literal>Y</literal>, except for 
        the combination <literal>Float</literal> and <literal>Whole</literal>, and that
        <literal>x + y</literal> always produces the same value, with the same type, as
        <literal>y + x</literal>.</para>
        
    </section>
    
    <section id="bitwise">
    <title>Bitwise operators</title>
    
    <para>These are C-style bitwise operations for bit strings (unsigned integers).
    A <literal>Boolean</literal> is considered a bit string of length one, so these
    operators also apply to <literal>Boolean</literal> values. Note that in Ceylon
    these operators have a higher precedence than they have in C or Java. There are
    no bitshift operators in Ceylon.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Definition</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Bitwise operations</emphasis></entry></row>
        
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>~rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>rhs.complement</literal></entry>
            <entry></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>|</literal></entry>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>lhs.or(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;</literal></entry>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>lhs.and(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>^</literal></entry>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>lhs.xor(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        
        <row><entry namest="first" nameend="last"><emphasis>Bitwise assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>|=</literal></entry>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>lhs:=lhs|rhs</literal></entry>
            <entry><literal>Assignable&lt;Bits&lt;X&gt;&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;=</literal></entry>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>lhs:=lhs&amp;rhs</literal></entry>
            <entry><literal>Assignable&lt;Bits&lt;X&gt;&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>^=</literal></entry>
            <entry><literal>lhs ^= rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>lhs:=lhs^rhs</literal></entry>
            <entry><literal>Assignable&lt;Bits&lt;X&gt;&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    </section>
    
</chapter>