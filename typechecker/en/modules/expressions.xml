<chapter id="expressions">
    <title>Expressions</title>
    
    <para>Ceylon expressions are significantly more powerful than Java, allowing a more
    declarative style of programming.</para>
    
    <para>Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values,</para>
        </listitem>
        <listitem>
            <para>invocations of methods, attributes and functors, and instantiations
            of classes,</para>
        </listitem>
        <listitem>
            <para>operators and control expressions, and</para>
        </listitem>
        <listitem>
            <para>functor expressions.</para>
        </listitem>
    </itemizedlist>
    
    <section id="literals">
    <title>Literals</title>
    
    <para>Ceylon supports a special literal value syntax for each of the following types: 
    <!--literal>Boolean</literal--> <literal>Date</literal>, <literal>Time</literal>
    <literal>Integer</literal>, <literal>Float</literal>, <literal>Character</literal>, 
    <literal>String</literal> and <literal>Regex</literal>.
    </para>
    
    <programlisting>Literal :=
DateLiteral | TimeLiteral
IntegerLiteral | FloatLiteral |
CharacterLiteral
StringLiteral | RegexLiteral |
EnumerationLiteral |
"this" | "super" | "null"</programlisting>

    <para>The keywords <literal>this</literal>, <literal>super</literal> and 
    <literal>null</literal> are equivalent to the Java forms.</para>
    
    <!--
    <section>
        <title>Boolean literals</title>
        
        <para>A boolean literal has this form:</para>
        
        <programlisting>BooleanLiteral := "true" | "false"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Boolean found = false;</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>Boolean found = lang.Boolean.FALSE;</programlisting>
        
        <para>TODO: is this really a special literal, or is it just an
        enumerated instance of the <literal>Boolean</literal> class?</para>

    </section>
    -->
    
    <section>
        <title>Datetime literals</title>
        
        <para>A datetime literal has the form:</para>
        
        <!--
        <programlisting>DatetimeLiteral := "now"</programlisting>
        -->
        
        <programlisting>DateLiteral := 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <programlisting>TimeLiteral := 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <!--
        <programlisting>Datetime datetime = now;</programlisting>
        -->
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>Datetimes may be composed from dates and times using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Integer</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section>
    
    <section>
        <title>Integer literals</title>
        
        <para>An integer literal has this form:</para>
        
        <programlisting>IntegerLiteral = 
Digit+ | 
"'" ( HexDigit{4} | HexDigit{8} ) "'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Integer i = i + 10;</programlisting>
        
        <programlisting>panel.backgroundColor = 'FF33';</programlisting>
        
    </section>
    
    <section>
        <title>Float literals</title>
        
        <para>A float literal has this form:</para>
        
        <programlisting>FloatLiteral := 
Digit+ "." Digit+ 
( ("E"|"e")? ("+"|"-")? Digit+ )?</programlisting>
        
        <para>For example:</para>
        
        <programlisting>public static Float pi = 3.14159;</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>public static final Float pi = new lang.Float(3.14159f);</programlisting>

    </section>
    
    <section>
        <title>String literals</title>
        
        <para>A string literal has this form:</para>
        
        <programlisting>StringLiteral = "&quot;" ( Character+ | "${" Expression "}" )* "&quot;"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>person.name = "Gavin";</programlisting>
        
        <programlisting>log.info("${Time()} ${message}");</programlisting>
        
        <programlisting>String multilineString = "Strings may
span multiple lines
if you prefer.";</programlisting>
        
        <para>The first example is equivalent to this Java code:</para>
        
        <programlisting>person.name().set( new lang.String("Gavin") );</programlisting>

    </section>
    
    <section>
        <title>Character literals</title>
        
        <para>A character literal has this form:</para>
        
        <programlisting>CharacterLiteral := "'" Character "'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>if ( string[i] == '+' ) { ... }</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>if ( string.at(i).equals( new lang.Character('+') ) ) { ... }</programlisting>
        
        <para>TODO: do we really need character literals??</para>
        
    </section>
    
    <!--section>
        <title>Byte literals</title>
        
        <para>A byte literal has this form:</para>
        
        <programlisting>ByteLiteral := "'" ( BinaryDigit{8} | HexDigit{2} ) "'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Byte masked = b &amp; '01101001';</programlisting>
        
        <programlisting>Byte byte = 'A0';</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>Byte masked = b.and( new lang.Byte("01101001") );</programlisting>
        
        <programlisting>Byte byte = new lang.Byte("A0")</programlisting>
        
    </section-->
    
    <section>
        <title>Regex literals</title>
        
        <para>A regex literal has this form:</para>
        
        <programlisting>RegexLiteral := "`" RegularExpression "`"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Boolean isEmail = email.matches( `^\w+@((\w+)\.)+$` );</programlisting>
        
        <programlisting>Integer quotedWords = `\W"w+"\W`.matcher(text).count();</programlisting>
        
        <para>The second example is equivalent to this Java code:</para>
        
        <programlisting>Integer quotedWords = new lang.Regex("\\W\"w+\"\\W").matcher(text).count();</programlisting>
        
    </section>
    
    <section>
        <title>Enumeration literals</title>
        
        <para>The following literal is supported, representing an empty enumeration:</para>
        
        <programlisting>"none"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Enumeration&lt;String&gt; enum = none;</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>Enumeration&lt;String&gt; enum = collections.Enumeration.emptyEnumeration&lt;String&gt;();</programlisting>

         <para>TODO: is this really a special literal, or is it just the single
        enumerated instance of the <literal>EmptyEnumeration</literal> class,
        which has a converter to <literal>Enumeration&lt;X&gt;</literal>?</para>

        <para>There are no true literals for lists, sets or maps. However, the
        <literal>..</literal> and <literal>-></literal> operators, together with
        the convenient enumeration constructor syntax, and some built-in converters 
        help us achieve the desired effect.</para>

        <programlisting>List&lt;Integer&gt; numbers = 1..10;</programlisting>
        <programlisting>List&lt;String&gt; languages = { "Java", "Ceylon", "Smalltalk" };</programlisting>
                
        <para>Enumerations are transparently converted to sets or maps,
        allowing sets and maps to be initialized as follows:</para>
        
        <programlisting>Map&lt;String, String&gt; map = { "Java"->"Boring...", "Scala"->"Difficult :-(", "Ceylon"->"Fun!" };</programlisting>
        <programlisting>Set&lt;String&gt; set = { "Java", "Ceylon", "Scala" };</programlisting>
        <programlisting>OpenList&lt;String&gt; list = none;</programlisting>
        
    </section>

    <section>
        <title>Object literals</title>
        
        <para>There are no true literals for objects. Rather, there is a nice syntax 
        for calling the class constructor, assigning attribute values (including 
        constant attribute values) and (optionally) overriding methods and attributes. 
        For example:</para>
        
        <programlisting>Person gavin = Person { 
    firstName = "Gavin";
    initial = 'A';
    lastName = "King";
    address = Address { ... };
    birthdate = Date { day = 25; month = MARCH; year = ... }
    employer = jboss;
};</programlisting>

        <programlisting>Person gavin = Person(jboss) { 
    firstName = "Gavin";
    initial = 'A';
    lastName = "King";
    address = Address { ... };
    birthdate = Date { day = 25; month = MARCH; year = ... }
};</programlisting>

    </section>
    
    <section>
        <title>Type and member literals</title>
        
        <para>The <literal>Type</literal> object for a type, the <literal>Method</literal>
        object for a method, or the <literal>Attribute</literal> object for an attribute
        may be referred to using a special literal syntax:</para>
        
        <programlisting>TypeLiteral := HASH Type</programlisting>
        
        <programlisting>MemberLiteral := Type HASH Identifier</programlisting>
               
        <para>For example:</para>
        
        <programlisting>Type&lt;List&lt;String&gt;&gt; stringListType = #List&lt;String&gt;&gt;;</programlisting>
        <programlisting>Attribute&lt;Person, String&gt; nameAttribute = Person#name;</programlisting>
        <programlisting>Method&lt;Person, (String) void&gt;&gt; sayMethod = Person#say;</programlisting>
        
        <para>Note that the <literal>#</literal> curry operator may also be applied to an 
        arbitrary expression, to obtain a <literal>Callable&lt;(P p,Q q,...) produces R&gt;</literal> 
        where <literal>P p, Q q,...</literal> are the method parameter types and <literal>R</literal> 
        is the method return type, or a <literal>Value&lt;T&gt;</literal> or 
        <literal>OpenValue&lt;T&gt;</literal> where <literal>T</literal> is the attribute 
        type.</para>
        
        
    </section>

    </section>

    <section id="invocations">
        <title>Invocations</title>
        
        <para>Methods, classes, class instances and functors are <emphasis>invokable</emphasis>.
        Invocation of a class is called <emphasis>instantiation</emphasis>. Invocation of a
        class instance is called <emphasis>attribute configuration</emphasis>.</para>
        
        <para>Any invocation must specify values for parameters, either by listing or naming 
        parameter values.</para>
        
        <programlisting>ParamValues := OrderedParamValues | NamedParamValues</programlisting>
        
        <para>Required parameters must be specified. Optional parameters and varargs may also be 
        specified.</para>
        
        <para>When parameter values are listed, required parameters are assigned first, in the order
        in which they were declared, followed by optional parameters, in the order they were declared.
        If there are any remaining optional parameters, they will be assigned their default values.
        On the other hand, if any parameter values are unassigned, they will be treated as varargs.</para>
            
        <programlisting>OrderedParamValues := "(" ( Expression ("," Expression)* )? ")"</programlisting>
                
        <para>When parameter values are named, required and optional parameter values are specified 
        by name. Vararg parameter values are specified by listing them.</para>

        <programlisting>NamedParamValues := "{" NamedParamValue* ( VarargParamValue ("," VarargParamValue)* )? "}"</programlisting>

        <programlisting>NamedParamValue := Identifier Initializer ";"</programlisting>

        <programlisting>VarargParamValue := Expression | Variable Initializer</programlisting>
        <!--programlisting>VarargParamValue := Expression | Variable Initializer | ForComprehension</programlisting-->
        
        <para>A vararg parameter may be a local declaration. Multiple vararg parameters may be
        constructed using a <literal>for</literal> comprehension.</para>
        
        <para>TODO: exactly what types are accepted by a vararg parameter? Any <literal>Iterable</literal>?
        Exactly how is it accessed in the body of the method? As a <literal>List</literal>?</para>
        
        <para>TODO: should there be a special syntax to "spread" the values of a list into vararg
        parameters, eg. <literal>*list</literal>.</para>
        
        <section>
            <title>Method invocation</title>
            
            <para>Method invocations follow the following schema.</para>
            
            <programlisting>MethodInvocation := MethodReference TypeParams? ParamValues</programlisting>
            
            <programlisting>MemberReference := (Expression DOT)? Identifier</programlisting>
            
            <para>For example:</para>
            
            <programlisting>log.info("Hello world!")</programlisting>
            <programlisting>log.info { message = "Hello world!"; }</programlisting>
            <programlisting>printer.print { join = ", "; "Gavin", "Emmanuel", "Max", "Steve" }</programlisting>
            <programlisting>printer.print { "Names: ", from (Person p in people) p.name }</programlisting>
            
            <para>The value of a method invocation is the return value of the method.
            The parameter values are passed to the formal parameters of the method.</para>
            
            <para>Methods may not be invoked on an expression of type <literal>optional</literal>.</para>
            
        </section>
        
        <section>
            <title>Static method invocation</title>
            
            <para>Static method invocations follow the following schema.</para>
            
            <programlisting>StaticMethodInvocation := (RegularType DOT)? Identifier TypeParams? ParamValues</programlisting>
            
            <para>For example:</para>
            
            <programlisting>HashCode.calculate(default, firstName, initial, lastName)</programlisting>
            <programlisting>HashCode.calculate { algorithm=default; firstName, initial, lastName }</programlisting>
            
            <para>The value of a static method invocation is the return value of the static method.
            The parameter values are passed to the formal parameters of the method.</para>
            
        </section>
        
        <section>
            <title>Class instantiation</title>
            
            <para>Classes may be instantiated according to the following schema:</para>
            
            <programlisting>Instantiation := RegularType ParamValues</programlisting>
            
            <para>For example:</para>
            
            <programlisting>Map&lt;String, Person&gt;(entries)</programlisting>
            <programlisting>Point { x=1.1; y=-2.3; }</programlisting>
            <programlisting>ArrayList&lt;String&gt; { capacity=10; "gavin", "max", "emmanuel", "steve", "christian" }</programlisting>
            
            <programlisting>Panel {
    label = "Hello";
    Input i = Input(),
    Button {
        label = "Hello";
        action = () {
            log.info(i.value);
        }
    }
}</programlisting>
            
            <para>The value of a class instantiation is a new instance of the class.
            The parameter values are passed to the initialization parameters of the 
            class. If the class has no initialization parameters, they are assigned
            directly to attributes of the class (in this case, named parameters must 
            be used).</para>
            
        </section>
            
        <section>
            <title>Enumeration instantiation</title>
            
            <para>Enumerations may be instantiated according to the following 
            simplified syntax:</para>
            
            <programlisting>EnumerationInstantiation := "{" Expression ("," Expression)* "}"</programlisting>
            
            <para>In this case, there is no need to explicitly specify the type.</para>
            
            <para>For example:</para>
            
            <programlisting>Enumeration&lt;String&gt; names = { "gavin", "max", "emmanuel", "steve", "christian" };</programlisting>
                        
        </section>
            
        <section>
            <title>Inline classes</title>
            
            <para>Inline classes may be instantiated according to:</para>
            
            <programlisting>InlineClass := Annotation* Instantiation Interfaces Block</programlisting>

            <para>For example:</para>
            
            <programlisting>Task task = Task() {
    timeout=1000;
    override void run() { ... }
    override void fail(Exception e) { ... }
}</programlisting>

            <programlisting>return transactional Database() 
        satisfies Resource {
    url = "jdbc:hsqldb:.";
    username = "gavin";
    password = "foobar";
    override void create() open();
    override void destroy() close();
};</programlisting>
            
            <para>The value of an inline class instantiation is a new instance of the inline class.
            The named parameter values are assigned directly to attributes of the superclass.</para>
            
        </section>
        
        <section>
            <title>Attribute configuration</title>
            
            <para>Attribute configuration follows the following schema.</para>
            
            <programlisting>AttributeConfiguration := Expression NamedParamValues</programlisting>
            
            <para>For example:</para>
            
            <programlisting>person { firstName="Gavin"; initial='A'; lastName="King"; }</programlisting>
            
            <para>The value of an attribute configuration is the instance being configured.
            The parameter values are assigned to attributes of the instance.</para>
                        
        </section>
        
        <section>
            <title>Functor invocation</title>
            
            <para>Functor invocations follow the following schema.</para>
            
            <programlisting>FunctorInvocation := Expression ParamValues</programlisting>
            
            <para>For example:</para>
            
            <programlisting>compare("AAA", "aaa")</programlisting>
            <programlisting>compare { x = "AAA"; y = "aaa"; }</programlisting>
            
            <para>The value of a functor invocation is the return value of the functor.
            The parameter values are passed to the formal parameters of the functor
            implementation.</para>
            
        </section>
        
        <section>
            <title>Attribute access</title>
            
            <para>Attribute get access follows the following schema:</para>
            
            <programlisting>AttributeGet := MemberReference</programlisting>
            
            <para>This attribute getter call:</para>
        
            <programlisting>String name = person.name;</programlisting>
        
            <para>is equivalent to the following Java code:</para>

            <programlisting>String name = person.name().get();</programlisting>
        
            <para>Attribute set access follows the following schema:</para>
            
            <programlisting>AttributeSet := MemberReference "=" Expression</programlisting>
            
            <para>This attribute setter call:</para>
        
            <programlisting>person.name = "Gavin";</programlisting>
        
            <para>is equivalent to the following Java code:</para>

            <programlisting>person.name().set("Gavin");</programlisting>
                        
            <para>If getter code is specified, and <literal>assign</literal> is not specified,
            the attribute is not settable, and any attempt to assign to the attribute will
            result in a compiler error.</para>
        
        </section>
        
    </section>
    
    <section id="assignableexpressions">
        <title>Assignable expressions</title>
        
        <para>Certain expressions are <emphasis>assignable</emphasis>. An assignable
        expression may appear as the LHS of the <emphasis>=</emphasis> (assign) operator,
        and possibly, depending upon the type of the expression, as the LHS of the 
        numeric or logical assignment operators <literal>=, +=, -=, *=, /=, %=, &amp;=, 
        |=, ^=, &amp;&amp;=, ||=</literal> or as the subject of the increment or decrement
        operators <literal>++, --</literal>.</para>
        
        <para>The following expressions are assignable:</para>
        
        <itemizedlist>
            <listitem>
                <para>a local declared <literal>mutable</literal>, for example 
                <literal>count</literal>,</para>
            </listitem>
            <listitem>
                <para>any attribute expression where the underlying attribute has a setter
                or is a simple attribute declared <literal>mutable</literal>, for example 
                <literal>person.name</literal>, and</para>
            </listitem>
            <listitem>
                <para>element expressions for the type <literal>OpenCorrespondence</literal>, 
                for example <literal>order.lineItems[0]</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>When an assignment expression is executed, the value of the local or
        attribute is set to the new value, or the <literal>define()</literal> method of
        <literal>OpenCorrespondence</literal> is called.</para>
        
        <para>Thus, the following statement:</para>
        
        <programlisting>order.lineItems[0] = LineItem { product = prod; quantity = 1; };</programlisting>
        
        <para>Is equivalent to the Java:</para>
        
        <programlisting>order.lineItems.define( 0, new LineItem(prod, 1) );</programlisting>
        
        
    </section>
    
    <section id="operators">
    <title>Operators</title>
            
    <para>Operators are syntactic shorthand for more complex expressions
    involving method invocation or attribute access. Each operator is defined 
    for a particular type. There is support for user-defined operator 
    <emphasis>overloading</emphasis>. However, the semantics of an operator 
    may be customized by the implementation of the type that the operator
    applies to.</para>
    
    <para>For example, the following Ceylon code examples:</para>
    
    <programlisting>Double z = x * y;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>x *= 2;</programlisting>
    
    <programlisting>if ( x > 100 ) { ... }</programlisting>
    
    <programlisting>User gavin = users["Gavin"];</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = list[0..20];</programlisting>
    
    <programlisting>for ( Integer i in 1..10 ) { ... }</programlisting>

    <programlisting>if ( name == value ) return ... ;</programlisting>
    
    <programlisting>if ( x&gt;10 || x&lt;0 ) { ... }</programlisting>
    
    <programlisting>log.info( "Hello " + $person + "!")</programlisting>
    
    <programlisting>List&lt;String&gt; names = ArrayList&lt;Person&gt;()^.add(person1)^.add(person2)*.name;</programlisting>
    
    <programlisting>optional String name = person?.name;</programlisting>
    
    
    <para>Are equivalent to the following (Ceylon) code:</para>
    
    <programlisting>Double z = x.multiply(y);</programlisting>
    
    <programlisting>count = count.successor;</programlisting>
    
    <programlisting>Integer j = ( i = i.successor ).predecessor;</programlisting>
    
    <programlisting>z = z.multiply(2);</programlisting>
    
    <programlisting>if ( x.compare(100).larger ) { ... }</programlisting>
    
    <programlisting>User gavin = users.value("Gavin");</programlisting>
        
    <programlisting>List&lt;Item&gt; firstPage = list.range(0..20);</programlisting>
    
    <programlisting>for ( Integer i in Range(1,10) ) { ... }</programlisting>

    <programlisting>if ( if (name exists) name.equals(value) else if (value exists) false else true ) return ... ;</programlisting>
    
    <programlisting>if ( x.compare(10).larger ) true else x.compare(0).smaller ) { ... }</programlisting>
    
    <programlisting>log.info( "Hello ".join(person.string).join("!") )</programlisting>
    
    <programlisting>List&lt;String&gt; names = 
    Spread&lt;String&gt; { 
        lhs = Chain&lt;String&gt; { 
            lhs = Chain&lt;String&gt; { 
                lhs = ArrayList(); 
                override void call() { lhs.add(person1); } }.lhs
            }
            override void call() { lhs.add(person2); } }.lhs
        }
        override void call(String element) { element.name; } 
    }.result;</programlisting>
    
    <programlisting>optional String name = if (person exists) person.name else null;</programlisting>
    
    <section>
        <title>List of operators</title>
    
        <para>The following table defines the semantics of the Ceylon operators:</para>
        
        <para>TODO: if there's one thing C syntax got wrong, it's the use of 
        <literal>=</literal> for assignment. <literal>:=</literal> is a much, much 
        better choice. Should we fix this, or is consistency with other C-like languages 
        more important? One interesting possibility would be to use <literal>:=</literal> 
        only for re-assigning mutable values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>=</literal></entry>
            <entry><literal>lhs = rhs</literal></entry>
            <entry>assign</entry>
            <entry></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Member reference</emphasis></entry></row>

        <row>
            <entry><literal>#</literal></entry>
            <entry><literal>lhs#member</literal></entry>
            <entry>curry</entry>
            <entry></entry>
            <entry><literal>Object</literal></entry>
            <entry></entry>
            <entry><literal>Callable&lt;(P p, Q q,...) produces R&gt;</literal>, 
            <literal>Value&lt;T&gt;</literal> or
            <literal>OpenValue&lt;T&gt;</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Member invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>.</literal></entry>
            <entry><literal>lhs.member</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>Object</literal></entry>
            <entry></entry>
            <entry>Member type</entry>
        </row>
        <row>
            <entry><literal>^.</literal></entry>
            <entry><literal>lhs^.member</literal></entry>
            <entry>chain invoke</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>?.</literal></entry>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe invoke</entry>
            <entry><literal>if (lhs exists) lhs.member else null</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry></entry>
            <entry><literal>optional</literal> member type</entry>
        </row>
        
        <!-- Spread -->
        
        <row>
            <entry><literal>*.</literal></entry>
            <entry><literal>lhs*.member</literal></entry>
            <entry>spread invoke</entry>
            <entry><literal>for (X x in lhs) x.member</literal></entry>
            <entry><literal>Iterable&lt;X&gt;</literal></entry>
            <entry></entry>
            <entry><literal>List</literal> of member type</entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Equality</emphasis></entry></row>
        
        <row>
            <entry><literal>===</literal></entry>
            <entry><literal>lhs === rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal>Object.identical(lhs, rhs)</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>==</literal></entry>
            <entry><literal>lhs == rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>if (lhs exists) lhs.equals(rhs) else if (rhs exists) false else true</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>!=</literal></entry>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>if (lhs exists) lhs.equals(rhs).negation else if (rhs exists) true else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=&gt;</literal></entry>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>lhs.compare(rhs).smaller</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>lhs.compare(rhs).larger</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>lhs.compare(rhs).smallAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>lhs.compare(rhs).largeAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
                
        <row><entry namest="first" nameend="last"><emphasis>Logical operations</emphasis></entry></row>
        
        <row>
            <entry><literal>!</literal><!--or <literal>not</literal>--></entry>
            <entry><literal>!rhs</literal><!--or <literal>not rhs</literal>--></entry>
            <entry>logical negation</entry>
            <entry><literal>rhs.negation</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>|</literal></entry>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>disjunction</entry>
            <entry><literal>lhs.or(rhs)</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;</literal></entry>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>conjunction</entry>
            <entry><literal>lhs.and(rhs)</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>^</literal></entry>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>exclusive disjunction</entry>
            <entry><literal>lhs.xor(rhs)</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>||</literal></entry>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>shortcircuit disjunction</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;&amp;</literal></entry>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>shortcircuit conjunction</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>=></literal></entry>
            <entry><literal>lhs => rhs</literal></entry>
            <entry>implication</entry>
            <entry><literal>if (lhs) rhs else true</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>|=</literal></entry>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>lhs = lhs.or(rhs)</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;=</literal></entry>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>lhs = lhs.and(rhs)</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>^=</literal></entry>
            <entry><literal>lhs ^= rhs</literal></entry>
            <entry>xor</entry>
            <entry><literal>lhs = lhs.xor(rhs)</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>||=</literal></entry>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>shortcircuit or</entry>
            <entry><literal>lhs = if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>&amp;&amp;=</literal></entry>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>shortcircuit and</entry>
            <entry><literal>lhs = if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Existence (null value handling)</emphasis></entry></row>
        
        <row>
            <entry><!--<literal>?</literal> or --><literal>exists</literal></entry>
            <entry><!--<<literal>lhs?</literal> or --><literal>lhs exists</literal></entry>
            <entry>exists</entry>
            <entry><literal>if (lhs exists) true else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>?</literal></entry>
            <entry><literal>lhs ? rhs</literal></entry>
            <entry>default</entry>
            <entry><literal>if (lhs exists) lhs else rhs</literal></entry>
            <entry><literal>optional T</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>T</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Default assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>?=</literal></entry>
            <entry><literal>lhs ?= rhs</literal></entry>
            <entry>default assignment</entry>
            <entry><literal>if (lhs exists) lhs else lhs=rhs</literal></entry>
            <entry><literal>optional T</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!--  
        <row>
            <entry><literal>?:</literal></entry>
            <entry><literal>lhs ?: rhs</literal></entry>
            <entry>null default</entry>
            <entry><literal>if (lhs?) lhs else rhs</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Object</literal></entry>
        </row>
        -->
        
        <!--
        <row>
            <entry><literal>?=</literal></entry>
            <entry><literal>lhs ?= rhs</literal></entry>
            <entry>null assignment</entry>
            <entry><literal>if (lhs?) false else (lhs=rhs)?</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>=?</literal></entry>
            <entry><literal>lhs =? rhs</literal></entry>
            <entry>null assignment</entry>
            <entry><literal>if (rhs?) (lhs=rhs)? else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        -->
        <!--         
        <row><entry namest="first" nameend="last"><emphasis>Emptiness</emphasis></entry></row>
        --> 
        
        <row>
            <entry><literal><!--??-->nonempty</literal></entry>
            <entry><literal><!--??-->lhs nonempty</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (lhs exists) lhs.empty.negation else false</literal></entry>
            <entry><literal>optional Container</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <!--  
        <row>
            <entry><literal>??:</literal></entry>
            <entry><literal>lhs ??: rhs</literal></entry>
            <entry>empty default</entry>
            <entry><literal>if (lhs)? ( if (lhs.empty) rhs else lhs ) else rhs</literal></entry>
            <entry><literal>optional Holder</literal></entry>
            <entry><literal>Container</literal></entry>
            <entry><literal>Container</literal></entry>
        </row>
        -->
        
        <!--  
        <row>
            <entry><literal>??=</literal></entry>
            <entry><literal>lhs ??= rhs</literal></entry>
            <entry>empty assignment</entry>
            <entry><literal>if (lhs??) false else (lhs=rhs)??</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>=??</literal></entry>
            <entry><literal>lhs =?? rhs</literal></entry>
            <entry>empty assignment</entry>
            <entry><literal>if (rhs??) (lhs=rhs)?? else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>in</literal></entry>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>lhs.in(rhs)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Category&lt;X&gt;</literal> or <literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <!--  
        <row>
            <entry><literal>~></literal> or <literal>in</literal></entry>
            <entry><literal>lhs ~> rhs</literal> or <literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>lhs.in(rhs)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Category&lt;X&gt;</literal> or <literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row>
            <entry><literal>!~></literal></entry>
            <entry><literal>lhs !~> rhs</literal></entry>
            <entry>not in</entry>
            <entry><literal>lhs.in(rhs).negation</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Category&lt;X&gt;</literal> or <literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row>
            <entry><literal>*~></literal></entry>
            <entry><literal>lhs *~> rhs</literal></entry>
            <entry>all in</entry>
            <entry><literal>for (X x in lhs: !x.in(rhs)) found false fail true</literal></entry>
            <entry><literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Category&lt;X&gt; or <literal>Iterable&lt;X&gt;</literal></literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        -->

        <row><entry namest="first" nameend="last"><emphasis>Concatenation</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>join</entry>
            <entry><literal>lhs.join(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Keyed element access</emphasis></entry></row>
        
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.value(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>List&lt;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[,,]</literal></entry>
            <entry><literal>lhs[x, y, z]</literal></entry>
            <entry>enumerated range</entry>
            <entry><literal>Enumeration( lhs.lookup(x), lhs.lookup(y), lhs.lookup(z) )</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>Enumeration&lt;X&gt;</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Subranges</emphasis></entry></row>
        
        <row>
            <entry><literal>[..]</literal></entry>
            <entry><literal>lhs[x..y]</literal></entry>
            <entry>subrange</entry>
            <entry><literal>lhs.range(x,y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[x...]</literal></entry>
            <entry>upper range</entry>
            <entry><literal>lhs.tail(x)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[...y]</literal></entry>
            <entry>lower range</entry>
            <entry><literal>lhs.head(y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        <!--  
        
        <row><entry namest="first" nameend="last"><emphasis>Shift</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;&lt;</literal></entry>
            <entry><literal>lhs &lt;&lt; rhs</literal></entry>
            <entry>left shift</entry>
            <entry><literal>lhs.shiftLeft(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>>></literal></entry>
            <entry><literal>lhs >> rhs</literal></entry>
            <entry>right shift</entry>
            <entry><literal>lhs.shiftRight(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set operations</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs.union(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs.intersection(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>cartesian product</entry>
            <entry><literal>lhs.product(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;Pair&lt;X,Y&gt;&gt;</literal></entry>
        </row>
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>subset</entry>
            <entry><literal>lhs.subset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>superset</entry>
            <entry><literal>lhs.superset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>proper subset</entry>
            <entry><literal>lhs.properSubset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>proper superset</entry>
            <entry><literal>lhs.properSuperset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        -->
        
        <row><entry namest="first" nameend="last"><emphasis>Constructors</emphasis></entry></row>

        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>-></literal></entry>
            <entry><literal>lhs -> rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>@</literal></entry>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>Instant</literal></entry>
            <entry><literal>Instant</literal></entry>
            <entry><literal>Interval</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Render</emphasis></entry></row>
        
        <row>
            <entry><literal>$</literal></entry>
            <entry><literal>$rhs</literal></entry>
            <entry>render</entry>
            <entry><literal>if (rhs exists) rhs.string else ""</literal></entry>
            <entry></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>String</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>++rhs</literal></entry>
            <entry>increment</entry>
            <entry><literal>rhs = rhs.successor</literal></entry>
            <entry></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>--rhs</literal></entry>
            <entry>decrement</entry>
            <entry><literal>rhs = rhs.predecessor</literal></entry>
            <entry></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>lhs++</literal></entry>
            <entry>successor</entry>
            <entry><literal>(lhs = lhs.successor).predecessor</literal></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>lhs--</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>(lhs = lhs.predecessor).successor</literal></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operations</emphasis></entry></row>
        
        <!-- Unary negative -->
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.inverse</literal></entry>
            <entry></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        
        <!-- Arithmetic -->
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.add(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.subtract(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.multiply(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.divide(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        <row>
            <entry><literal>%</literal></entry>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.remainder(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        <row>
            <entry><literal>**</literal></entry>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>exponentiate</entry>
            <entry><literal>lhs.exponentiate(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>+=</literal></entry>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>lhs = lhs.add(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        <row>
            <entry><literal>-=</literal></entry>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>lhs = lhs.subtract(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        <row>
            <entry><literal>*=</literal></entry>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs = lhs.multiply(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        <row>
            <entry><literal>/=</literal></entry>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs = lhs.divide(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        <row>
            <entry><literal>%=</literal></entry>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs = lhs.remainder(rhs)</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
            <entry><literal>Number</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Duration arithmetic</emphasis></entry></row>
                
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>extend</entry>
            <entry><literal>lhs.extend(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>curtail</entry>
            <entry><literal>lhs.curtail(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs.divide(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Integer</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Bitwise operations</emphasis></entry></row>
        
        <row>
            <entry><literal>|||</literal></entry>
            <entry><literal>lhs ||| rhs</literal></entry>
            <entry>bitwise or</entry>
            <entry><literal>lhs.or(rhs)</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;&amp;&amp;</literal></entry>
            <entry><literal>lhs &amp;&amp;&amp; rhs</literal></entry>
            <entry>bitwise and</entry>
            <entry><literal>lhs.and(rhs)</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        <row>
            <entry><literal>^^^</literal></entry>
            <entry><literal>lhs ^^^ rhs</literal></entry>
            <entry>bitwise xor</entry>
            <entry><literal>lhs.xor(rhs)</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>~rhs</literal></entry>
            <entry>bitwise not</entry>
            <entry><literal>rhs.not</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section>
        <title>Operator precedence and associativity</title>
        
        <para>This table defines operator precedence from highest to lowest,
        along with associativity rules:</para>
        
    <table>
    <tgroup cols="4">
        <colspec colnum="1" colwidth="2.5*" align="center"/>
        <colspec colnum="2" colwidth="2.0*" align="center"/>
        <colspec colnum="3" colwidth="1.0*" align="center"/>
        <colspec colnum="4" colwidth="0.7*" align="center"/>
    <thead>
        <row>
            <entry>Operations</entry>
            <entry>Operators</entry>
            <entry>Type</entry>
            <entry>Associativity</entry>
        </row>
    </thead>
    <tbody>
    
            <row>
                <entry>Member invocation and lookup, subrange, reflection:</entry>
                <entry>
                <literal>.</literal>, 
                <literal>^.</literal>, 
                <literal>*.</literal>, 
                <literal>?.</literal>, 
                <literal>[]</literal>, 
                <literal>[..]</literal>, 
                <literal>[...]</literal>, 
                <literal>[,,]</literal>,
                <literal>#</literal></entry>
                <entry>Binary / ternary / N-ary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Prefix increment, decrement,
                negation, render<!--, bitwise complement-->:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>, 
                <literal>-</literal>, 
                <literal>$</literal>,
                <!--literal>~</literal--> 
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Postfix increment, decrement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>
                </entry> 
                <entry>Unary postfix</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            <!--  
            <row>
                <entry>Exponentiation, shift:</entry>
                <entry>
                <literal>**</literal>,
                <literal>&lt;&lt;</literal>, 
                <literal>>></literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            -->
            <row>
                <entry>Multiplication, division, remainder
                <!--intersection--><!--, bitwise and--> for
                numbers<!--, sets--><!--and durations-->:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal><!--,
                <literal>~</literal>,
                <literal>&amp;&amp;&amp;</literal>-->
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Addition, subtraction, concatenation 
                <!--union, complement, join--><!--, bitwise or, bitwise xor-->
                for numbers<!--, sets,--><!-- and durations--> and lists:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal><!--, 
                <literal>|||</literal>, 
                <literal>^^^</literal>-->
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Date/time composition:</entry> 
                <entry><literal>@</literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Range, interval and entry construction:</entry> 
                <entry><literal>..</literal>, <literal>-></literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <!--
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>?</literal>, <literal>??</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Binary existence, emptiness:</entry> 
                <entry><literal>?:</literal>, <literal>??:</literal></entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            -->
            <row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Comparison, <!--set comparison,--> containment:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <!--<literal>~></literal>,
                <literal>!~></literal>,
                <literal>*~></literal>-->
                <literal>in</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality:</entry>
                <entry>
                <literal>==</literal>, 
                <literal>!=</literal>, 
                <literal>===</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry>Negation:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Conjunction:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>, 
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Disjunction:</entry>
                <entry>
                <literal>||</literal>, 
                <literal>|</literal>, 
                <literal>^</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Implication:</entry>
                <entry>
                <literal>=></literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Assignment, numeric assignment, logical assignment,
                default assignment:</entry> 
                <entry>
                <literal>=</literal>, 
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>,
                <literal>?=</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
    </tbody>
    </tgroup>
    </table>
            
    </section>
    
    </section>

    <section id="functorexpressions">
        <title>Functor expressions</title>
        
        <para>A functor expression has this form:</para>
        
        <programlisting>FunctorExpression := FunctorParams OpenBlock</programlisting>
        
        <para>A functor body may not contain a <literal>return</literal> directive. If the functor
        body is a block, the value of the functor, when executed, is determined by the 
        <literal>produces</literal> directive.</para>
                
        <para>For example:</para>
        
        <programlisting>(Float x,Float y) produces Comparison order = (Float x, Float y) { produces x&lt;=&gt;y };</programlisting>
        
        <programlisting>people.sort( (Person x, Person y) y.name&lt;=&gt;x.name );</programlisting>
               
        <programlisting>people.select( (Person p) p.age>18 )
    .collect( (Person p) p.name );</programlisting>
        
        <programlisting>namedValues.each( (String name->Object value) log.info("${name} ${value}") );</programlisting>
        
        <!--  
        <programlisting>people.collect( Collect&lt;Person&gt;(Person p: p.age>18) return p.name );</programlisting>
        
        <programlisting>people.select( Collect&lt;Person&gt;(Person p: p.age>18) );</programlisting>
        -->
        
        <para>Consider the following functor expression:</para>
        
        <programlisting>(String x, String y) produces Comparison order = (String x, String y) { produces x &lt;=&gt; y }</programlisting>
        
        <para>Or:</para>
        
        <programlisting>(String x, String y) produces Comparison order = (String x, String y) x &lt;=&gt; y;</programlisting>
        
        <para>These expressions are both equivalent to this Java code:</para>

        <programlisting>F2&lt;String,String,Comparison&gt; order = 
    new F2&lt;String,String,Comparison&gt;() {
        public Comparison call(String x, String y) { 
            return Comparison.compare(x,y); 
        }
    };</programlisting>
        
        <para>And this functor invocation:</para>
        
        <programlisting>Comparison result = order("Gavin", "Emmanuel");</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Comparison result = order.call("Gavin", "Emmanuel");</programlisting>
        
        <para>The following code:</para>
        
        <programlisting>(0..10).each( (Integer num) log.info(num) );</programlisting>
        
        <para>Is equivalent to:</para>
        
        <programlisting>new Range&lt;Integer&gt;(0, 10).each( 
    new F1&lt;Integer,Boolean&gt;() {
        @Override Boolean call(Integer x) { 
            ParentClass.this.log.info(num); 
        } 
    } );</programlisting>
    
        <para>This code:</para>
        
        <programlisting>Integer min = 0;
Integer max = 0;
List list = list.select(Integer x) 
    return x > min &amp;&amp; x &lt; max;</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>Integer min = 0; 
Integer max = 10; 
List list = list.select( new F1&lt;Integer,Boolean&gt;(min, max) { 
        final Integer min = (Integer) locals[0];
        final Integer max = (Integer) locals[1];
        @Override Boolean call(Integer x) { 
            return x > min &amp;&amp; x &lt; max; 
        } 
    } );</programlisting>
    
        <section id="functorparametersyntax">
        <title>Syntax extension for functor parameters</title>
        
        <para>Furthermore, for parameters of a method which are functor types, Ceylon
        provides a special method invocation protocol:</para>
        
        <programlisting>MemberReference OrderedParamValues FunctorParamValues</programlisting>
        
        <para>After the list of ordered parameters, a named list of functor parameters may be specified:</para>
        
        <programlisting>FunctorParamValues := SimpleFunctorExpression? (Identifier SimpleFunctorExpression)*</programlisting>
        
        <para>The identifiers listed after the ordered parameter values are names of method 
        parameters of functor type, in the order in which they appear in the method declaration. 
        Each of these arguments is a functor expression, where the functor parameter list may 
        be omitted for functors with no parameters:</para>
        
        <programlisting>SimpleFunctorExpression := FunctorLocals? OpenBlock</programlisting>
        
        <para>For example:</para>
        
        <programlisting>String label = (x>10).if() isTrue "big" isFalse "little";</programlisting>
        
        <programlisting>amounts.sort() by (Float x, Float y) { produces x&lt;=&gt;y }</programlisting>
        
        <programlisting>people.sort() by (Person x, Person y) y.name&lt;=&gt;x.name;</programlisting>
        
        <programlisting>people.select() only (Person p) { produces p.age>18 }
    .collect() each (Person p) { produces p.name };</programlisting>
    
        <programlisting>namedValues.each() do (String name->Object value) log.info("${name} ${value}");</programlisting>

        <programlisting>optional specialPerson = search (people) findFirst (Person p) p.special orIfNoneFound null;</programlisting>
        
        <programlisting>(x>10).if() 
isTrue {
    log.debug("big");
    big(x);
}
isFalse {
    log.debug("little");
    little(x);
}</programlisting>
        <!--  
        <programlisting>people.collect(Person p: p.age>18) return p.name;</programlisting>
        
        <programlisting>people.select(Person p: p.age>18);</programlisting>
        -->
        
        <!-- 
        <para>Finally, if the functor has exactly one parameter, the variable list
        may be eliminated.</para>
        
        <programlisting>people.select( return it.age>18 )
    .collect( return it.name );</programlisting>
         -->
         
        <para>The name of the first parameter may be omitted, if desired.</para>
        
        <programlisting>people.sort() (Person x, Person y) y.name&lt;=&gt;x.name;</programlisting>
        
        <programlisting>people.select() (Person p) { produces p.age>18 }
    .collect() (Person p) { produces p.name };</programlisting>
        
        <section>
            <title>Syntax extension for iterations</title>
            
        <para>A specialized invocation syntax is provided for methods which iterate 
        collections. If the first parameter of the method is of type <literal>Iterable&lt;X&gt;</literal>,
        annotated <literal>iterated</literal>, and all remaining parameters are of functor 
        type, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>MemberReference "(" ForIterator ")" FunctorParamValues</programlisting>
        
        <para>And each functor expression for a parameter annotated <literal>coordinated</literal>
        of type <literal>(X x) produces Y</literal> or <literal>(X x) void</literal> need not 
        declare its parameter. Instead, its parameter is declared by the iterator.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
List&lt;Y&gt; from&lt;X,Y&gt;(iterated Iterable&lt;X&gt; elements, 
                  coordinated (X x) produces Y select, 
                  coordinated (X x) produces Boolean if);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; names = from (Person p in people) p.name if p>20;</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; names = from (people) select (Person p) p.name if (Person p) p>20;</programlisting>
        
        <para>Or, we may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; labels = from (Key key -> Value value in namedValues) 
                      select "${key} ${value}"
                      if user.authorized(key);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; labels = from (namedValues) 
                      select (Key key -> Value value) "${key} ${value}"
                      if (Key key -> Value value) user.authorized(key);</programlisting>
                      
        </section>
        
        <section>
            <title>Syntax extension for variable definition</title>
            
        <para>A specialized invocation syntax is also provided for methods which define 
        a variable. If the first parameter of the method is of type <literal>X</literal>,
        annotated <literal>specified</literal>, and all remaining parameters are of functor 
        type, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>MemberReference "(" Variable Initializer ")" FunctorParamValues</programlisting>
        
        <para>And each functor expression for a parameter annotated <literal>coordinated</literal>
        of type <literal>(X x) produces Y</literal> or <literal>(X x) void</literal> need not 
        declare its parameter. Instead, its parameter is declared by the initializer.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
Y ifExists&lt;X,Y&gt;(specified optional X value,
                coordinated (X x) produces Y then, 
                () produces Y otherwise);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Exact amount = ifExists(Payment p = order.payment) p.amount otherwise 0.0;</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Exact amount = ifExists(order.payment) then (Payment p) p.amount otherwise 0.0;</programlisting>
        
         <para>And for the following method declaration:</para>
        
        <programlisting>public static
Y using&lt;X,Y&gt;(specified X resource, 
             coordinated (X x) produces Y seek)
  where X >= Usable;</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Order order = using (Session s = Session()) s.get(#Order, oid);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Order order = using (Session()) seek (Session s) s.get(#Order, oid);</programlisting>
        
        </section>
        
        <section>
            <title>Syntax extension for lists of cases</title>
        </section>
        
        <para>A specialized invocation syntax is also provided for methods which define 
        a list of cases. If the method has a parameter of type 
        <literal>Enumeration&lt;(X x) produces Y&gt;</literal> annotated <literal>cases</literal>,
        the parameter value may be specified according to:</para>
        
        <programlisting>(Identifier FunctorExpression)+</programlisting>
        
        <para>Or, if the method has a parameter of type 
        <literal>Enumeration&lt;Entry&lt;Case&lt;X&gt;, () produces Y&gt;&gt;</literal> annotated 
        <literal>cases</literal>, the parameter value may be specified according to:</para>
        
        <programlisting>("(" Case ")" SimpleFunctorExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
X attempt&lt;X&gt;(() produces X seek, 
             cases (E e) produces X where E>=Exception... except);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>attempt() { 
    produces doSomething(); 
} 
except (SomethingWrong sw) {
    log.info(sw);
    produces -1;
}
except (SomethingElseWrong sew) {
    log.warn(sew);
    produces -2;
}</programlisting>
        
        <para>And for the following method declaration:</para>
        
        <programlisting>public static
void select&lt;X&gt;(X selector),
               cases Entry&lt;Case&lt;X&gt;, () produces X&gt;... value);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>select(payment.type) 
value (CHECK) {
    paybyCheck(payment);
}
value (CARD) {
    paybyCard(payment);
}</programlisting>
        
        </section>
    
        <!--
        <section>
        <title>TODO: assignment to local variables from surrounding scope</title>
    
        <para>The following code:</para>
        
        <programlisting>Integer min = 0;
Integer max = 0;
Integer count = 0;
Integer size = list.each(Integer x) { 
    if ( x > min ) count++; 
    if ( x > max) max = x; 
};</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>Integer min = 0; 
Integer max = 0;
Integer count = 0;
final List list$1 = list;
final F1&lt;Integer,Boolean&gt; functor$1 = 
    new F1&lt;Integer,Boolean&gt;(min, max, count) { 
        Integer min = (Integer) locals[0];
        Integer max = (Integer) locals[1];
        Integer count = (Integer) locals[2];
        @Override Boolean call(Integer x) { 
            if ( x > min ) count++; 
            if ( x > max) max = x; 
            locals[0] = min;
            locals[1] = max;
            locals[2] = count;
        }
    };
final Integer result$1 = list$1.each(functor$1);
final Object[] locals$1 = functor$1.locals();
min = (Integer) locals[0];
max = (Integer) locals[1];
count = (Integer) locals[2];
Integer size = result$1;</programlisting>

        <para>Or, perhaps:</para>
    
        <programlisting>Integer min = 0; 
Integer max = 0;
Integer count = 0;
final List list$1 = list;
final F1&lt;Integer,Boolean&gt; functor$1 = 
    new F1&lt;Integer,Boolean&gt;(min, max, count) { 
        @Override Boolean call(Integer x) { 
            if ( x > locals[0] ) locals[3]++; 
            if ( x > locals[1] ) locals[1] = x; 
        }
    };
final Integer result$1 = list$1.each(functor$1);
final Object[] locals$1 = functor$1.locals();
min = (Integer) locals[0];
max = (Integer) locals[1];
count = (Integer) locals[2];
Integer size = result$1;</programlisting>

        </section>
    -->
    
    </section>
    
</chapter>