<chapter id="expressions">
    <title>Expressions</title>
    
    <para>Ceylon expressions are significantly more powerful than Java, allowing a 
    more declarative style of programming.</para>
    
    <para>Expressions are formed from:</para>
    
    <itemizedlist>
        <listitem>
            <para>literal values,</para>
        </listitem>
        <listitem>
            <para>invocation of methods and instantiation of classes and 
            enumerations,</para>
        </listitem>
        <listitem>
            <para>evaluation and assignment of attributes, and</para>
        </listitem>
        <listitem>
            <para>operators.</para>
        </listitem>
    </itemizedlist>
    
    <section id="literals">
    <title>Literals</title>
    
    <para><!--Since Ceylon is a language for expressing not only instructions, but also 
    structured data, the language supports parsed literals for dates and times
    in addition to numeric and string datatypes.--> Ceylon supports literal values
    of the following types:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>Natural</literal> and <literal>Float</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>String</literal> and <literal>Character</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Quoted</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Type</literal>, <literal>Attribute</literal> and 
            <literal>Method</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <!--itemizedlist>
        <listitem>
            <para><literal>Date</literal> and <literal>Time</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Natural</literal> and <literal>Float</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>Character</literal>,</para>
        </listitem>
        <listitem>
            <para><literal>String</literal> and <literal>Regex</literal>.</para>
        </listitem>
    </itemizedlist-->
    
    <programlisting>Literal := 
NaturalLiteral | FloatLiteral | 
StringLiteral | CharacterLiteral | 
QuotedLiteral | 
TypeLiteral | MemberLiteral</programlisting>

    <!--programlisting>Literal :=
DateLiteral | TimeLiteral
NaturalLiteral | FloatLiteral |
CharacterLiteral | StringLiteral | RegexLiteral |
TypeLiteral | MemberLiteral |
SpecialValue</programlisting-->

    <para>Ceylon does not need a special syntax for <literal>Boolean</literal> literal 
    values, since <literal>Boolean</literal> is just a <literal>Selector</literal>
    with the enumerated instances <literal>true</literal> and <literal>false</literal>.</para>
    
    <comment><para>TODO: Should we have a literal syntax for version numbers, for use
    in the module architecture, for example: <literal>@1.2.3BETA</literal>?</para></comment>
    
    <!--section id="datetime">
        <title><literal>Date</literal> and <literal>Time</literal> literals</title>
        
        <para>A <literal>Date</literal> literal has the form:</para>
        
        <programlisting>DateLiteral := 
"'" 
Digit{1,2} "/" Digit{1,2} "/" Digit{4} 
"'"</programlisting>
        
        <para>A <literal>Time</literal> literal has the form:</para>
        
        <programlisting>TimeLiteral := 
"'" 
Digit{1,2} ":" Digit{2} ( ":" Digit{2} ( ":" Digit{3} )? )? 
(" " "AM"|"PM")? 
(" " Character{3,4})? 
"'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        
        <para>A <literal>Datetime</literal> may be composed from a <literal>Date</literal> and 
        a <literal>Time</literal> using the <literal>@</literal> operator.</para>
        
        <programlisting>Datetime datetime = '25/03/2005' @ '12:00 AM PST';</programlisting>
        
        <comment><para>TODO: alternatively, we could follow RFC3339-style datetimes, for example:
        <literal>1996-12-19T16:39:57-08:00</literal>.</para></comment>
        
        <comment><para>TODO: should we allow wildcards and ranges, to get cron-style expressions 
        like <literal>'1/*/*' @ '00:00 GMT'</literal>?</para></comment>
        
        <para>The <literal>..</literal> operator lets us construct intervals:</para>
        
        <programlisting>Interval&lt;Date&gt; timeRange = '0:0:00' .. '12:59:59 PM';</programlisting>
        <programlisting>Interval&lt;Date&gt; dateRange = '1/1/2008' .. '31/12/2007';</programlisting>
        <programlisting>Interval&lt;Datetime&gt; datetimeRange = '1/1/2008' @ '0:0:00' .. '31/12/2007' @ '12:59:59 PM';</programlisting>
        
    </section-->
    
        <!--
        
        <para>The attributes <literal>hours</literal>, <literal>minutes</literal>, <literal>seconds</literal>,
        <literal>years</literal>, <literal>months</literal>, <literal>days</literal>, <literal>weeks</literal>
        of the <literal>Natural</literal> class let us construct durations.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 12.hours + 34.minutes;</programlisting>
        <programlisting>Duration&lt;Date&gt; duration = 1.year + 2.months + 3.days;</programlisting>
        
        <para>Durations may be composed using the arithmetic operators <literal>+</literal>, 
        <literal>-</literal>, <literal>*</literal> and <literal>/</literal>.</para>
        
        <programlisting>Duration&lt;Time&gt; duration = 1.seconds / 10 - 1.seconds / 1000;</programlisting> 
        
        <para>The methods <literal>before()</literal> and <literal>after()</literal> let us add and
        subtract durations to and from datetimes.</para>
        
        <programlisting>Time time = 10.seconds.before('12:00 AM');</programlisting>
        <programlisting>Date date = 1.week.after('2/9/1974');</programlisting>
        
        -->
        
    <section id="naturalnumber">
        <title>Natural number literals</title>
        
        <para>A <literal>Natural</literal> literal has this form:</para>
        
        <programlisting>NaturalLiteral = Digit+</programlisting>
        
        <!--programlisting>NaturalLiteral = 
Digit+ | 
"'" ( HexDigit{4} | HexDigit{8} ) "'"</programlisting-->

        <para>For example:</para>
        
        <programlisting>Natural m = n + 10;</programlisting>
        
        <!--programlisting>panel.backgroundColor = 'FF33';</programlisting-->
        
        <para>Negative integer values can be produced using the unary
        <literal>-</literal> operator:</para>
        
        <programlisting>Integer i = -1;</programlisting>
        
    </section>
    
    <section id="floatnumber">
        <title>Floating point number literals</title>
        
        <para>A <literal>Float</literal> literal has this form:</para>
        
        <programlisting>FloatLiteral := Digit+ "." Digit+ ( ("E"|"e") ("+"|"-")? Digit+ )?</programlisting>
        
        <para>For example:</para>
        
        <programlisting>public static Float pi = 3.14159;</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>public static final Float pi = new lang.Float(3.14159f);</programlisting>

    </section>
    
    <section id="character">
        <title>Character literals</title>
        
        <para>A <literal>Character</literal> literal has this form:</para>
        
        <programlisting>CharacterLiteral := "@" Character</programlisting>
        
        <para>For example:</para>
        
        <programlisting>if ( string[i] == @+ ) { ... }</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>if ( string.at(i).equals( new lang.Character('+') ) ) { ... }</programlisting>
        
        <para>A character literal may contain an escape sequence.</para>
        
        <programlisting>List&lt;Character&gt; ws = { @\s, @\t, @\r, @\f, @\n };</programlisting>
        
        <para>Which is equivalent to this Java code:</para>
        
        <programlisting>List&lt;Character&gt; ws = new lang.Enumeration&lt;Character&gt;(' ', '\t', '\r', '\r', '\n');</programlisting>
        
        <comment><para>TODO: do we really need character literals??</para></comment>
        
    </section>
    
    <section id="string">
        <title>String literals</title>
        
        <para>A <literal>String</literal> literal has this form:</para>
        
        <programlisting>StringLiteral = "&quot;" ( Character+ | "${" Expression "}" )* "&quot;"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>person.name := "Gavin";</programlisting>
        
        <programlisting>log.info("${Time()} ${message}");</programlisting>
        
        <programlisting>String multiline = "Strings may
span multiple lines
if you prefer.";</programlisting>

        <programlisting>out("Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n");</programlisting>
        
        <para>Equivalent to the following Java code:</para>
        
        <programlisting>person.name().set( new lang.String("Gavin") );</programlisting>
        
        <programlisting>log.info( new lang.String( Time(), " ", message ) );</programlisting>
        
        <programlisting>final lang.String multiline = new lang.String("Strings may\nspan multiple lines\nif you prefer.");</programlisting>
        
        <programlisting>out( new lang.String( "Melbourne\tVic\tAustralia\nAtlanta\tGA\tUSA\nGuanajuato\tGto\tMexico\n") );</programlisting>
        
        <comment><para>TODO: we need to support that the embedded expressions
        are evaluated lazily when the string literal appears as a method 
        parameter. This is important for log messages and assertions. So 
        should <literal>"${Time()} ${message}"</literal> actually be a
        method of type <literal>String()</literal> with no parameters, instead 
        of a <literal>String</literal>? (And we would have a built-in converter 
        to do implicit conversion to <literal>String</literal>.)</para></comment>
        
        <comment><para>TODO: is <literal>"{Time()} {message}"</literal> a better 
        syntax for interpolation?</para></comment>

    <!--comment>
    <para>TODO: Very often, string literals are actually used to embed some
    kind of mini-language. Therefore I would like to let you perform compile-time 
    validation of string literals. Three options:</para>
    <itemizedlist>
      <listitem>
        <para>Annotation of string literals, for example 
        <literal>url "http://jboss.org/ceylon"</literal>,
        <literal>mail "mailto:gavin@hibernate.org"</literal>, 
        <literal>regex "w+(d+)?"</literal>,
        <literal>dt "25/03/2005 12:00 AM PST"</literal>,
        <literal>color "FF3B"</literal>,
        <literal>cron "0 0 23 ? * MON-FRI"</literal>.</para>
      </listitem>
      <listitem>
        <para>Annotation of the parameter of a method or constructor, for example
        <literal>Url("http://jboss.org/ceylon")</literal>, 
        <literal>Mail("mailto:gavin@hibernate.org")</literal>, 
        <literal>Regex("w+(d+)?")</literal>,
        <literal>datetime("25/03/2005 12:00 AM PST")</literal>,
        <literal>Color("FF3B")</literal>,
        <literal>Cron("0 0 23 ? * MON-FRI")</literal>.</para>
      </listitem>
      <listitem>
        <para>A special kind of <literal>extension</literal> for literal strings.</para>
      </listitem>
    </itemizedlist>
    <para>This is a solution for literal dates and times, regexes, hexadecimal numbers,
    etc, and even for more domain-specific things like names, cron expressions, internet
    addresses, etc.</para>
    </comment-->
    
    </section>
    
    <section id="quoted">
        <title>Single quoted literals</title>
        
        <para>Single-quoted strings are used to express literal values for dates, 
        times, regexes and hexadecimal numbers, and even for more domain-specific 
        things like names, cron expressions, internet addresses, and phone numbers.
        This is an important facility since Ceylon is a language for expressing 
        structured data.</para>
        
        <para>A <literal>Quoted</literal> literal has this form:</para>
        
        <programlisting>QuotedLiteral := "'" Character* "'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Date date = '25/03/2005';</programlisting>
        <programlisting>Time time = '12:00 AM PST';</programlisting>
        <programlisting>Boolean isEmail = email.matches( '^\w+@((\w+)\.)+$' );</programlisting>
        <programlisting>Cron schedule = '0 0 23 ? * MON-FRI';</programlisting>
        <programlisting>Color color = 'FF3B66';</programlisting>
        <programlisting>Url url = 'http://jboss.org/ceylon';</programlisting>
        <programlisting>mail.to:='gavin@hibernate.org';</programlisting>
        <programlisting>PhoneNumber ph = '+1 (404) 129 3456';</programlisting>
        <programlisting>Duration duration = '1h 30m';</programlisting>
        
        <para>Extensions that apply to the type <literal>Quoted</literal> are
        evaluated at compile time for single-quoted literals, alowing compile-time
        validation of the contents of the single-quoted string.</para>
        
        <programlisting>public extension Date date(Quoted dateString) { return ...; }</programlisting>
        <programlisting>public extension class Regex(Quoted expression) { return ...; }</programlisting>
        
    </section>
    
    <!--section>
        <title>Byte literals</title>
        
        <para>A byte literal has this form:</para>
        
        <programlisting>ByteLiteral := "'" ( BinaryDigit{8} | HexDigit{2} ) "'"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Byte masked = b &amp; '01101001';</programlisting>
        
        <programlisting>Byte byte = 'A0';</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>Byte masked = b.and( new lang.Byte("01101001") );</programlisting>
        
        <programlisting>Byte byte = new lang.Byte("A0")</programlisting>
        
    </section-->
    
    <!--section id="regex">
        <title>Regex literals</title>
        
        <para>A <literal>Regex</literal> literal has this form:</para>
        
        <programlisting>RegexLiteral := "`" RegularExpression "`"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Boolean isEmail = email.matches( `^\w+@((\w+)\.)+$` );</programlisting>
        
        <programlisting>Natural quotedWords = `\W"w+"\W`.matcher(text).count();</programlisting>
        
        <para>The second example is equivalent to this Java code:</para>
        
        <programlisting>Natural quotedWords = new lang.Regex("\\W\"w+\"\\W").matcher(text).count();</programlisting>
        
    </section-->
    
    <!--
    <section>
        <title>Enumeration literals</title>
        
        <para>The following literal is supported, representing an empty enumeration:</para>
        
        <programlisting>"none"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Enumeration&lt;String&gt; enum = none;</programlisting>
        
        <para>Equivalent to this Java code:</para>
        
        <programlisting>Enumeration&lt;String&gt; enum = collections.Enumeration.emptyEnumeration&lt;String&gt;();</programlisting>

        <comment><para>TODO: is this really a special literal, or is it just the single
        enumerated instance of the <literal>EmptyEnumeration</literal> class,
        which has a converter to <literal>Enumeration&lt;X&gt;</literal>?</para></comment>

    </section>
    -->

    <section id="typemember">
        <title>Type and member literals</title>
        
        <para>The <literal>Type</literal> object for a type, the <literal>Method</literal>
        object for a method, or the <literal>Attribute</literal> object for an attribute
        may be referred to using a special literal syntax:</para>
        
        <programlisting>TypeLiteral := HASH Type</programlisting>
        
        <programlisting>MemberLiteral := HASH (Type ".")? MemberName</programlisting>
               
        <para>For example:</para>
        
        <programlisting>Type&lt;List&lt;String&gt;&gt; stringListType = #List&lt;String&gt;;</programlisting>
        <programlisting>Attribute&lt;Person, String&gt; nameAttribute = #Person.name;</programlisting>
        <programlisting>Method&lt;Person, String&gt;&gt; sayMethod = #Person.say;</programlisting>
        
    </section>

    </section>

    <section id="specialvalues">
        <title><literal>this</literal>, <literal>super</literal>, 
        <literal>null</literal> and <literal>none</literal></title>
        
        <programlisting>SpecialValue := "this" | "super" | "null" | "none"</programlisting>
        
        <para>The keyword <literal>null</literal> refers to a special
        value that is assignable to all <literal>optional</literal> 
        types, and never to non-<literal>optional</literal> types. The 
        Ceylon language and compiler ensures that this value never
        receives any invocation.</para>
        
        <para>The keyword <literal>super</literal> refers to the
        current instance (the instance that is being invoked), and 
        is of the same type as the immediate superclass of the class. 
        Any invocation of this reference is processed by the method 
        defined or inherited by this superclass, bypassing any method 
        declaration that overrides the method on the current class or 
        any subclass of the current class.</para>
        
        <para>The keyword <literal>this</literal> refers to the
        current instance, and is assignable to both the type of the 
        current class (the class which declares the method being 
        invoked), and to the special type <literal>subtype</literal>, 
        representing the concrete type of the current instance.</para>
        
        <para>The keyword <literal>none</literal> refers to a special
        value that is assignable to all types that extend 
        <literal>Enumeration</literal>. This value has no elements.</para>
        
    </section>
    
    <section id="methodreferences">
        <title>Method references</title>
        
        <para>A method reference has the form:</para>
        
        <programlisting>MethodReference :=  InstanceMethodReference | StaticMethodReference</programlisting>
        
        <programlisting>StaticMethodReference := ("set" | "get") (RegularType ".")? MemberName</programlisting>
            
        <programlisting>InstanceMethodReference := ("set" | "get")? MemberReference</programlisting>
            
        <programlisting>MemberReference :=  (Expression ".")? MemberName</programlisting>
            
        <para>where the member name is the name of a method.</para>
        
        <comment><para>TODO: Would it be better to put the <literal>set</literal> or 
        <literal>get</literal> keyword after the member reference (and before the parameter
        list)?</para></comment>
        
        <para>A method reference may be used to define a method using <literal>=</literal>. 
        The two methods must have exactly the same signature.</para>
        
        <programlisting>Comparison order(X x, Y y) = Order.reverse;</programlisting>
        
        <programlisting>void out(String message) = log.info;</programlisting>
        
        <para>Method references may appear as an argument to a functional parameter, either as 
        a positional argument, or on the RHS of an <literal>=</literal> specifier in a named 
        parameter invocation. The signature of the functonal parameter must match the signature 
        of the method. For example:</para>
        
        <programlisting>//a method which accepts a method reference
void sort(List&lt;String&gt; list, Comparison by(String x, String y)) { ... }</programlisting>
        
        <programlisting>Comparison reverseAlpha(String x, String y) { return y&lt;=&gt;x; } //a local method declaration
sort(names, reverseAlpha); //pass a reference to the method to another method</programlisting>

        <para>A method reference may be returned by a method with multiple parameter lists.
        The reference must be to a method with the same signature, after removal of the first
        parameter list.</para>
        
        <programlisting>//a method that returns a method reference
Comparison getOrder(Boolean reverse=false)(Natural x, Natural y) {
    Comparison natural(Natural x, Natural y) { return x&lt;=&gt;y; }
    Comparison reverse(Natural x, Natural y) { return y&lt;=&gt;x; }
    if (reverse) {
        return reverse;
    else {
        return natural;
    }
}</programlisting>

        <programlisting>Comparison order(Natural x, Natural y) = getOrder();</programlisting>
        
        <para>Getter and setter method references are especially useful.</para>
        
        <programlisting>TextInput { 
    size=15; 
    onInit = get person.name; 
    onUpdate = set person.name; 
}</programlisting>

    </section>

    <section id="invocations">
        <title>Invocations</title>
        
        <para>Methods and classes are <emphasis>invokable</emphasis>. Invocation of a class is 
        called <emphasis>instantiation</emphasis>.</para>
        
        <para>Any invocation must specify values for parameters, either by listing or naming 
        parameter values.</para>
        
        <programlisting>Arguments := PositionalArguments | NamedArguments</programlisting>
        
        <para>Required parameters must be specified. Defaulted parameters and varargs may also be 
        specified.</para>
        
        <section id="positionalarguments">
            <title>Positional arguments</title>
        
        <para>When parameter values are listed, required parameters are specified first, in the 
        order in which they were declared, followed by defaulted parameters, in the order they 
        were declared. If there are any remaining defaulted parameters, they will be assigned 
        their default values. On the other hand, if any parameter values are unassigned, they 
        will be treated as varargs.</para>
            
        <programlisting>PositionalArguments := "(" ( Expression ("," Expression)* )? ")"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>(getProduct(id), 1)</programlisting>
                
        </section>
        
        <section id="namedarguments">
            <title>Named arguments</title>
            
        <para>When parameter values are named, required and defaulted parameter values are specified 
        by name. Vararg parameter values are specified by listing them.</para>

        <programlisting>NamedArguments := "{" NamedArgument* VarargArguments? "}"</programlisting>
        
        <para>A named argument either:</para> 
        
        <itemizedlist>
            <listitem>
            <para>specifies its value using <literal>=</literal>, and is terminated by a semicolon, 
            or</para>
            </listitem>
            <listitem>
            <para>only for functional parameters, specifies a formal parameter list and a block of 
            code (an inline method declaration).</para>
            </listitem>
        </itemizedlist>

        <programlisting>NamedArgument := ParameterName (Specifier ";" | FormalParams Body)</programlisting>
        
        <para>For example:</para>
        
        <programlisting>{ 
    product = getProduct(id); 
    quantity = 1; 
}</programlisting>
        
        <programlisting>{ 
    label = "Say Hello"; 
    onClick() { 
        say("Hello"); 
    } 
}</programlisting>
        
        <programlisting>{ 
    by(X x, X y) { return x&lt;=&gt;y; } 
}</programlisting>

        <comment><para>TODO: Getter, setter specification for parameters declared <literal>mutable</literal>?</para></comment>
        
        <comment><para>TODO: should we allow a comma-separated list of values to be specified here,
        thereby allowing the braces around an enumeration instantiation to be omitted in this case?</para></comment>

        </section>

        <section id="varargarguments">
            <title>Vararg arguments</title>
            
        <para>Vararg arguments are seperated by commas.</para>

        <programlisting>VarargArguments := VarargArgument ("," VarargArgument)*</programlisting>

        <programlisting>VarargArgument := Expression | Variable Specifier</programlisting>
        
        <para>For example:</para>
        
        <programlisting>(1, 1, 2, 3, 5, 8)</programlisting>
        
        <para>A vararg argument may be a local declaration.</para>
        
        <comment><para>TODO: figure this out. Is this only for varargs in a named parameter
        invocation?</para></comment>
        
        <para>A vararg argument may be an <literal>Iterable</literal> of the parameter type.</para>
        
        <programlisting>( {1, 1, 2, 3, 5, 8} )</programlisting>
        
        </section>
        
        <section id="methodinvocation">
            <title>Method invocation</title>
            
            <para>Method invocations follow this schema:</para>
            
            <programlisting>MethodInvocation := InstanceMethodReference TypeArguments? Arguments</programlisting>
            
            <para>For example:</para>
            
            <programlisting>log.info("Hello world!")</programlisting>
            <programlisting>log.info { message = "Hello world!"; }</programlisting>
            <programlisting>printer.print { join = ", "; "Gavin", "Emmanuel", "Max", "Steve" }</programlisting>
            <programlisting>printer.print { "Names: ", from (Person p in people) select p.name }</programlisting>
            <programlisting>set person.name("Gavin")</programlisting>
            
            <para>The value of a method invocation is the return value of the method.
            The parameter values are passed to the formal parameters of the method.</para>
            
            <para>Methods may not be invoked using the <literal>.</literal> operator on an 
            expression of type <literal>optional</literal>. They may be invoked using 
            <literal>?.</literal>.</para>
            
        </section>
        
        <section id="staticmethodinvocation">
            <title>Static method invocation</title>
            
            <para>Static method invocations follow this schema:</para>
            
            <programlisting>StaticMethodInvocation := StaticMethodReference TypeArguments? Arguments</programlisting>
            
            <para>For example:</para>
            
            <programlisting>HashCode.calculate(default, firstName, initial, lastName)</programlisting>
            <programlisting>HashCode.calculate { algorithm=default; firstName, initial, lastName }</programlisting>
            <programlisting>get Process.args()</programlisting>
            
            <para>The value of a static method invocation is the return value of the static method.
            The parameter values are passed to the formal parameters of the method.</para>
            
        </section>
        
        <section id="classinstantiation">
            <title>Class instantiation</title>
            
            <para>Classes may be instantiated according to the following schema:</para>
            
            <programlisting>Instantiation := RegularType Arguments</programlisting>
            
            <para>For example:</para>
            
            <programlisting>Map&lt;String, Person&gt;(entries)</programlisting>
            <programlisting>Point { x=1.1; y=-2.3; }</programlisting>
            <programlisting>ArrayList&lt;String&gt; { capacity=10; "gavin", "max", "emmanuel", "steve", "christian" }</programlisting>
            
            <programlisting>Panel {
    label = "Hello";
    Input i = Input(),
    Button {
        label = "Hello";
        action() {
            log.info(i.value);
        }
    }
}</programlisting>
            
            <para>The value of a class instantiation is a new instance of the class.
            The parameter values are passed to the initialization parameters of the 
            class. If the class has no initialization parameters, they are assigned
            directly to attributes of the class (in this case, named parameters must 
            be used).</para>
            
        </section>
        
        <section id="enumerations">
            <title>Enumerations</title>
            
            <para>Enumerations may be instantiated according to the following simplified 
            syntax:</para>
            
            <programlisting>Enumeration := "{" ( Expression ("," Expression)* )? "}"</programlisting>
            
            <para>This is a shortcut for instantiation of the <literal>Enumeration</literal>
            class, where there is no need to explicitly specify the type.</para>
            
            <para>For example:</para>
            
            <programlisting>Enumeration&lt;String&gt; names = { "gavin", "max", "emmanuel", "steve", "christian" };</programlisting>
            
            <programlisting>OpenList&lt;Connection&gt; connections = {};</programlisting>
            
            <para>Empty braces <literal>{}</literal> and <literal>none</literal> are synonyms
            for a special value that can be assigned to any enumeration type.</para>
            
            <!--comment><para>Note: <literal>none</literal> can appear as a functor body, but 
            <literal>{ ... }</literal> cannot (unless surrounded by parentheses).</para></comment-->
                        
            <para>There are no true literals for lists, sets or maps. However, the 
            <literal>..</literal> and <literal>-></literal> operators, together with the 
            convenient enumeration constructor syntax, and some built-in extensions help 
            us achieve the desired effect.</para>

            <programlisting>List&lt;String&gt; languages = { "Java", "Ceylon", "Smalltalk" };</programlisting>
            <programlisting>List&lt;Natural&gt; numbers = 1..10;</programlisting>
                
            <para>Enumerations are transparently converted to sets or maps, allowing sets 
            and maps to be initialized as follows:</para>
        
            <programlisting>Map&lt;String, String&gt; map = { "Java"->"Boring...", "Scala"->"Difficult :-(", "Ceylon"->"Fun!" };</programlisting>
            <programlisting>Set&lt;String&gt; set = { "Java", "Ceylon", "Scala" };</programlisting>
            <programlisting>OpenList&lt;String&gt; list = {};</programlisting>
            
            <para>This representation is used as the canonical literal form for collections.</para>
            
        </section>
        
        <!--section id="functorinvocation">
            <title>Functor invocation</title>
            
            <para>Functor invocations follow the following schema.</para>
            
            <programlisting>FunctorInvocation := Expression Arguments</programlisting>
            
            <para>For example:</para>
            
            <programlisting>compare("AAA", "aaa")</programlisting>
            <programlisting>compare { x = "AAA"; y = "aaa"; }</programlisting>
            
            <para>The value of a functor invocation is the return value of the functor.
            The parameter values are passed to the formal parameters of the functor
            implementation.</para>
            
        </section-->
        
        <!--  
        <section>
            <title>Attribute initialization</title>
            
            <para>Attribute initialization follows the following schema.</para>
            
            <programlisting>AttributeInitialization := Instantiation "{" Initialization* "}"</programlisting>
            
            <para>For example:</para>
            
            <programlisting>Person me = Person() { firstName="Gavin"; initial='A'; lastName="King"; }</programlisting>
            
            <para>The value of an attribute initialization is the instance being initialized.
            The named parameter values are assigned to uninitialized attributes of the instance.</para>
            
            <para>All non-<literal>optional</literal> attributes of a class must be explicitly
            initialized when the class is instantiated, either in the body of the class, or using
            attribute initialization. Uninitialized <literal>optional</literal> attributes are 
            implicitly initialized to <literal>null</literal> if not explicitly initialized.</para>
            
            <comment><para>TODO: is this the right thing to say? Should we require explicit 
            initialization even for <literal>optional</literal> attributes?</para></comment>
                        
        </section>
        -->
        
        <section id="attributeevaluationassignment">
            <title>Attribute evaluation and assignment</title>
            
            <para>Attribute evaluation follows this schema:</para>
            
            <programlisting>AttributeGet := MemberReference</programlisting>
            
            <para>This attribute evaluation:</para>
        
            <programlisting>String name = person.name;</programlisting>
        
            <para>is equivalent to the following Java code:</para>

            <programlisting>String name = person.name().get();</programlisting>
        
            <para>Attribute assignment follows the following schema:</para>
            
            <programlisting>AttributeSet := MemberReference AssignmentOperator Expression</programlisting>
            
            <para>This attribute assignment:</para>
        
            <programlisting>person.name := "Gavin";</programlisting>
        
            <para>is equivalent to the following Java code:</para>

            <programlisting>person.name().set("Gavin");</programlisting>
                        
            <para>If getter code is specified, and <literal>assign</literal> is not specified,
            the attribute is not settable, and any attempt to assign to the attribute will
            result in a compiler error.</para>
        
            <para>Attributes may not be accessed using the <literal>.</literal> operator when 
            the expression is of type <literal>optional</literal>. They may be accessed using 
            <literal>?.</literal>.</para>
            
            <para>Attributes may not be assigned when the expression of type 
            <literal>optional</literal>.</para>
            
        </section>
        
    </section>
    
    <!--section id="inlineclassesliteralobjectsenumerations">
        <title>Literal objects, inline classes, and enumerations</title>
    
        <para>Three additional kinds of expressions exist for inline instantiation of an object.</para>
        
        <itemizedlist>
            <listitem>
                <para>Literal objects allow instantiation and initialization of a class without 
                execution of the constructor.</para>
            </listitem>
            <listitem>
                <para>Inline classes allow inline instantiation of an anonymous subclass of a
                certain class.</para>
            </listitem>
            <listitem>
                <para>Enumerations allow instantiation of a collection via a simplified syntax.</para>
            </listitem>
        </itemizedlist>
        
        <para>A literal object or inline class specification may bypass the constructor of the 
        class or superclass. In this case, the literal object or inline class specification takes 
        on responsibility for initialization of simple attributes of the class or superclass. This 
        means that a literal object or inline class specification which bypasses the constructor 
        must exist in a scope in which all attributes of the class or superclass are visible. Use 
        of this feature does not bypass language level accessibility checks.</para>
    
    <section id="literalobjects">
        <title>Literal objects</title>
        
        <para>A literal object is specified according to:</para>
        
        <programlisting>LiteralObject := "new" RegularType PositionalArguments? "{" (Assignment | Specification)* "}"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Calculator calc = new Calculator() { currentValue := 1.0; };</programlisting>
        
        <programlisting>Person gavin = new Person { 
    firstName = "Gavin";
    initial = 'A';
    lastName = "King";
    address := new Address { ... };
    birthdate = new Date { day = 25; month = MARCH; year = ... };
    employer := jboss;
};</programlisting>

        <para>A literal object must be of a concrete class and must either:</para>
        
        <itemizedlist>
            <listitem>
                <para>specify initialization parameters, and then an arbitrary list of
                mutable attribute assignments, or</para>
            </listitem>
            <listitem>
                <para>specify no initialization parameters, and specify values for each 
                simple attribute of the class, including private attributes, except 
                attributes annotated <literal>transient</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Literal objects which specify no initialization parameters are created without 
        execution of the body of the class to which they belong. Literal objects may refer to 
        immutable locals and members of the containing class in the attribute initializer 
        expressions. They may not refer to mutable locals.</para>
        
        <para>The value of a literal object expression is a new instance of the class.</para>
            
        <comment><para>TODO: are you allowed to have arbitrary code inside a literal object 
        specification?</para></comment>

        <comment><para>TODO: is there some kind of solution for getting around access 
        restrictions if you want to use a literal object specification for a class that
        extends a superclass in another package/module?</para></comment>

        <para>The classes <literal>Serializer</literal> and <literal>Deserializer</literal>
        provide the ability to serialize and deserialize any object to its 
        <emphasis>canonical literal form</emphasis>.</para>
        
        <programlisting>Person person = ...;
Serializer&lt;Person&gt; srlz = Serializer(person);
String serializedPerson = srlz; //using built-in converter
Deserializer&lt;Person&gt; dsrlz = Deserializer&lt;Person&gt;(serializedPerson);
Person deserialized = dsrlz; //using built-in converter</programlisting>

    </section>
    
        <section id="inlineclasses">
            <title>Inline classes</title>
            
            <para>Inline classes may be specified according to:</para>
            
            <programlisting>InlineClass := "new" Annotation* RegularType PositionalArguments? Interfaces "{" Statement* "}"</programlisting>

            <para>For example:</para>
            
            <programlisting>Task task = new Task() {
    timeout := 1000;
    override void run() { ... }
    override void fail(Exception e) { ... }
};</programlisting>

            <programlisting>return new transactional Database 
        satisfies Resource {
    url = "jdbc:hsqldb:.";
    username = "gavin";
    password = "foobar";
    override void create() { open(); }
    override void destroy() { close(); }
};</programlisting>
            
            <para>An inline class is a literal object expression which may additionally:</para>
            
            <itemizedlist>
                <listitem>
                    <para>include arbitrary code to be executed when the inline class is
                    evaluated,</para>
                </listitem>
                <listitem>
                    <para>declare and override members, and</para>
                </listitem>
                <listitem>
                    <para>declare annotations.</para>
                </listitem>
            </itemizedlist>
            
            <para>The superclass of an inline class may be an abstract class. The inline
            class itself must be concrete.</para>
            
            <para>The value of an inline class expression is a new instance of the inline 
            class.</para>
            
        </section>
        
    </section-->
    
    <section id="assignableexpressions">
        <title>Assignable expressions</title>
        
        <para>Certain expressions are <emphasis>assignable</emphasis>. An assignable
        expression may appear as the LHS of the <literal>:=</literal> (assign) operator,
        and possibly, depending upon the type of the expression, as the LHS of the 
        numeric or logical assignment operators <literal>=, +=, -=, *=, /=, %=, &amp;=, 
        |=, ^=, &amp;&amp;=, ||=</literal> or as the subject of the increment or decrement
        operators <literal>++, --</literal>.</para>
        
        <para>The following expressions are assignable:</para>
        
        <itemizedlist>
            <listitem>
                <para>a local declared <literal>mutable</literal>, for example 
                <literal>count := 0</literal>,</para>
            </listitem>
            <listitem>
                <para>any attribute expression where the underlying attribute has a setter
                or is a simple attribute declared <literal>mutable</literal>, for example 
                <literal>person.name := "Gavin"</literal>,</para>
            </listitem>
            <listitem>
                <para>element expressions for the type <literal>OpenCorrespondence</literal>, 
                for example <literal>order.lineItems[0] := lineItem</literal>, and</para>
            </listitem>
            <listitem>
                <para>range expressions for the type <literal>OpenSequence</literal>, 
                for example <literal>fibonacci[0..1] := {0,1}</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>When an assignment expression is executed, the value of the local or
        attribute is set to the new value, or the <literal>define()</literal> method of
        <literal>OpenCorrespondence</literal> is called.</para>
        
        <para>Thus, the following statement:</para>
        
        <programlisting>order.lineItems[0] := LineItem { product = prod; quantity = 1; };</programlisting>
        
        <para>Is equivalent to the Java:</para>
        
        <programlisting>order.lineItems.define( 0, new LineItem(prod, 1) );</programlisting>
        
        
    </section>
    
    <section id="operators">
    <title>Operators</title>
            
    <para>Operators are syntactic shorthand for more complex expressions
    involving method invocation or attribute access. Each operator is defined 
    for a particular type. There is support for user-defined operator 
    <emphasis>overloading</emphasis>. However, the semantics of an operator 
    may be customized by the implementation of the type that the operator
    applies to. This is called <emphasis>operator polymorphism</emphasis>.</para>
    
    <para>Some examples:</para>
    
    <programlisting>Float z = x * y;</programlisting>
    
    <programlisting>++count;</programlisting>
    
    <programlisting>Integer j = i++;</programlisting>
    
    <programlisting>if ( x > 100 ) { ... }</programlisting>
    
    <programlisting>User gavin = users["Gavin"];</programlisting>
    
    <programlisting>List&lt;Item&gt; firstPage = list[0..20];</programlisting>
    
    <programlisting>for ( Natural n in 1..10 ) { ... }</programlisting>
    
    <programlisting>List&lt;Day&gt; nonworkDays = days[{0,7}];</programlisting>

    <programlisting>if ( name == value ) return ... ;</programlisting>
    
    <programlisting>log.info( "Hello " + $person + "!")</programlisting>
    
    <programlisting>List&lt;String&gt; names = ArrayList&lt;Person&gt;()^.append(person1)^.append(person2)*.name;</programlisting>
    
    <programlisting>optional String name = person?.name;</programlisting>
    
    
    <!--para>Are equivalent to the following (Ceylon) code:</para>
    
    <programlisting>Float z = x.times(y);</programlisting>
    
    <programlisting>count := count.successor;</programlisting>
    
    <programlisting>Integer j := ( i := i.successor ).predecessor;</programlisting>
    
    <programlisting>if ( x.compare(100).larger ) { ... }</programlisting>
    
    <programlisting>User gavin = users.value("Gavin");</programlisting>
        
    <programlisting>List&lt;Item&gt; firstPage = list.range(0..20);</programlisting>
    
    <programlisting>for ( Natural n in Range(1,10) ) { ... }</programlisting>

    <programlisting>if ( nullsafeEquals(name, value) ) return ... ;</programlisting>
       
    <programlisting>log.info( "Hello ".join(person.string).join("!") )</programlisting>
    
    <programlisting>List&lt;String&gt; names = 
    Spread&lt;String&gt; { 
        lhs = Chain&lt;String&gt; { 
            lhs = Chain&lt;String&gt; { 
                lhs = ArrayList(); 
                override void call() { lhs.append(person1); } }.lhs
            }
            override void call() { lhs.append(person2); } }.lhs
        }
        override void call(String element) { element.name; } 
    }.result;</programlisting>
    
    <programlisting>optional String name = if (exists person) person.name else null;</programlisting>
    
    <programlisting>List&lt;Day&gt; nonworkDays = days.values(Enumeration(0,7));</programlisting-->

    <section id="operatorlist">
        <title>List of operators</title>
    
        <para>The following tables define the semantics of the Ceylon operators:</para>
    
    <section id="basic">
    <title>Basic invocation and assignment operators</title>
    
    <para>These operators support method invocation and attribute evaluation and
    assignment. The <literal>$</literal> operator is a shortcut for converting
    any expression to a <literal>String</literal>.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Member invocation</emphasis></entry></row>
        
        <row>
            <entry><literal>.</literal></entry>
            <entry><literal>lhs.member</literal></entry>
            <entry>invoke</entry>
            <entry></entry>
            <entry><literal>X</literal> or type <literal>X</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry>Member type</entry>
        </row>
        <row>
            <entry><literal>^.</literal></entry>
            <entry><literal>lhs^.member</literal></entry>
            <entry>chain invoke</entry>
            <entry></entry>
            <entry><literal>X</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>?.</literal></entry>
            <entry><literal>lhs?.member</literal></entry>
            <entry>nullsafe invoke</entry>
            <entry><literal>if (exists lhs) lhs.member else null</literal></entry>
            <entry><literal>optional X</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry><literal>optional</literal> member type</entry>
        </row>
        
        <row>
            <entry><literal>*.</literal></entry>
            <entry><literal>lhs*.member</literal></entry>
            <entry>spread invoke</entry>
            <entry><literal>for (X x in lhs) x.member</literal></entry>
            <entry><literal>Iterable&lt;X&gt;</literal></entry>
            <entry>Member of <literal>X</literal></entry>
            <entry><literal>List</literal> of member type</entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignment</emphasis></entry></row>
    
        <row>
            <entry><literal>:=</literal></entry>
            <entry><literal>lhs := rhs</literal></entry>
            <entry>assign</entry>
            <entry><literal>Object.assign(set lhs,rhs)</literal></entry>
            <entry><literal>X</literal> or <literal>optional X</literal></entry>
            <entry><literal>X</literal> or <literal>optional X</literal></entry>
            <entry><literal>X</literal> or <literal>optional X</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Render</emphasis></entry></row>
        
        <row>
            <entry><literal>$</literal></entry>
            <entry><literal>$rhs</literal></entry>
            <entry>render</entry>
            <entry><literal>if (exists rhs) rhs.string else ""</literal></entry>
            <entry></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>String</literal></entry>
        </row>
    
        <row><entry namest="first" nameend="last"><emphasis>Compound invocation assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>.=</literal></entry>
            <entry><literal>lhs.=member</literal></entry>
            <entry>apply</entry>
            <entry><literal>Object.assign(set lhs,lhs.member)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry>Member of <literal>X</literal>, of
            type <literal>X</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Type or method argument specification</emphasis></entry></row>
        
        <row>
            <entry><literal>(,,)</literal> or {;;;}</entry>
            <entry><literal>lhs(x,y,z)</literal> or 
            <literal>lhs { a=x; b=y; c=z; }</literal></entry>
            <entry>arguments</entry>
            <entry><literal></literal></entry>
            <entry>Type or method</entry>
            <entry>Parameter types of type or method</entry>
            <entry>Type or return type of method</entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
        
    <section id="equalitycomparison">
    <title>Equality and comparison operators</title>
    
    <para>These operators compare values for equality, order, magnitude, or membership,
    producing boolean values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Equality</emphasis></entry></row>
        
        <row>
            <entry><literal>===</literal></entry>
            <entry><literal>lhs === rhs</literal></entry>
            <entry>identical</entry>
            <entry><literal>Object.identical(lhs, rhs)</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>==</literal></entry>
            <entry><literal>lhs == rhs</literal></entry>
            <entry>equal</entry>
            <entry><literal>if (exists lhs) lhs.equals(rhs) else if (exists rhs) false else true</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>!=</literal></entry>
            <entry><literal>lhs != rhs</literal></entry>
            <entry>not equal</entry>
            <entry><literal>if (exists lhs) lhs.equals(rhs).complement else if (exists rhs) true else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=&gt;</literal></entry>
            <entry><literal>lhs &lt;=&gt; rhs</literal></entry>
            <entry>compare</entry>
            <entry><literal>lhs.compare(rhs)</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Comparison</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>smaller</entry>
            <entry><literal>lhs.compare(rhs).smaller</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>larger</entry>
            <entry><literal>lhs.compare(rhs).larger</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>small as</entry>
            <entry><literal>lhs.compare(rhs).smallAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>large as</entry>
            <entry><literal>lhs.compare(rhs).largeAs</literal></entry>
            <entry><literal>Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Containment</emphasis></entry></row>
        
        <row>
            <entry><literal>in</literal></entry>
            <entry><literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>lhs.in(rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry><literal>Category</literal> or <literal>Iterable&lt;Object&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Assignability</emphasis></entry></row>
        
        <row>
            <entry><literal>is</literal></entry>
            <entry><literal>lhs is Rhs</literal></entry>
            <entry>is</entry>
            <entry><literal>lhs.instanceOf(#Rhs)</literal></entry>
            <entry><literal>Object</literal></entry>
            <entry>Any type</entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <!--  
        <row>
            <entry><literal>~></literal> or <literal>in</literal></entry>
            <entry><literal>lhs ~> rhs</literal> or <literal>lhs in rhs</literal></entry>
            <entry>in</entry>
            <entry><literal>lhs.in(rhs)</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Category&lt;X&gt;</literal> or <literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row>
            <entry><literal>!~></literal></entry>
            <entry><literal>lhs !~> rhs</literal></entry>
            <entry>not in</entry>
            <entry><literal>lhs.in(rhs).negation</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Category&lt;X&gt;</literal> or <literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row>
            <entry><literal>*~></literal></entry>
            <entry><literal>lhs *~> rhs</literal></entry>
            <entry>all in</entry>
            <entry><literal>for (X x in lhs: !x.in(rhs)) found false fail true</literal></entry>
            <entry><literal>Iterable&lt;X&gt;</literal></entry>
            <entry><literal>Category&lt;X&gt; or <literal>Iterable&lt;X&gt;</literal></literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: should we really have the equality operators accept null
    values?</para></comment>
    
    </section>
                
    <section id="logical">
    <title>Logical operators</title>
    
    <para>These are the usual logical operations for boolean values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Logical operations</emphasis></entry></row>
        
        <row>
            <entry><literal>!</literal></entry>
            <entry><literal>!rhs</literal></entry>
            <entry>not</entry>
            <entry><literal>if (rhs) false else true</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>||</literal></entry>
            <entry><literal>lhs || rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else rhs</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;&amp;</literal></entry>
            <entry><literal>lhs &amp;&amp; rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) rhs else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>=></literal></entry>
            <entry><literal>lhs => rhs</literal></entry>
            <entry>implication</entry>
            <entry><literal>if (lhs) rhs else true</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Logical assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>||=</literal></entry>
            <entry><literal>lhs ||= rhs</literal></entry>
            <entry>conditional or</entry>
            <entry><literal>if (lhs) true else Object.assign(set lhs,rhs)</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>

        <row>
            <entry><literal>&amp;&amp;=</literal></entry>
            <entry><literal>lhs &amp;&amp;= rhs</literal></entry>
            <entry>conditional and</entry>
            <entry><literal>if (lhs) Object.assign(set lhs,rhs) else false</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    <section id="nullvalues">
    <title>Operators for handling null values</title>
    
    <para>These operators make it easy to work with <literal>optional</literal>
    types.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Existence</emphasis></entry></row>
        
        <row>
            <entry><!--<literal>?</literal> or --><literal>exists</literal></entry>
            <entry><!--<<literal>lhs?</literal> or --><literal>lhs exists</literal></entry>
            <entry>exists</entry>
            <entry><literal>if (exists lhs) true else false</literal></entry>
            <entry><literal>optional Object</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal><!--??-->nonempty</literal></entry>
            <entry><literal><!--??-->lhs nonempty</literal></entry>
            <entry>nonempty</entry>
            <entry><literal>if (exists lhs) lhs.empty.complement else false</literal></entry>
            <entry><literal>optional Container</literal></entry>
            <entry></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Default</emphasis></entry></row>
        
        <row>
            <entry><literal>?</literal></entry>
            <entry><literal>lhs ? rhs</literal></entry>
            <entry>default</entry>
            <entry><literal>if (exists lhs) lhs else rhs</literal></entry>
            <entry><literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
        </row>

        <row><entry namest="first" nameend="last"><emphasis>Default assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>?=</literal></entry>
            <entry><literal>lhs ?= rhs</literal></entry>
            <entry>default assignment</entry>
            <entry><literal>if (exists lhs) lhs else Object.assign(set lhs,rhs)</literal></entry>
            <entry><literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
            <entry><literal>T</literal> or <literal>optional T</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>

    <section id="listmap">
    <title>Correspondence and sequence operators</title>
    
    <para>These operators provide a simplified syntax for accessing values 
    of a <literal>Correspondence</literal>, and for joining and obtaining
    subranges of <literal>Sequences</literal>s.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Keyed element access</emphasis></entry></row>
        
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[index]</literal></entry>
            <entry>lookup</entry>
            <entry><literal>lhs.value(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>Y</literal></entry>
        </row>
        <row>
            <entry><literal>?[]</literal></entry>
            <entry><literal>lhs?[index]</literal></entry>
            <entry>nullsafe lookup</entry>
            <entry><literal>if (exists lhs) lhs.value(index) else null</literal></entry>
            <entry><literal>optional Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>X</literal></entry>
            <entry><literal>optional Y</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>list lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>List&lt;Y&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>[]</literal></entry>
            <entry><literal>lhs[indices]</literal></entry>
            <entry>set lookup</entry>
            <entry><literal>lhs.values(index)</literal></entry>
            <entry><literal>Correspondence&lt;X,Y&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Sequence subranges</emphasis></entry></row>
        
        <row>
            <entry><literal>[..]</literal></entry>
            <entry><literal>lhs[x..y]</literal></entry>
            <entry>subrange</entry>
            <entry><literal>Sequences.range(lhs,x,y)</literal></entry>
            <entry><literal>S where S>=Sequence&lt;X&gt; &amp; S(X... elements)</literal></entry>
            <entry>Two <literal>Natural</literal> values</entry>
            <entry><literal>S</literal></entry>
        </row>
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[x...]</literal></entry>
            <entry>upper range</entry>
            <entry><literal>Sequences.range(lhs,x)</literal></entry>
            <entry><literal>S where S>=Sequence&lt;X&gt; &amp; S(X... elements)</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>S</literal></entry>
        </row>
        <!--
        <row>
            <entry><literal>[...]</literal></entry>
            <entry><literal>lhs[...y]</literal></entry>
            <entry>lower range</entry>
            <entry><literal>lhs.range(0,y)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        -->

        <row><entry namest="first" nameend="last"><emphasis>Sequence concatenation</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>join</entry>
            <entry><literal>Sequences.join(lhs, rhs)</literal></entry>
            <entry><literal>S where S>=Sequence&lt;X&gt; &amp; S(X... elements)</literal></entry>
            <entry><literal>S</literal></entry>
            <entry><literal>S</literal></entry>
        </row>

        <!--  
        
        <row><entry namest="first" nameend="last"><emphasis>Shift</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;&lt;</literal></entry>
            <entry><literal>lhs &lt;&lt; rhs</literal></entry>
            <entry>left shift</entry>
            <entry><literal>lhs.shiftLeft(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>>></literal></entry>
            <entry><literal>lhs >> rhs</literal></entry>
            <entry>right shift</entry>
            <entry><literal>lhs.shiftRight(rhs)</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>List&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set operations</emphasis></entry></row>
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>union</entry>
            <entry><literal>lhs.union(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>lhs ~ rhs</literal></entry>
            <entry>intersection</entry>
            <entry><literal>lhs.intersection(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>lhs.complement(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
        </row>
        
        -->
        
        <!--
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>cartesian product</entry>
            <entry><literal>lhs.product(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;Y&gt;</literal></entry>
            <entry><literal>Set&lt;Pair&lt;X,Y&gt;&gt;</literal></entry>
        </row>
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Set comparison</emphasis></entry></row>
        
        <row>
            <entry><literal>&lt;=</literal></entry>
            <entry><literal>lhs &lt;= rhs</literal></entry>
            <entry>subset</entry>
            <entry><literal>lhs.subset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;=</literal></entry>
            <entry><literal>lhs &gt;= rhs</literal></entry>
            <entry>superset</entry>
            <entry><literal>lhs.superset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&lt;</literal></entry>
            <entry><literal>lhs &lt; rhs</literal></entry>
            <entry>proper subset</entry>
            <entry><literal>lhs.properSubset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        <row>
            <entry><literal>&gt;</literal></entry>
            <entry><literal>lhs &gt; rhs</literal></entry>
            <entry>proper superset</entry>
            <entry><literal>lhs.properSuperset(rhs)</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Set&lt;X&gt;</literal></entry>
            <entry><literal>Boolean</literal></entry>
        </row>
        
        -->
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should we overload <literal>*</literal> for lists, like
    in some other languages? It is nice to be able to do stuff like 
    <literal>"-"*n</literal>.</para></comment>
    
    <comment><para>TODO: Should we have operators for set union/intersection/complement
    and set comparison?</para></comment>
    
    </section>
    
    <section id="constructors">
    <title>Operators for constructing objects</title>
    
    <para>These operators simplify the syntax for constructing certain commonly 
    used built-in types.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Range and entry constructors</emphasis></entry></row>

        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>range</entry>
            <entry><literal>Range(lhs, rhs)</literal></entry>
            <entry><literal>T where T &gt;= Ordinal &amp; T &gt;= Comparable&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
            <entry><literal>Range&lt;T&gt;</literal></entry>
        </row>
        
        <row>
            <entry><literal>-></literal></entry>
            <entry><literal>lhs -> rhs</literal></entry>
            <entry>entry</entry>
            <entry><literal>Entry(lhs, rhs)</literal></entry>
            <entry><literal>U</literal></entry>
            <entry><literal>V</literal></entry>
            <entry><literal>Entry&lt;U,V&gt;</literal></entry>
        </row>
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Datetime and interval constructors</emphasis></entry></row>

        <row>
            <entry><literal>@</literal></entry>
            <entry><literal>lhs @ rhs</literal></entry>
            <entry>datetime</entry>
            <entry><literal>Datetime(lhs, rhs)</literal></entry>
            <entry><literal>Date</literal></entry>
            <entry><literal>Time</literal></entry>
            <entry><literal>Datetime</literal></entry>
        </row>
        
        <row>
            <entry><literal>..</literal></entry>
            <entry><literal>lhs .. rhs</literal></entry>
            <entry>interval</entry>
            <entry><literal>Interval(lhs, rhs)</literal></entry>
            <entry><literal>T where T >= Instant</literal></entry>
            <entry><literal>Instant&lt;T&gt;</literal></entry>
            <entry><literal>Interval&lt;T&gt;</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: Should we have operators for performing arithmetic with
    datetimes and durations, constructing intervals and combining dates and 
    times?</para></comment>
    
    </section>
    
    <section id="arithmetic">
    <title>Arithmetic operators</title>
    
    <para>These are the usual mathematical operations for all kinds of
    numeric values.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Increment, decrement</emphasis></entry></row>
        
        <!-- Prefix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>++rhs</literal></entry>
            <entry>successor</entry>
            <entry><literal>Object.assign(set rhs,rhs.successor)</literal></entry>
            <entry></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>--rhs</literal></entry>
            <entry>predecessor</entry>
            <entry><literal>Object.assign(set rhs,rhs.predecessor)</literal></entry>
            <entry></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <!-- Postfix increment, decrement -->
        
        <row>
            <entry><literal>++</literal></entry>
            <entry><literal>lhs++</literal></entry>
            <entry>increment</entry>
            <entry><literal>(Object.assign(set lhs,lhs.successor)).predecessor</literal></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        <row>
            <entry><literal>--</literal></entry>
            <entry><literal>lhs--</literal></entry>
            <entry>decrement</entry>
            <entry><literal>(Object.assign(set lhs,lhs.predecessor)).successor</literal></entry>
            <entry><literal>Ordinal&lt;T&gt;</literal></entry>
            <entry></entry>
            <entry><literal>T</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric operations</emphasis></entry></row>
        
        <!-- Unary negative -->
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>-rhs</literal></entry>
            <entry>negation</entry>
            <entry><literal>rhs.inverse</literal></entry>
            <entry></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        
        <!-- Numeric -->
        
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>sum</entry>
            <entry><literal>lhs.plus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>difference</entry>
            <entry><literal>lhs.minus(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>product</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>quotient</entry>
            <entry><literal>lhs.divided(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>%</literal></entry>
            <entry><literal>lhs % rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>lhs.remainder(rhs)</literal></entry>
            <entry><literal>Integral&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>**</literal></entry>
            <entry><literal>lhs ** rhs</literal></entry>
            <entry>power</entry>
            <entry><literal>lhs.power(rhs)</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <row><entry namest="first" nameend="last"><emphasis>Numeric assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>+=</literal></entry>
            <entry><literal>lhs += rhs</literal></entry>
            <entry>add</entry>
            <entry><literal>Object.assign(set lhs,lhs.plus(rhs))</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>-=</literal></entry>
            <entry><literal>lhs -= rhs</literal></entry>
            <entry>subtract</entry>
            <entry><literal>Object.assign(set lhs,lhs.minus(rhs))</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>I</literal></entry>
        </row>
        <row>
            <entry><literal>*=</literal></entry>
            <entry><literal>lhs *= rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>Object.assign(set lhs,lhs.times(rhs))</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>/=</literal></entry>
            <entry><literal>lhs /= rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>Object.assign(set lhs,lhs.divided(rhs))</literal></entry>
            <entry><literal>Numeric&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        <row>
            <entry><literal>%=</literal></entry>
            <entry><literal>lhs %= rhs</literal></entry>
            <entry>remainder</entry>
            <entry><literal>Object.assign(set lhs,lhs.remainder(rhs))</literal></entry>
            <entry><literal>Integral&lt;N,I&gt;</literal></entry>
            <entry><literal>N</literal></entry>
            <entry><literal>N</literal></entry>
        </row>
        
        <!--
        <row><entry namest="first" nameend="last"><emphasis>Duration arithmetic</emphasis></entry></row>
                
        <row>
            <entry><literal>+</literal></entry>
            <entry><literal>lhs + rhs</literal></entry>
            <entry>extend</entry>
            <entry><literal>lhs.extend(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>-</literal></entry>
            <entry><literal>lhs - rhs</literal></entry>
            <entry>curtail</entry>
            <entry><literal>lhs.curtail(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>*</literal></entry>
            <entry><literal>lhs * rhs</literal></entry>
            <entry>multiply</entry>
            <entry><literal>lhs.times(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        
        <row>
            <entry><literal>/</literal></entry>
            <entry><literal>lhs / rhs</literal></entry>
            <entry>divide</entry>
            <entry><literal>lhs.divide(rhs)</literal></entry>
            <entry><literal>Duration</literal></entry>
            <entry><literal>Natural</literal></entry>
            <entry><literal>Duration</literal></entry>
        </row>
        -->
        
        <!--
        
        <row><entry namest="first" nameend="last"><emphasis>Bitwise operations</emphasis></entry></row>
        
        <row>
            <entry><literal>|||</literal></entry>
            <entry><literal>lhs ||| rhs</literal></entry>
            <entry>bitwise or</entry>
            <entry><literal>lhs.or(rhs)</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;&amp;&amp;</literal></entry>
            <entry><literal>lhs &amp;&amp;&amp; rhs</literal></entry>
            <entry>bitwise and</entry>
            <entry><literal>lhs.and(rhs)</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        <row>
            <entry><literal>^^^</literal></entry>
            <entry><literal>lhs ^^^ rhs</literal></entry>
            <entry>bitwise xor</entry>
            <entry><literal>lhs.xor(rhs)</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>~rhs</literal></entry>
            <entry>bitwise not</entry>
            <entry><literal>rhs.not</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
            <entry><literal>Binary</literal></entry>
        </row>
        
        -->
        
    </tbody>
    </tgroup>
    </table>
    
        <para>Built-in converters allow for type promotion of numeric values used in 
        expressions. Coverters exist for the following numeric types:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>lang.Natural</literal> to <literal>lang.Integer</literal>,
                <literal>lang.Float</literal>, <literal>lang.Whole</literal> and 
                <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Integer</literal> to <literal>lang.Float</literal>,
                <literal>lang.Whole</literal> and <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Float</literal> to <literal>lang.Decimal</literal></para>
            </listitem>
            <listitem>
                <para><literal>lang.Whole</literal> to <literal>lang.Decimal</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>This means that <literal>x + y</literal> is defined for any combination 
        of numeric types <literal>X</literal> and <literal>Y</literal>, except for 
        the combination <literal>Float</literal> and <literal>Whole</literal>, and that
        <literal>x + y</literal> always produces the same value, with the same type, as
        <literal>y + x</literal>.</para>
        
    </section>
    
    <section id="bitwise">
    <title>Bitwise operators</title>
    
    <para>These are C-style bitwise operations for bit strings (unsigned integers).
    A <literal>Boolean</literal> is considered a bit string of length one, so these
    operators also apply to <literal>Boolean</literal> values. Note that in Ceylon
    these operators have a higher precedence than they have in C or Java. There are
    no bitshift operators in Ceylon.</para>
    
    <table>
    <tgroup cols="7">
        <colspec colnum="1" colwidth="2.0*" align="center" colname="first"/>
        <colspec colnum="2" colwidth="4.5*" align="center"/>
        <colspec colnum="3" colwidth="4.0*" align="center"/>
        <colspec colnum="4" colwidth="8.5*" align="center"/>
        <colspec colnum="5" colwidth="4.0*" align="center"/>
        <colspec colnum="6" colwidth="3.5*" align="center"/>
        <colspec colnum="7" colwidth="3.5*" align="center" colname="last"/>
    <thead>
        <row>
            <entry>Op</entry>
            <entry>Example</entry>
            <entry>Name</entry>
            <entry>Equivalent</entry>
            <entry>LHS type</entry>
            <entry>RHS type</entry>
            <entry>Return type</entry>
        </row>
    </thead>
    <tbody>
    
        <row><entry namest="first" nameend="last"><emphasis>Bitwise operations</emphasis></entry></row>
        
        <row>
            <entry><literal>~</literal></entry>
            <entry><literal>~rhs</literal></entry>
            <entry>complement</entry>
            <entry><literal>rhs.complement</literal></entry>
            <entry></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>|</literal></entry>
            <entry><literal>lhs | rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>lhs.or(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;</literal></entry>
            <entry><literal>lhs &amp; rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>lhs.and(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>^</literal></entry>
            <entry><literal>lhs ^ rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>lhs.xor(rhs)</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>

        
        <row><entry namest="first" nameend="last"><emphasis>Bitwise assignment</emphasis></entry></row>
        
        <row>
            <entry><literal>|=</literal></entry>
            <entry><literal>lhs |= rhs</literal></entry>
            <entry>or</entry>
            <entry><literal>Object.assign(set lhs,lhs.or(rhs))</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>&amp;=</literal></entry>
            <entry><literal>lhs &amp;= rhs</literal></entry>
            <entry>and</entry>
            <entry><literal>Object.assign(set lhs,lhs.and(rhs))</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        <row>
            <entry><literal>^=</literal></entry>
            <entry><literal>lhs ^= rhs</literal></entry>
            <entry>exclusive or</entry>
            <entry><literal>Object.assign(set lhs,lhs.xor(rhs))</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>Bits&lt;X&gt;</literal></entry>
            <entry><literal>X</literal></entry>
        </row>
        
    </tbody>
    </tgroup>
    </table>
    
    </section>
    
    </section>
    
    <section id="operatorprecedence">
        <title>Operator precedence and associativity</title>
        
        <para>This table defines operator precedence from highest to lowest,
        along with associativity rules:</para>
        
    <table>
    <tgroup cols="4">
        <colspec colnum="1" colwidth="2.5*" align="center"/>
        <colspec colnum="2" colwidth="2.0*" align="center"/>
        <colspec colnum="3" colwidth="1.0*" align="center"/>
        <colspec colnum="4" colwidth="0.7*" align="center"/>
    <thead>
        <row>
            <entry>Operations</entry>
            <entry>Operators</entry>
            <entry>Type</entry>
            <entry>Associativity</entry>
        </row>
    </thead>
    <tbody>
    
            <row>
                <entry>Member invocation and lookup, subrange,
                postfix increment, postfix decrement:</entry>
                <entry>
                <literal>.</literal>, 
                <literal>^.</literal>, 
                <literal>*.</literal>, 
                <literal>?.</literal>, 
                <literal>(,,)</literal>,
                <literal>{;;;}</literal>,
                <literal>[]</literal>, 
                <literal>[..]</literal>, 
                <literal>[...]</literal>,
                <literal>++</literal>, 
                <literal>--</literal></entry>
                <entry>Binary / ternary / N-ary / unary postfix</entry>
                <entry>Left</entry>
            </row>
            
            <row>
                <entry>Prefix increment, prefix decrement,
                negation, render, bitwise complement:</entry>
                <entry>
                <literal>++</literal>, 
                <literal>--</literal>, 
                <literal>-</literal>, 
                <literal>$</literal>,
                <literal>~</literal> 
                </entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Exponentiation:</entry>
                <entry>
                <literal>**</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            <!--  
            <row>
                <entry>Exponentiation, shift:</entry>
                <entry>
                <literal>**</literal>,
                <literal>&lt;&lt;</literal>, 
                <literal>>></literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            -->
            <row>
                <entry>Multiplication, division, remainder,
                bitwise and:</entry> 
                <entry>
                <literal>*</literal>, 
                <literal>/</literal>, 
                <literal>%</literal>,
                <literal>&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Addition, subtraction, bitwise or,
                bitwise xor, list concatenation:</entry> 
                <entry>
                <literal>+</literal>, 
                <literal>-</literal>, 
                <literal>|</literal>, 
                <literal>^</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <!--row>
                <entry>Date/time composition:</entry> 
                <entry><literal>@</literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row-->
            <row>
                <entry>Range<!--, interval--> and entry construction:</entry> 
                <entry><literal>..</literal>, <literal>-></literal></entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>exists</literal>, <literal>nonempty</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            <!--
            <row>
                <entry>Existence, emptiness:</entry>
                <entry><literal>?</literal>, <literal>??</literal></entry> 
                <entry>Unary postfix</entry>
                <entry>None</entry>
            </row>
            -->
            <row>
                <entry>Default:</entry> 
                <entry><literal>?</literal></entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>

            <row>
                <entry>Comparison, <!--set comparison,--> containment,
                assignability:</entry> 
                <entry>
                <literal>&lt;=&gt;</literal>,
                <literal>&lt;</literal>, 
                <literal>&gt;</literal>, 
                <literal>&lt;=</literal>, 
                <literal>&gt;=</literal>,
                <!--<literal>~></literal>,
                <literal>!~></literal>,
                <literal>*~></literal>-->
                <literal>in</literal>,
                <literal>is</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            <row>
                <entry>Equality:</entry>
                <entry>
                <literal>==</literal>, 
                <literal>!=</literal>, 
                <literal>===</literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
        
            <row>
                <entry>Logical not:</entry>
                <entry><literal>!</literal></entry>
                <entry>Unary prefix</entry>
                <entry>Right</entry>
            </row>
            <row>
                <entry>Logical and:</entry> 
                <entry>
                <literal>&amp;&amp;</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical or:</entry>
                <entry>
                <literal>||</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Left</entry>
            </row>
            <row>
                <entry>Logical implication:</entry>
                <entry>
                <literal>=></literal>
                </entry>
                <entry>Binary</entry>
                <entry>None</entry>
            </row>
            
            <row>
                <entry>Assignment:</entry> 
                <entry>
                <literal>:=</literal>, 
                <literal>.=</literal>,
                <literal>+=</literal>, 
                <literal>-=</literal>, 
                <literal>*=</literal>, 
                <literal>/=</literal>, 
                <literal>%=</literal>, 
                <literal>&amp;=</literal>, 
                <literal>|=</literal>, 
                <literal>^=</literal>, 
                <literal>&amp;&amp;=</literal>, 
                <literal>||=</literal>,
                <literal>?=</literal>
                </entry>
                <entry>Binary</entry>
                <entry>Right</entry>
            </row>
            
    </tbody>
    </tgroup>
    </table>
    
    <comment><para>TODO: should <literal>?</literal> have a higher precedence?</para></comment>
    
    <comment><para>TODO: should <literal>^</literal> have a higher precedence than
    <literal>|</literal> like in C and Java?</para></comment>
    
    <comment><para>TODO: should <literal>^,|,&amp;</literal> have a lower precedence
    than <literal>+,-,*,/</literal> like in Ruby?</para></comment>
    
    <comment><para>Note: if we decide to add <literal>&lt;&lt;</literal> and 
    <literal>&gt;&gt;</literal> later, we could give them the same precedence
    as <literal>**</literal>.</para></comment>
    
    </section>
    
    </section>

    <!--section id="functorexpressions">
        <title>Functor expressions</title>
        
        <para>A functor expression has this form:</para>
        
        <programlisting>FunctorExpression := FunctorHeader? FormalParams FunctorBody</programlisting>
        
        <para>Functor expressions must specify a formal parameter list.</para>
        
        <para>A functor expression may optionally specify annotations and/or return type. 
        In this case, the keyword <literal>functor</literal> is required.</para>
        
        <para>A functor body may be a single expression, or a block.</para>
        
        <programlisting>FunctorBody = Expression | Block</programlisting>
        
        <para>If the body of a non-<literal>void</literal> functor is a block, the value of 
        the functor, when executed, is determined by the <literal>produce</literal> directive. 
        A functor body may not contain a <literal>return</literal> directive.</para>
                
        <para>For example:</para>
        
        <programlisting>functor Comparison(Float x, Float y) order = functor Comparison(Float x, Float y) { produce x&lt;=&gt;y };</programlisting>
        
        <para>The keyword <literal>functor</literal>, and the return type may be omitted:</para>

        <programlisting>functor Comparison(Float x, Float y) order = (Float x, Float y) { produce x&lt;=&gt;y };</programlisting>
        
        <para>The braces around the functor body and the <literal>produce</literal> keyword 
        may be omitted.</para>
        
        <programlisting>people.sort( (Person x, Person y) y.name &lt;=&gt; x.name );</programlisting>
               
        <programlisting>people.select( (Person p) p.age>18 )
    .collect( (Person p) p.name );</programlisting>
    
        <para>The braces are required for a <literal>void</literal> functor.</para>
        
        <programlisting>namedValues.each( (String name->Object value) { log.info("${name} ${value}"); } );</programlisting>
                 
        <para>A functor expression can only appear as the right side of an assignment, initializer
        or specifier, as an argument, in a control directive, as an element of an enumeration
        instantiation, or surrounded by parentheses.</para>
                        
        <para>Consider the following functor expression:</para>
        
        <programlisting>functor Comparison(String x, String y) order = (String x, String y) { produce x &lt;=&gt; y }</programlisting>
        
        <para>Or, equivalently:</para>
        
        <programlisting>functor Comparison(String x, String y) order = (String x, String y) x &lt;=&gt; y;</programlisting>
        
        <para>These expressions are both equivalent to this Java code:</para>

        <programlisting>F2&lt;String,String,Comparison&gt; order = 
    new F2&lt;String,String,Comparison&gt;() {
        public Comparison call(String x, String y) { 
            return Comparison.compare(x,y); 
        }
    };</programlisting>
        
        <para>And this functor invocation:</para>
        
        <programlisting>Comparison result = order("Gavin", "Emmanuel");</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Comparison result = order.call("Gavin", "Emmanuel");</programlisting>
        
        <para>Functors may refer to immutable locals and members of the
        containing class. They may not refer to mutable locals.</para>
    
        <para>The following code:</para>
        
        <programlisting>(0..10).each( (Natural num) { log.info(num); } );</programlisting>
        
        <para>Is equivalent to:</para>
        
        <programlisting>new Range&lt;Natural&gt;(0, 10).each( 
    new F1&lt;Natural,Boolean&gt;() {
        @Override Boolean call(Natural x) { 
            ParentClass.this.log.info(num); 
        } 
    } );</programlisting>
    
        <para>This code:</para>
        
        <programlisting>Integer min = 0;
Integer max = 10;
List list = list.select( (Integer x) x &gt; min &amp;&amp; x &lt; max );</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>final Integer min = 0; 
final Integer max = 10; 
List list = list.select( new F1&lt;Integer,Boolean&gt;() { 
        @Override Boolean call(Integer x) { 
            return x > min &amp;&amp; x &lt; max; 
        } 
    } );</programlisting>
    
    </section-->
               
    <section id="smalltalkprotocol">
        <title>Smalltalk-style method invocation</title>
        
        <para>Ceylon provides a special method invocation protocol inspired by Smalltalk 
        for specifying arguments to functional parameters of a method. This special
        invocation protocol may be used to imitate the syntax of built-in control
        structures. For example:</para>
        
        <programlisting>sort(amounts) by (Float x, Float y) { return x&lt;=&gt;y };</programlisting>
        
        <programlisting>people select (Person p) p.name having (Person p) p.age>18;</programlisting>
        
        <programlisting>x>10
isTrue {
    log.debug("big");
    big(x);
}
isFalse {
    log.debug("little");
    little(x);
};</programlisting>
        
        <para>In a Smalltalk-style method invocation, an argument to a functional 
        parameter may be specified with certain punctuation eliminated:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the functional parameter declares no parameters, the empty
                parentheses may be eliminated, and</para>
            </listitem>
            <listitem>
                <para>if the body of the method implementation consists of a single
                <literal>return</literal> directive, the braces and <literal>return</literal>
                keyword may be eliminated.</para>
            </listitem>
        </itemizedlist>
        
        <para>These arguments are called <emphasis>functional arguments</emphasis> of
        a positional parameter invocation.</para>
        
        <programlisting>FunctionalBody := FormalParameters? (Block | Expression)</programlisting>
        
        <programlisting>FunctionalArgument := ParameterName FunctionalBody</programlisting>
        
        <para>For example:</para>
        
        <programlisting>elements (Person p) p.age>18</programlisting>
        
        <programlisting>isTrue x+1</programlisting>
        
        <programlisting>each { count+=1; }</programlisting>
        
        <para>Functional arguments are listed without any seperating punctuation:</para>
        
        <programlisting>isTrue x+1 isFalse x-1</programlisting>
        
        <programlisting>select (Person p) p.name having (Person p) p.age>18</programlisting>
        
        <para>Arguments must be listed in the same order as the formal parameters are 
        declared.</para>
                
        <para>The method invocation protocol begins with either:</para>

        <itemizedlist>
            <listitem>
                <para>a normal method invocation with a period before the method name 
                and an ordered list of arguments surrounded be parentheses, or</para>
            </listitem>
            <listitem>
                <para>the receiving expression, followed by the the method name, without 
                the period or parentheses, followed immediately by the first block 
                argument.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>MethodInvocationWithFunctionalArguments :=
( MemberReference TypeArguments? PositionalArguments | Expression MemberName FunctionalBody ) 
FunctionalArgument*</programlisting>
                
        <para>Some additional examples:</para>
        
        <programlisting>namedValues each (String name->Object value) { 
    log.info("${name} ${value}"); 
};</programlisting>
        
        <programlisting>Set&lt;People&gt; adults = people elements (Person p) p.age>18;</programlisting>

        <programlisting>int index = lineItems firstIndex (LineItem li) !li.product.available;</programlisting>
        
        <programlisting>people sort (Person p, Person q) p.name&lt;=&gt;q.name;</programlisting>
        
        <programlisting>String label = x>10 isTrue "big" isFalse "little";</programlisting>
        
        <programlisting>optional specialPerson = search (people) findFirst (Person p) p.special orIfNoneFound null;</programlisting>
        
        <comment><para>TODO: there is a small problem here. In <literal>x.foo(y) bar z</literal>, 
        is <literal>bar</literal> the name of a method or of a parameter of 
        <literal>foo()</literal>?</para> That's not such a big deal for the compiler, but
        for the human reader I guess it's going to get confusing occasionally. So should we
        play it safe and require the form <literal>x.foo(y).bar() baz z</literal> in the case 
        that <literal>bar</literal> is the method name?</comment>

        <comment><para>TODO: On the other hand, if we don't want to play things safe, should 
        we allow this invocation protocol for methods with no parameters, or with arguments 
        which are not functional (I have checked that this can be parsed), for example:</para></comment>
        
        <programlisting>Integer x = y integer;</programlisting>
        <programlisting>log info "Hello World";</programlisting>
        <programlisting>log.info(", " join org.employees*.name);</programlisting>

        <section id="iteration">
            <title>Iteration</title>
            
        <para>A specialized invocation syntax is provided for methods which iterate 
        collections. If the first parameter of the method is of type <literal>Iterable&lt;X&gt;</literal>,
        annotated <literal>iterated</literal>, and all remaining parameters are functional
        parameters, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>MemberReference "(" ForIterator ")" BlockArguments</programlisting>
        
        <para>And each functional argument for a parameter annotated <literal>coordinated</literal>
        with a single parameter of type <literal>X</literal> need not declare its formal
        parameter. Instead, its parameter is declared by the iterator.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
List&lt;Y&gt; from&lt;X,Y&gt;(iterated Iterable&lt;X&gt; elements, 
                  coordinated Boolean having(X x),
                  coordinated Y select(X x));</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; names = from (Person p in people) having p>20 select p.name;</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; names = from (people) having (Person p) p>20 select (Person p) p.name;</programlisting>
        
        <para>Or, we may invoke the method as follows:</para>
                  
        <programlisting>List&lt;String&gt; labels = from (Key key -> Value value in namedValues)
                      having user.authorized(key) 
                      select "${key} ${value}";</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>List&lt;String&gt; labels = from (namedValues)
                      having (Key key -> Value value) user.authorized(key) 
                      select (Key key -> Value value) "${key} ${value}";</programlisting>
                      
        </section>
        
        <section id="localdefinition">
            <title>Variable definition</title>
            
        <para>A specialized invocation syntax is also provided for methods which define 
        a variable. If the first parameter of the method is of type <literal>X</literal>,
        annotated <literal>specified</literal>, and all remaining parameters are functional
        parameters, then the method may be invoked according to the following protocol:</para>
        
        <programlisting>MemberReference "(" Variable Specifier ")" BlockArguments</programlisting>
        
        <para>And each functional argument for a parameter annotated <literal>coordinated</literal>
        with a single parameter of type <literal>X</literal> need not declare its formal
        parameter. Instead, its parameter is declared by the variable specifier.</para>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
Y ifExists&lt;X,Y&gt;(specified optional X value, 
                coordinated Y then(X x), 
                Y otherwise());</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Decimal amount = ifExists(Payment p = order.payment) then p.amount otherwise 0.0;</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Decimal amount = ifExists(order.payment) then (Payment p) p.amount otherwise 0.0;</programlisting>
        
         <para>And for the following method declaration:</para>
        
        <programlisting>public static
Y using&lt;X,Y&gt;(specified X resource, 
             coordinated Y seek(X x) )
  where X >= Usable;</programlisting>
                  
        <para>We may invoke the method as follows:</para>
                  
        <programlisting>Order order = using (Session s = Session()) seek s.get(#Order, oid);</programlisting>
        
        <para>Which is equivalent to:</para>
        
        <programlisting>Order order = using (Session()) seek (Session s) s.get(#Order, oid);</programlisting>
        
        </section>
        
        <!--section id="caseslist">
            <title>Lists of cases</title>
        
        <para>Finally, a specialized invocation syntax is provided for methods which define 
        a list of cases. If the method has a parameter of type 
        <literal>Iterable&lt;Entry&lt;Case&lt;X&gt;, functor Y()&gt;&gt;</literal> annotated 
        <literal>cases</literal>, the parameter may be specified according to:</para>
        
        <programlisting>(case "(" Case ")" SimpleBlockExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
Y select&lt;X, Y&gt;(X selector,
              cases Entry&lt;Case&lt;X&gt;, functor Y()&gt;... cases);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>return select (payment.type) 
    case (check) payByCheck(payment)
    case (card) payByCard(payment);
</programlisting>
        
        </section-->
        <!--  
        <para>Or, If the method has a parameter of type 
        <literal>Enumeration&lt;functor Y(X x)&gt;</literal> annotated <literal>cases</literal>,
        the parameter value may be specified according to:</para>
        
        <programlisting>(LIdentifier BlockExpression)+</programlisting>
        
        <para>For example, for the following method declaration:</para>
        
        <programlisting>public static
X attempt&lt;X&gt;(functor X() seek, 
             cases functor X(E e) where E>=Exception... except);</programlisting>
                  
        <para>We may invoke the method as follows:</para>
        
        <programlisting>attempt() 
seek { 
    produce doSomething(); 
} 
except (SomethingWrong sw) {
    log.info(sw);
    produce -1;
}
except (SomethingElseWrong sew) {
    log.warn(sew);
    produce -2;
}</programlisting>
        -->
        
    </section>
    
        <!--
        <section>
        <title>TODO: assignment to local variables from surrounding scope</title>
    
        <para>The following code:</para>
        
        <programlisting>Integer min = 0;
Integer max = 0;
Integer count = 0;
Integer size = list.each(Integer x) { 
    if ( x > min ) count++; 
    if ( x > max) max = x; 
};</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>Integer min = 0; 
Integer max = 0;
Integer count = 0;
final List list$1 = list;
final F1&lt;Integer,Boolean&gt; functor$1 = 
    new F1&lt;Integer,Boolean&gt;(min, max, count) { 
        Integer min = (Integer) locals[0];
        Integer max = (Integer) locals[1];
        Integer count = (Integer) locals[2];
        @Override Boolean call(Integer x) { 
            if ( x > min ) count++; 
            if ( x > max) max = x; 
            locals[0] = min;
            locals[1] = max;
            locals[2] = count;
        }
    };
final Integer result$1 = list$1.each(functor$1);
final Object[] locals$1 = functor$1.locals();
min = (Integer) locals[0];
max = (Integer) locals[1];
count = (Integer) locals[2];
Integer size = result$1;</programlisting>

        <para>Or, perhaps:</para>
    
        <programlisting>Integer min = 0; 
Integer max = 0;
Integer count = 0;
final List list$1 = list;
final F1&lt;Integer,Boolean&gt; functor$1 = 
    new F1&lt;Integer,Boolean&gt;(min, max, count) { 
        @Override Boolean call(Integer x) { 
            if ( x > locals[0] ) locals[3]++; 
            if ( x > locals[1] ) locals[1] = x; 
        }
    };
final Integer result$1 = list$1.each(functor$1);
final Object[] locals$1 = functor$1.locals();
min = (Integer) locals[0];
max = (Integer) locals[1];
count = (Integer) locals[2];
Integer size = result$1;</programlisting>

        </section>
    -->
    
</chapter>