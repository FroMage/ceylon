<chapter id="typesystem">
    <title>Type system overview</title>
    
    <para>Every value in a Ceylon program is an instance of a type that can be expressed 
    within the Ceylon language as a <emphasis>class</emphasis>. The language does not 
    define any primitive or compound types that cannot, in principle, be expressed within 
    the language itself.</para>
    
    <para>A class is a recipe for producing new values, called <emphasis>instances</emphasis>
    of the class (or simply <emphasis>objects</emphasis>), and defines the operations and 
    attributes of the resulting values. A class instance may hold references to other 
    objects, and has an identity distinct from these references.</para>
    
    <para>Each class declaration 
    defines a type. However, not all types are classes. It is often advantageous to write 
    generic code that abstracts the concrete class of a value. This technique is called 
    <emphasis>polymorphism</emphasis>. Ceylon supports two different kinds of polymorphism:</para>
    
    <itemizedlist>
        <listitem>
            <para><emphasis>subtype polymorphism</emphasis>, where a subtype <literal>B</literal>
            inherits a supertype <literal>A</literal>, and</para>
        </listitem>
        <listitem>
            <para><emphasis>parametric polymorphism</emphasis>, where a type definition 
            <literal>A&lt;T&gt;</literal> is parameterized by a <emphasis>generic type 
            parameter</emphasis> <literal>T</literal>.</para>
        </listitem>
    </itemizedlist>
    
    <para>Ceylon, like Java and many other object-oriented languages, supports a single
    inheritance model for classes. A class may directly inherit at most one other class, 
    and all classes eventually inherit, directly or indirectly, the class 
    <literal>ceylon.language.Void</literal>, which acts as the root of the class hierarchy.</para>
    
    <para>A truly hierarchical type system is much too restrictive for more abstract 
    programming tasks. Therefore, in addition to classes, Ceylon recognizes the following 
    kinds of type:</para>
    
    <itemizedlist>
        <listitem>
            <para>An <emphasis>interface</emphasis> is an abstract type schema that cannot
            itself be directly instantiated. An interface may define concrete members, but
            these members may not hold references to other objects. A class may 
            <emphasis>implement</emphasis> one or more interfaces. An instance of a class 
            that implements an interface is also considered an instance of the interface.</para>
        </listitem>
        <listitem>
            <para>A <emphasis>generic type parameter</emphasis> is considered a type
            within the declaration that it parameterizes. In fact, it is an abstraction
            over many types: it generalizes the declaration to all types which could be 
            substituted for the parameter.</para>
        </listitem>
        <listitem>
            <para>A <emphasis>produced type</emphasis> is formed by specifying arguments
            for the generic type parameters of a parameterized type.</para>
        </listitem>
        <!--
        <listitem>
            <para>A <emphasis>union</emphasis> is a type whose value may be a value of 
            any one of an enumerated list of types. <emphasis>NOTE: Union types are a 
            feature proposed for inclusion in a future version of the language.</emphasis></para>
        </listitem>
        -->
    </itemizedlist>
    
    <para>The Ceylon type system is much more complete than most other object oriented
    languages. In Ceylon, it's possible to answer questions that might at first sound
    almost nonsensical if you're used to languages with more traditional type systems. 
    For example:</para>
    
    <itemizedlist>
        <listitem>
            <para>What is the return type of a <literal>void</literal> method?</para>
        </listitem>
        <listitem>
            <para>What is the type of an local that may or may not hold a value of 
            type <literal>T</literal>?</para>
        </listitem>
        <listitem>
            <para>What is the type that represents methods that accept two <literal>Float</literal>
            values?</para>
        </listitem>
        <listitem>
            <para>What is the type of an expression that may be evaluated to produce
            a <literal>String</literal>?</para>
        </listitem>
        <listitem>
            <para>What is the type of a sequence of natural numbers of length <literal>n+1</literal>?</para>
        </listitem>
        <listitem>
            <para>What is the type that represents subclasses of <literal>Renderer</literal> 
            which must be provided at instantiation time with a function that accepts an 
            object and produces a <literal>String</literal>?</para>
        </listitem>
    </itemizedlist>
    
    <para>The answers, as we shall discover, are: <literal>Void</literal>, 
    <literal>Optional&lt;T&gt;</literal>, <literal>Method&lt;Object, Void, Float, Float&gt;</literal>,
    <literal>Gettable&lt;String&gt;</literal>, <literal>BoundedSequence&lt;n+1&gt;</literal>, 
    and <literal>Class&lt;Renderer, Callable&lt;String,Object&gt;&gt;</literal>.</para>
    
    <!--itemizedlist>
        <listitem>
            <para><literal>Void</literal>, </para>
        </listitem>
        <listitem>
            <para><literal>Optional&lt;T&gt;</literal></para>
        </listitem>
        <listitem>
            <para><literal>Method&lt;Void, Float, Float&gt;</literal>, and</para>
        </listitem>
        <listitem>
            <para><literal>Gettable&lt;String&gt;</literal>.</para>
        </listitem>
    </itemizedlist-->
    

    <section id="identifiernaming">
        <title>Identifier naming</title>

        <para>The Ceylon compiler enforces identifier naming conventions. Types must
        be named with an initial uppercase. Members, parameters and locals must be 
        named with an initial lowercase or underscore. A package name element is an
        all-lowercase identifier.</para>
        
        <programlisting>PackageName: PIdentifier</programlisting>
        <programlisting>TypeName: UIdentifier</programlisting>
        <programlisting>MemberName: LIdentifier</programlisting>
        <programlisting>ParameterName: LIdentifier</programlisting>
        
        <para>An underscore <literal>_</literal> is considered a lowercase letter.</para>
        
        <para>Ceylon defines three identifier namespaces:</para>
        
        <itemizedlist>
            <listitem>
                <para>classes, interfaces, and type parameters share a single 
                namespace,</para>
            </listitem>
            <listitem>
                <para>methods, attributes, and locals share a single namespace, and</para>
            </listitem>
            <listitem>
                <para>packages have their own dedicated namespace.</para>
            </listitem>
        </itemizedlist>
        
        <para>The Ceylon parser is able to unambiguously identify which namespace an 
        identifier belongs to.</para>
        
    </section>
      
    <section id="type">
        <title>Types</title>
    
        <para>A <emphasis>type</emphasis> or <emphasis>type schema</emphasis> is name 
        (an initial uppercase identifier) and an optional list of type parameters, with 
        a set of:</para>
        
        <itemizedlist>
            <listitem>
                <para>attribute schemas,</para>
            </listitem>
            <listitem>
                <para>method schemas, and</para>
            </listitem>
            <listitem>
                <para>class schemas.</para>
            </listitem>
        </itemizedlist>
        
        <para>The attribute, method, and class schemas are called the 
        <emphasis>members</emphasis> of the type.</para>
        
        <para>Speaking formally:</para>
        
        <itemizedlist>
            <listitem>
                <para>An <emphasis>attribute schema</emphasis> is a name (an initial 
                lowercase identifier) with a type and mutability.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>method schema</emphasis> is a name (an initial lowercase 
                identifier) and an optional list of type parameters, with a type (often 
                called the <emphasis>return type</emphasis>) and a list of one or more 
                parameter lists.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>class schema</emphasis> is a type schema with a 
                parameter list.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>parameter list</emphasis> is a list of names (initial 
                lowercase identifiers) with types. The <emphasis>signature</emphasis> of 
                a parameter list is formed by discarding the names, leaving the list of 
                types.</para>
            </listitem>
        </itemizedlist>
        
        <para>Speaking slightly less formally, we usually refer to an attribute, method, or 
        member class of a type, meaning an attribute schema, method schema or class schema
        that is a member of the type.</para>
        
        <section id="memberdistinctness">
            <title>Member distinctness</title>
        
        <!--
        <para>The <emphasis>erased signature</emphasis> of a method or class is formed by:</para>
        
        <itemizedlist>
            <listitem>
                <para>taking the signature of the parameter list of the member class, or of 
                the first parameter list of the method, and</para>
            </listitem>
            <listitem>
                <para>replacing each occurrence of any type alias in the signature with the
                aliased type, and</para>
            </listitem>
            <listitem>
                <para>replacing each occurrence of <literal>Optional&lt;T&gt;</literal> in 
                the signature with <literal>T</literal>, and</para>
            </listitem>
            <listitem>
                <para>replacing each occurrence of any type parameter in the signature with 
                the first declared upper bound of the type parameter, or <literal>ceylon.language.Void</literal> 
                if there is no declared upper bound, and</para>
            </listitem>
            <listitem>
                <para>replacing the type of any sequenced type parameter in the signature with 
                <literal>ceylon.language.Void...</literal>, and then</para>
            </listitem>
            <listitem>
                <para>discarding the type arguments of each element of the list, leaving just 
                the name of a class or interface.</para>
            </listitem>
        </itemizedlist>
        
        <para>Two erased signatures are considered <emphasis>distinct</emphasis> if they 
        have different lengths, or if at some position within the lists, the two types are 
        non-identical.</para>
        
        <comment><para>TODO: non-identical, or non-assignable?</para></comment>
        
        <comment><para>TODO: what about sequenced parameters? what does Java do?</para></comment>
        
        <comment><para>Note: I really, really hate this stuff. Is there any way we can do 
        better than Java here?</para></comment>
        
        <comment><para>TODO: I think we should nuke all the above, and simply outlaw 
        overloading by parameter type, while retaining the ability to overload by
        arity.</para></comment>
        -->
        
        <para>A type may not have:</para>
        
        <itemizedlist>
            <listitem>
                <para>two attributes with the same name,</para>
            </listitem>
            <listitem>
                <para>a method and an attribute with the same name,</para>
            </listitem>
            <listitem>
                <para>two methods with the same name, or</para>
            </listitem>
            <listitem>
                <para>two member classes with the same name.</para>
            </listitem>
            <!--  
            <listitem>
                <para>two methods with the same name and non-distinct erased signatures, 
                or</para>
            </listitem>
            <listitem>
                <para>two member classes with the same name and non-distinct erased signatures.</para>
            </listitem>
            -->
        </itemizedlist>
        
        </section>
        
        <section id="subtyping">
            <title>Subtyping</title>
        
        <para>A type may be a <emphasis>subtype</emphasis> of another type. Subtyping obeys 
        the following rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>Identity: <literal>X</literal> is a subtype of <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>Transitivity: if <literal>X</literal> is a subtype of <literal>Y</literal>
                and <literal>Y</literal> is a subtype of <literal>Z</literal> then
                <literal>X</literal> is a subtype of <literal>Z</literal>.</para>
            </listitem>
            <!--
            <listitem>
                <para>Unions: <literal>X</literal> is a subtype of <literal>X|Y</literal> for 
                any types <literal>X</literal> and <literal>Y</literal>. Furthermore, if both 
                <literal>X</literal> and <literal>Y</literal> are subtypes of <literal>Z</literal>,
                then <literal>X|Y</literal> is also a subtype of <literal>Z</literal>.
                </para>
            </listitem>
            -->
            <listitem>
                <para>Interfaces <!--and unions--> are objects: all interfaces <!--and unions--> 
                are subtypes of <literal>ceylon.language.Object</literal>. Conversely, only 
                a subtype of <literal>ceylon.language.Object</literal> may satisfy an interface.
                <!-- or be an enumerated subtype of a union.--></para>
            </listitem>
            <listitem>
                <para>Single root: all types are subtypes of <literal>ceylon.language.Void</literal>.</para>
            </listitem>
        </itemizedlist>
        
        </section>
        
        <!--
        <section id="unions">
            <title>Unions</title>
            
            <para>For any types <literal>X</literal> and <literal>Y</literal>, a <emphasis>union</emphasis>,
            <literal>X|Y</literal>, of the types may be formed.</para>
            
            <programlisting>Union: Type ("|" Type)*</programlisting>
            
            <para>The union type constructor <literal>|</literal> is associative, so the union of 
            three types may be written <literal>X|Y|Z</literal>.</para>
            
            <para>If <literal>X</literal> and <literal>Y</literal> are both subtypes of a third type 
            <literal>Z</literal>, then <literal>X|Y</literal> inherits all members of <literal>Z</literal>.</para>
            
        </section>
        -->
        
        <section id="assignability">
            <title>Assignability</title>
        
        <para>In a certain compilation unit, a type may be <emphasis>assignable</emphasis> 
        to another type. If, in some compilation unit, <literal>X</literal> is assignable 
        to <literal>Y</literal>, then:</para>
        
        <itemizedlist>
            <listitem>
                <para>For each non-<literal>variable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has an attribute with the same name, whose type is 
                assignable to the type of the attribute of <literal>Y</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>variable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has a <literal>variable</literal> attribute with the 
                same name and the same type.</para>
            </listitem>
            <listitem>
                <para>For each method of <literal>Y</literal>, <literal>X</literal> has a 
                method with the same name, with the same number of parameter lists, with 
                the same signatures, and whose return type is assignable to the return type 
                of the method of <literal>Y</literal>.</para>
            </listitem>
            <listitem>
                <para>For each member class of <literal>Y</literal>, <literal>X</literal>
                has a member class of the same name, with a parameter list with the same 
                signature, that is assignable to the member class of <literal>Y</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Assignability obeys the following rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>Identity: <literal>X</literal> is assignable to <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>Subtyping: if <literal>Y</literal> is a subtype of <literal>X</literal> 
                then <literal>Y</literal> is assignable to <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>Transitivity: if <literal>X</literal> is assignable to <literal>Y</literal>
                and <literal>Y</literal> is assignable to <literal>Z</literal> then
                <literal>X</literal> is assignable to <literal>Z</literal>.</para>
            </listitem>
            <listitem>
                <para>Lazy evaluation: the type <literal>Gettable&lt;T&gt;</literal> is 
                assignable to <literal>T</literal> for every type <literal>T</literal>.</para>
            </listitem>
            <!--
            <listitem>
                <para>Nullsafety: the type <literal>Optional&lt;T&gt;</literal> is 
                not assignable to <literal>Object</literal>. Nor is its subtype
                <literal>Nothing</literal>.</para>
            </listitem>
            -->
        </itemizedlist>
        
        <para>A type <literal>X</literal> may be assignable to a type <literal>Y</literal>
        even if <literal>X</literal> is not a subtype of <literal>Y</literal> if there is 
        an enabled extension which introduces <literal>Y</literal> to <literal>X</literal>.</para>
        
        </section>
        
        <section id="typeofaprogramelement">
            <title>Type of a program element</title>
        
        <para>Method, attribute, and parameter declarations must declare a type.</para>
        
        <programlisting>Type: UnabbreviatedType Abbreviation*</programlisting>
        
        <para>If the type is a class or interface nested inside a containing class or 
        interface, the type must be fully qualified by its containing types, except when 
        used inside the body of a containing type.</para>
        
        <programlisting>UnabbreviatedType: TypeNameWithArguments ("." TypeNameWithArguments)* | Subtype</programlisting>
        
        <para>Unlike Java, the name of a type may not be qualified by the package name.</para>
        
        <para>Types are identified by the name of the type (a class, interface, or 
        type parameter), together with a list of type arguments if the type definition 
        specifies type parameters.</para>
        
        <programlisting>TypeNameWithArguments: TypeName TypeArguments?</programlisting>
        
        <para>If a type has type parameters or a sequenced type parameter, a type argument 
        list must be specified. If a type has no type parameters, and no sequenced type 
        parameter, no type argument list may be specified.</para>        
        
        <para>Certain declarations which usually require an explicit type may omit the type, 
        forcing the compiler to infer it, by specifying the keyword <literal>local</literal>
        where the type usually appears.</para>
        
        <programlisting>InferableType: Type | "local"</programlisting>
        
        <para>Type inference is only allowed for block local declarations. The keyword
        <literal>local</literal> may not be combined with the <literal>shared</literal>
        annotation.</para>
        
        <comment><para>TODO: should we call this keyword <literal>define</literal>, in
        case we change our minds later about using it for non-local declarations?</para></comment>
        
        <comment><para>TODO: should we let you leave off the type arguments in the type
        of a local declaration? For example <literal>Sequence names = people[].name;</literal></para></comment>
        
        </section>
        
        <section id="typenameabbreviations">
            <title>Type name abbreviations</title>
            
        <para>The following type name abbreviations are supported:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>X?</literal> means <literal>Optional&lt;X&gt;</literal> for
                any type <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para><literal>X[]</literal> means <literal>Sequence&lt;X&gt;</literal> for
                any type <literal>X</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>X[n]</literal> means <literal>BoundedSequence&lt;X,#n&gt;</literal> 
                for any type <literal>X</literal> and dimension <literal>n</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Abbreviation: "?" | "[]" | "[" dimension "]"</programlisting>
        
        <para>Abbreviations may be combined:</para>
        
        <programlisting>String?[] words = { "hello", "world", null };
String? firstWord = words[0];</programlisting>
        
        <para>When a type appears in an expression, the abbreviations <literal>X?</literal>,
        <literal>X[]</literal> and <literal>X[n]</literal> cannot be used (they cannot be 
        disambiguated from operator expressions).</para>
        
        <comment><para>TODO: It might be difficult to support <literal>T??</literal>
        since <literal>Optional</literal> is erased.</para></comment>
        
        <comment><para>TODO: Java lets you put the <literal>[]</literal> after the variable
        name. C requires that. Should we support/require this variation? It is consistent
        with how we declare functional parameters!</para></comment>
        
        </section>
        
    </section>
        
    <section id="inheritance">
        <title>Inheritance</title>
        
        <para>Subtyping is a static relationship between classes, interfaces, and type 
        parameters, produced through the use of <emphasis>inheritance</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>a class may <emphasis>extend</emphasis> another class,</para>
            </listitem>
            <listitem>
                <para>a class may <emphasis>implement</emphasis> one or more interfaces,</para>
            </listitem>
            <listitem>
                <para>an interface may <emphasis>extend</emphasis> one or more other interfaces,</para>
            </listitem>
            <!--
            <listitem>
                <para>a union may <emphasis>satisfy</emphasis> one or more interfaces,</para>
            </listitem>
            -->
            <listitem>
                <para>a type parameter may <emphasis>satisfy</emphasis> a class and/or one or 
                more interfaces or type parameters, or</para>
            </listitem>
            <listitem>
                <para>a type parameter may <emphasis>abstract</emphasis> a class, interface or 
                type parameter.</para>
            </listitem>
        </itemizedlist>
        
        <!-- 
        <comment><para>TODO: should we let an interface extend a class other than 
        <literal>Object</literal>? What this would mean is that every class that implements
        the interface, and every interface that extends the interface, would need to directly 
        or indirectly extend the given class, and the interface type would be considered
        assignable to the class. It would mean some hacking around the VM-level type system,
        unfortunately.</para></comment>
        -->
        
        <para>Ceylon visually distinguishes between a list of types which represents a
        combination (intersection) of the types, and a list of types which represents a 
        choice between (union of) the types. An intersection is written as 
        <literal>X &amp; Y &amp; Z</literal>. A union is written as 
        <literal>X | Y | Z</literal>.</para>
        
        <comment><para>Note: Ceylon does not currently support ad hoc union types and/or 
        intersection types, but this would be the syntax if we ever decided to do so.</para>
        <programlisting>void write(String|Integer|Float value) { ... }</programlisting>
        <programlisting>void store(Persistent&amp;Format&amp;IdentifiableObject object) { ... }</programlisting>
        <para>This syntax is consistent with the interpretation of these operators as set 
        intersection and union.</para></comment>
        
    <section id="extendedclass">
        <title>Extension</title>
    
        <para>A class may extend another class.</para>
        
        <programlisting>ExtendedType: "extends" Type PositionalArguments</programlisting>
    
        <para>The <literal>extends</literal> clause must specify exactly one superclass. 
        If the superclass is a parameterized type, the <literal>extends</literal> clause 
        must specify type arguments. The <literal>extends</literal> clause must specify 
        arguments for the initializer parameters of the superclass.</para>
        
        <programlisting>extends Person(name, org)</programlisting>
    
        <para>
        If a class does not explicitly specify a superclass using <literal>extends</literal>,
        its superclass is <literal>ceylon.language.BaseObject</literal>. <!--There is one exception 
        to this rule: the built-in class <literal>ceylon.language.Void</literal> which does not have 
        a superclass.-->
        </para>
        
        <para>
        The root class <literal>ceylon.language.Void</literal> does not have a superclass.
        </para>
        
        <para>Suppose <literal>X</literal> and <literal>Y</literal> are classes.</para>
    
        <itemizedlist>
        <listitem>
            <para>If <literal>X</literal> extends <literal>Y</literal>, then
            <literal>X</literal> is a subtype of <literal>Y</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X</literal> extends <literal>Y&lt;B&gt;</literal>, then
            <literal>X</literal> is a subtype of <literal>Y&lt;B&gt;</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> extends <literal>Y&lt;T&gt;</literal>, 
            then <literal>X&lt;B&gt;</literal> is a subtype of <literal>Y&lt;B&gt;</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> extends <literal>Y</literal>, 
            then <literal>X&lt;B&gt;</literal> is a subtype of <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
        <para>A user-defined class must extend <literal>ceylon.language.Object</literal>
        or one of its subclasses.</para>
        
    </section>
    
    <section id="satisfiedinterfaces">
        <title>Satisfaction</title>
    
        <para>A class may implement one or more interfaces. An interface may extend one
        or more interfaces. <!--A union may satisfy one or more interfaces.--> A type 
        parameter may satisfy one or more interfaces and, optionally, a class.</para>
        
        <programlisting>SatisfiedTypes: "satisfies" Type ("&amp;" Type)*</programlisting>
    
        <para>The <literal>satisfies</literal> clause may specify multiple types. If 
        a satisfied type is a parameterized type, the <literal>satisfies</literal> clause 
        must specify type arguments.</para>
        
        <programlisting>satisfies T[] &amp; Collection&lt;T&gt;</programlisting>
        
        <para>Suppose <literal>Y</literal> is an interface and <literal>X</literal> is
        a class or interface.</para>
    
        <itemizedlist>
        <listitem>
            <para>If <literal>X</literal> satisfies <literal>Y</literal>, then
            <literal>X</literal> is a subtype of <literal>Y</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X</literal> satisfies <literal>Y&lt;B&gt;</literal>, then
            <literal>X</literal> is a subtype of <literal>Y&lt;B&gt;</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> satisfies <literal>Y&lt;T&gt;</literal>, 
            then <literal>X&lt;B&gt;</literal> is a subtype of <literal>Y&lt;B&gt;</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> satisfies <literal>Y</literal>, 
            then <literal>X&lt;B&gt;</literal> is a subtype of <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
        <!--
        <comment><para>TODO: We could let a class or interface conditionally implement or 
        extend an interface, called a <emphasis>conditional supertype</emphasis>, depending 
        upon the argument of a type parameter.</para>
        
        <programlisting>ConditionalTypes: SatisfiedTypes Conditions</programlisting>
        
        <programlisting>Conditions: "if" "(" Condition ("&amp;&amp;" Condition)* ")"</programlisting>
        
        <para>A <emphasis>condition</emphasis> would be a list of upper bounds and metatype
        bounds applying to a type parameter of the class of interface.</para>
        
        <programlisting>Condition: TypeName (Metatypes SatisfiedTypes? | SatisfiedTypes)</programlisting>
        
        <para>The type parameter must be a covariant or nonvariant type parameter of
        the class or interface.</para>
        
        <programlisting>satisfies SequenceEquality&lt;T&gt; if (T satisfies Equality&lt;T&gt;)</programlisting>
        
        <para>Then a produced type for the class or interface would be a subtype of the
        conditional supertype if the type arguments satisfy the bounds specified by the 
        condition.</para>
        
        <programlisting><![CDATA[shared interface Sequence<out T>
        satisfies Iterable<T> &
                  Category &
                  Correspondence<Natural,T> & 
                  Sized
        satisfies ElementwiseEquality 
                  if (T satisfies Equality<IdentifiableObject>) {        
    ... 
}

shared interface ElementwiseEquality
        satisfies Equality<Sequence<IdentifiableObject>> &
                  Correspondence<Natural,IdentifiableObject> & 
                  Sized
        given T satisfies Equality<IdentifiableObject> {

    shared actual Boolean equals(Sequence<IdentifiableObject> that) {
        if (this.size!=that.size) { return false; }
        for (Integer i in 0..size-1) {
            if (this[i]!=that[i]) { return false; }
        }
        fail {
            return true;
        }
    }

    shared actual Integer hash {
        Integer h:=0;
        for (Integer i in 0..size-1) {
            h^=this[i].hash;
        }
        return h;
    }
      
}]]></programlisting>
        
        <para>An even more flexible form of this, which allows "conditional members",
        would allow the following simplification to the above example:</para>
        <programlisting><![CDATA[shared interface Sequence<out T>
        satisfies Iterable<T> &
                  Category &
                  Correspondence<Natural,T> & 
                  Sized
        satisfies Equality<Sequence<IdentifiableObject>> 
                  if (T satisfies Equality<IdentifiableObject>) {        
    ... 

    shared actual Boolean equals(Sequence<IdentifiableObject> that) 
            if (T satisfies Equality<IdentifiableObject>) {
        if (this.size!=that.size) { return false; }
        for (Integer i in 0..size-1) {
            if (this[i]!=that[i]) { return false; }
        }
        fail {
            return true;
        }
    }

    shared actual Integer hash 
            if (T satisfies Equality<IdentifiableObject>) {
        Integer h:=0;
        for (Integer i in 0..size-1) {
            h^=this[i].hash;
        }
        return h;
    }
      
}]]></programlisting>
        </comment>
        -->
        
    </section>
    
    <section id="cases">
        <title>Cases</title>
        
        <para>An interface or <literal>abstract</literal> class may optionally 
        specify an enumerated list of all its subtypes.<!--A union must specify an 
        enumerated list of its subtypes.--></para>
        
        <para>Likewise, a type parameter may specify an enumerated list of all
        types which it accepts as a type argument.</para>
    
        <programlisting>CaseTypes: "of" CaseType ("|" CaseType)*</programlisting>
        
        <para>The <literal>of</literal> clause may specify multiple types, called
        <emphasis>cases</emphasis>.</para>
        
        <programlisting>CaseType: MemberName | Type</programlisting>
        
        <para>Each case is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a subtype of the interface or <literal>abstract</literal> 
                class, or</para>
            </listitem>
            <listitem>
                <para>the name specified in the <literal>object</literal> 
                declaration of a toplevel anonymous class that extends 
                <literal>ceylon.language.Case</literal> and is a subtype of the 
                interface or <literal>abstract</literal> class.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>of larger | smaller | equal</programlisting>
        
        <programlisting>of Root&lt;T&gt; | Leaf&lt;T&gt; | Branch&lt;T&gt;</programlisting>
        
        <para>An explicit list of cases allows safe use of a type in a 
        <literal>switch</literal> statement. The compiler is able to validate that 
        the <literal>switch</literal> contains an exhaustive list of all cases of 
        the type.</para>
        
        <para>Therefore, the <literal>of</literal> declaration is used to simulate 
        enumerated types and algebraic datatypes.</para>
        
        <itemizedlist>
            <listitem>
                 <para>A <emphasis>simple algebraic datatype</emphasis> is a 
                 parameterized type <literal>A&lt;T&gt;</literal> with a list 
                 of cases where every case <literal>C&lt;T&gt;</literal> is 
                 parameterized by <literal>T</literal> and for every possible type 
                 argument <literal>X</literal> satisfying the constraints on 
                 <literal>T</literal> declared by <literal>A</literal>, 
                 <literal>C&lt;X&gt;</literal> is a legal produced type where 
                 <literal>X</literal> also satisfies the constraints on 
                 <literal>T</literal> declared by <literal>C</literal> and the
                 produced type <literal>C&lt;X&gt;</literal> is assignable to 
                 the produced type <literal>A&lt;X&gt;</literal>.</para>
            </listitem>
            <listitem>
                 <para>A <emphasis>generalized algebraic datatype</emphasis> is a 
                 parameterized type <literal>A&lt;T&gt;</literal> with a list 
                 of cases where either (a) at least one case is not parameterized 
                 by <literal>T</literal>&mdash;and is therefore assignable to 
                 <literal>A&lt;Y&gt;</literal> only for some values of the type 
                 argument <literal>Y</literal>, or (b) for at least one case
                 <literal>C&lt;X&gt;</literal> there is a type argument 
                 <literal>X</literal> satisfying the constraints on 
                 <literal>T</literal> declared by <literal>A</literal> where 
                 <literal>C&lt;X&gt;</literal> is not a legal produced type 
                 since <literal>X</literal> does not satisfy a constraint on 
                 <literal>T</literal> declared by <literal>C</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>NOTE: Support for generalized algebraic datatypes is a 
        proposed feature for a future version of the language.</para></comment>
        
        <para>Given a parameterized type <literal>A&lt;T&gt;</literal>, a case 
        <literal>C&lt;T&gt;</literal> of <literal>A&lt;T&gt;</literal>, and a
        type argument <literal>X</literal> of <literal>T</literal>, we say that 
        <literal>C&lt;X&gt;</literal> is the <emphasis>produced case</emphasis> 
        of the produced type <literal>A&lt;X&gt;</literal>.</para>
        
        <para>The cases of a produced type <literal>A&lt;X&gt;</literal> 
        for a simple algebraic datatype <literal>A&lt;T&gt;</literal> and a type 
        argument <literal>X</literal> include exactly every produced case 
        <literal>C&lt;X&gt;</literal> for a case <literal>C&lt;T&gt;</literal> 
        of <literal>A&lt;T&gt;</literal>. Therefore, for every case of the simple 
        algebraic datatype <literal>A&lt;T&gt;</literal>, there is a corresponding 
        produced case of <literal>A&lt;X&gt;</literal>.</para>
        
        <para>On the other hand, the cases of a produced type <literal>A&lt;X&gt;</literal> 
        for a generalized algebraic datatype <literal>A&lt;T&gt;</literal> and a 
        type argument <literal>X</literal> include only the following:</para>
        
        <itemizedlist>
            <listitem>
                <para>every case <literal>C</literal> of <literal>A&lt;T&gt;</literal> 
                which is not parameterized by <literal>T</literal> and which is 
                assignable to <literal>A&lt;X&gt;</literal>, and</para>
            </listitem>
            <listitem>
                <para>every produced case <literal>C&lt;X&gt;</literal> for a
                case <literal>C&lt;T&gt;</literal> of <literal>A&lt;T&gt;</literal>
                which is a legal produced type where <literal>X</literal> satisfies
                all constraints on <literal>T</literal> declared by <literal>C</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>Therefore, for a given case of the generalized algebraic datatype 
        <literal>A&lt;T&gt;</literal>, there may be no corresponding case of 
        <literal>A&lt;X&gt;</literal>. In the extreme case that there is exactly 
        one case of the produced type <literal>A&lt;X&gt;</literal>, the compiler 
        treats the type <literal>A&lt;X&gt;</literal> as a type alias of that 
        unique case. Hence, <literal>A&lt;X&gt;</literal> may have members that
        are not part of the parameterized type schema <literal>A&lt;T&gt;</literal>.</para>
        
        <para>In the following example, the generalized algebraic datatype has 
        more than one case for each value of <literal>T</literal>:</para>
        
        <programlisting><![CDATA[interface Expression<T> 
        of Constant<T> | Sum | Product | Conjunction | Disjunction
        given T of Number | Boolean { ... }
        
class Constant<T>(T value) 
        extends Case($value)
        satisfies Expression<T> 
        given T of Number | Boolean { ... }

class Sum(Expression<Number>... terms) 
        satisfies Expression<Number> { ... }
class Product(Expression<Number>... terms) 
        satisfies Expression<Number> { ... }

class Conjunction(Expression<Boolean>... terms) 
        satisfies Expression<Boolean> { ... }
class Disjunction(Expression<Boolean>... terms) 
        satisfies Expression<Boolean> { ... }]]></programlisting>
        
        <para>Then <literal>Expression&lt;Number&gt;</literal> has the cases
        <literal>Sum</literal>, <literal>Product</literal> and 
        <literal>Constant&lt;Number&gt;</literal>, but 
        <literal>Expression&lt;Boolean&gt;</literal> has the cases
        <literal>Conjunction</literal>, <literal>Disjunction</literal> and 
        <literal>Constant&lt;Number&gt;</literal>.</para>
        
        <!--
        <para>The key here is that not every case listed in the <literal>of</literal>
        clause is valid for every possible value of the type parameter <literal>T</literal>. 
        Indeed, some cases do not even mention <literal>T</literal>, thus limiting 
        the case to exactly one possible value of <literal>T</literal>. This, the
        list of cases in a <literal>switch</literal> will depend upon the exact
        type argument to <literal>T</literal>.</para>
        
        <para>However, initially we can support only enumerated types and plain
        old algebraic datatypes, simply by imposing the restriction that each case
        must include all the type parameters of the type.</para>
        
        <para>We can even use this as the basis for a kind of "conditional"
        subtyping:</para>
        -->
        
        <para>In this example, the generalized algebraic datatype has exactly 
        one case for each value of <literal>T</literal>:</para>
        
        <programlisting><![CDATA[interface Expression<T>
        of NumericExpression<T> | BooleanExpression | StringExpression
        given T of Number | Boolean | String { ... }
        
class NumericExpression<T>
        satisfies Expression<T>
        given T satisfies Number { ... }

class BooleanExpression
        satisfies Expression<Boolean> { ... }

class StringExpression
        satisfies Expression<String> { 
    shared StringExpression uppercase { ... }
    shared StringExpression lowercase { ... }
    ...
}]]></programlisting>
        
        <para>Then the type <literal>Expression&lt;String&gt;</literal> has the
        attributes <literal>uppercase</literal> and <literal>lowercase</literal>,
        even though the parameterized type <literal>Expression&lt;T&gt;</literal>
        does not declare these members.</para>
        
        <!--  
        <para>The compiler could reason that every <literal>Expression&lt;Integer&gt;</literal>
        is actually a <literal>NumericExpression&lt;Integer&gt;</literal>, that
        every <literal>Expression&lt;Boolean&gt;</literal> is actually a
        <literal>BooleanExpression</literal> without the need for explicit mention
        of the subtype.</para>
        -->
        
        <comment>
        <para>TODO: Actually, a potentially better syntax for GADTs would make the 
        conditions explicit:</para>
        
        <programlisting><![CDATA[interface Expression<T> 
        of Constant<Number> | Sum | Product 
                if (T satisfies Number)
        of Constant<Boolean> | Conjunction | Disjunction 
                if (T satisfies Boolean)
        given T of Number | Boolean { ... }]]></programlisting>
        </comment>
        
    </section>
    
    <section id="metatypes">
        <title>Metatypes</title>
        
        <comment><para>NOTE: Metatypes are a proposed feature for a future version 
        of the language.</para></comment>
        
        <para>A class or interface may optionally specify a list of 
        <emphasis>metatypes</emphasis>, interfaces implemented by the concrete
        metatype of the type. The metatypes may not define <literal>formal</literal> 
        members.</para>
        
        <para>Similarly, a type constraint may specify a list of types which 
        must be supertypes of the metatype of the type argument.</para>
        
        <programlisting>Metatypes: "is" Type ("&amp;" Type)*</programlisting>
        
        <para>The concrete metatype of a type <literal>T</literal> is the concrete 
        class of the object to which the expression <literal>T</literal> evaluates.
        The name of this class is not specified here.</para>
        
        <programlisting>is Monoid&lt;T&gt;</programlisting>
        
        <para>Metatypes allow a function to operate polymorphically over the 
        metamodel object that represents a type. For example, a library could
        define the following generic functionality:</para>
        
        <programlisting><![CDATA[shared interface Joinable<S> {
    shared formal S empty;
    shared formal S join(S x, S y); 
}

shared S join<S>(S... sequences)
        given S is Joinable<S> {
    S result := S.empty;
    for (S s in sequences) {
        result := S.join(result,s);
    }
    return result;
}]]></programlisting>

        <para>Which could be utilized as follows:</para>

<programlisting><![CDATA[shared interface JoinableLinkedList<T> 
        satisfies Joinable<LinkedList<T>> {
    shared actual LinkedList<T> empty = LinkedList<T>();
    shared actual LinkedList<T> join(LinkedList<T> x, LinkedList<T> y) {
        return x.append(y);
    }
}

shared class LinkedList<T>(T... elements) 
        is JoinableLinkedList<T> 
        satisfies T[] { ... }]]></programlisting>
        
    </section>
        
    </section>

    <section id="generictypeparameters">
        <title>Generic type parameters</title>
    
        <para>Methods, classes, interfaces, and type parameters may declare one or more generic 
        type parameters.</para>
        
        <programlisting>TypeParams: "&lt;" (TypeParam ",")* (TypeParam | SequencedTypeParam) "&gt;"</programlisting>
        
        <para>A declaration with type parameters is called <emphasis>generic</emphasis> or
        <emphasis>parameterized</emphasis>.</para>
        
        <itemizedlist>
        <listitem>
            <para>A type declaration with no type parameters defines exactly one type. A 
            parameterized type declaration defines a template for producing types: one type 
            for each possible combination of type arguments that satisfy the type constraints 
            specified by the type. The types of members of the this type are determined by 
            replacing every appearance of each type parameter in the schema of the 
            parameterized type definition with its type argument.</para>
        </listitem>
        <listitem>
            <para>A method declaration with no type parameters defines exactly one operation 
            per type. A parameterized method declaration defines a template for producing
            overloaded operations: one operation for each possible combination of type arguments 
            that satisfy the type constraints specified by the method declaration.</para>
        </listitem>
        <listitem>
            <para>A class declaration with no type parameters defines exactly one instantiation 
            operation. A parameterized class declaration defines a template for producing 
            overloaded instantiation operations: one instantiation operation for each possible 
            combination of type arguments that satisfy the type constraints specified by the 
            class declaration. The type of the object produced by an instantiation operation is 
            determined by substituting the same combination of type arguments for the type 
            parameters of the parameterized class.</para>
        </listitem>
        </itemizedlist>
        
        <!--
        <para>There are two kinds of type parameter:</para>
        
        <itemizedlist>
        <listitem>
            <para>an <emphasis>ordinary type parameter</emphasis> parameterizes the type by some
            other type, and</para>
        </listitem>
        <listitem>
            <para>a <emphasis>dimensional type parameter</emphasis> parameterizes the type by a
            natural number.</para>
        </listitem>
        </itemizedlist>
        -->
                
        <section id="typeparametersandvariance">
            <title>Type parameters and variance</title>
        
        <para>A type parameter allows a declaration to be abstracted over a constrained set of 
        types.</para>
        
        <para>Each type parameter has a name and a specified <emphasis>variance</emphasis>.</para>
        
        <programlisting>TypeParam: Variance TypeName</programlisting>
        
        <para>Within the body of the declaration it parameterizes, an ordinary type parameter is 
        itself a type. The type parameter is a subtype of every upper bound of the type parameter. 
        However, a class or interface may not extend or implement a type parameter.</para>
        
        <para>A <emphasis>covariant</emphasis> type parameter is indicated using <literal>out</literal>.
        A <emphasis>contravariant</emphasis> type parameter is indicated using <literal>in</literal>.</para>
        
        <programlisting>Variance:  ("out" | "in")?</programlisting>
        
        <para>A type parameter declared neither <literal>out</literal> nor <literal>in</literal> 
        is called <emphasis>nonvariant</emphasis>.</para>
        
        <programlisting>Map&lt;K, V&gt;</programlisting>
        
        <programlisting>Sender&lt;in M&gt;</programlisting>
        
        <programlisting>Container&lt;out T&gt;</programlisting>
        
        <programlisting>BinaryFunction&lt;in X, in Y, out R&gt;</programlisting>
        
        <comment><para>TODO: Would <literal>produces</literal> and <literal>consumes</literal> 
        be better?</para></comment>
        
        <para>A covariant type parameter may only appear in covariant positions of the type 
        definition. A contravariant type parameter may only appear in contravariant positions 
        of the type definition. Nonvariant type parameters may appear in any position.</para>
        
        <itemizedlist>
            <listitem>
                <para>The return type of a method is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A parameter type of a method is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A type parameter of a method is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A parameter type of a nested class initializer is a contravariant 
                position.</para>
            </listitem>
            <listitem>
                <para>A type parameter of a nested class is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>The type of a non-<literal>variable</literal> attribute is a covariant 
                position.</para>
            </listitem>
            <listitem>
                <para>The type of a <literal>variable</literal> attribute is a nonvariant 
                position.</para>
            </listitem>
            <listitem>
                <para>An upper bound of a type parameter in a contravariant position is a 
                contravariant position.</para>
            </listitem>
            <listitem>
                <para>An upper bound of a type parameter in a covariant position is a covariant 
                position.</para>
            </listitem>
            <listitem>
                <para>A lower bound of a type parameter in a contravariant position is a 
                covariant position.</para>
            </listitem>
            <listitem>
                <para>A type parameter in a covariant position cannot have a lower bound. 
                <comment>TODO: is this correct?</comment></para>
            </listitem>
            <listitem>
                <para>A covariant type argument of a satisfied or extended type is a covariant 
                position.</para>
            </listitem>
            <listitem>
                <para>A contravariant type argument of a satisfied or extended type is a 
                contravariant position.</para>
            </listitem>
            <listitem>
                <para>A covariant type argument of a type in a covariant position is a covariant 
                position.</para>
            </listitem>
            <listitem>
                <para>A contravariant type argument of a type in a covariant position is a 
                contravariant position.</para>
            </listitem>
            <listitem>
                <para>A covariant type argument of a type in a contravariant position is a 
                contravariant position.</para>
            </listitem>
            <listitem>
                <para>A contravariant type argument of a type in a contravariant position is a 
                covariant position.</para>
            </listitem>
            <listitem>
                <para>A nonvariant type argument of a type is a nonvariant position.</para>
            </listitem>
            <listitem>
                <para>A parameter of a callable parameter in a contravariant position is 
                covariant.</para>
            </listitem>
            <listitem>
                <para>A parameter of a callable parameter in a covariant position is 
                contravariant.</para>
            </listitem>
            <listitem>
                <para>The return type of a callable parameter in a contravariant position is 
                contravariant.</para>
            </listitem>
            <listitem>
                <para>The return type of a callable parameter in a covariant position is
                covariant.</para>
            </listitem>
        </itemizedlist>
        
        <para>These rules apply to members declared by the type, and to members inherited from 
        supertypes.</para>
        
        <comment><para>TODO: when working with contravariant type parameters, it would be
        really nice to have a special <literal>bottom</literal> type, defined as the 
        intersection of all types. Then, for example, <literal>Sender&lt;bottom&gt;</literal>
        would be a supertype of <literal>Sender&lt;X&gt;</literal> for every 
        type argument <literal>X</literal>.</para></comment>
        
        </section>
        
        <section id="sequencedtypeparameters">
            <title>Sequenced type parameters</title>
        
        <para>A <emphasis>sequenced type parameter</emphasis> allows a declaration to be 
        abstracted over a variable length list of arbitrary types. This allows declarations 
        with parameter lists to be represented by metamodel objects within the 
        language.</para>
        
        <para>A sequenced type parameter is identified by an elipsis <literal>...</literal>,
        indicating that it accepts a list of zero or more type arguments.</para>
        
        <programlisting>SequencedTypeParam: TypeName "..."</programlisting>
        
        <para>Sequenced type parameters are always non-variant.</para>
        
        <programlisting>Type&lt;X, P...&gt;</programlisting>
        <programlisting>Method&lt;X, T, P...&gt;</programlisting>
        <programlisting>Tuple&lt;P...&gt;</programlisting>
        
        <para>Inside the declaration of the parameterized type or method, a sequenced type 
        parameter may be used as a type argument to other types which accept a sequenced 
        type parameter, or it may be used as the type of the last parameter declared by a 
        parameter list. It may not appear in any other position. The sequenced type 
        parameter acts as a pseudo-type. It is treated by the Ceylon compiler as if it were 
        a type with no members, to which no other type may be assigned, and which can only 
        by assigned to itself.</para>
        
        <comment><para>TODO: Should we let you declare a covariant sequenced type parameter?
        This is useful for modelling tuples. Should we allow you to declare a contravariant
        sequenced type parameter, and say that method parameter types are contravariant?</para></comment>
        
        <comment><para>TODO: should we let you write things like:</para>
        <programlisting>class Foo&lt;P...&gt;(Tuple&lt;Bar&lt;P&gt;...&gt; barTup) {
    ...
    void baz(Baz&lt;P&gt;... bazs) {
        ...
    }
}</programlisting>
        <para>It's probably only really useful if we also let you do stuff like this:</para>
        <programlisting><![CDATA[List<T> zip<T,P...>(List<P>... x, T producing(P... args)) {
    return from (Natural i in 0..min(x.lastIndex...)) select (f(x[i]...));
}]]></programlisting></comment>

        </section>
        
    <section id="generictypeconstraints">
    <title>Generic type constraints</title>

        <para>A parameterized method, class, or interface declaration may declare constraints 
        upon ordinary type parameters using the <literal>given</literal> clause.</para>
        
        <programlisting>TypeConstraints: TypeConstraint+</programlisting>
        
        <para>There may be at most one <literal>given</literal> clause per type parameter.</para>
        
        <programlisting>TypeConstraint: "given" TypeName TypeParams? Params? TypeConstraintInheritance</programlisting>
        
        <programlisting>TypeConstraintInheritance: CaseTypes? Metatypes? SatisfiedTypes? AbstractedType?</programlisting>
        
        <programlisting>AbstractedType: "abstracts" Type</programlisting>
        
        <para>Note that the syntax for a type constraint is essentially the same syntax used 
        for other type declarations such as class and interface declarations.</para>
        
        <para>There are five kinds of type constraint:</para>
        
        <itemizedlist>
            <listitem>
                <para>an <emphasis>upper bound</emphasis>, <literal>given X satisfies T</literal>, 
                specifies that the type parameter <literal>X</literal> is a subtype of a 
                given type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>a <emphasis>lower bound</emphasis>, <literal>given X abstracts T</literal>, 
                specifies that a given type <literal>T</literal> is a subtype of the type 
                parameter <literal>X</literal>,</para>
            </listitem>
            <!--listitem>
                <para>a subtype bound, <literal>X = subtype</literal>, specifies that 
                the type parameter <literal>X</literal> represents the concrete type
                of the current instance, and</para>
            </listitem-->
            <listitem>
                <para>an <emphasis>enumerated bound</emphasis>, <literal>given X of T | U | V</literal>
                specifies that the type parameter <literal>X</literal> represents one of 
                the enumerated types,</para>
            </listitem>
            <listitem>
                <para>a <emphasis>metatype bound</emphasis>, <literal>given X is T</literal>, 
                specifies that the concrete metatype of the type parameter is a subtype of 
                a given type <literal>T</literal> <emphasis>(note that metatypes are a 
                proposed feature for a future version of the language)</emphasis>, and</para>
            </listitem>
            <listitem>
                <para>an <emphasis>initialization parameter specification</emphasis>, 
                <literal>given X(...)</literal> specifies that the type parameter 
                <literal>X</literal> is a class with the given parameter types.</para>
            </listitem>
        </itemizedlist>
        
        <para>A constraint may not refer to a sequenced type parameter.</para>
        
        <para>A single <literal>given</literal> clause may specify multiple constraints
        on a certain type parameter. For example, it may specify multiple upper bounds
        together with an initialization parameter specification. If multiple upper bounds
        are specified, at most one upper bound may be a class.</para>
        
        <programlisting>given T(Natural n) satisfies IdentifiableObject &amp; Comparable&lt;T&gt;</programlisting>
        
        <programlisting>given X satisfies Number&lt;X&gt;
given Y(Natural count) satisfies Number&lt;Y&gt;</programlisting>
       
        <programlisting>given S satisfies BoundedSequence&lt;Decimal,N&gt;</programlisting>

        <programlisting>given T satisfies Ordinal &amp; Comparable&lt;T&gt; abstracts X</programlisting>
        
        <programlisting>given N is Monoid&lt;N&gt;</programlisting>
        
        <programlisting>given T of String | Natural | Integer | Float</programlisting>
        
        <para>An initialization parameter specification allows instantiation of the type 
        represented by the type parameter within the body of the declaration.</para>
        
        <programlisting><![CDATA[T create<T>(Object object) 
        given T(String s) { 
    return T(object.string.lowercase);
}]]></programlisting>
        
        <para>An enumerated bound allows the use of an exhaustive <literal>switch</literal>
        with expressions of the parameter type.</para>
        
        <programlisting><![CDATA[T uppercase<T>(T t) 
        given T of String | Range<Character> { 
    switch (T)
    case (satisfies String) { 
        return t.uppercase;
    }
    case (satisfies Range<Character>) { 
        return t.first.uppercase..t.last.uppercase;
    }
}]]></programlisting>
        
        <!--
        <para>Subtype bounds are needed since the special type <literal>subtype</literal>
        cannot appear in a contravariant position. A subtype bound cannot be applied to
        a covariant or contravariant type parameter.</para>
        -->
        
        <para>A constraint affects the type arguments that can be assigned to a type
        parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type argument to a type parameter with an upper bound must be a 
                type which is a subtype of all upper bounds.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with a lower bound must be a type 
                of which all lower bounds are subtypes.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with an enumerated type bound must 
                be a subtype of one of the enumerated types, or a type with an enumerated 
                subtype list that is a subset of the enumerated types of the constraint.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with a metatype bound must have 
                a metatype assignable to all metatype bounds.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with an initialization parameter
                specification must be a class with the given initialization parameter
                types.</para>
            </listitem>
        </itemizedlist>
        
        <para>Within the body of the declaration, a constraint affects the assignability of 
        a type parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type parameter is considered a subtype of its upper bound.</para>
            </listitem>
            <listitem>
                <para>The lower bound of a type parameter is considered a subtype of the
                type parameter.</para>
            </listitem>
            <listitem>
                <para>A metamodel reference to the type parameter is assignable to the
                metatype bound.</para>
            </listitem>
            <listitem>
                <para>A type parameter is considered a supertype of its enumerated type
                bounds.</para>
            </listitem>
        </itemizedlist>
        
        <para>Every type parameter has an implicit upper bound of type <literal>Void</literal>.</para>
        
        <!--  
        <comment><para>TODO: eventually we should support the ability to implicitly pass in an
        extension that is imported by the client code, using a type constraint of form:</para>
        <programlisting>given extension E(X x) satisfies Format</programlisting>
        <para>(We would need to define an identity extension in <literal>ceylon.language</literal>.)</para>
        <para>In the following special case, this lets us implement a Haskell-style type class 
        as an extension of the metatype:</para>
        <programlisting>given extension E(Type&lt;X&gt; tx) satisfies Monoid&lt;X&gt;</programlisting>
        <para>The extension type would be inferred at the point of invocation, using the usual
        rules for searching for extensions.</para>
        </comment>
        -->
        
        <!-- 
        <comment><para>TODO: at some stage it would be very interesting to support "assignability
        upper bounds", for example <literal>given X is String</literal>, where the client code is
        required to have an enabled extension that introduces the bound <literal>String</literal>
        to the type parameter <literal>X</literal>. Under the covers this extension would be passed
        as a <literal>Callable&lt;String,X&gt;</literal> to the initializer or method that declares 
        the constrained type parameter. Scala calls this feature "view bounds".</para></comment>
        -->
        
        <para>Note that an upper bound type constraint of form:</para>
        
        <programlisting>given X satisfies T</programlisting>
        
        <para>is equivalent to a metatype bound of this form:</para>
        
        <programlisting>given X is Type&lt;T&gt;</programlisting>
        
        <para>and that an initialization parameter specification type constraint of form:</para>
        
        <programlisting>given X(A a, B b)</programlisting>
        
        <para>is equivalent to a metatype bound of this form:</para>
        
        <programlisting>given X is Callable&lt;X,A,B&gt;</programlisting>
        
        <comment><para>TODO: Should we let you declare a constraint for a sequenced type 
        parameter?</para>
        <programlisting>class Foo&lt;P...&gt;(P... args) 
        given P satisfies Comparable&lt;P&gt; {
    ...
}</programlisting></comment>

        <comment><para>TODO: Should we inherit generic type constraints from supertypes, 
        like in C#, or require them to be re-declared, like in Java?</para></comment>
        
    </section>
    
       <section id="thesubtypekeyword">
            <title>The <literal>subtype</literal> keyword</title>
            
        <para>The keyword <literal>subtype</literal> is used to refer to the runtime 
        type of an object.</para>
            
        <programlisting>Subtype: "subtype" | ParameterName "." "subtype"</programlisting>
        
        <para>Every class or interface has an implicit type parameter that never needs 
        to be declared. This special type parameter, referred to using the keyword 
        <literal>subtype</literal>, represents the runtime type of the current instance 
        (the instance that is being invoked). It is considered a covariant type parameter
        of the type, and may only appear in covariant positions of the type definition.
        It is upper bounded by the type (and is therefore assignable to the type).</para>
        
        <programlisting><![CDATA[shared interface Wrapper<out X> {}]]></programlisting>
        
        <programlisting><![CDATA[shared abstract class Wrappable() {
   shared Wrapper<subtype> wrap() {
       return Wrapper(this);
   }
}]]></programlisting>
        
        <programlisting><![CDATA[shared class Special() extends Wrappable() {}]]></programlisting>

        <programlisting><![CDATA[Special special = Special();
Wrapper<Special> wrapper = special.wrap();]]></programlisting>

        <para>The only expression assignable to the type <literal>subtype</literal> is
        the special value <literal>this</literal>, except inside the body of a method or
        attribute annotated <literal>definite</literal>, where the class that declares 
        the method or attribute is assignable to <literal>subtype</literal>. 
        <emphasis>(Note that <literal>definite</literal> is a proposed feature for a 
        future version of the language.)</emphasis></para>
        
        <para>Every method has an implicit type parameter for each parameter of the
        method. For a method parameter <literal>x</literal>, the type parameter is
        referred to using the syntax <literal>x.subtype</literal>. This special type
        parameter represents the runtime type of the argument to the given parameter
        when the method is invoked. It is upper bounded by the declared type of the
        parameter (and is therefore assignable to the parameter type).</para>
        
        <programlisting><![CDATA[Entry<Name,x.subtype> named(String name, Object x) {
    return Name(name) -> x;
}]]></programlisting>
        
        <programlisting><![CDATA[Person gavin = Person("Gavin");
Entry<Name,Person> entry = named(gavin.name, gavin);]]></programlisting>
        
        <para>The only expression assignable to the type <literal>x.subtype</literal> 
        is the parameter <literal>x</literal> itself.</para>
        
        <comment><para>TODO: Should we allow you to refer to the concrete type of a
        refining member class in a subclass of the current class using the syntax
        <literal>subtype.MemberClass</literal>, to which the expression 
        <literal>MemberClass(...)</literal> is assignable? And/or the concrete type of 
        the containing class of a subtype of the current member class, using the syntax
        <literal>outer.subtype</literal>, to which <literal>outer</literal> is 
        assignable? Both would be considered implicit covariant type parameters.</para></comment>
        
        <comment><para>TODO: Should we let you declare type constraints on 
        <literal>subtype</literal>? The only really useful case I can think of would 
        be an initialization parameter constraint: <literal>given subtype(Foo foo, Bar bar)</literal>,
        which would let you do <literal>subtype(foo, bar)</literal> to instantiate a new
        instance of the concrete subclass of the current class, getting an expression
        of type <literal>subtype</literal>. Note that <literal>given subtype satisfies Foo</literal>
        (like a Scala "self type" declaration) is really not very different to declaring 
        the type <literal>satisfies Foo</literal>. Perhaps <literal>given subtype is 
        Metatype</literal> would be useful.</para>
        </comment>
        
        <comment><para>TODO: Are metatypes constrained so that if <literal>X satisfies Y</literal> 
        then <literal>X is Y</literal>? If so, then the type of <literal>y.type</literal> 
        as currently declared is not specific enough (it should be assignable to all 
        metatypes of Y). So if we do decide to add this constraint, then we should 
        probably merge together the keyword <literal>subtype</literal> with attribute
        <literal>Object.type</literal>, and get a new keyword, <literal>type</literal>,
        which can be used as <literal>subtype</literal> is currently used, or as a
        member, <literal>x.type</literal>.</para></comment>
        
        </section>
        
    <section id="dimensionaltypeparameters">
        <title>Dimensional type parameters</title>
            
        <comment><para>NOTE: dimensional type parameters are a proposed feature for a 
        future version of the language.</para></comment>
        
        <para>A dimensional type parameter allows a declaration to be abstracted over 
        the natural numbers.</para>
        
        <para>A dimensional type parameter is distinguished by an upper bound of the
        following form:</para>
        
        <programlisting>given N satisfies Dimension</programlisting>
        
        <para>Where the type <literal>Dimension</literal> represents the natural numbers:</para>
        
        <programlisting>shared interface Dimension of Zero | Successor&lt;Nat&gt; {}
shared interface Zero satisfies Dimension {}
shared interface Successor&lt;out N&gt; satisfies Dimension given N satisfies Dimension {}</programlisting>
        
        <comment><para>TODO: should we allow more specific constraints on dimensional 
        type parameters, for example <literal>given N&gt;=#1</literal>.</para></comment>
        
        <comment><para>TODO: should we let you declare <literal>X&lt;#n&gt;</literal>
        instead of <literal>X&lt;N&gt; given N satisfies Dimension</literal>, since
        actually the <literal>n</literal> is more useful than the <literal>N</literal>
        inside the declaration.</para></comment>
        
     </section>
        
     <section id="parameterizedtypeparameters">
        <title>Parameterized type parameters</title>

        <comment><para>NOTE: Parameterized type parameters is a proposed feature for a 
        future version of the language.</para></comment>
        
        <para>A <emphasis>parameterized type parameter</emphasis> is defined using a type
        constraint of form <literal>given X&lt;T&gt;</literal>, which specifies that the 
        type parameter is itself a parameterized type.</para>
            
        <programlisting>given M&lt;T&gt;(T... elements) satisfies Iterable&lt;T&gt;</programlisting>
    
        <para>The parameters of a parameterized type parameter may themselves have 
        constraints. These constraints are be defined in the same list of type
        constraints.</para>
        
        <para>A type argument to a parameterized type parameter must be a parameterized 
        type with type parameters to which the the type parameters of the parameterized
        type parameter are assignable.</para>
        
        <para>A parameterized type parameter appears as a produced type (with type 
        arguments) in the body of the declaration.</para>
        
        <programlisting><![CDATA[R<Entry<U,V>> entry<R,U,V>(R<U> u, R<V> v) 
        given R<T>(T x) satisfies Reference<T> {
    return R(u.value->v.value);
}]]></programlisting>

        <para>Note that the argument to a parameterized type parameter is not, strictly
        speaking, a type. Rather, it is a parameterized type&mdash;a <emphasis>type
        constructor</emphasis>. For example, in the following, <literal>WeakReference</literal> 
        is viewed as a function from types <literal>T</literal> to produced types 
        <literal>WeakReference&lt;T&gt;</literal>:</para>
        
        <programlisting><![CDATA[WeakReference<Person> person = ... ;
WeakReference<Org> org = ... ;
WeakReference<Entry<Person,Org>> e = entry(person, org);  //infers X==WeakReference, U==Person, V==Org]]></programlisting>
        
        <para>Parameterized type parameters allow functions to operate generically 
        over "container" types:</para>
                
        <programlisting><![CDATA[M<U> map<M,U,V>(U function(V v), M<V> inputs)
        given M<T>() satisfies Iterable<T> & Addable<T> {
    M<U> outputs := M<U>();
    for (V input in inputs) {
        outputs.=add(function(input));
    }
    return outputs;
}]]></programlisting>

        <programlisting>Set&lt;Person&gt; people = ... ;
Set&lt;String&gt; names = map(Person.name, people);</programlisting>

        <para>This effect can not even be achieved with metatypes. Even some cases
        which can be expressed using metatypes are more elegantly expressed using
        parameterized type parameters:</para>
        
        <programlisting><![CDATA[S<T> join<S,T>(S<T>... sequences)
        given S<E>(E... es) satisfies E[] 
        given E satisfies Equality<E>
        given T satisfies Equality<T> {
    return S(joinSequences(sequences));
}]]></programlisting>
        
        <comment>
        <para>TODO: There are at least two other interesting functions which map
        types to types:</para>
        <itemizedlist>
            <listitem>
                 <para>the identity type constructor <literal>id&lt;T&gt; == T</literal>, 
                 and</para>
            </listitem>
            <listitem>
                <para>constant type constructors (non-parameterized types), for 
                example, <literal>String&lt;T&gt; == String</literal>.</para>
            </listitem>
        </itemizedlist>
        <para>Should we allow these type constructors as arguments to a 
        parameterized type parameter?</para>
        
        <programlisting><![CDATA[Comparison compare<S,T>(S<T> x, S<T> y)
        given S<X> satisfies X[] | X
        given T satisfies PartlyComparable<T> {
    switch (S<T>)
    case (T) {
        return x<=>y;
    }
    case (T[]) {
        for (local i in 0..min(x.size,y.size)) {
            Comparison c = x[i]<=>y[i];
            switch (c)
            case (larger) {
                return larger;
            }
            case (smaller) {
                return smaller;
            }
            else {
                continue;
            }
        }
        return uncomparable;
    }
}]]></programlisting>

        <para>Note that <literal>given S&lt;X&gt; satisfies X[] | X</literal> is a way of writing
        <literal>given S&lt;X&gt; satisfies X[] | id&lt;X&gt;</literal>. A second example:</para>
        
        <programlisting><![CDATA[X<T> findByKey<X,T,K>(Type<T> type, X<K> keys)
        given X<E> of E | E[]
        given K satisfies Equality<K> {
    ...
}]]></programlisting>
        <programlisting>Person p = findByKey(Person, personId);</programlisting>
        <programlisting>Order[] orders = findByKey(Order, orderIds);</programlisting>
        <programlisting><![CDATA[T[] findManyByIntegerKey<T>(Type<T> type, Integer[] keys) = findByKey<Sequence,T,Integer>;
T findSingleByIntegerKey<T>(Type<T> type, Integer key) = findByKey<id,T,Integer>;]]></programlisting>
<para>Or we could keep it simple :-)</para>
        </comment>
        
    </section>
    
    </section>

    <section id="generictypearguments">
        <title>Generic type arguments</title>
            
        <para>A list of <emphasis>type arguments</emphasis> produces a new type schema 
        from a parameterized type schema, or a new method schema from a method schema 
        with type parameters.</para>
        
        <para>A type argument list is a list of types and dimensions, and an optional 
        sequenced type argument.</para>
        
        <programlisting>TypeArguments: "&lt;" (TypeArgument ",")* (TypeArgument | SequencedType) "&gt;"</programlisting>
        
        <para>A <emphasis>sequenced type argument</emphasis> is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a reference to a sequenced type parameter of the containing 
                declaration, or</para>
            </listitem>
            <listitem>
                <para>a <emphasis>sequenced type</emphasis>, which represents a 
                sequence of values of some specified type.</para>
            </listitem>
        </itemizedlist>
        
        <para>A sequenced type argument must appear last in the list of type arguments.</para>
                
        <programlisting>SequencedType: TypeName "..."</programlisting>
        
        <para>A <emphasis>type argument</emphasis> is a type or a dimension:</para>
        
        <programlisting>TypeArgument: Type | Dimension</programlisting>
        
        <para>A type argument may itself be a parameterized type or type parameter.</para>
        
        <programlisting>Map&lt;Key, List&lt;Item&gt;&gt;</programlisting>
        <programlisting>Entry&lt;String,Person?&gt;</programlisting>
        <programlisting>Stack&lt;Frame&gt;.Entry</programlisting>
        <programlisting>Callable&lt;X,T,P...&gt;</programlisting>
        <programlisting>Callable&lt;String[],Object...&gt;</programlisting>
        
        <programlisting>Vector&lt;#10&gt;</programlisting>
        <programlisting>Matrix&lt;#x,#y&gt;</programlisting>
        
        <para>Any type schema in which the special type parameter <literal>subtype</literal> 
        occurs is considered a parameterized type. Any occurrence of the type is considered 
        a produced type, where the type argument to the type parameter <literal>subtype</literal> 
        is:</para>
        
        <itemizedlist>
            <listitem>
                <para>the special type <literal>x.subtype</literal>, if the produced type 
                occurs in the declaration of a method parameter <literal>x</literal>, or</para>
            </listitem>
            <listitem>
                <para>the type itself, otherwise.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that in principle the type argument to <literal>subtype</literal> is 
        always the runtime type of the instance. However, except in the special case of
        a method argument, there is no syntax for referring to this type.</para>
        
        <para>Any method schema in which the special type parameter <literal>x.subtype</literal> 
        occurs is considered a parameterized method schema. The type argument to the type 
        parameter <literal>x.subtype</literal> is:</para>
        
        <itemizedlist>
            <listitem>
                <para>the special type <literal>y.subtype</literal>, if the argument to
                <literal>x</literal> is a method parameter <literal>y</literal>, or</para>
            </listitem>
            <listitem>
                <para>the statically determined type of the method argument, otherwise.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that in principle the type argument to <literal>x.subtype</literal> is 
        always the runtime type of the argument. However, except in the special case of
        a method argument, there is no syntax for referring to this type.</para>
        
        <comment><para>TODO: Actually, a better way to define this stuff might be to say
        that the type <literal>x.subtype</literal> is a legitimate type for any expression
        <literal>x</literal>, but then severely restrict the use of such types in declaration 
        schemas.</para></comment>
        
        <section id="dimensions">
            <title>Dimensions</title>
        
            <comment><para>NOTE: dimensional type parameters are a proposed feature
            for a future version of the language.</para></comment>
        
        <para>A <emphasis>dimension</emphasis> is an expression composed of dimensional
        type parameters, natural number literals, locals of type <literal>Natural</literal>, 
        the operators <literal>+</literal> and <literal>*</literal>, and parentheses.</para>
        
        <programlisting>Dimension: DimensionTerm ("+" DimensionTerm)*</programlisting>
        <programlisting>DimensionTerm: (DimensionConstant "*")* DimensionAtom</programlisting>
        <programlisting>DimensionAtom: DimensionConstant | DimensionVariable | ParenDimension</programlisting>
        <programlisting>ParenDimension: "(" Dimension ")"</programlisting>
        
        <para>A <emphasis>dimensional type constant</emphasis> is an expression of form
        <literal>#c</literal> where <literal>c</literal> is a natural number literal.</para>
        
        <programlisting>DimensionConstant: "#" NaturalLiteral</programlisting>
        
        <para>A <emphasis>dimensional type variable</emphasis> is a dimensional type parameter, 
        or an expression of form <literal>#n</literal> where <literal>n</literal> is a local of 
        type <literal>Natural</literal>.</para>
        
        <programlisting>DimensionVariable: TypeName | "#" MemberName</programlisting>
        
        <para>The <emphasis>canonical form</emphasis> of a dimension expression is formed
        by algebraically simplifying the expression to a dimension expression of form:</para>
        
        <programlisting>#c + #n * N + #m * M + ...</programlisting>
        
        <para>where <literal>c</literal>, <literal>n</literal>, <literal>m</literal>, 
        <literal>...</literal> are constant natural numbers and <literal>N</literal>, 
        <literal>M</literal>, <literal>...</literal> are distinct dimensional type
        variables.</para>
        
        <para>Two dimension expressions are considered <emphasis>equivalent</emphasis> if 
        they have the same canonical form, ignoring the order of terms. For example, the
        following represent the same type:</para>
        
        <programlisting>Vector&lt;#2*N+#i+#3&gt;</programlisting>
        <programlisting>Vector&lt;(N+#2)+(#i+N+#1)&gt;</programlisting>
        
        <comment><para>Note: the <literal>#</literal> symbol acts almost like an operator 
        that accepts a value of type <literal>Natural</literal>, and returns a 
        <literal>Type&lt;Dimension&gt;</literal>, where <literal>#0 == Zero</literal>,
        <literal>#1 == Successor&lt;Zero&gt;</literal>, 
        <literal>#2 == Successor&lt;Successor&lt;Zero&gt;&gt;</literal>,
        etc.</para></comment>
        
        <comment><para>Note: we will provide a function that does the opposite and obtains 
        the <literal>Natural</literal> that corresponds to a dimensional type, something
        like: 
        <programlisting>shared Natural natural&lt;N&gt;() given N satisfies Dimension { ... }</programlisting></para></comment>
        
        <comment><para>TODO: should we allow ranges as arguments to dimensional type 
        parameters, for example, <literal>Vector&lt;#0...&gt;</literal> or
        <literal>Vector&lt;#1..#10&gt;</literal>, where <literal>Vector&lt;#c&gt;</literal>
        is a subtype of <literal>Vector&lt;#m..#n&gt;</literal> if 
        <literal>m&lt;=c&lt;=n</literal>. If so, we should also allow abbreviations 
        like <literal>String[1..n]</literal> for sequences.</para></comment>
        
        </section>
                
        <section id="typeargumentconformance">
            <title>Type argument conformance</title>
        
        <para>A type argument list <emphasis>conforms</emphasis> to a type parameter list 
        if:</para>
        
        <itemizedlist>
             <listitem>
                 <para>a type argument that satisfies the constraints of the type parameter 
                 is specified for every ordinary type parameter,</para>
             </listitem>
             <listitem>
                 <para>a dimension is specified for every dimensional type parameter, and</para>
             </listitem>
             <listitem>
                 <para>if the type parameter list has no sequenced type parameter, then there
                 are no additional type arguments, and no sequenced type argument.</para>
             </listitem>
        </itemizedlist>
        
        </section>
                
        <section id="producedtypes">
            <title>Produced types and and variance</title>
            
        <para>If a type argument list conforms to a type parameter list, the combination
        of the parameterized type together with the type argument list is itself a type,
        called a <emphasis>produced type</emphasis>.</para>
        
        <para>For a generic type <literal>T&lt;X&gt;</literal>, the types 
        <literal>T&lt;A&gt;</literal> and <literal>T&lt;B&gt;</literal> represent the 
        same type if and only if <literal>A</literal> and <literal>B</literal> are the 
        same type.</para>
        
        <para>For a generic type <literal>T&lt;n&gt;</literal>, the types 
        <literal>T&lt;a&gt;</literal> and <literal>T&lt;b&gt;</literal> represent the 
        same type if and only if <literal>a</literal> and <literal>b</literal> are 
        equivalent dimension expressions.</para>
        
        <para>For a generic type <literal>T&lt;X&gt;</literal>, a type <literal>A</literal>,
        and a subtype <literal>B</literal> of <literal>A</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    If <literal>X</literal> is a covariant type parameter, 
                    <literal>T&lt;B&gt;</literal> is a subtype of <literal>T&lt;A&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is a contravariant type parameter, 
                    <literal>T&lt;A&gt;</literal> is a subtype of <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is nonvariant (neither covariant nor contravariant), 
                    there is no subtype relationship between <literal>T&lt;A&gt;</literal> and 
                    <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        </section>
                
        <section id="typeargumentsubstitution">
            <title>Type argument substitution</title>
        
        <para>A type argument is substituted for every appearance of the corresponding
        type parameter in the schema of the parameterized declaration, including:</para>
        
        <itemizedlist>
            <listitem>
                <para>attribute types,</para>
            </listitem>
            <listitem>
                <para>method return types,</para>
            </listitem>
            <listitem>
                <para>method parameter types,</para>
            </listitem>
            <listitem>
                <para>initializer parameter types, and</para>
            </listitem>
            <listitem>
                <para>type arguments of extended classes and satisfied interfaces.</para>
            </listitem>
        </itemizedlist>
        
        <para>A dimension is substituted for every appearance of the corresponding 
        dimensional type parameter in the schema of the parameterized declaration.
        The dimension appears as a parenthesized expression in expressions involving
        the dimensional type parameter.</para>
        
        <para>In the case of a sequenced type parameter:</para>
        
        <itemizedlist>
        <listitem> 
            <para>the type arguments are appended to the list of type arguments in every 
            parameterized type in which the sequenced type parameter appears, and</para>
        </listitem>
        <listitem> 
            <para>a list of parameters whose types are the type arguments is appended to 
            the list of parameters of every parameter list in which the sequenced type 
            parameter appears.</para>
        </listitem>
        </itemizedlist>
        
        <programlisting>Method&lt;Order, Item, Product, Natural&gt;</programlisting>
        
        <para>A sequenced type in a type argument list results in a sequenced type
        parameter in a parameter list.</para>
        
        <programlisting>Method&lt;String, Object...&gt;</programlisting>

        <para>A reference to a sequenced type parameter in a type argument list results 
        in a tuple parameter in a parameter list.</para>
        
        <programlisting>Method&lt;String, String, P...&gt;</programlisting>

        <comment><para>TODO: should we let you fill in the parameter names, so you can 
        call this thing using named arguments?
        <programlisting>Method&lt;Order, Item, Product prod, Natural quantity&gt;</programlisting>
        </para></comment>
        
        <!--overloading:
        <para>Substitution of type arguments may result in an ambiguity:</para>
        
        <itemizedlist>
            <listitem>
                <para>two methods of the parameterized type with the same name may now
                also have non-distinct erased signatures, or</para>
            </listitem>
            <listitem>
                <para>two member classes of the parameterized type with the same name may 
                now also have non-distinct erased signatures.</para>
            </listitem>
        </itemizedlist>
        
        <para>In this case, the member class or method may not be called. Any invocation of 
        the member results in a compiler error.</para>
        
        <para>A type with an ambiguity may never be extended or implemented by another type.
        It may not appear in an <literal>extends</literal>, <literal>satisfies</literal> or
        <literal>abstracts</literal> clause.</para>
        -->
        
        </section>
                
        <section id="reification">
            <title>Reification</title>
        
        <para>Type arguments are <emphasis>reified</emphasis> in Ceylon. An instance of a 
        generic type holds a reference to its type arguments. Therefore, the following are 
        legal in Ceylon:</para>
        
        <itemizedlist>
            <listitem>
                <para>testing the runtime value of a type argument of an instance, for 
                example, <literal>objectList is List&lt;Person&gt;</literal> or 
                <literal>case (is List&lt;Person&gt;)</literal>,</para>
            </listitem>
            <listitem>
                <para>filtering exceptions based on type arguments, for example,
                <literal>catch (NotFoundException&lt;Person&gt; pnfe)</literal>,</para>
            </listitem>
            <listitem>
                <para>testing the runtime value of an instance against a type parameter,
                for example <literal>x is T</literal>, or against a type with a type 
                parameter as an argument, for example, 
                <literal>objectList is List&lt;T&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>obtaining a <literal>Type</literal> object representing a type with 
                type arguments, for example, <literal>List&lt;Person&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>obtaining a <literal>Type</literal> object representing the runtime 
                value of a type parameter, for example, <literal>T</literal>, or of a 
                type with a type parameter as an argument, for example, 
                <literal>List&lt;T&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>obtaining a <literal>Type</literal> object representing the
                runtime value of a type argument of an instance using reflection, for 
                example, <literal>objectList.type.arguments.first</literal>,</para>
            </listitem>
            <listitem>
                <para>instantiating a type parameter with an initialization parameter
                specification, for example, <literal>T(parent)</literal>, and</para>
            </listitem>
            <listitem>
                <para>obtaining the numeric value of a dimensional type parameter, for
                example, <literal>for (Natural i in 0..natural&lt;N&gt;())</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Sequenced type parameters are not reified. None of the above operations can 
        be performed with a sequenced type parameter.</para>
        
        <para>The implicit type parameter <literal>subtype</literal> evaluates to the 
        concrete type of the current instance, as determined at runtime. Likewise, an 
        implicit type parameter of form <literal>x.subtype</literal> evaluates to the 
        concrete type of the method argument <literal>x</literal>, as determined at runtime. 
        This is different to other type parameters which reify to the type argument 
        determined at compile time.</para>
        
        </section>
                
    </section>
    
    <section id="parameters">
        <title>Parameters</title>
    
        <para>A method or class declaration may declare a list or <emphasis>parameters</emphasis>, 
        including, optionally, <emphasis>defaulted parameters</emphasis> (parameters with default
        values) and a <emphasis>sequenced parameter</emphasis> (a "vararg" parameter).</para>
        
        <para>In a parameter list, parameters with default values must occur after required 
        parameters. The sequenced parameter, if any, must occur last.</para>
        
        <programlisting>Params: 
"("
FormalParam ("," FormalParam)* ("," DefaultParam)* ("," SequencedParam)? | 
DefaultParam ("," DefaultParam)* ("," SequencedParam)? | 
SequencedParam?
")"</programlisting>

        <programlisting>FormalParam: Param | EntryParamPair</programlisting>
        
        <para>Each parameter is declared with a type and name and may have annotations and/or
        parameters of its own.</para>
        
        <programlisting>Param: Annotation* (Type | "void") (ParameterName | "this") Params*</programlisting>
        
        <para>A parameter may not be be declared <literal>variable</literal>, and may not be 
        assigned to within the body of the method or class.</para>
        
        <para>Only a parameter of a toplevel extension method or class may define a parameter
        named <literal>this</literal>.</para>
        
        <section id="callableparameters">
            <title>Callable parameters</title>
        
        <para>A parameter with its own parameter list (or lists) is called a 
        <emphasis>callable parameter</emphasis>. Think of it as an abstract local method that 
        must be defined by the caller when the method is invoked or the class is instantiated. 
        </para>
            
        <programlisting>(String label, void onClick())</programlisting>
        
        <programlisting>(Comparison by(X x, X y))</programlisting>
        
        <para>A callable parameter declaration is equivalent to a parameter declaration with 
        no parameter lists where the type is the callable type of the method declaration. So 
        the above are equivalent to:</para>
        
        <programlisting>(String label, Callable&lt;Object&gt; onClick)</programlisting>
        
        <programlisting>(Callable&lt;Comparison,X,X&gt; by)</programlisting>
        
        </section>
        
        <section id="defaultedparameters">
            <title>Defaulted parameters</title>
        
        <para>Defaulted parameters specify a default argument.</para>
    
        <programlisting>DefaultParam: FormalParam Specifier</programlisting>
        
        <para>The <literal>=</literal> specifier is used throughout the language to indicate a 
        value which cannot be reassigned.</para>
        
        <programlisting>Specifier: "=" Expression</programlisting>
        
        <para>Defaulted parameters must occur after non-defaulted parameters in the parameter 
        list.</para>
        
        <programlisting>(Product product, Natural quantity=1)</programlisting>
        
        <para>The type of the default argument expression must be assignable to the declared
        type of the parameter.</para>
        
        </section>
        
        <section id="sequencedandtupleparameters">
            <title>Sequenced and tuple parameters</title>
        
        <para>The elipsis <literal>...</literal> indicates that a parameter is either:</para>
        
        <itemizedlist>
            <listitem>
                <para>A <emphasis>sequenced parameter</emphasis>, which accepts a list of 
                arguments of the specified type <literal>T</literal>, or a single argument of 
                type <literal>T[]</literal>. Inside the method or class, the sequenced parameter 
                has type <literal>T[]</literal>.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>tuple parameter</emphasis> representing a list of parameters 
                whose types are defined by a sequenced type parameter. Inside the method or class, 
                the argument has the pseudo-type of the sequenced type parameter and is assignable 
                to any tuple parameter of the same pseudo-type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>SequencedParam: Annotation* Type "..." ParameterName</programlisting>
        
        <para>The sequenced parameter or tuple parameter must be the last parameter in the 
        list.</para>
        
        <programlisting>(Name name, Organization? org=null, Address... addresses)</programlisting>
        
        <programlisting>(T instance, P... args)</programlisting>
        
        </section>
        
        <section id="entryandrangeparameters">
            <title>Key/value parameter pairs</title>
        
        <para>A parameter of type <literal>Entry</literal> may be specified as a pair of variables.</para>
        
        <programlisting>EntryParamPair: Annotation* Type ParameterName "->" Type ParameterName</programlisting>
        
        <para>A key/value parameter pair declaration of form <literal>U u -> V v</literal> results 
        in a method with a single parameter of type <literal>Entry&lt;U,V&gt;</literal>.</para>
        
        <programlisting>(Key key -> Value value)</programlisting>
        <programlisting>(String name -> String? password = "guest" -> null)</programlisting>
                
        </section>
        
    </section>
    
    <section id="annotations">
        <title>Program element annotations</title>

        <para>Declarations may be preceded by a list of annotations. An annotation is an
        initial lowercase identifier, optionally followed by an argument list. A list of 
        annotations does not require punctuation between the individual annotations in the 
        list.</para>
    
        <programlisting>Annotation: MemberName ( Arguments | Literal+ )?</programlisting>
        
        <para>Unlike Java, the name of an annotation may not be a qualified name.</para>
        
        <para>For an annotation with no arguments, or with only literal-valued arguments, 
        the parentheses around, and commas between, the positional arguments may be 
        omitted.</para>
        
        <programlisting>doc "The user login action"
by "Gavin King"
   "Andrew Haley"
throws (DatabaseException 
        -> "if database access fails")
see (LogoutAction.logout)
scope (session) 
action { description="Log In"; url="/login"; }
shared deprecated</programlisting>

        <para>An annotation is an invocation of a toplevel method that occurs when the 
        type is loaded by the virtual machine. The return value of the invocation is 
        made available via reflection.</para>
        
        <para>For example, the built-in <literal>doc</literal> annotation is defined as 
        follows:</para>
        
        <programlisting>shared annotation { of=any; occurs=onceEachElement; }
Description doc(String description) { 
    return Description(description.normalize())
}</programlisting>
        
        <para>The annotation may be specified at a program element using any one of three 
        forms.</para>
        
        <para>Using a positional argument invocation of the method:</para>
        
        <programlisting>doc("the name") String name;</programlisting>
        
        <para>Using a named argument invocation of the method:</para>
        
        <programlisting>doc {description="the name";} String name;</programlisting>
        
        <para>Or using the special abbreviated form for annotations with literal value
        arguments:</para>
        
        <programlisting>doc "the name" String name;</programlisting>
        
        <para>And its value may be obtained like this:</para>
        
        <programlisting>Description? description = Person.annotations(Description).first;</programlisting>
        
        <para>Unlike Java, the same annotation may appear multiple times for the same
        program element. Furthermore, different annotations (toplevel methods) may 
        return values of the same type.</para>
        
    </section>
    
    <!--
    <section id="metatype">
        <title>Metatypes</title>
        
        <para>For every type <literal>X</literal>, the <emphasis>metatype</emphasis> 
        <literal>MX</literal> of the type defines a typesafe metamodel of the members of 
        the type.</para>
        
        <itemizedlist>
            <listitem>
                <para>For each non-<literal>variable</literal> attribute of <literal>X</literal> 
                with type <literal>T</literal>, <literal>MX</literal> has an attribute with 
                the same name and type <literal>Attribute&lt;X,T&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>variable</literal> attribute of <literal>X</literal> 
                with type <literal>T</literal>, <literal>MX</literal> has an attribute with 
                the same name and type <literal>MutableAttribute&lt;X,T&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each method of <literal>X</literal> with return type <literal>R</literal> 
                and parameter types <literal>P...</literal>, <literal>MX</literal> has an 
                attribute with the same name and type <literal>Method&lt;X,R,P...&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>abstract</literal> member class <literal>Y</literal> 
                of <literal>X</literal>, <literal>MX</literal> has an attribute with the same 
                name and type <literal>MemberClass&lt;X,Y&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>For each non-<literal>abstract</literal> member class <literal>Y</literal> 
                of <literal>X</literal> with initializer parameter types <literal>P...</literal>, 
                <literal>MX</literal> has an attribute with the same name and type 
                <literal>MemberConcreteClass&lt;X,Y,P...&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    -->
        
</chapter>