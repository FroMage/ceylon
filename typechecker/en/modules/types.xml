<chapter id="types">
    <title>Basic types</title>
    
    <para>There are no primitive types in Ceylon, however, there are certain
    important types provided by the SDK modules <literal>ceylon.language</literal>
    and <literal>ceylon.collection</literal>. Many of these types support 
    operators.</para>
    
    <section id="languagemodule">
        <title>The language module</title>
        
        <para>The module <literal>ceylon.language</literal> contains types which
        are referred to in the language definition.</para>
        
        <para>Toplevel types, toplevel methods, toplevel attributes, <!--enumerated instances,--> 
        and extensions defined in <literal>ceylon.language</literal> do not need 
        to be explicitly imported.</para>
    
        <comment><para>Note: we will probably need to do the following erasures:</para>
        <itemizedlist>
            <listitem>
                <para><literal>Optional&lt;T&gt;</literal>, <literal>Something&lt;T&gt;</literal>
                and <literal>Nothing&lt;T&gt;</literal> to <literal>T</literal></para>
            </listitem>
            <listitem>
                <para><literal>Void</literal>, <literal>Object</literal> and 
                <literal>IdentifiableObject</literal> to <literal>java.lang.Object</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>Exception</literal> to <literal>java.lang.Throwable</literal>.</para>
            </listitem>
        </itemizedlist>
        <para>Therefore the members declared by <literal>Object</literal> and
        <literal>Exception</literal> will require special handling in the compiler.</para>
        </comment>
        
    <section id="void">
        <title>The void type</title>
        
        <para>The class <literal>Void</literal> is the root of the type
        system. All types are assignable to <literal>Void</literal>, which
        supports the the operator <literal>.</literal> (member selection).
        However, <literal>Void</literal> itself does not declare any 
        members.</para>
        
        <programlisting>public abstract class Void() extends null {}</programlisting>
        
        <para>The special syntax <literal>extends null</literal> indicates
        that <literal>Void</literal> has no superclass.</para>
        
        <para>In contrast to <literal>Optional</literal>, which represents a
        possibly undefined value of a well-defined type, an expression of type
        <literal>Void</literal> represents a possibly undefined value with a 
        possibly undefined type! Therefore we can't really do anything very
        much with a <literal>Void</literal>&mdash;we can't even ask it what
        kind of thing it <literal>is</literal>.</para>
        
        <para>In practice, <literal>Void</literal> is used mainly to abstract
        the return types of methods which may or may not be declated
        <literal>void</literal>.</para>
        
    </section>
    
    <section id="object">
        <title>The <literal>Object</literal> class</title>
    
        <para>The class <literal>Object</literal> represents a definite value. 
        Expressions of type <literal>Object</literal> may be the subject of the 
        <literal>is</literal> operator (assignability).</para>
        
        <programlisting><![CDATA[public abstract class Object() 
        extends Void() {
    
    doc "The |Type| of the instance."
    public Type<subtype> type {
        return ... 
    }
    
    doc "A developer-friendly string representing the instance."
    public formal String string;
    
    ...
        
}]]></programlisting>
    
        <para>All interface <!--and union--> types are assignable to 
        <literal>Object</literal>.</para>
    
        <para>Classes which are optimized by the compiler to Java primitive 
        types extend <literal>Object</literal> directly, since there is no 
        well-defined notion of identity for these types. Most other types
        are subclasses of <literal>IdentifiableObject</literal>.</para>
    
<!-- 
    doc "Binary assignability operator |x is Y|. Determine if the 
         instance is of the given |Type|."
    public Boolean instanceOf(Type<Object> type) {
        return this.type.assignableTo(type)
    }    
 -->
<!--
    doc "A log object for the type."
    public default Log log { 
        return type.log 
    }
 -->
    
    </section>
    
    <section id="equals">
        <title>Objects which support equality</title>
        
        <para>Types which can be compared for equality must satisfy the interface 
        <literal>Equals&lt;T&gt;</literal>. Two expressions of type
        <literal>Equals&lt;T&gt;</literal>, for the same type <literal>T</literal>,
        may be compared using the binary operators <literal>&equals;</literal> 
        (equals) and <literal>!=</literal> (not equals).</para>
        
        <programlisting><![CDATA[public interface Equals<in T> 
        given T satisfies Object {
    
    doc "The equals operator |x == y|. Implementations should 
         respect the constraint that if |x===y| then |x==y|,
         the constraint that if |x==y| then |y==x|,
         and the constraint that if |x==y| and |y==z| then
         |x==z|."
    formal Boolean equals(T other);
    
    doc "The hash code of the instance. Implementations of |hash| 
         must respect the constraint that if |x==y| then 
         |x.hash==y.hash|."
    formal Integer hash;
    
}]]></programlisting>

        <para>We can't apply the <literal>==</literal> operator to expressions
        of arbitrary type. The reason for this is that traditionally numeric
        equality is defined even for values of differing numeric type.
        Furthermore, Ceylon has an extensible system of numeric types and it
        is therefore impossible to write a single implementation of 
        <literal>equals()</literal> that takes into consideration all possible 
        numeric types. Therefore type promotion (an extension) must be applied 
        to one value when values of two different numeric types are compared. 
        If <literal>==</literal> were defined for any <literal>Object</literal>, 
        there would be no reason for the compiler to apply the type promotion.</para>
        
        <comment><para>TODO: Should we rename <literal>Equals</literal> to 
        <literal>Comparable</literal> and <literal>Comparable</literal> to
        <literal>Ordered</literal>?</para></comment>
    
    </section>
    
    <section id="identifiableobject">
        <title><literal>IdentifiableObject</literal> and <literal>BaseObject</literal></title>
        
        <para>The class <literal>IdentifiableObject</literal> represents a type 
        whose values are always passed by reference. Expressions of type 
        <literal>IdentifiableObject</literal> support the binary operator 
        <literal>&identical;</literal> (identity equals).</para>
        
        <programlisting><![CDATA[public abstract class IdentifiableObject() 
        extends Object() satisfies Equals<IdentifiableObject> {

    doc "The |Class| of the instance."
    actual Class<subtype> type {
        return ... 
    }
    
    default actual Boolean equals(IdentifiableObject that) {
        return this===that
    }
    
    default actual Integer hash {
        return identityHash(this);
    }
        
}]]></programlisting>
        
        <para>The following toplevel methods expose the notion of object 
        identity:</para>
    
        <programlisting>public Boolean identical(IdentifiableObject x, IdentifiableObject y) { return ... }</programlisting>
        <programlisting>public Integer identityHash(IdentifiableObject x) { return ... }</programlisting>
    
        <para>Classes written in other Java VM languages (including Java classes) 
        are considered subtypes of <literal>IdentifiableObject</literal>. Indeed,
        you can think of <literal>IdentifiableObject</literal> as Ceylon's
        representation of <literal>java.lang.Object</literal>.</para>
    
        <para>User-written classes usually extend <literal>BaseObject</literal>.
        Subclasses of <literal>BaseObject</literal> have default implementations 
        of <literal>equals()</literal>, <literal>hash</literal> and 
        <literal>string</literal> provided for them.</para>
        
        <programlisting><![CDATA[public abstract class BaseObject() 
        extends IdentifiableObject() {
        
    Attribute<subtype,Object>[] idAttributes() {
        return from ( Attribute<subtype,Object> a in type.attributes() ) 
                    where ( nonempty a.annotations(Id) );
    }
    
    doc "The equals operator |x == y|. Default implementation compares
         attributes annotated |id|, or performs identity comparison."
    see (id)
    default actual Boolean equals(IdentifiableObject that) {
        if (that.type!=type) {
            return false
        }
        Attribute<subtype,Object>[] idAttributes = idAttributes();
        if (nonempty idAttributes) {
            return equals(that, idAttributes)
        }
        else {
            return super.equals(that)
        }
    }
    
    doc "Compares the given attributes of this instance with the given
         attributes of the given instance."
    public Boolean equals(IdentifiableObject that, Attribute<subtype,Object>... attributes) {
        if (is subtype that) {
            return forAll (Attribute<subtype,Object> a in attributes)
                        every ( a(this) == a(that) )
        }
        else {
            return false
        }
    }
    
    doc "The hash code of the instance. Default implementation compares
         attributes annotated |id|, or assumes identity equality."
    see (id)
    default actual Integer hash { 
        Attribute<subtype,Object>[] idAttributes = idAttributes();
        if (nonempty idAttributes) {
            return hash(idAttributes)
        }
        else {
            return super.hash
        }
    }
    
    doc "Computes the hash code of the instance using the given 
         attributes."
    public Integer hash(Attribute<subtype,Object>... attributes) { ... }
        
    doc "A developer-friendly string representing the instance. 
         By default, the string contains the name of the type, 
         and the values of all attributes annotated |id|."
    default actual String string {
        return string(idAttributes())
    }
    
    doc "A developer-friendly string representing the instance,
         containing the name of the type, and the value of the
         given attributes." 
    public default String string(Attribute<subtype,Object>... attributes) {
        mutable Character[] result := "";
        result .= with (type.name, "{");
        result .= forEach (Attribute<subtype,Object> a in attributes)
                    with ({ a.name, "=", $a(this), ";" });
        result .= with ("}");
        return result 
    }
    
    ...
        
}]]></programlisting>
    
    </section>
    
    <section id="callable">
        <title>Callable references</title>
        
        <para>The type <literal>Callable</literal> represents an executable
        operation. Expressions of type <literal>Callable</literal> may be the 
        subject of the argument specification operators <literal>()</literal> 
        and <literal>{}</literal>.</para>
        
        <programlisting><![CDATA[public interface Callable<out R, P...> {
    formal R call(P... args);
}]]></programlisting>
    
        <para>The following extension provides function <emphasis>composition</emphasis>, 
        combining a <literal>Callable&lt;Y,X&gt;</literal> with a <literal>Callable&lt;X,P...&gt;</literal>
        to produce a <literal>Callable&lt;Y,P...&gt;</literal>:</para>
        
        <programlisting><![CDATA[public extension Y composeable<X,Y,P...>(Y this(X x))(X g(P... args))(P... args) {
    Y compose(X g(P... args))(P... args) {
        Y composition(P... args) {
            return this(g(args))
        }
        return composition
    }
    return compose
}]]></programlisting>

       <para>For example:</para>
       
       <programlisting>void logFormatted(Date date) = log.info(DateFormat('dd/mm/yyyy').format);</programlisting>

       <para>The next extension allows the first parameter of any function with multiple 
       parameters to be <emphasis>curried</emphasis>, transforming a 
       <literal>Callable&lt;R,T,P...&gt;</literal> into a
       <literal>Callable&lt;Callable&lt;R,P...&gt;,T&gt;</literal>:</para>

       <programlisting><![CDATA[public extension class Curryable<R,T,P...>(R this(T t, P... args)) {
    R partial(T t)(P... p) {
        R curried(P... p) {
            return this(t, args)
        }
        return curried
    }
}]]></programlisting>
       
       <para>For example:</para>
       
       <programlisting>void info(String message) = log.message.partial(Level.info);
void hello() = info.partial("Hello!");</programlisting>
       
       <para>This extension does the reverse, transforming a 
       <literal>Callable&lt;Callable&lt;R,P...&gt;,T&gt;</literal> into a
       <literal>Callable&lt;R,T,P...&gt;</literal>:</para>

       <programlisting><![CDATA[public extension class Flattenable<R,T,P...>(R this(T t)(P... args)) {
    R flatten(T t, P... p) {
        return this(t)(p)
    }
}]]></programlisting>
       
       <para>For example:</para>
       
       <programlisting>void say(Person p, String words) = Person.say.flatten;</programlisting>
       
       <para>Finally, this extension swaps the first and second parameter lists of
       a function with multiple parameter lists, transforming a 
       <literal>Callable&lt;Callable&lt;R,Q...&gt;,P...&gt;</literal> into a
       <literal>Callable&lt;Callable&lt;R,P...&gt;,Q...&gt;</literal>:</para>
       
       <programlisting><![CDATA[public extension class Shuffleable<R,P...,Q...>(R this(P... p)(Q... q)) {
   R shuffle(Q... q)(P... p) {
       R shuffled(P... p) {
           return this(p)(q)
       }
       return shuffled
   }
}]]></programlisting>
        
        <para>For example:</para>
        
        <programlisting>Float sqr(Float x) = Float.power.shuffle(2);
void say(String words, Person p) = Person.say.shuffle.flatten;</programlisting>
        
    </section>
    
    <section id="evaluableandassignable">
        <title>Evaluable and assignable values</title>
        
        <para>The class <literal>Gettable</literal> represents a reference which may 
        be evaluated to produce a value, allowing pass by reference and lazy evaluation 
        semantics. Instances of <literal>Gettable&lt;T&gt;</literal> are transparently 
        assignable to <literal>T</literal> (evaluation).</para>
        
        <programlisting><![CDATA[public abstract class Gettable<out T>()
        extends Void() {}]]></programlisting>
        
        <para>Note that <literal>Gettable</literal> is not a subclass of 
        <literal>Object</literal>.</para>
        
        <para>The following method allows a <literal>Gettable&lt;T&gt;</literal>
        to be treated as a <literal>Callable&lt;T&gt;</literal>:</para>

        <programlisting><![CDATA[public T get<T>(Gettable<T> value)() { 
    return value 
}]]></programlisting>
    
        <para>The subtype <literal>Settable</literal> represents a reference
        to an assignable value, allowing pass by reference semantics for assignable
        values. Expressions of type <literal>Settable</literal> support the binary
        operator <literal>:=</literal> (assign).</para>
        
        <programlisting><![CDATA[public abstract class Settable<T>()
        extends Gettable<T>() {}]]></programlisting>

        <para>The following method allows an <literal>Settable&lt;T&gt;</literal>
        to be treated as a <literal>Callable&lt;T,T&gt;</literal>:</para>

        <programlisting><![CDATA[public T set<T>(Settable<T> value)(T newValue) { 
    return value := newValue; 
}]]></programlisting>
    
    </section>
    
    <section id="boolean">
        <title>Boolean values</title>
        
        <para>The <literal>Boolean</literal> class represents
        boolean values. Expressions of type <literal>Boolean</literal> support 
        the binary <literal>||</literal> and <literal>&amp;&amp;</literal> 
        operators and the unary <literal>!</literal> operator.</para>
        
        <programlisting><![CDATA[public object true extends Boolean() {}
public object false extends Boolean() {}
public abstract class Boolean() 
        of true, false 
        extends Case() {}]]></programlisting>

    </section>
    
    <section id="matchersandcases">
        <title>Matchers and cases</title>
        
        <para>The interface <literal>Matcher</literal> represents a
        type that may be used as a <literal>case</literal> in the 
        <literal>switch</literal> construct.</para>
        
        <programlisting><![CDATA[public interface Matcher<in X> {

    doc "Determine if the given value matches
         this case, returning |true| iff the
         value matches."
    formal Boolean matches(X value);
    
}]]></programlisting>

        <comment><para>TODO: the two extensions that follow don't actually 
        work, since they overload the <literal>matches()</literal> method of
        <literal>Matcher</literal> in a way that doesn't permit resolution 
        according to the rules we have written down.</para></comment>

        <para>An extension allows <literal>Matcher&lt;X&gt;</literal> to 
        function as <literal>Matcher&lt;X?&gt;</literal>.</para>
        
        <programlisting><![CDATA[public extension class OptionalMatcher<X>(Matcher<X> this) 
        satisfies Matcher<X?> {
        
    actual Boolean matches(X? x) {
        if (exists value) {
            return this.matches(x)
        }
        else {
            return false;
        }
    }
        
}]]></programlisting>

        <para>An extension allows <literal>Matcher&lt;X&gt;</literal> to 
        function as <literal>Matcher&lt;Y&gt;</literal> where <literal>X</literal> 
        is a subtype of <literal>Y</literal>.</para>
        
        <programlisting><![CDATA[public extension class SupertypeMatcher<X,Y>(Matcher<X> this) 
        satisfies Matcher<Y> 
        given X satisfies Y {
        
    actual Boolean matches(Y y) {
        if (is X y) {
            return this.matches(y)
        }
        else {
            return false;
        }
    }
        
}]]></programlisting>
        
        <para>The class <literal>Case</literal> is the supertype of anonymous 
        classes that may be cases in an <literal>of</literal> clause.</para>
        
        <programlisting><![CDATA[public abstract class Case() 
        satisfies Matcher<Object> {
    actual Boolean matches(Object that) {
        return this===that
    }
    actual default String string { 
        return type.declarationName
    }
}

public abstract class Case(String caseName) 
        extends Case() {
    actual String string = caseName
}]]></programlisting>

    </section>
    
    <section id="optionalandnull">
        <title>Optional and null values</title>
        
        <para>The class <literal>Optional</literal> represents a
        value that may be null.</para>
        
        <programlisting><![CDATA[public abstract class Optional<out X>() 
        of Something<X>, Nothing<X>
        extends Void() {
    
    doc "The unary postfix existence operator 
         |x exists|."
    public formal Boolean defined;
    
}]]></programlisting>

<!--
    doc "The binary default operator 
         |x ? y|."
    public T default<T>(T defaultValue) 
            given T abstracts X;
-->

        <para>Expressions of type <literal>Object?</literal> support the 
        binary operators <literal>?.</literal> (nullsafe invoke) and 
        <literal>?</literal> (default) and the unary operator 
        <literal>exists</literal>.</para>
        
        <para>Note that <literal>Optional</literal> is not a subtype of 
        <literal>Object</literal>. Therefore it is not possible to apply 
        the <literal>is</literal> operator to an expression of type 
        <literal>Optional</literal>. The reason behind this is that 
        <literal>Optional</literal> and its subtypes are erased by the
        compiler, and null values are untyped at the virtual machine
        level.</para>
        
        <para>If an optional value is not null, it is represented by an
        instance of the subclass <literal>Something</literal>.</para>
        
        <programlisting><![CDATA[public extension class Something<out X>(X this) 
        extends X?() {

    public extension X value = this;
    
    actual Boolean defined { 
        return true 
    }
    
}]]></programlisting>

<!-- 
    actual T default<T>(T defaultValue) 
            given T abstracts X {
        return value;
    }
-->
        <para>If an optional value is null, it is represented by an instance 
        of the subclass <literal>Nothing</literal>.</para>

        <programlisting><![CDATA[public class Nothing<out X>() 
            extends X?() {
    actual Boolean defined { 
        return false 
    }
}]]></programlisting>

        <para>Non-optional values are transparently assignable to optional
        values, since <literal>Something&lt;X&gt;</literal> is an extension of 
        <literal>X</literal> enabled in every compilation unit. Likewise, 
        instances of <literal>Something&lt;X&gt;</literal> are transparently 
        assignable to <literal>X</literal>.</para>
        
        <para>The value <literal>null</literal> is transparently assignable to 
        optional values, since <literal>Nothing&lt;X&gt;</literal> is an 
        extension of <literal>Null</literal> enabled in every compilation unit.</para>
        
        <programlisting><![CDATA[doc "Represents a null reference."  
public object null extends Void() satisfies Matcher<Object?> {

    actual Boolean matches(Object? value) {
        return !value exists;
    }
    
    public extension Nothing<X> nothing<X>() {
        return Nothing<X>()
    }
     
}]]></programlisting>
        
<!--
    actual T default<T>(T defaultValue) 
            given T abstracts X {
        return defaultValue;
    }
-->    
        <para>Note that <literal>Optional</literal> is not a reified type. The compiler
        erases all references to <literal>Optional&lt;X&gt;</literal> to 
        <literal>X</literal> after performing type validation and before generating
        bytecode. The compiler also replaces references to <literal>Null.null</literal>
        with the Java <literal>null</literal>. Therefore, none of the extensions defined 
        in this section are actually executed.</para>
        
    </section>
    
    <section id="exception">
        <title>Exceptions</title>
        
        <para>The class <literal>Exception</literal> is the base class for all
        exception types.</para>
        
        <programlisting><![CDATA[public class Exception(Exception? cause=null, String? message=null) 
        extends IdentifiableObject() {
    
    public String message = message ? cause?.message ? "";
    
    public Exception cause = cause ? this;
    
    public StackTrace stackTrace { return ... }
    
    actual String string {
        if (nonempty message) {
            return type.name + ": " + message
        }
        else {
            return type.name
        }
    }
    
}]]></programlisting>

    </section>

    <section id="usable">
        <title>Usables</title>
        
        <para>The interface <literal>Usable</literal> represents an
        object with a lifecycle controlled by <literal>try</literal>.</para>
        
        <programlisting><![CDATA[public interface Usable {

    doc "Called before entry into a |try| block."
    formal void begin();
    
    doc "Called before normal exit from a |try| block."
    formal void end();

    doc "Called before exit from a |try| block when an
         exception occurs."
    default void end(Exception e) {
        end();
    }
    
}]]></programlisting>
       
        <!--
        <para>An <literal>Usable</literal> is used according to the
        following idiom:</para>
            
        <programlisting><![CDATA[Transaction t = Transaction();
t.begin();
try {
    doSomething(t);
    t.end();
}
catch (Exception e) {
    t.end(e);
}]]></programlisting>
        -->
    </section>
    
    <section id="category">
        <title>Containers and categories</title>
        
        <para>The interface <literal>Container</literal> represents
        the abstract notion of an object that may be empty. Expressions
        of type <literal>Container?</literal> support the unary postfix 
        operator <literal>nonempty</literal>.</para>
        
        <programlisting><![CDATA[public interface Container {
        
    doc "The nonempty operator. Determine 
         if the container is empty."
    formal Boolean empty;
    
}]]></programlisting>
    
        <para>The interface <literal>Category</literal> represents the 
        abstract notion of an object that contains other objects. An 
        expression of type <literal>Category</literal> may occur as the
        right hand argument of the <literal>in</literal> operator.</para>
        
        <programlisting><![CDATA[public interface Category {
    
    doc "Determine if the given object belongs to the category.
         Return |true| iff the given object belongs to the 
         category."
    formal Boolean contains(Object object);

    doc "Determine if the given objects belong to the category.
         Return |true| iff all the given objects belong to the 
         category."
    default Boolean contains(Object... objects) {
        return forAll(Object object in objects) every (contains(object))
    }

}]]></programlisting>
        
        <!--
        <programlisting><![CDATA[public interface Category {
    
    doc "Determine if the given element belongs to the category."
    public Boolean contains(Object element);

}]]></programlisting>

        <programlisting><![CDATA[public extension class Categories(Category category) {
        
    doc "Determine if all the given elements belong to the 
         category."
    public Boolean contains(Object... elements) {
        return forAll (Object elem in elements) every category.contains(elem)
    }
    
}]]></programlisting>
        -->
        
        <para>Any <literal>Object</literal> may belong to categories. The 
        following extension defines the binary <literal>in</literal>
        operator:</para>
    
    <programlisting><![CDATA[public extension class Objects(Object this) {
    
    doc "Determine if this object belongs to the given |Category|.
         The binary |in| operator."
    see (Category)
    public Boolean in(Category category) {
        return category.contains(this)
    }

}]]></programlisting>
    
        <para>There is a mutable subtype, representing a category to which 
        objects may be added.</para>
        
        <programlisting><![CDATA[public interface OpenCategory<in X> 
        satisfies Category 
        given X satisfies Object {
    
    doc "Add the given objects to the category. Return the number of 
         objects which did not already belong to the category."
    public Natural add(X... objects);

}]]></programlisting>

        <!--
        <programlisting><![CDATA[public interface OpenCategory<in X> 
        satisfies Category {
    
    doc "Add the given element to the category. Return |true| if 
         the element did not already belong to the category."
    public Boolean add(X element);

}]]></programlisting>

        <programlisting><![CDATA[public extension class OpenCategories<in X>(OpenCategory<X> category) {
        
    doc "Add the given elements to the category. Return |true| if 
         at least one element did not already belong to the 
         category."
    public Boolean add(X... elements) {
        Boolean added = false;
        for (X x in elements) {
            added |= category.add(x);
        }
        return added
    }
    
}]]></programlisting>
        -->

    </section>
    
    <section id="iterableanditerator">
        <title>Iterable objects and iterators</title>
        
        <para>The interface <literal>Iterable</literal> represents an
        object which can produce a sequence of values, and which can
        be iterated using a <literal>for</literal> loop.</para>
        
        <programlisting><![CDATA[public interface Iterable<out X> satisfies Container {
    
    doc "A sequence of objects belonging
         to the container."
    formal Iterator<X> iterator();
    
}]]></programlisting>
        
        <para>A Ceylon <literal>Iterator</literal> is a stateless object
        that produces a theoretically unbounded sequence of values.</para>
        
        <programlisting><![CDATA[public interface Iterator<out X> {

    formal X? head;
    formal Iterator<X> tail;

    actual default Boolean empty {
        return !(head exists)
    }

}]]></programlisting>
        
        <para>An <literal>Iterator</literal> is used according to the
        following idiom:</para>
            
        <programlisting><![CDATA[mutable local iter := iterable.iterator();
while (exists local value = iter.head) {
    ...
    iter.=tail;
}]]></programlisting>
    
    <para>The following interface allows <literal>Iterable</literal> objects
    to be used with the <literal>in</literal> operator.</para>
    
    <programlisting><![CDATA[public interface FiniteCategory<T>
        satisfies Iterable<T>, Category
        given T satisfies Object, Equals<T> {
        
    actual default Boolean contains(Object... objects) {
        for (Object obj in objects) {
            if (is T obj) {
                if ( forAll (Object elem in this) every (elem != obj) ) {
                    return false
                }
            }
            else {
                return false
            }
        }
        fail {
            return true
        }
    }
    
}]]></programlisting>
    
        <comment><para>TODO: should we provide for mutation/removal during 
        iteration:</para>
        <programlisting><![CDATA[public interface OpenIterable<X> 
        satisfies Iterable<X> {
    actual OpenIterator<X> iterator();
}]]></programlisting>
        <programlisting><![CDATA[public interface OpenIterator<X> 
        satisfies Iterator<X> {
    actual mutable X? head;
    public void remove();
}]]></programlisting></comment>

        <comment><para>TODO: this alternate solution abstracts efficient 
        iteration of sequences and linked lists/trees, but suffers from
        the problem that the <literal>indexedValue()</literal> operation 
        accepts tokens from iterations of other objects, and is therefore 
        much less typesafe.</para>
        <programlisting><![CDATA[public interface Indexed<out X, I> 
        given I satisfies Ordinal {
    
    formal I firstIndex;
    formal Gettable<X>? indexedValue(I index);
    
}]]></programlisting>
        <para>For example, a <literal>Sequence&lt;X&gt;</literal> would 
        be an <literal>Indexed&lt;X, Natural&gt;</literal> and a 
        <literal>LinkedList&lt;X&gt;</literal> would be an 
        <literal>Indexed&lt;X, Link&lt;X&gt;&gt;</literal>. The idiom
        would be:</para>
        <programlisting><![CDATA[mutable local i := indexed.firstIndex;
while (exists local value = indexed.indexedValue(i)) {
    ...
    ++i;
}]]></programlisting>
        <para>Mutation/removal during iteration would also be possible.</para>
        <programlisting><![CDATA[public interface OpenIndexed<X, I> 
        satisfies Indexed<X,I>
        given I satisfies Ordinal {
    actual mutable Settable<X>? indexedValue(I index);
    public void removeIndex(I index);
}]]></programlisting>
</comment>
    
    </section>
    
    <section id="entry">
        <title>Entries</title>
        
        <para>The <literal>Entry</literal> class represents a pair of 
        associated objects.</para>

        <para>Entries may be constructed using the <literal>-></literal> 
        operator.</para>

            <programlisting><![CDATA[public class Entry<out U, out V>(U key, V value) 
        extends Object() 
        satisfies Equals<Entry<U,V>>
        given U satisfies Object, Equals<U> 
        given V satisfies Object, Equals<V> {
    
    doc "The key used to access the entry."
    public U key = key;
    
    doc "The value associated with the key."
    public V value = value;
    
    actual Boolean equals(Entry<U,V> that) {
        return this.key==that.key && this.value==that.value
    }
    
    actual Integer hash = ... ; 

}]]></programlisting>

    </section>
    
    <section id="correspondence">
        <title>Correspondences</title>
        
        <para>The interface <literal>Correspondence</literal> represents
        the abstract notion of an object that maps value of one type to values
        of some other type. It supports the binary operator
        <literal>[key]</literal> (lookup).</para>

        <programlisting><![CDATA[public interface Correspondence<in U, out V>
        is EnumerableCorrespondence<U,V>
        given U satisfies Object, Equals<U> 
        given V satisfies Object, Equals<V> {
    
    doc "Binary lookup operator x[key]. Returns the value defined
         for the given key, or |null| if there is no value defined
         for the given key."
    formal Gettable<V?> value(U key);
    
    doc "Binary sequenced lookup operator |x[keys]|. Return a list 
         of values defined for the given keys, in order."
    throws (UndefinedKeyException
            -> "if no value is defined for one of the given 
                keys")
    default V[] values(U... keys) {
        return from (U key in keys) select (this[key])
    }
    
    doc "Binary iterated lookup operator |x[keys]|. Return an iterator
         of the values defined for the given keys."
    throws (UndefinedKeyException
            -> "if no value is defined for one of the given 
                keys")
    default Iterable<V> values(Iterable<U> keys) {
        return from (U key in keys) select (this[key])
    }
    
    doc "Determine if there are values defined for the given keys.
         Return |true| iff there are values defined for all the
         given keys."
    default Boolean defines(U... keys) {
        return forAll (U key in keys) every (this[key] exists)
    }
    
}]]></programlisting>

        <!--     
        <programlisting><![CDATA[public interface Correspondence<in U, out V> {
    
    doc "Binary lookup operator x[key]. Returns the value defined
         for the given key."
    public V value(U key);
    
    doc "Determine if there is a value defined for the given key."
    public Boolean defines(U key);
    
}]]></programlisting>

        <programlisting><![CDATA[public extension class Correspondences<in U, out V>(Correspondence<U, V> correspondence) {

    doc "Binary lookup operator x[keys]. Returns a list of values 
         defined for the given keys, in order."
    public List<V> values(List<U> keys) {
        return from (U key in keys) select correspondence.lookup(key)
    }
    
    doc "Binary lookup operator x[keys]. Returns a set of values 
         defined for the given set of keys."
    public Set<V> values(Set<U> keys) {
        return ( from (U key in keys) select correspondence.lookup(key) ).elements
    }
    
    doc "Determine if there are values defined for all the given 
    keys."
    public Boolean defines(U... keys) {
        for (U key in keys) {
            if ( !correspondence.defines(key) ) {
                return false
            }
        }
        fail {
            return true
        }
    }
    
}]]></programlisting>
        -->
        
        <para>The metatype allows direct instantiation of the
        <literal>Correspondence</literal> interface:</para>
        
        <programlisting><![CDATA[public interface EnumerableCorrespondence<U,V>
        satisfies Callable<Correspondence<U,V>,Entry<U,V>...>
        given U satisfies Object, Equals<U> 
        given V satisfies Object, Equals<V> {
    actual default Correspondence<U,V> call(Entry<U,V>... entries) {
        object correspondence 
                satisfies Correspondence<U,V> {
            ...
        }
        return correspondence
    }
}]]></programlisting>
        
        <para>There is a mutable subtype, representing a correspondence
        for which new mappings may be defined, and existing mappings 
        modified. It provides for the use of element expressions in
        assignments.</para>
        
        <!-- Association? -->

        <programlisting><![CDATA[public interface OpenCorrespondence<in U, V> 
        satisfies Correspondence<U, V> 
        given U satisfies Object, Equals<U> 
        given V satisfies Object, Equals<V> {
    
    actual Settable<V?> value(U key);
    
    doc "Add the given entries, overriding any definitions that 
         already exist."
    throws (UndefinedKeyException
            -> "if a value can not be defined for one of the 
                given keys")
    public default void define(Entry<U, V>... definitions) {
        for (U key->V value in definitions) {
            this[key] := value;
        }
    }
    
    doc "Assign a value to the given key. Return the previous value 
         for the key, or |null| if there was no value defined."
    throws (UndefinedKeyException
            -> "if a value can not be defined for the given key")
    public default V? define(U key -> V value) {
        Settable<V?> definition = this[key];
        V? result = definition;
        definition := value;
        return result;
    }

}]]></programlisting>
        
        <comment><para>TODO: Should we rename <literal>value()</literal>, <literal>define()</literal>
        and <literal>defines()</literal> to <literal>get()</literal>, <literal>set()</literal>
        and <literal>has()</literal>?</para></comment>
        
    </section>
    
    <section id="comparableandordinal">
        <title>Ordered values</title>
        
        <para>The <literal>Comparable</literal> interface 
        represents totally ordered types, and supports the binary operators 
        <literal>&gt;, &lt;, &lt;=, &gt;=</literal> and <literal>&lt;=&gt;</literal>
        (compare).</para>
        
        <programlisting><![CDATA[public interface Comparable<in T> 
        satisfies Equals<T>
        given T satisfies Object {
    
    doc "The binary compare operator |<=>|. Compares this 
         object with the given object. Implementations must
         respect the constraint that if |x==y| then
         |x<=>y == Comparison.equal|, the constraint that 
         if |x>y| then |y<x|, and the constraint that if 
         |x>y| and |y>z| then |x>z|."
    formal Comparison compare(T other);
    
    doc "The binary |>| operator."
    Boolean largerThan(T other) {
        return compare(other)==larger
    }
    
    doc "The binary |<| operator."
    Boolean smallerThan(T other) {
        return compare(other)==smaller
    }
    
    doc "The binary |>=| operator."
    Boolean asLargeAs(T other) {
        return compare(other)!=smaller
    }
    
    doc "The binary |<=| operator."
    Boolean asSmallAs(T other) {
        return compare(other)!=larger
    }
    
}]]></programlisting>
        
        <programlisting><![CDATA[doc "The receiving object is larger than 
     the given object."
public object larger extends Comparison() {}

doc "The receiving object is smaller than 
     the given object."
public object smaller extends Comparison() {}

doc "The receiving object is exactly equal 
     to the given object."
public object equal extends Comparison() {}
    
doc "The result of a comparison between two
     objects."
public abstract class Comparison() 
        of larger, smaller, equal 
        extends Case() {}]]></programlisting>

        <comment><para>TODO: should we support partial orders? Give
        <literal>Comparison</literal> an extra <literal>uncomparable</literal>
        value, or let <literal>compare()</literal> return 
        <literal>null</literal>?</para></comment>
        
        <comment><para>TODO: if so, why not just move <literal>compare()</literal>
        up to <literal>Object</literal> to simplify things?</para></comment>
        
        <para>The toplevel methods <literal>min()</literal> and <literal>max()</literal>
        return the minimum and maximum values of a list of <literal>Comparable</literal>s.</para>
        
        <programlisting><![CDATA[public X min<X>(X x, X... xs) 
        given X satisfies Comparable<X> {
    mutable X min := x;
    for (X y in xs) { 
        if (y<min) { 
            min:=y;
        }
    }
    return min
}]]></programlisting>

        <programlisting><![CDATA[public X max<X>(X x, X... xs) 
        given X satisfies Comparable<X> {
    mutable X max := x;
    for (X y in xs) { 
        if (y>max) { 
            max:=y;
        }
    }
    return max
}]]></programlisting>

        <para>The <literal>Ordinal</literal> interface represents 
        objects in a sequence, and supports the binary operator 
        <literal>..</literal> (range). In addition, variables support 
        the postfix unary operators <literal>++</literal> (increment) 
        and <literal>--</literal> (decrement) and prefix unary 
        operators <literal>++</literal> (successor) and 
        <literal>--</literal> (predecessor).</para>
        
        <programlisting><![CDATA[public interface Ordinal {

    doc "The unary |++| operator. The successor of this instance."
    throws (OutOfRangeException
            -> "if this is the maximum value")
    formal subtype successor;
    
    doc "The unary |--| operator. The predecessor of this instance."
    throws (OutOfRangeException
            -> "if this is the minimum value")
    formal subtype predecessor;
    
}]]></programlisting>

    </section>
    
    <section id="bounded">
        <title>Bounded</title>
        
        <para>The <literal>Bounded</literal> class represents a value
        from an upper-bounded list of natural numbers.</para>
        
        <programlisting><![CDATA[public class Bounded<#max>(Bounded<#max> b)
       extends Object()
       satisfies Comparable<Bounded<#max>>, Number {
   
    doc "The |Natural| representing this natural
         number."
    public extension Natural natural { ... }

    actual Comparison compare(Bounded<#max> other) {
        return natural.compare(other.natural)
    }

    doc "This natural number, as a |Bounded<#nmax>| where
         |nmax>=max|."
    public extension Bounded<#max+inc> bounded<#inc>() { ... }
   
}]]></programlisting>
        
        <para><literal>Bounded&lt;#n&gt;</literal> does not implement 
        <literal>Ordinal</literal>, so the type 
        <literal>Range&lt;Bounded&lt;#n&gt;&gt;</literal> does not exist.
        Instead, the following utility method is provided:</para> 
        
        <programlisting><![CDATA[doc "A sequence of |Bounded<#n+1>| from
     from |0| to |n|."
public Bounded<#n+1>[n+1] zeroTo<#n>() { ... }]]></programlisting>

    </section>
    
    <section id="sequence">
        <title>Sequences</title>
        
        <para>A <literal>Sequence</literal> is a correspondence from 
        a bounded progression of natural numbers. Sequences support the 
        binary operators <literal>[].</literal> (spread), <literal>+</literal> 
        (join) and <literal>[i...]</literal> (upper range) and the ternary 
        operator <literal>[i..j]</literal> (subrange) in addition to operators 
        inherited from <literal>Correspondence</literal>:</para>

        <programlisting><![CDATA[public interface Sequence<out X> 
        is EnumerableSequence<X>
        satisfies Correspondence<Natural, X>, Iterable<X>, Container, Category
        given X satisfies Object, Equals<X> {

    doc "The index of the last element of the sequence,
         or |null| if the sequence has no elements."
    formal Natural? lastIndex;
    
    actual default Iterator<X> iterator() {
        class SequenceIterator(Natural from) 
                satisfies Iterator<X> {
            actual X? head { 
                return this[from] 
            }
            actual Iterable<X> tail {
                return SequenceIterator(from+1)
            }
        }
        if (is Iterable<X> sequence) {
            return this.iterator()
        else {
            return SequenceIterator(0)
        }
    }
    
    actual default Boolean empty {
        return !(this.lastIndex exists)
    }
    
    actual default Boolean contains(Object object) {
        if (is X object) {
            return forAny (X x in this) some (x==object)
        }
        else {
            return false
        }
    }
    
    doc "The first element of the sequence, or
         |null| if the sequence has no elements."
    default X? first {
        return this[0]
    }
    
    doc "The rest of the sequence, after removing 
         the first element."
    default X[] rest {
        return this[1...]
    }

    doc "The last element of the sequence, or
         |null| if the sequence has no elements."
    default X? last {
        if (exists Natural index = sequence.lastIndex) {
            return this[index]
        }
        else {
            return null
        }
    }
   
}]]></programlisting>
        
        <para>The metatype allows direct instantiation of <literal>X[]</literal>:</para>
        
        <programlisting><![CDATA[public interface EnumerableSequence<X>
        satisfies Callable<X[],X...> 
        given X satisfies Object, Equals<X> {
    actual default X[] call(X... elements) {
        return elements
    }
}]]></programlisting>
        
        <para>The following extension provides access to the indices 
        of the sequence in a <literal>for</literal> loop.</para>
        
        <programlisting><![CDATA[public extension class SequenceEntryIterable<X>(X[] this)
        satisfies Iterable<Entry<Natural,X>> 
        given X satisfies Object, Equals<X> {
        
    actual Iterator<Entry<Natural,X>> iterator() {
        class EntryIterator(Natural from) 
                satisfies Iterator<Entry<Natural,X>> {
            actual Entry<Natural,X>? head {
                if (exists X x = this[from]) {
                    return from->x
                }
                else {
                    return null;
                }
            }
            actual Iterable<Entry<Natural,X>> tail {
                return EntryIterator(from+1)
            }
        }
        return EntryIterator(0)
    }
    
}]]></programlisting>

        <comment><para>TODO: or should we just directly make <literal>X[]</literal> 
        assignable to <literal>Entry&lt;Natural,X&gt;[]</literal>?</para></comment>
        
        <para>The compiler is permitted to optimize away the call to these 
        extensions in a loop such as:</para>
        
        <programlisting><![CDATA[for (local elem in sequence) { 
    ...
}]]></programlisting>
        
        <para>or even:</para>
        
        <programlisting><![CDATA[for (Natural n -> local elem in sequence) {
    ...
}]]></programlisting>
        
        <para>which are both equivalent to:</para>
        
        <programlisting><![CDATA[if (exists Natural last=sequence.lastIndex) {
    mutable Natural n := 0;
    while (n<=last) { 
        local elem = sequence[n];
        ...
        ++n;
    }
}]]></programlisting>        
        
        <comment><para>TODO: for some kinds of sequences, especially linked
        lists, access by index is very inefficient. How can we make iteration
        of these kinds of sequences efficient?</para></comment>
        
        <para>Toplevel methods define the join and range operators, for 
        sequence types:</para>

        <programlisting><![CDATA[doc "The binary join operator |x + y|. The returned 
     sequence does not reflect changes to the original 
     sequences."
public T[] join<T>(T[]... sequences) 
        given T satisfies Object, Equals<T> {
            
    object joinedSequence satisfies T[] {
        actual Natural? lastIndex {
            mutable Natural? result := null;
            for (T[] s in sequences) {
                if (exists Natural last = s.lastIndex) {
                    if (exists result) {
                        result += last;
                    }
                    else {
                        result := last;
                    }
                }
            }
            return result
        }
        actual Gettable<T?> value(Natural index) {
            T? value {
                mutable Natural i := index;
                for (T[] s in sequences) {
                    if (exists Natural last = s.lastIndex) {
                        if (i<=last) {
                            return s[i]
                        }
                        else {
                            i-=last;
                        }
                    }
                }
                return null
                
            }
            return value
        }
    }
    
    return copy(joinedSequence) //take a shallow copy
    
}]]></programlisting>
        
        <programlisting><![CDATA[doc "The ternary range operator |x[from..to]|, along
     with the binary upper range |x[from...]| operator. 
     The returned sequence does not reflect changes 
     to the original sequence."
public T[] range<T>(T[] sequence, Natural from, Natural? to=sequence.lastIndex) 
        given T satisfies Object, Equals<T> {
         
    object rangeSequence satisfies T[] {
        actual Natural? lastIndex {
            if (exists Natural last = sequence.lastIndex) {
                if (exists to) {
                    if (to<last) {
                        return to-from
                    }
                    else {
                        return last-from
                    }
                }
            }
            else {
                return null
            }
        } 
        actual Gettable<T?> value(Natural index) {
            T? value {
                if (exists to) {
                    if (index>to) {
                        return null
                    }
                }
                return sequence[index+from]
            }
            return value
        }
     }

    return copy(rangeSequence) //take a shallow copy
    
}]]></programlisting>
        
        <para>There is a mutable subtype which allows assignment to
        an index.</para>
        
        <programlisting><![CDATA[public interface OpenSequence<X>
        satisfies X[], OpenCorrespondence<Natural,X> 
        given X satisfies Object, Equals<X> {}]]></programlisting>

        <para>A <literal>BoundedSequence</literal> adds a typesafe bound
        to the indices, allowing use of indices of type <literal>Bounded&lt;#n&gt;</literal>.</para>
        
        <programlisting><![CDATA[public interface BoundedSequence<out X, #n>
        satisfies X[] 
        given X satisfies Object, Equals<X> {
        
    formal Gettable<X> value(Bounded<#n> index);
    actual default Bounded<#n>? lastIndex;
    
}]]></programlisting>

        <para>The following extension provides access to the indices 
        of the bounded sequence in a <literal>for</literal> loop. The
        indices are of type <literal>Bounded&lt;#n&gt;</literal>.</para>
        
        <programlisting><![CDATA[public extension class SequenceEntryIterable<X>(X[n] this)
        satisfies Iterable<Entry<Bounded<#n>,X>> 
        given X satisfies Object, Equals<X> {
        
    actual Iterator<Entry<Bounded<#n>,X>> iterator() {
        class EntryIterator(Bounded<#n> from) 
                satisfies Iterator<Entry<Bounded<#n>,X>> {
            actual Entry<Bounded<#n>,X>? head {
                return from->this[from]
            }
            actual Iterable<Entry<Bounded<#n>,X>> tail {
                if (from+1<n) {
                    return EntryIterator(from.successor)
                }
                else {
                    return none
                }
            }
        }
        return EntryIterator(0)
    }
    
}]]></programlisting>

        <!--
        <para>A helper class adds a useful convenience attribute.</para>
        
        <programlisting><![CDATA[public extension class BoundSequences<out X,n>(X[n] sequence) {
   
    doc "A sequence of all indices of the the sequence."
    public Bounded<n>[n] indices {
        return ifTrue(n>0)
            then Bounded<n>(0)..Bounded<n>(n-1)
            otherwise {}
    }
   
}]]></programlisting>
        -->
        
        <para>There is a mutable subtype which allows assignment to an index.</para>
        
        <programlisting><![CDATA[public interface OpenBoundedSequence<X,#n>
        satisfies X[n], OpenSequence<X> 
        given X satisfies Object, Equals<X> {
    public Settable<X> value(Bounded<#n> index);
}]]></programlisting>

        <para>The value <literal>none</literal> is transparently assignable to 
        <literal>X[]</literal> and <literal>X[0]</literal>.</para>
        
        <programlisting><![CDATA[doc "Represents an empty sequence."
public object none {

    public extension class EmptySequence<out X>() 
            satisfies X[0] 
            given X satisfies Object, Equals<X> {
        
        actual Natural? lastIndex = null;
        
        actual Gettable<X?> value(Natural index) {
            X? nullValue = null;
            return nullValue 
        }
        
        actual Gettable<X> value(Bounded<#0> index) {
            throw Exception()
        }
        
    }
    
}]]></programlisting>
        
        <para>The <literal>zip()</literal> function combines <literal>BoundedSequence</literal>s 
        into a single <literal>BoundedSequence</literal>.</para>

        <programlisting><![CDATA[public T[n] zip<T,X,Y,n>(X[n] x, Y[n] y, T producing(X x, Y y)) {
    return from (Bounded<#n> i in zeroTo<#n>()) 
                select (producing(x[i],y[i]))
}]]></programlisting>

        <programlisting><![CDATA[public Entry<X,Y>[n] zip<X,Y,n>(X[n] x, Y[n] y) {
    return zip(x,y,Entry)
}]]></programlisting>

        <programlisting><![CDATA[public T[n] zip<T,X,n>(X[n] lists..., T producing(X x...)) {
    return from (Bounded<#n> i in zeroTo<#n>()) 
                select (producing(from (X[n] list in lists) select (list[i]));
}]]></programlisting>

<!--
        <programlisting><![CDATA[public T[][n] zip<T,X,n>(X[n] lists...) {
    return zip(lists,ArrayList)
}]]></programlisting>
-->
    </section>
    
    <section id="range">
        <title>Ranges</title>
        
        <para>Ranges implement <literal>Sequence</literal>, therefore they 
        support the join, subrange, contains and lookup operators, among 
        others. Ranges may be constructed using the <literal>..</literal> 
        operator:</para> 
        
        <programlisting><![CDATA[public class Range<X>(X first, X last) 
        extends Object() 
        satisfies X[], Matcher<X>, Equals<Range<X>>
        given X satisfies Object, Ordinal, Comparable<X>, Equals<X> { 
    
    doc "The first value in the range."
    public X first = first;
    
    doc "The last value in the range."
    public X last = last;
    
    doc "Return a |Sequence| of values in the range, 
         beginning at the first value, and 
         incrementing by a constant step size,
         until a value outside the range is
         reached."
    public X[] by(Natural stepSize) { 
        return from (Natural index->X value in this) 
                    where (index%stepSize == 0) 
    }
    
    public Natural? index(X x) {
        if (x<first || x>last) {
            return null
        }
        else {
            //optimize this for numbers!
            mutable Natural index:=0;
            mutable X value:=first;
            while (value<x) {
                ++index;
                ++value;
            }
            return index
        }
    }
    
    actual Iterator<X> iterator() {
        class RangeIterator(X x) 
                satisfies Iterator<X> {
            actual X? head { 
                if (x>last) { 
                    return null 
                } 
                else { 
                    return x 
                }
            }
            actual Iterator<X> tail {
                return RangeIterator(x.successor)
            }
        }
        return RangeIterator(first)
    }
    
    actual Boolean empty = last<first;
    
    actual Boolean contains(Object... objects) {
        for (Object x in objects) {
            if (is X x) {
                if ( x<first || x>last ) ) {
                    return false
                }
            }
            else {
                return false
            }
        }
        fail {
            return true
        } 
    }
    
    actual Boolean matches(X x) {
        return x>first && x<last
    }
    
    actual Natural? lastIndex = index(last);
    
    actual Gettable<X?> value(Natural n) {
        //optimize this for numbers!
        mutable Natural index:=0;
        mutable X? value:=first;
        while (index<n) {
            ++index;
            ++value;
            if (value>last) {
                value := null;
                break
            }
        }
        return value
    }
    
    actual Boolean equals(Range<X> that) {
        return that.first==first && that.last==last
    }
    
    ...
    
}]]></programlisting>
        
        <para>The compiler is permitted to optimize away creation of a
        <literal>Range</literal> in code such as the following:</para>
        
        <programlisting><![CDATA[i in min..max]]></programlisting>
        
        <para>which is equivalent to:</para>
        
        <programlisting><![CDATA[(i>=min && i<=max)]]></programlisting>
        
        <para>and:</para>
        
        <programlisting><![CDATA[for (local i in min..max) {
    ...
}]]></programlisting>
    
        <para>which is equivalent to:</para>
        
        <programlisting><![CDATA[mutable local i := min;
while (i<=max) {
    ...
    i.=successor;
}]]></programlisting>
        
    </section>
    
    <section id="characterandstring">
        <title>Characters and strings</title>
        
        <para>UTF-16 Unicode Characters are represented by the following class:</para>

        <programlisting><![CDATA[public class Character(small Natural utf16)
        extends Object()
        satisfies Ordinal, Comparable<Character>, Matcher<Character> { 
    ... 
    
    doc "The UTF-8 encoding"
    public String utf8 { return ... }
    
    public Character lowercase { return .. }
    public Character uppercase { return .. }
    
    public extension class StringToCharacter(String this) {
    
        doc "Parse the string representation of a |Character| in UTF-16"
        public Character parseUtf16Character() { return ... }
    
        doc "Parse the string representation of a |Character| in UTF-8"
        public Character parseUtf8Character() { return ... }
    
    }
 
}]]></programlisting>
        
        <para><literal>String</literal> implements <literal>Sequence</literal>, 
        and therefore supports the join, subrange, contains and lookup operators, 
        among others. Any <literal>Character[]</literal> may be transparently
        converted to <literal>String</literal>.</para> 
                
        <programlisting><![CDATA[public extension class String(Character[] this) 
        extends Object() 
        satisfies Character[], Comparable<String>, Matcher<String>, Format {
    
    Character[] chars;
    if (is String this) {
        chars = this;
    }
    else {
        chars = copy(this)
    }
    
    ... 
    
    doc "Split the string into tokens, using the given
         separator characters."
    public Iterable<String> tokens(Iterable<Character> separators=" ,;\n\l\r\t") { return ... }
    
    doc "Split the string into lines of text."
    public Iterable<String> lines() { return tokens("\n\l\r") }
    
    public String replace(Character with(Character character)) { return ... }
    
    public String replace(Character character -> Character replacement) {
        return replace() with (Character c) 
            (ifTrue (c==character) then (replacement) otherwise (c))
    }
    
    public String replace(Correspondence<Character,Character> replacements) { 
        return replace() with (Character c) (replacements[c] ? c)
    }
    
    doc "The string, with all characters in lowercase."
    public String lowercase {
        return replace() with (Character c) (c.lowercase)
    }
    
    doc "The string, with all characters in uppercase."
    public String uppercase {
        return replace() with (Character c) (c.uppercase)
    }
    
    doc "Remove the given characters from the beginning 
         and end of the string.
    public String strip(Character[] whitespace = " \n\l\r\t") { return ... }
    
    doc "Collapse substrings of the given characters into
         single space characters."
    public String normalize(Character[] whitespace = " \n\l\r\t") { return ... }
    
    doc "Join the given strings, using this string as
         a separator."
    public String join(String... strings) { return ... }
    
}]]></programlisting>
        
        <para>The extension class <literal>StringBuilder</literal> makes it more 
        efficient to produce a string using procedural code:</para>
        
        <programlisting><![CDATA[public extension class StringBuilder(Character[] this) {
        
    Character[] with(Character[] appendedStrings...) {
        mutable OpenList<Character> list = ArrayList<Character>(this);
        list.append(string);
        for (Character[] s in appendedStrings) {
            list.append(s);
        }
    }
    
    Character[] forEach<X>(iterated Iterable<X> objects, 
                           Character[] with(coordinated X x)) {
        mutable OpenList<Character> list = ArrayList<Character>(this);
        for (X x in objects) {
            list.append(with(x));
        }
        return list 
    }
    
    Character[] forEach<X>(iterated Iterable<X> objects, 
                           Character[][] with(coordinated X x)) {
        mutable OpenList<Character> list = ArrayList<Character>(this);
        for (X x in objects) {
            for (Character[] s in with(x)) {
                list.append(s);
            }
        }
        return list 
    }
       
}]]></programlisting>

        <comment><para>TODO: Is this OK, or is it going to need to be a mutable 
        class?</para></comment>
        
        <!--
        <para>A string template is represented by an instance of <literal>StringTemplate</literal>.</para>
        
        <programlisting>public class StringTemplate(...) {
        
    doc "Evaluate all interpolated expressions, producing 
         a constant character string with no interpolated
         expressions."
    public extension String interpolate() { return ... }

}</programlisting>
        -->
        
    </section>
    
    <section id="regex">
        <title>Regular expressions</title>
        
        <programlisting><![CDATA[public extension class Regex(Quoted this)
        satisfies Matcher<String> { 
        
    doc "Return the substrings of the given string which
         match the parenthesized groups of the regex,
         ordered by the position of the opening parenthesis
         of the group." 
    public Match? matchList(String string)() { return ... }
    
    doc "Determine if the given string matches the regex."
    actual Boolean matches(String string) { return ... }
    
    ... 
    
}]]></programlisting>
        
        <comment><para>TODO: I assume these are just Java (Perl 5-style) regular 
        expressions. Is there some other better syntax around? Something BNF-like,
        perhaps?</para></comment>

    </section>
    
    <section id="number">
        <title>Numbers</title>
        
        <para>Ceylon's numeric type system is designed to accommodate the following
        considerations:</para>
        
        <itemizedlist>
            <listitem>
                <para>The system is extensible and new numeric types may be defined
                by libraries. Numeric types defined by libraries should work the 
                same as built-in numeric types.</para>
            </listitem>
            <listitem>
                <para>Two values of different numeric types should be combinable
                using operators without the need for explicit type conversions, 
                but</para>
            </listitem>
            <listitem>
                <para>implicit type conversions should never lose information
                and</para>
            </listitem>
            <listitem>
                <para>binary operators must be symmetric.</para>
            </listitem>
            <listitem>
                <para>Furthermore, there should be no special cases in the language 
                definition or type checker to accommodate numeric types.</para>
            </listitem>
            <listitem>
                <para>However, it must be possible for the compiler to optimize 
                certain of the built-in numeric types to take advantage of the VM's 
                native support for numeric types.</para>
            </listitem>
            <listitem>
                <para>It is not necessary to encode information about the limits
                of the machine's representation of a numeric value into the type
                system. A single <literal>Integer</literal> class is sufficient
                to represent 32, 64, or 128 bit integer values. A single 
                <literal>Float</literal> class is sufficient to represent single
                and double precision floating point values. It is simply not
                possible for the compiler to detect numeric overflow or loss of
                significant precision.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <literal>Number</literal> interface is the abstract supertype
        of all classes which represent numeric values.</para>
        
        <programlisting><![CDATA[public interface Number {
    
    doc "Determine if the number represents
         an integer value"
    formal Boolean integral;
    
    doc "Determine if the number is positive"
    formal Boolean positive;
    
    doc "Determine if the number is negative"    
    formal Boolean negative;

    doc "Determine if the number is zero"
    formal Boolean zero;
    
    doc "Determine if the number is one"
    formal Boolean unit;
    
    doc "The number, represented as a |Decimal|"
    formal Decimal decimal;

    doc "The number, represented as a |Float|"
    throws (FloatOverflowException
            -> "if the number is too large to be
                represented as a |Float|")
    formal Float float;
    
    doc "The number, represented as an |Whole|,
         after truncation of any fractional 
         part"
    formal Whole whole;
    
    doc "The number, represented as an |Integer|,
         after truncation of any fractional 
         part"
    throws (IntegerOverflowException
            -> "if the number is too large to be
                represented as an |Integer|")
    formal Integer integer;
    
    doc "The number, represented as a |Natural|,
         after truncation of any fractional 
         part"
    throws (NegativeNumberException
            -> "if the number is negative")
    formal Natural natural;
    
    doc "The magnitude of the number"
    formal subtype magnitude;
    
    doc "1 if the number is positive, -1 if it
         is negative, or 0 if it is zero."
    formal subtype sign;
    
    doc "The fractional part of the number,
         after truncation of the integral
         part"
    formal subtype fractionalPart;
    
    doc "The integral value of the number 
         after truncation of the fractional
         part"
    formal subtype wholePart;

}]]></programlisting>

        <para>It is not possible to perform arithmetic or comparisons upon
        a <literal>Number</literal> without additional information about its
        type.</para>

        <para>The subtype <literal>Numeric</literal> supports the binary 
        operators <literal>+,-, *, /, **</literal>. In addition, 
        <literal>mutable</literal> values of type <literal>Numeric</literal> 
        support the compound assignment operators 
        <literal>+=, -=, /=, *=</literal>.</para>

<programlisting><![CDATA[public interface Numeric<N>
        satisfies Number, Comparable<N>
        given N satisfies Numeric<N> {

    doc "The binary |+| operator"
    formal N plus(N number);

    doc "The binary |-| operator"
    formal N minus(N number);

    doc "The binary |*| operator"
    formal N times(N number);

    doc "The binary |/| operator"
    formal N divided(N number);

    doc "The binary |**| operator"
    formal N power(N number);
    
}]]></programlisting>

        <comment><para>TODO: I suppose <literal>Numeric</literal> should not extend
        <literal>Comparable</literal>, since complex numbers are not comparable.</para></comment>

        <para>The subtype <literal>Integral</literal> supports the binary 
        operator <literal>%</literal>, and inherits the unary operators 
        <literal>++</literal> and <literal>--</literal> from 
        <literal>Ordinal</literal>.</para>

<programlisting><![CDATA[public interface Integral<N>
        satisfies Numeric<N>, Ordinal
        given N satisfies Number {

    doc "The binary |%| operator"
    formal N remainder(N number);

}]]></programlisting>

        <para>The type <literal>Invertable</literal> supports the unary
        prefix <literal>-</literal> operator.</para>
        
        <programlisting><![CDATA[public interface Invertable<I> 
    given I satisfies Number {
    
    doc "The unary |-| operator"
    formal I inverse;

}]]></programlisting>
        
        <para>Five numeric types are built in:</para>

        <para><literal>Natural</literal> represents 63 bit unsigned integers
        (including zero).</para>
        
        <programlisting><![CDATA[public class Natural(Natural natural)
        extends Object() 
        satisfies Integral<Natural>, Invertable<Integer>, Matcher<Integer> { 
    ... 
    
    doc "Implicit type promotion to |Integer|"
    actual extension Integer integer { return ... }
    
    doc "Implicit type promotion to |Whole|"
    actual extension Whole whole { return ... }
    
    doc "Implicit type promotion to |Float|"
    actual extension Float float { return ... }
    
    doc "Implicit type promotion to |Decimal|"
    actual extension Decimal decimal { return ... }

    doc "Shift bits left by the given number of places"
    public Natural leftShift(Natural digits) { return ... }
    
    doc "Shift bits right by the given number of places"
    public Natural rightShift(Natural digits) { return ... }
    
    public extension class StringToNatural(String this) {
    
        doc "Parse the string representation of a |Natural| in the given radix"
        public Natural parseNatural(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <comment><para>TODO: the <literal>Numeric</literal> type is much more complicated
        because of <literal>Natural</literal>. As an alternative approach, we could replace
        <literal>Natural</literal> with a <literal>Binary</literal> type, and have 
        <literal>Integer</literal> literals instead of <literal>Natural</literal> 
        literals. I don't love this, because natural numbers are especially common in real
        applications.</para></comment>

        <para><literal>Integer</literal> represents 64 bit signed integers.</para>

        <programlisting><![CDATA[public class Integer(Boolean sign, Natural natural)
        extends Object() 
        satisfies Integral<Integer>, Invertable<Integer>, Matcher<Integer> {
    ...
    
    doc "Implicit type promotion to |Whole|"
    actual extension Whole whole { return ... }
    
    doc "Implicit type promotion to |Float|"
    actual extension Float float { return ... }

    doc "Implicit type promotion to |Decimal|"
    actual extension Decimal decimal { return ... }

    public extension class StringToInteger(String this) {
    
        doc "Parse the string representation of an |Integer| in the given radix"
        public Integer parseInteger(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <para><literal>Whole</literal> represents arbitrary-precision
        signed integers.</para>

        <programlisting><![CDATA[public class Whole(Boolean sign, small Natural... digits)
        extends Object() 
        satisfies Integral<Whole>, Invertable<Whole> {
    ...
    
    public small Natural precision = ...;
    
    doc "Implicit type promotion to |Decimal|"
    actual extension Decimal decimal { return ... }
    
    public extension class StringToWhole(String this) {
    
        doc "Parse the string representation of a |Whole| in the given radix"
        public Whole parseWhole(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>
        
        <para><literal>Float</literal> represents 64 bit floating point
        values.</para>

        <programlisting><![CDATA[public class Float(Float float)
        extends Object() 
        satisfies Numeric<Float>, Invertable<Float> { 
    ... 
    
    doc "The natural logarithm of the number"
    public Float ln { return ... }
    
    doc "Implicit type promotion to |Decimal|"
    actual extension Decimal decimal { return ... }
    
    public extension class StringToFloat(String this) {
    
        doc "Parse the string representation of a |Float| in the given radix"
        public Float parseFloat(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <para><literal>Decimal</literal> represents arbitrary-precision
        and arbitrary-scale decimals.</para>

        <programlisting><![CDATA[public class Decimal(Whole value, small Integer scale)
        extends Object() 
        satisfies Numeric<Decimal>, Invertable<Decimal> {
    ...

    public small Natural precision = ...;
    public small Integer scale = ...;
    
    public extension class StringToDecimal(String this) {
    
        doc "Parse the string representation of a |Decimal| in the given radix"
        public Decimal parseDecimal(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

    </section>
    
    <section id="slots">
        <title>Slotwise operations</title>
        
        <para>The interface <literal>Slots</literal> defines the slotwise 
        binary operators <literal>|, &amp;, ^</literal> and <literal>~</literal>. 
        For any implementation of <literal>Slots</literal>, there should be 
        a "slot" function that accepts a key and returns a 
        <literal>Boolean</literal>.</para>
        
        <programlisting><![CDATA[public interface Slots<B>
        given B satisfies Slots<B> {
        
    doc "Slotwise or operator |x | y|. Implementations
         should respect the constraint that 
         |(x|y).slot(z)==(x.slot(z)||y.slot(z))|."
    formal B or(B bits);
    
    doc "Slotwise and operator |x & y|. Implementations
         should respect the constraint that 
         |(x&y).slot(z)==(x.slot(z)&&y.slot(z))|."
    formal B and(B bits);
    
    doc "Slotwise xor operator |x ^ y|. Implementations
         should respect the constraint that 
         |(x^y).slot(z)==((x|y).slot(z)&&!(x&y).slot(z))|.""
    formal B xor(B bits);
    
    doc "Slotwise complement in operator |x ~ y|. 
         Implementations should respect the constraint 
         that |(x~y).slot(z)==(x.slot(z)&&!y.slot(z))|.""
    formal B complement(B bits);
    
}]]></programlisting>

        <para><literal>Set</literal> extends <literal>Slots</literal>. 
        In the case of a set, <literal>|</literal> represents union, 
        <literal>&amp;</literal> represents intersection, and
        <literal>~</literal> represents set complement.</para>

        <para>The interface <literal>FixedSlots</literal> defines the 
        unary operator <literal>~</literal>.</para>
        
        <programlisting><![CDATA[public interface FixedSlots<B> 
        satisfies Slots<B> {
        
    doc "Slotwise complement operator |~x|. 
         Implementations should respect the constraint 
         that |(~x).slot(z)==!x.slot(z)|."
    formal Bits<#n> complement;
    
}]]></programlisting>

    </section>
        
    <section id="bitstrings">
        <title>Bit strings</title>
        
        <para>The interface <literal>Bits</literal> represents a fixed length
        string of boolean values, and supports the unary operator 
        <literal>~</literal>.</para>
        
        <programlisting><![CDATA[public interface Bits<#n> 
        satisfies Boolean[n], Equals<Bits<#n>>, FixedSlots<Bits<#n>> {}]]></programlisting>

        <comment><para>TODO: should we model <literal>Bits&lt;#n&gt;</literal> as 
        a decorator of <literal>Boolean[n]</literal>, like what we do with 
        <literal>String</literal> and <literal>Character[]</literal>?</para></comment>

        <para>Boolean values are transparently converted to and from 
        <literal>Bits&lt;1&gt;</literal>.</para>

        <programlisting><![CDATA[public extension class BooleanBit(Boolean this)
        satisfies Bits<1> {

    public extension Boolean boolean { return this }

    actual Bits<1> or(Bits<1> bit) {
        if (this) {
            return this
        else {
            return bit
        }
    }
    
    actual Bits<1> and(Bits<1> bit) {
        if (this) {
            return bit
        else {
            return false
        }
    }
    
    actual Bits<1> xor(Bits<1> bit) {
        if (this) {
            return bit.complement
        else {
            return bit
        }
    }
    
    actual Bits<1> complement(Bits<1> bit) {
        if (this) {
            return bit.complement
        else {
            return this
        }
    }
    
    actual Bits<1> complement {
        return BooleanBit(!this)
    }
    
    actual Gettable<Boolean> value(Bounded<1> index) {
        return this
    }
    
    actual Gettable<Boolean?> value(Natural key) {
        Boolean? result;
        if (key==0) {
            result = boolean 
        }
        else {
            result = null
        }
        return result
    }
    
    actual Bounded<1> lastIndex {
        return 0
    }
    
}]]></programlisting>

        <!--
        <programlisting><![CDATA[public extension Bits<1> booleanToBits(Boolean b) { .... }]]></programlisting>
        <programlisting><![CDATA[public extension Boolean bitsToBoolean(Bits<1> b) { return b[0] }]]></programlisting>
        -->

        <comment><para>TODO: we need a bunch of functions for converting bit 
        strings to and from numeric values, characters, etc.</para></comment>
        
    </section>
    
    <section id="metamodel">
        <title>Metamodel</title>
        
        <para>The metamodel (reflection API) reifies the schema of a type, making it
        available to the program at runtime.</para>
        
        <para>A <literal>Function</literal> represents a toplevel method.</para>

        <programlisting><![CDATA[public interface Function<out R, P...> 
        satisfies Callable<R, P...>, Annotated {
        
    formal String name;
    
    formal Boolean extension;
    
    formal Visiblity visibility;
    
    formal Type<R> returnType;
    formal Parameter<Object>[] parameters;
    
    formal void intercept( R onInvoke(R proceed(P... args), P... args) )();

}]]></programlisting>

        <para>A <literal>Value</literal> represents a toplevel attribute.</para>

        <programlisting><![CDATA[public interface Value<out T> 
        satisfies Annotated {
    
    formal String name;
    
    formal Boolean mutable;    
    
    formal Visiblity visibility;
    
    formal Type<T> type;
    
    formal extension Gettable<T> value;
    
    formal void intercept( T onGet(T proceed()) )();

}]]></programlisting>

        <programlisting><![CDATA[public interface MutableValue<T> 
        satisfies Value<T> {
        
    actual formal Settable<T> value;
    
    formal void intercept( void onSet(void proceed(T value), T value) )();

}]]></programlisting>

        <comment><para>TODO: should <literal>onSet()</literal> return the new value of
        the attribute instead of being <literal>void</literal>?</para></comment>

        <para>An instance of <literal>Type</literal> represent a type: an interface or 
        class, together with type arguments.</para>
        
        <programlisting><![CDATA[public interface Type<out X> 
        satisfies Annotated {
        
    formal String name;
    
    formal Boolean mutable;
    
    formal Visiblity visibility;
    
    doc "Return all the attributes of the given 
         type."
    formal Set<Attribute<X,T>> attributes<T>(Type<T> type = Object);
    
    doc "Return all the methods of the given 
         callable type."
    formal Set<Method<X,R,P...>> methods<R,P...>(Type<Callable<R,P...>> type);
    
    doc "Return all the instantiable member classes 
         of the given callable type."
    formal Set<MemberConcreteClass<X,Y,P...>> concreteClasses<Y,P...>(Type<Callable<Y,P...>> type);
    
    doc "Return all the member types which are subtypes 
         of the given type."
    formal Set<MemberType<X,Y>> types<Y>(Type<Y> type = Object);
    
    ...
    
}]]></programlisting>
        
        <para>An instance of <literal>Interface</literal> represents an interface.</para>
        
        <programlisting><![CDATA[public interface Interface<out X> 
        satisfies Type<X> {}]]></programlisting>

        <para>An instance of <literal>Class</literal> represents a class.</para>
        
        <programlisting><![CDATA[public interface Class<out X> 
        satisfies Type<X> {
    
    formal Boolean abstract;
    
}]]></programlisting>

        <para>An instance of <literal>ConcreteClass</literal> represents a class
        which can be directly instantiated.</para>
        
        <programlisting><![CDATA[public interface ConcreteClass<out X, P...> 
        satisfies Class<X>, Callable<X,P...> {
    
    formal Boolean extension;
    
    formal Parameter<Object>[] parameters;
    
}]]></programlisting>

        <para>An instance of <literal>Member</literal> represents a method, attribute,
        or member type.</para>

        <programlisting><![CDATA[public interface Member<in X, out T> 
        satisfies Annotated, Callable<T,X> {
    
    formal String name;
    
    formal Boolean default;
    formal Boolean formal;
    formal Boolean actual;
    formal Boolean extension;
    
    formal Visiblity visibility;
    
    formal Type<T> memberType;
    
}]]></programlisting>

        <para>A <literal>Method</literal> represents a method declaration.</para>

        <programlisting><![CDATA[public interface Method<in X, R, P...> 
        satisfies Member<X, Function<R, P...>> {
        
    formal Type<R> returnType;
    formal Parameter<Object>[] parameters;
    
    formal void intercept<S>( R onInvoke(S instance, R proceed(P... args), P... args) )()
                    given S abstracts X;
    
}]]></programlisting>

        <para>An <literal>Attribute</literal> represents an attribute declaration.</para>

        <programlisting><![CDATA[public interface Attribute<in X, T> 
        satisfies Member<X, Value<T>> {
        
    formal Boolean mutable;
    
    formal void intercept<S>( T onGet(S instance, T proceed()) )()
                    given S abstracts X;
    
}]]></programlisting>

        <programlisting><![CDATA[public interface MutableAttribute<in X, T> 
        extends Attribute<X, T>
        satisfies Member<X, MutableValue<T>> {  //this is OK since Member is covariant in T
        
    formal void intercept<S>( void onSet(S instance, void proceed(T value), T value) )()
                    given S abstracts X;
    
}]]></programlisting>

        <para>An instance of <literal>MemberType</literal> represents a member 
        type.</para>
        
        <programlisting><![CDATA[public interface MemberType<X, Y> 
        satisfies Type<Y>, Member<X, Type<Y>> {}]]></programlisting>

        <para>An instance of <literal>MemberInterface</literal> represents a member 
        interface.</para>
        
        <programlisting><![CDATA[public interface MemberInterface<X, Y> 
        satisfies MemberType<X, Y>, Member<X, Interface<Y>> {}]]></programlisting>

        <para>An instance of <literal>MemberClass</literal> represents a member 
        class.</para>
        
        <programlisting><![CDATA[public interface MemberClass<X, Y> 
        satisfies MemberType<X, Y>, Member<X, Class<Y>> {}]]></programlisting>

        <para>An instance of <literal>MemberConcreteClass</literal> represents a member 
        class that can be directly instantiated.</para>
        
        <programlisting><![CDATA[public interface MemberConcreteClass<X, Y, P...> 
        satisfies MemberType<X, Y>, Member<X, ConcreteClass<Y,P...>> {
    
    formal Parameter<Object>[] parameters;
    
    formal void intercept<S>( Y onCreate(S instance, Y proceed(P... args), P... args) )()
                    given S abstracts X;
    
}]]></programlisting>

        <para>A <literal>Parameter</literal> represents a parameter of a method 
        or class.</para>

        <programlisting><![CDATA[public interface Parameter<out T> 
        satisfies Annotated {
    formal String name;
    formal Type<T> type;
}]]></programlisting>

        <para>An <literal>Annotated</literal> program element may be asked for a
        list of its annotation values.</para>

        <programlisting><![CDATA[public interface Annotated {
    doc "Return all the annotation values that are 
         assignable to the given type."
    formal T[] annotations<T>(Type<T> type = Object) 
            given T satisfies Object;
}]]></programlisting>

        <para>An interceptor may be removed by invoking the returned method reference:</para>

        <programlisting><![CDATA[void removeSayInterceptor() = person.say.intercept() 
    onInvoke(void proceed(String words), String words) { 
        proceed(words.uppercase);
    };
...
removeSayInterceptor();]]></programlisting>

    </section>
    
    <section id="process">
        <title>The current process</title>
        
        <para>The object <literal>process</literal> provides information about the
        current process, command line arguments, and access to the standard input 
        and output streams.</para>
        
        <programlisting><![CDATA[public object process {
    
    public List<String> args = ... ;
    
    public Map<String,String> properties = ... ;
    
    public extension OutputStream out = .... ;
    public extension InputStream in = .... ;
    
}]]></programlisting>
        
    
    </section>
    
    <section id="formattingobjects">
        <title>Formatting objects</title>
        
        <para>The interface <literal>Format</literal> defines a method
        to produce a <literal>String</literal> representation of a certain object.
        An expression of type <literal>FormattedObject</literal> may be the target
        of the format operator <literal>$</literal> or may be used in a string
        template. Classes should not implement <literal>FormattedObject</literal> 
        directly. Instead, an extension may decorate a class with a representation
        in a particular format.</para>
        
        <programlisting>public interface Format {
    formal String formatted;
}</programlisting>

        <para>The package <literal>ceylon.language.util</literal>, which is not imported
        by default, defines a format useful only for debugging purposes:</para>
        
        <programlisting>public extension class DebugFormat(Object? obj) 
        satisfies Format {
    actual String formatted {
        if (obj exists) {
            return obj.string;
        }
        else {
            return "null"
        }
    }
}</programlisting>

        <para>A compilation unit selects a format by enabling the corresponding  
        extension.</para>
        
    </section>
    
    <section id="logging">
        <title>Logging</title>
        
        <para>The class <literal>lang.Log</literal> allows all modules in an application
        to send log messages to a common output stream.</para>
        
        <programlisting><![CDATA[public class Log(LogChannel channel, String category) {
    
    public void log(LogPriority priority, Gettable<String> message) {
        if ( channel.enabled(priority) ) {
            send(priority, message) );
        }
    }
    
    public void log(LogPriority priority, String message) {
        if ( channel.enabled(priority) ) {
            send(priority, message) );
        }
    }
    
    void send(LogPriority priority, String message) {
        channel.send( priority, LogMessage(priority, category, message) );
    }
    
}]]></programlisting>

        <para>The class <literal>LogPriority</literal> defines an extensible set of
        levels of importance for log messages.</para>

        <programlisting><![CDATA[public object trace extends LogPriority("Trace", 100) {}
public object info extends LogPriority("Info", 200) {}
public object warn extends LogPriority("Warn", 300) {}
public object error extends LogPriority("Error", 400) {}

doc "The severity of a log message."
public abstract class LogPriority(String string, Natural priority) {
    actual String string = string;
    module Natural priority = priority;
}]]></programlisting>

        <para>The class <literal>LogMessage</literal> describes a log message:</para>
        
        <programlisting><![CDATA[public class LogMessage(LogPriority priority, String category, String message) {
    public Priority priority = priority;
    public String category = category;
    public String message = message;
    public Datetime datetime = currentDatetime();
}]]></programlisting>

        <para>The following extensions make it easy to log from any object:</para>
        
        <programlisting><![CDATA[public extension class ObjectLog(Object this) {
    public Log log { 
        return Log(defaultLogChannel, this.type.name);
    }
}]]></programlisting>

        <programlisting><![CDATA[public extension class Logs(Log this) {
    public void debug(Gettable<String> message) { this.log(debug, message); }
    public void debug(String message) { this.log(debug, message); }
    public void info(Gettable<String> message) { this.info(debug, message); }
    public void info(String message) { this.info(debug, message); }
    public void warn(Gettable<String> message) { this.warn(debug, message); }
    public void warn(String message) { this.warn(debug, message); }
    public void error(Gettable<String> message) { this.error(debug, message); }
    public void error(String message) { this.error(debug, message); }
}]]></programlisting>
    
    </section>
    
    <!--
    
    <section id="datetime">
        <title>Instants, intervals and durations</title>
        
        <comment><para>TODO: this stuff is just for illustration, the real
        date/time API will be much more complex and fully internationalized.</para></comment>
        
        <programlisting><![CDATA[public class Instant() {
    ...
}]]></programlisting>

        <programlisting><![CDATA[public class Time(Natural hours, Natural minutes, 
        Natural? seconds=null, Natural? milliseconds=null,
        Timezone? timezone=null) 
        extends Instant() {
    public Natural hours = hours;
    public Natural minutes = minutes;
    public Natural? seconds = seconds;
    public Natural? milliseconds = milliseconds;
    public Timezone? timezone = timezone;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[public class Date(Integer year, Natural month, Natural day) 
        extends Instant() {
    public Integer year = year;
    public Natural month = month;
    public Natural day = day;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[public class Datetime(Time time, Date date) 
        extends Instant() {
    public Time time = time;
    public Date date = date;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[public class Interval<X>(X start, X end) 
        given X satisfies Instant {
    public X start = start;
    public X end = end;
    public Duration<X> duration { return ... }
    ...
}]]></programlisting>

        <programlisting><![CDATA[public class Duration<X>(Map<Granularity<X>, Natural> magnitude) 
        given X satisfies Instant {

    public Map<Granularity<X>, Natural> magnitude = magnitude;
    
    public X before(X instant) { ... }
    public X after(X instant) { ... }
    
    public Datetime before(Datetime instant) { ... }
    public Datetime after(Datetime instant) { ... }
    
    public Duration<X> add(Duration<X> duration) { ... }
    public Duration<X> subtract(Duration<X> duration) { ... }
    
    ...
}]]></programlisting>

        <programlisting><![CDATA[public interface Granularity<X> 
        given X satisfies Instant {}]]></programlisting>

        <programlisting><![CDATA[public class DateGranularity()
        satisfies Granularity<Date> {
    case year, 
    case month, 
    case week, 
    case day;
}]]></programlisting>

        <programlisting><![CDATA[public class TimeGranularity()
        satisfies Granularity<Time> {
    case hour, 
    case minute, 
    case second, 
    case millisecond;
}]]></programlisting>
        
    </section>
    
    -->
    
    <section id="control">
        <title>Control expressions</title>
        
        <para>The <literal>ceylon.language.assertion</literal> package defines 
        support for assertions.</para>
        
        <programlisting><![CDATA[doc "Assert that the block evaluates to true. The block 
     is executed only when assertions are enabled. If
     the block evaluates to false, throw an 
     |AssertionException| with the given message."
public void assert(Gettable<String> message, Boolean that()) {
    Boolean callerAssertionsEnabled  = ... ;
    if ( assertionsEnabled && !that() ) {
        throw AssertionException(message)
    }
}]]></programlisting>

        <comment><para>TODO: or should we do something more like what we do for
        logging, so that we get the caller class passed in?</para></comment>
    
        <para>The <literal>ceylon.language.conditional</literal> package defines 
        support for conditional expressions.</para>
        
        <programlisting><![CDATA[doc "If the condition is true, evaluate first block,
     and return the result. Otherwise, return |null|."
public Y? ifTrue<Y>(Boolean condition,
                    Y then()) {
    if (condition) {
        return then()
    }
    else {
        return null
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the condition is true, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
public Y ifTrue<Y>(Boolean condition,
                   Y then(), 
                   Y otherwise()) {
    if (condition) {
        return then()
    }
    else {
        return otherwise()
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the value is non-null, evaluate first block,
     and return the result. Otherwise, return |null|."
public Y? ifExists<X,Y>(specified X? value,
                        Y then(coordinated X x)) {
    if (exists value) {
        return then(value)
    }
    else {
        return null
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the value is non-null, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
public Y ifExists<X,Y>(specified X? value,
                       Y then(coordinated X x), 
                       Y otherwise()) {
    if (exists value) {
        return then(value)
    }
    else {
        return otherwise()
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the given list is empty, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
public Y ifEmpty<X,Y>(X[] list,
                      Y then(), 
                      Y otherwise(X first, X... rest)) {
    if (exists X first = list.first) {
        return otherwise(first, list.rest)
    }
    else {
        return then()
    }
}]]></programlisting>

        <para>The <literal>ceylon.language.exceptional</literal> package defines 
        support for exceptional expressions.</para>
        
        <programlisting><![CDATA[doc "Attempt to evaluate the first block. If an 
     exception occurs that matches the second block, 
     evaluate the block."
public Y attempt<Y,E>(Y seek(),
                      Y except(E e)) {
    try {
        return seek()
    }
    catch (E e) {
        return except(e)
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "Using the given resource, attempt to evaluate 
     the first block."
public Y using<X,Y>(specified X resource,
                    Y seek(coordinated X x))
        given X satisfies Usable {
    try (resource) {
        return seek(resource)
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "Using the given resource, attempt to evaluate 
     the first block. If an exception occurs that 
     matches the second block, evaluate the second 
     block."
public Y using<X,Y,E>(specified X resource,
                      Y seek(coordinated X x),
                      Y except(E e))
        given X satisfies Usable {
    try (resource) {
        return seek(resource)
    }
    catch (E e) {
        return except(e)
    }
}]]></programlisting>
    
<!--

        <programlisting><![CDATA[doc "Evaluate the block which matches the selector value, and
     return the result of the evaluation. If no block matches
     the selector value, return a null value."
public Y? select<X,Y>(X selector,
                              cases Iterable<Entry<Matcher<X>, functor Y()>> value) {
    for (Matcher<X> match -> X evaluate() in value) {
        if ( match.test(selector) ) {
            return evaluate(value)
        }
    }
    return null;
}]]></programlisting>

        <programlisting><![CDATA[doc "Evaluate the block which matches the selector value, and
     return the result of the evaluation. If no block matches
     the selector value, evaluate the last block and return
     the result of the evaluation."
public Y select<X,Y>(X selector,
                     cases Iterable<Entry<Matcher<X>, functor Y()>> value,
                     Y otherwise()) {
    if (exists Y y = select(selector, value)) {
        return y
    }
    else {
        return otherwise()
    }
}]]></programlisting>

-->

        <para>The <literal>ceylon.language.repetition</literal> package defines 
        support for loops.</para>
        
        <programlisting><![CDATA[doc "Repeat the block the given number of times."
public void repeat(Natural repetitions, void times()) {
    mutable Natural n:=0; 
    while (n<repetitions) {
        times();
        n++;
    }
}]]></programlisting>
    
        <para>The <literal>ceylon.language.quantification</literal> package defines 
        support for quantifiers.</para>
        
        <programlisting><![CDATA[doc "Count the elements for which the block 
     evaluates to true."
public Natural count<X>(iterated Iterable<X> elements,
                        Boolean where(coordinated X x)) {
    mutable Natural count := 0;
    for (X x in elements) {
        if ( where(x) ) {
            ++count;
        }
    }
    return count
}]]></programlisting>

        <programlisting><![CDATA[doc "Return true iff for every element, the block 
     evaluates to true."
public Boolean forAll<X>(iterated Iterable<X> elements,
                         Boolean every(coordinated X x)) {
    for (X x in elements) {
        if ( !every(x) ) {
            return false
        }
    }
    return true
}]]></programlisting>

        <programlisting><![CDATA[doc "Return true iff for some element, the block 
     evaluates to true."
public Boolean forAny<X>(iterated Iterable<X> elements,
                         Boolean some(coordinated X x)) {
    Boolean where(X x) { return !some(x) }
    return !forAll(elements, where)
}]]></programlisting>

        <programlisting><![CDATA[doc "Return the first element for which the block 
     evaluates to true, or |null|if no such element 
     is found."
public X? first<X>(iterated Iterable<X> elements,
                   Boolean where(coordinated X x)) {
    for (X x in elements) {
        if ( where(x) ) {
            return x
        }
    }
    return null
}]]></programlisting>

        <programlisting><![CDATA[doc "Return the first element for which the first 
     block evaluates to true, or the result of 
     evaluating the second block, if no such 
     element is found."
public X first<X>(iterated Iterable<X> elements,
                  Boolean where(coordinated X x),
                  X otherwise()) {
    if (exists X first = first(elements, where)) {
        return first
    }
    else {
        return otherwise()
    }
}]]></programlisting>
        
        <para>The <literal>ceylon.language.comprehension.list</literal> package defines 
        support for <literal>List</literal> comprehensions, tabulations, and folds.</para>
        
        <programlisting><![CDATA[doc "Iterate elements and return those for which 
     the first block evaluates to true, ordered 
     using the second block, if specified."
public List<X> from<X,C>(iterated Iterable<X> elements,
                         Boolean where(coordinated X x),
                         C by(coordinated X x) = naturalOrder) 
        given C satisfies Comparable<C> {
    X select(X x) { return x }
    return from(elements, where, select, by)
}]]></programlisting>

        <programlisting><![CDATA[doc "Iterate elements and for each element evaluate 
     the first block. Build a list of the resulting 
     values, ordered using the second block, if 
     specified."
public List<Y> from<X,Y,C>(iterated Iterable<X> elements,
                           Y select(coordinated X x),
                           C by(coordinated X x) = naturalOrder) 
        given C satisfies Comparable<C> {
    Boolean where(X x) { return true }
    return from(elements, where, select, by)
}]]></programlisting>

        <programlisting><![CDATA[doc "Iterate elements and select those for which 
     the first block evaluates to true. For each of 
     these, evaluate the second block. Build a list 
     of the resulting values, ordered using the 
     third block, if specified."
public List<Y> from<X,Y,C>(iterated Iterable<X> elements,
                           Boolean where(coordinated X x), 
                           Y select(coordinated X x),
                           C by(coordinated X x) = naturalOrder) 
        given C satisfies Comparable<C> {
    OpenList<Y> list = ArrayList<Y>();
    for (X x in elements) {
        if ( where(x) ) {
            list.append( select(x) );
        }
    }
    list.sort(by);
    return list
}]]></programlisting>

        <comment><para>TODO: rewrite <literal>from()</literal> to delegate to 
        <literal>list()</literal>.</para></comment>

        <programlisting><![CDATA[public List<X> list(Natural length, X containing(Natural index)) {
    OpenList<X> list = ArrayList<X>();
    for (Natural i in 0..length-1) {
        list.append(containing(i));
    }
    return list
}]]></programlisting>
        
        <programlisting><![CDATA[public List<X> list(X first, X? next(X previous)) {
    OpenList<X> list = ArrayList<X>();
    list.append(first);
    mutable X? x := first;
    while (true) {
        x := element(x);
        if (exists x) {
            list.append(x);
        }
        else {
            return list
        }
    }
}]]></programlisting>
        
        <programlisting><![CDATA[public List<X> list(Natural length, X first, X next(X previous)) {
    OpenList<X> list = ArrayList<X>();
    list.append(first);
    mutable X x := first;
    for (Natural i in 0..length-1) {
        x := element(x);
        list.append(x);
    }
    return list
}]]></programlisting>

        <programlisting><![CDATA[public Y fold<X,Y>(X[] list, Y initial, Y using(Y y, X x)) {
    mutable Y y:=initial;
    for (X x in list) {
        y:=using(u,x);
    }
    return y
}]]></programlisting>
        
        <comment><para>TODO: We should define versions of these that return just a
        lazily-evaluated <literal>Iterable</literal>.</para></comment>
        
        <para>The <literal>ceylon.language.comprehension.map</literal> package defines 
        support for <literal>Map</literal> comprehensions.</para>
        
        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given key. Each |Entry| is constructed 
     from the key and the value result of the 
     evaluation."
public Map<U,V> mapFrom<U,V>(iterated Iterable<U> keys,
                             V to(coordinated U key)) {
    Entry<U,V> of(U key) { return key->to(key) }
    return map(keys, of)
}]]></programlisting>

        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given value. Each |Entry| is constructed 
     from the value and the key result of the 
     evaluation."
public Map<U,V> mapTo<U,V>(iterated Iterable<V> values,
                           U from(coordinated V value)) { 
    Entry<U,V> of(V value) { return from(value)->value }
    return map(values, of)
}]]></programlisting>

        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given object and collecting the resulting 
     |Entry|s."
public Map<U,V> map<X,U,V>(iterated Iterable<X> elements,
                           Entry<U,V> of(coordinated X element)) {
    OpenMap<U,V> map = HashMap<U,V>();
    for (X x in elements) {
        map.add( of(x) );
    }
}]]></programlisting>
    
    </section>
    
    </section>
    
    <section id="collectionsmodule">
        <title>The collections module</title>
        
        <para>The module <literal>ceylon.collection</literal> contains the collections
        framework.</para>
    
    <section id="collections">
        <title>Collections</title>
        
        <para>The interface <literal>Collection</literal> is the 
        root of the Ceylon collections framework.</para>
        
        <programlisting><![CDATA[public interface Collection<out X> 
        satisfies Iterable<X>, Container, Category
        given X satisfies Object, Equals<X> {
    
    doc "The number of elements or entries belonging to the 
         collection."
    public Natural size;
    
    doc "Determine the number of times the given element
         appears in the collection."
    public Natural count(Object element);
    
    doc "Determine the number of elements or entries for
         which the given condition evaluates to |true|."
    public Natural count(Boolean where(X element));
    
    doc "Determine if the given condition evaluates to |true|
         for at least one element or entry."
    public Boolean contains(Boolean where(X element));
    
    doc "The elements of the collection, as a |Set|."
    public Set<X> elements;
    
    doc "The elements of the collection for which the given
         condition evaluates to |true|, as a |Set|."
    public Set<X> elements(Boolean where(X element));
    
    doc "The elements of the collection, sorted using the given
         comparison."
    public List<X> sortedElements(Comparison by(X x, X y));
    
    doc "An extension of the collection, with the given 
         elements. The returned collection reflects changes 
         made to the first collection."
    public Collection<T> with<T>(T... elements) given T abstracts X;

    doc "A mutable copy of the collection."
    public OpenCollection<T> copy<T>() given T abstracts X;
    
}]]></programlisting>

<!-- public Boolean containsAny(Object... objects); ??? -->

        <para>A decorator provides the ability to sort collections of
        <literal>Comparable</literal> values in natural order.</para>
        
        <programlisting><![CDATA[public extension class CollectionsOfComparable<out X>(Collection<X> this) 
        given X satisfies Comparable<X> {
        
    doc "The elements of the collection, sorted in natural order."
    public List<X> sortedElements() {
        return this.sortedElements() by (X x, X y) (x<=>y)
    }
    
}]]></programlisting>
        
        <para>Mutable collections implement <literal>OpenCollection</literal>:</para>
        
        <programlisting><![CDATA[public interface OpenCollection<X> 
        satisfies OpenCategory<X>, Collection<X> 
        given X satisfies Object, Equals<X> {
    
    doc "Remove all elements or entries of the collection,
         resulting in an empty collection."
    public Boolean clear();
    
    doc "Remove the given elements from the collection.
         Return the number of elements which belonged
         to the collection."
    public Natural remove(X... elements);
    
    doc "Remove all elements from the collection for which
         the given condition evaluates to |true|. Return 
         the number of elements which were removed."
    public Natural remove(Boolean where(X element));
    
}]]></programlisting>

    </section>

        <section id="sets">
            <title>Sets</title>
            
            <para>Sets implement the following interface:</para>
            
            <programlisting><![CDATA[public interface Set<out X> 
        satisfies Collection<X> 
        given X satisfies Object, Equals<X> {
    
    doc "Determine if the set is a superset of the given set.
         Return |true| if it is a superset."
    public Boolean superset(Set<Object> set);

    doc "Determine if the set is a subset of the given set.
         Return |true| if it is a subset."
    public Boolean subset(Set<Object> set);
    
    public actual Set<T> with<T>(T... elements) given T abstracts X;
    public actual OpenSet<T> copy<T>() given T abstracts X;

    public Set<T> union<T>(Set<T> set) 
            given T abstracts X;
    
    public Set<X> intersection<T>(Set<T> set) 
            given T abstracts X;
    
    public Set<T> exclusiveUnion<T>(Set<T> set) 
            given T abstracts X;
    
    public Set<X> complement<T>(Set<T> set) 
            given T abstracts X;
    
}]]></programlisting>

            <para>The following extension defines the <literal>|, &amp;, ^, ~</literal>
            operators for <literal>Set</literal>s.</para>
            
            <programlisting><![CDATA[public extension class SetSlots<X>(Set<X> this) 
        satisfies Slots<Set<X>> {
    
    actual Set<X> or(Set<X> set) {
        return this.union(set)
    }
    
    actual Set<X> and(Set<X> set) {
        return this.intersection(set)
    }
    
    actual Set<X> xor(Set<X> set) {
        return this.exclusiveUnion(set)
    
    }
    
    actual Set<X> complement(Set<X> set) {
        return this.complement(set)
    }
    
}]]></programlisting>

            <para>This extension allows direct instantiation of the interface:</para>

            <programlisting><![CDATA[public extension Set<T> newSet<T>(Type<Set<T>> this)(T... elements) {
    return HashSet(elements)
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public interface OpenSet<X> 
        satisfies Set<X>, OpenCollection<X> 
        given X satisfies Object, Equals<X> {}]]></programlisting>

        </section>
        
        <section id="lists">
            <title>Lists</title>
            
            <para>Lists implement the following interface, and support the 
            operators inherited from <literal>Collection</literal> and 
            <literal>Sequence</literal>:</para>
            
            <programlisting><![CDATA[public interface List<out X> 
        satisfies Collection<X>, X[] 
        given X satisfies Object, Equals<X> {
    
    doc "The index of the first element of the list
         which satisfies the condition, or |null| if 
         no element satsfies the condition."
    public Natural? firstIndex(Boolean where(X element));

    doc "The index of the last element of the list
         which satisfies the condition, or |null| if 
         no element satsfies the condition."
    public Natural? lastIndex(Boolean where(X element));
    
    doc "The elements of the list for which the given condition 
         evaluates to |true|, as a |List| with the original 
         order."
    public List<X> elementList(Boolean where(X element));
    
    doc "A sublist beginning with the element at the first given 
         index up to and including the element at the second given 
         index. The size of the returned sublist is one more than 
         the difference between the two indexes. The returned list 
         does reflect changes to the original list."
    public List<X> sublist(Natural from, Natural to=lastIndex);
    
    doc "A sublist of the given length beginning with the 
         first element of the list. The returned list does 
         reflect changes to the original list."
    public List<X> leading(Natural length=1);
    
    doc "A sublist of the given length ending with the 
         last element of the list. The returned list does 
         reflect changes to the original list."
    public List<X> trailing(Natural length=1);
    
    doc "Split the list into sublists, each beginning at an
         element for which the predicate returns true."
    public Iterable<List<X>> sublists(Boolean split(X element));
    
    doc "Split the list into sublists, each beginning at an
         element for which the predicate returns true. The 
         predicate may examine elements to the left and 
         right of the element under consideration."
    public Iterable<List<X>> sublists( 
            Boolean split(
                      doc "The current element, which
                           will be the first element
                           of the sublist if |split()|
                           returns |true|." 
                      X element, 
                      doc "The elements to the left,
                           beginning with the immediately
                           adjacent element." 
                      X[] left, 
                      doc "The elements to the right,
                           beginning with the immediately
                           adjacent element." 
                      X[] right
                  )
              );
    
    doc "An extension of the list with the given elements
         at the end of the list. The returned list does 
         reflect changes to the original list."
    public actual List<T> with<T>(T... elements) given T abstracts X;
    
    doc "An extension of the list with the given elements
         at the start of the list. The returned list does 
         reflect changes to the original list."
    public List<T> withInitial<T>(T... elements) given T abstracts X;
    
    doc "The list in reverse order. The returned list does 
         reflect changes to the original list."
    public List<X> reversed;
    
    doc "The unsorted elements of the list. The returned 
         bag does reflect changes to the original list."
    public Bag<X> unsorted;
    
    doc "A map from list index to element. The returned 
         map does reflect changes to the original list."
    public Map<Natural,X> map;
    
    doc "Produce a new list by applying an operation to
         every element of the list."
    public List<Y> transform<Y>(Y select(X element));
    
    public actual OpenList<T> copy<T>() given T abstracts X;

}]]></programlisting>

            <para>This extension allows direct instantiation of the interface:</para>

            <programlisting><![CDATA[public extension List<T> newList<T>(Type<List<T>> this)(T... elements) {
    return ArrayList(elements)
}]]></programlisting>

            <para>Any <literal>Sequence</literal> may be transparently converted to a 
            <literal>List</literal>:</para>
            
            <programlisting>public extension List&lt;X&gt; sequenceToList(X[] this) {
    if (is List&lt;X&gt; this) {
        return this
    }
    else {
        return SequenceList(this)
    }
}</programlisting>
            
<!--
            <para>Here's an implementation of the well-know quicksort algorithm 
            for a <literal>List</literal>:</para>
            
            <programlisting><![CDATA[doc "Quicksort for |List|s."
public List<X> quickSort<X>(List<X> list, Boolean byIncreasing(X x, X y)) {
    if (exists X pivot = list.first) {
        local createPartition = quickSort(list.rest.elementList);  
                //i.e. List<X> createPartition(Boolean where(X X)) = ...
        local smaller = byIncreasing.partial(pivot);                       
                //i.e. Boolean smaller(X x) = ...
        return createPartition(smaller) + {x} + createPartition(Boolean.complement(smaller))
    }
    else {
        return none
    }
}]]></programlisting>

            <para>For example:</para>
            
            <programlisting>List&lt;String&gt; sortedNames = quickSort(unsortedNames) byIncreasing (String x, String y) (x>y);</programlisting>
-->
            
            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public interface OpenList<X> 
        satisfies List<X>, OpenCollection<X>, OpenSequence<X> 
        given X satisfies Object, Equals<X> {

    doc "Remove the element at the given index, decrementing
         the index of every element with an index greater
         than the given index by one. Return the removed
         element."
    throws (UndefinedKeyException
            -> "if the index is not in the list")
    public X removeIndex(Natural at);
    
    doc "Add the given elements at the end of the list."
    public void append(X... elements);
    
    doc "Add the given elements at the start of the list,
         incrementing the index of every existing element
         by the number of given elements."
    public void prepend(X... elements);

    doc "Insert the given elements beginning at the given
         index, incrementing the index of every existing 
         element with that index or greater by the number 
         of given elements."
    throws (UndefinedKeyException
            -> "if the index is not in the list")
    public void insert(Natural at, X... elements);
    
    doc "Remove elements beginning with the first given index 
         up to and including the second given index,
         decrementing the indexes of all elements after
         with the second given index by one more than the 
         difference between the two indexes."
    throws (UndefinedKeyException
            -> "if the index is not in the list")
    public void delete(Natural from, Natural to=lastIndex);
    
    doc "Remove and return the first element, decrementing
         the index of every other element by one."
    throws (EmptyException
            -> "if the list is empty")
    public X removeFirst();

    doc "Remove and return the last element."
    throws (EmptyException
            -> "if the list is empty")
    public X removeLast();
    
    doc "Reverse the order of the list."
    public void reverse();
    
    doc "Reorder the elements of the list, according to the 
         given comparison."
    public void resort(Comparison by(X x, X y));
    
    actual OpenList<X> leading(Natural length);
    actual OpenList<X> trailing(Natural length);
    actual OpenList<X> sublist(Natural from, Natural to);
    actual OpenList<X> reversed;
    actual OpenMap<Natural,X> map;
    
}]]></programlisting>
            
        <para>A decorator provides the ability to resort lists of
        <literal>Comparable</literal> values in natural order.</para>
        
        <programlisting><![CDATA[public extension class OpenListsOfComparable<out X>(OpenList<X> this) 
        given X satisfies Comparable<X> {
        
    doc "Reorder the elements of the list, according to the 
         natural order."
    public void resort() {
        this.resort() by (X x, X y) (x<=>y);
    }
    
}]]></programlisting>
        
        </section>
            
        <section id="maps">
            <title>Maps</title>
            
            <para>Maps implement the following interface:</para>
            
            <comment><para>TODO: is it OK that maps are not contravariant 
            in the key type?</para></comment>
            
            <programlisting><![CDATA[public interface Map<U, out V>
        satisfies Collection<Entry<U,V>>, Correspondence<U, V> 
        given U satisfies Object, Equals<U> 
        given V satisfies Object, Equals<V> {
    
    doc "The keys of the map, as a |Set|."
    public Set<U> keys;
    
    doc "The values of the map, as a |Bag|."
    public Bag<V> values;
    
    doc "A |Map| of each value belonging to the map, to the 
         |Set| of all keys at which that value occurs."
    public Map<V, Set<U>> inverse;
    
    doc "Produce a new map by applying an operation to every 
         element of the map."
    public Map<U, W> transform<W>(W? select(U key -> V value));
    
    doc "The entries of the map for which the given condition 
         evaluates to |true|, as a |Map|."
    public Map<U, V> entries(Boolean where(U key -> V value));
    
    public actual Map<U, T> with<T>(Entry<U, T>... entries) given T abstracts V;
    public actual OpenMap<U,T> copy<T>() given T abstracts V;
    
}]]></programlisting>

            <para>This extension allows direct instantiation of the interface:</para>

            <programlisting><![CDATA[public extension Map<U,V> newMap<U,V>(Type<Map<U,V>> this)(Entry<U,V>... elements) {
    return HashMap(elements)
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public interface OpenMap<U,V> 
        satisfies Map<U,V>, OpenCollection<Entry<U,V>>, OpenCorrespondence<U, V> 
        given U satisfies Object, Equals<U> 
        given V satisfies Object, Equals<V> {
    
    doc "Remove the entry for the given key, returning the 
         value of the removed entry."
    throws (UndefinedKeyException
            -> "if no value is defined for the given key")   
    public V remove(U key);
    
    doc "Remove all entries from the map which have keys for 
         which the given condition evaluates to |true|. Return 
         entries which were removed."
    public Map<U,V> remove(Boolean where(U key));
    
    actual OpenSet<U> keys;
    actual OpenBag<V> values;
    actual OpenMap<V, Set<U>> inverse;
    
}]]></programlisting>
            
        </section>
        
        <section id="bags">
            <title>Bags</title>
            
            <para>Bags implement the following interface:</para>
            
            <programlisting><![CDATA[public interface Bag<out X> 
        satisfies Collection<X> 
        given X satisfies Object, Equals<X> {
    
    doc "A map from element to the number of occurrences of 
         the element. The returned map reflects changes to 
         the original bag."
    public Map<X,Natural> map;
    
    public actual Bag<T> with<T>(T... elements) given T abstracts X;
    public actual OpenBag<T> copy<T>() given T abstracts X;
    
}]]></programlisting>

            <para>This extension allows direct instantiation of the interface:</para>

            <programlisting><![CDATA[public extension Bag<T> newBag<T>(Type<Bag<T>> this)(T... elements) {
    return HashBag(elements)
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public interface OpenBag<X> 
        satisfies Bag<X>, OpenCollection<X> 
        given X satisfies Object, Equals<X> {
        
    actual OpenMap<X,Natural> map;
    
}]]></programlisting>
            
        </section>
        
    </section>
    
</chapter>