<chapter id="types">
    <title>Basic types</title>
    
    <para>There are no primitive types in Ceylon, however, there are certain
    important types provided by the SDK modules <literal>ceylon.language</literal>
    and <literal>ceylon.collection</literal>. Many of these types support 
    operators.</para>
    
    <section id="languagemodule">
        <title>The language module</title>
        
        <para>The module <literal>ceylon.language</literal> contains types which
        are referred to in the language definition.</para>
        
        <para>Toplevel declarations defined in <literal>ceylon.language</literal> 
        do not need to be explicitly imported.</para>
    
        <comment><para>Note: we will probably need to do the following erasures:</para>
        <itemizedlist>
            <listitem>
                <para><literal>Optional&lt;T&gt;</literal>, <literal>Something&lt;T&gt;</literal>
                and <literal>Nothing&lt;T&gt;</literal> to <literal>T</literal></para>
            </listitem>
            <listitem>
                <para><literal>Void</literal>, <literal>Object</literal> and 
                <literal>IdentifiableObject</literal> to <literal>java.lang.Object</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>Exception</literal> to <literal>java.lang.Throwable</literal>.</para>
            </listitem>
        </itemizedlist>
        <para>Therefore the members declared by <literal>Object</literal> and
        <literal>Exception</literal> will require special handling in the compiler.</para>
        </comment>
        
    <section id="void">
        <title>The void type</title>
        
        <para>The class <literal>Void</literal> is the root of the type
        system. All types are assignable to <literal>Void</literal>, which
        supports the the operator <literal>.</literal> (member selection).
        However, <literal>Void</literal> itself does not declare any 
        members.</para>
        
        <programlisting>shared abstract class Void() extends null {}</programlisting>
        
        <para>The special syntax <literal>extends null</literal> indicates
        that <literal>Void</literal> has no superclass.</para>
        
        <para>In contrast to <literal>Optional</literal>, which represents a
        possibly undefined value of a well-defined type, an expression of type
        <literal>Void</literal> represents a possibly undefined value with a 
        possibly undefined type! Therefore we can't really do anything very
        much with a <literal>Void</literal>&mdash;we can't even ask it what
        kind of thing it <literal>is</literal>.</para>
        
        <para>In practice, <literal>Void</literal> is used mainly to abstract
        the return types of methods which may or may not be declated
        <literal>void</literal>.</para>
        
    </section>
    
    <section id="object">
        <title>The <literal>Object</literal> class</title>
    
        <para>The class <literal>Object</literal> represents a definite value. 
        Expressions of type <literal>Object</literal> may be the subject of the 
        <literal>is</literal> operator (assignability).</para>
        
        <programlisting><![CDATA[shared abstract class Object() 
        extends Void() {
    
    doc "The |Type| of the instance."
    shared Type<subtype> type {
        return ... 
    }
    
    doc "A developer-friendly string representing the instance."
    shared formal String string;
    
    ...
        
}]]></programlisting>
    
        <para>All interface <!--and union--> types are assignable to 
        <literal>Object</literal>.</para>
    
        <para>Classes which are optimized by the compiler to Java primitive 
        types extend <literal>Object</literal> directly, since there is no 
        well-defined notion of identity for these types. Most other types
        are subclasses of <literal>IdentifiableObject</literal>.</para>
    
<!-- 
    doc "Binary assignability operator |x is Y|. Determine if the 
         instance is of the given |Type|."
    shared Boolean instanceOf(Type<Object> type) {
        return this.type.assignableTo(type)
    }    
 -->
<!--
    doc "A log object for the type."
    shared default Log log { 
        return type.log 
    }
 -->
    
    </section>
    
    <section id="equals">
        <title>Objects which support equality</title>
        
        <para>Types which can be compared for equality must satisfy the interface 
        <literal>Equality&lt;T&gt;</literal>. Two expressions of type
        <literal>Equality&lt;T&gt;</literal>, for the same type <literal>T</literal>,
        may be compared using the binary operators <literal>&equals;</literal> 
        (equals) and <literal>!=</literal> (not equals).</para>
        
        <programlisting><![CDATA[shared interface Equality<in T> 
        given T satisfies Equality<T> {
    
    doc "The equals operator |x == y|. Implementations should 
         respect the constraint that if |x===y| then |x==y|,
         the constraint that if |x==y| then |y==x|,
         and the constraint that if |x==y| and |y==z| then
         |x==z|."
    shared formal Boolean equals(T other);
    
    doc "The hash code of the instance. Implementations of |hash| 
         must respect the constraint that if |x==y| then 
         |x.hash==y.hash|."
    shared formal Integer hash;
    
}]]></programlisting>

        <para>We can't apply the <literal>==</literal> operator to expressions
        of arbitrary type. The reason for this is that traditionally numeric
        equality is defined even for values of differing numeric type.
        Furthermore, Ceylon has an extensible system of numeric types and it
        is therefore impossible to write a single implementation of 
        <literal>equals()</literal> that takes into consideration all possible 
        numeric types. Therefore type promotion (an extension) must be applied 
        to one value when values of two different numeric types are compared. 
        If <literal>==</literal> were defined for any <literal>Object</literal>, 
        there would be no reason for the compiler to apply the type promotion.</para>
        
        <comment><para>TODO: Should we rename <literal>Equality</literal> to 
        <literal>Comparable</literal> and <literal>Comparable</literal> to
        <literal>Ordered</literal>?</para></comment>
    
    </section>
    
    <section id="identifiableobject">
        <title><literal>IdentifiableObject</literal> and <literal>BaseObject</literal></title>
        
        <para>The class <literal>IdentifiableObject</literal> represents a type 
        whose values are always passed by reference. Expressions of type 
        <literal>IdentifiableObject</literal> support the binary operator 
        <literal>&identical;</literal> (identity equals).</para>
        
        <programlisting><![CDATA[shared abstract class IdentifiableObject() 
        extends Object() 
        satisfies Equality<IdentifiableObject> {

    doc "The |Class| of the instance."
    shared actual Class<subtype> type {
        return ... 
    }
    
    shared default actual Boolean equals(IdentifiableObject that) {
        return this===that;
    }
    
    shared default actual Integer hash {
        return identityHash(this);
    }
        
}]]></programlisting>
        
        <para>The following toplevel methods expose the notion of object 
        identity:</para>
    
        <programlisting>doc "Return |True| if |x| and |y| are identical."
    shared Boolean identical(IdentifiableObject x, IdentifiableObject y) {
        return ...
    }</programlisting>
        <programlisting>doc "Return the hash of |x|."
    shared Integer identityHash(IdentifiableObject x) {
        return ...
    }</programlisting>
    
        <para>Classes written in other Java VM languages (including Java classes) 
        are considered subtypes of <literal>IdentifiableObject</literal>. Indeed,
        you can think of <literal>IdentifiableObject</literal> as Ceylon's
        representation of <literal>java.lang.Object</literal>.</para>
    
        <para>User-written classes usually extend <literal>BaseObject</literal>.
        Subclasses of <literal>BaseObject</literal> have default implementations 
        of <literal>equals()</literal>, <literal>hash</literal> and 
        <literal>string</literal> provided for them.</para>
        
        <programlisting><![CDATA[shared abstract class BaseObject() 
        extends IdentifiableObject() {
        
    Attribute<subtype,Object>[] idAttributes() {
        return from ( Attribute<subtype,Object> a in type.attributes() ) 
                    where ( a.annotations(Id) nonempty );
    }
    
    doc "The equals operator |x == y|. Default implementation compares
         attributes annotated |id|, or performs identity comparison."
    see (id)
    shared default actual Boolean equals(IdentifiableObject that) {
        if (that.type!=type) {
            return false;
        }
        Attribute<subtype,Object>[] idAttributes = idAttributes();
        if (nonempty idAttributes) {
            return equals(that, idAttributes);
        }
        else {
            return super.equals(that);
        }
    }
    
    doc "Compares the given attributes of this instance with the given
         attributes of the given instance."
    shared Boolean equals(IdentifiableObject that, Attribute<subtype,Object>... attributes) {
        if (is subtype that) {
            return forAll (Attribute<subtype,Object> a in attributes)
                        every ( a(this) == a(that) );
        }
        else {
            return false;
        }
    }
    
    doc "The hash code of the instance. Default implementation compares
         attributes annotated |id|, or assumes identity equality."
    see (id)
    shared default actual Integer hash { 
        Attribute<subtype,Object>[] idAttributes = idAttributes();
        if (nonempty idAttributes) {
            return hash(idAttributes);
        }
        else {
            return super.hash;
        }
    }
    
    doc "Computes the hash code of the instance using the given 
         attributes."
    shared Integer hash(Attribute<subtype,Object>... attributes) { ... }
        
    doc "A developer-friendly string representing the instance. 
         By default, the string contains the name of the type, 
         and the values of all attributes annotated |id|."
    shared default actual String string {
        return string(idAttributes());
    }
    
    doc "A developer-friendly string representing the instance,
         containing the name of the type, and the value of the
         given attributes." 
    shared default String string(Attribute<subtype,Object>... attributes) {
        variable Character[] result := "";
        result .= with (type.name, "{");
        result .= forEach (Attribute<subtype,Object> a in attributes)
                    with ({ a.name, "=", $a(this), ";" });
        result .= with ("}");
        return result;
    }
    
    ...
        
}]]></programlisting>
    
    </section>
    
    <section id="callable">
        <title>Callable references</title>
        
        <para>The type <literal>Callable</literal> represents an executable
        operation. Expressions of type <literal>Callable</literal> may be the 
        subject of the argument specification operators <literal>()</literal> 
        and <literal>{}</literal>.</para>
        
        <programlisting><![CDATA[doc "The type |Callable| represents an executable operation."
shared interface Callable<out R, P...> {
    shared formal R call(P... args);
}]]></programlisting>
    
        <para>The following extension provides function <emphasis>composition</emphasis>, 
        combining a <literal>Callable&lt;Y,X&gt;</literal> with a <literal>Callable&lt;X,P...&gt;</literal>
        to produce a <literal>Callable&lt;Y,P...&gt;</literal>:</para>
        
        <programlisting><![CDATA[doc "The following extension provides function composition,
     combining a |Callable<Y,X>| with a |Callable<X,P...>| to produce a |Callable<Y,P...>|."
shared extension Y composeable<X,Y,P...>(Y this(X x))(X g(P... args))(P... args) {
    Y compose(X g(P... args))(P... args) {
        Y composition(P... args) {
            return this(g(args));
        }
        return composition;
    }
    return compose;
}]]></programlisting>

       <para>For example:</para>
       
       <programlisting>void logFormatted(Date date) = log.info(DateFormat('dd/mm/yyyy').format);</programlisting>

       <para>The next extension allows the first parameter of any function with multiple 
       parameters to be <emphasis>curried</emphasis>, transforming a 
       <literal>Callable&lt;R,T,P...&gt;</literal> into a
       <literal>Callable&lt;Callable&lt;R,P...&gt;,T&gt;</literal>:</para>

       <programlisting><![CDATA[doc "allows the first parameter of any function with multiple parameters to be curried,
     transforming a |Callable<R,T,P...>| into a |Callable<Callable<R,P...>,T>|."
shared extension class Curryable<R,T,P...>(R this(T t, P... args)) {
    R partial(T t)(P... p) {
        R curried(P... p) {
            return this(t, args);
        }
        return curried;
    }
}]]></programlisting>
       
       <para>For example:</para>
       
       <programlisting>void info(String message) = log.message.partial(Level.info);
void hello() = info.partial("Hello!");</programlisting>
       
       <para>This extension does the reverse, transforming a 
       <literal>Callable&lt;Callable&lt;R,P...&gt;,T&gt;</literal> into a
       <literal>Callable&lt;R,T,P...&gt;</literal>:</para>

       <programlisting><![CDATA[doc "Reverse of a currying operation. Transform a |Callable<Callable<R,P...>,T>| into a |Callable<R,T,P...>|."
shared extension class Flattenable<R,T,P...>(R this(T t)(P... args)) {
    R flatten(T t, P... p) {
        return this(t)(p);
    }
}]]></programlisting>
       
       <para>For example:</para>
       
       <programlisting>void say(Person p, String words) = Person.say.flatten;</programlisting>
       
       <para>Finally, this extension swaps the first and second parameter lists of
       a function with multiple parameter lists, transforming a 
       <literal>Callable&lt;Callable&lt;R,Q...&gt;,P...&gt;</literal> into a
       <literal>Callable&lt;Callable&lt;R,P...&gt;,Q...&gt;</literal>:</para>
       
       <programlisting><![CDATA[doc "Swaps the first and second parameter lists of a function with multiple parameter lists,
     transforming a |Callable<Callable<R,Q...>,P...>| into a |Callable<Callable<R,P...>,Q...>|."
shared extension class Shuffleable<R,P...,Q...>(R this(P... p)(Q... q)) {
   R shuffle(Q... q)(P... p) {
       R shuffled(P... p) {
           return this(p)(q);
       }
       return shuffled;
   }
}]]></programlisting>
        
        <para>For example:</para>
        
        <programlisting>Float sqr(Float x) = Float.power.shuffle(2);
void say(String words, Person p) = Person.say.shuffle.flatten;</programlisting>
        
    </section>
    
    <section id="evaluableandassignable">
        <title>Evaluable and assignable values</title>
        
        <para>The class <literal>Gettable</literal> represents a reference which may 
        be evaluated to produce a value, allowing pass by reference and lazy evaluation 
        semantics. Instances of <literal>Gettable&lt;T&gt;</literal> are transparently 
        assignable to <literal>T</literal> (evaluation).</para>
        
        <programlisting><![CDATA[shared abstract class Gettable<out T>()
        extends Void() {}]]></programlisting>
        
        <para>Note that <literal>Gettable</literal> is not a subclass of 
        <literal>Object</literal>.</para>
        
        <para>The following method allows a <literal>Gettable&lt;T&gt;</literal>
        to be treated as a <literal>Callable&lt;T&gt;</literal>:</para>

        <programlisting><![CDATA[shared T get<T>(Gettable<T> value)() { 
    return value;
}]]></programlisting>
    
        <para>The subtype <literal>Settable</literal> represents a reference
        to an assignable value, allowing pass by reference semantics for assignable
        values. Expressions of type <literal>Settable</literal> support the binary
        operator <literal>:=</literal> (assign).</para>
        
        <programlisting><![CDATA[shared abstract class Settable<T>()
        extends Gettable<T>() {}]]></programlisting>

        <para>The following method allows an <literal>Settable&lt;T&gt;</literal>
        to be treated as a <literal>Callable&lt;T,T&gt;</literal>:</para>

        <programlisting><![CDATA[shared T set<T>(Settable<T> value)(T newValue) { 
    return value := newValue;
}]]></programlisting>
    
    </section>
    
    <section id="boolean">
        <title>Boolean values</title>
        
        <para>The <literal>Boolean</literal> class represents
        boolean values. Expressions of type <literal>Boolean</literal> support 
        the binary <literal>||</literal> and <literal>&amp;&amp;</literal> 
        operators and the unary <literal>!</literal> operator.</para>
        
        <programlisting><![CDATA[shared object true extends Boolean() {}
shared object false extends Boolean() {}
shared abstract class Boolean() 
        of true | false 
        extends Case() {}]]></programlisting>

    </section>
    
    <section id="matchersandcases">
        <title>Matchers and cases</title>
        
        <para>The interface <literal>Matcher</literal> represents a
        type that may be used as a <literal>case</literal> in the 
        <literal>switch</literal> construct.</para>
        
        <programlisting><![CDATA[shared interface Matcher<in X> {

    doc "Determine if the given value matches
         this case, returning |true| iff the
         value matches."
    shared formal Boolean matches(X value);
    
    shared Boolean matchesCase<Y>(Y? y) 
            given Y abstracts X {
        if (exists y) {
            if (is X y) {
                return matches(y);
            }
            else {
                return false;
            }
        }
        else {
            //match only if this is a case(null)
            return this==null.matcher;
        }
    }
        
}]]></programlisting>

        <!-- 
        <comment><para>TODO: the two extensions that follow don't actually 
        work, since they overload the <literal>matches()</literal> method 
        of <literal>Matcher</literal>.</para></comment>

        <para>An extension allows <literal>Matcher&lt;X&gt;</literal> to 
        function as <literal>Matcher&lt;X?&gt;</literal>.</para>
        
        <programlisting><![CDATA[shared extension class OptionalMatcher<X>(Matcher<X> this) 
        satisfies Matcher<X?> {
        
    shared actual Boolean matches(X? x) {
        if (exists value) {
            return this.matches(x);
        }
        else {
            return false;
        }
    }
    
}]]></programlisting>

        <para>An extension allows <literal>Matcher&lt;X&gt;</literal> to 
        function as <literal>Matcher&lt;Y&gt;</literal> where <literal>X</literal> 
        is a subtype of <literal>Y</literal>.</para>
        
        <programlisting><![CDATA[shared extension class SupertypeMatcher<X,Y>(Matcher<X> this) 
        satisfies Matcher<Y> 
        given X satisfies Y {
        
    shared actual Boolean matches(Y y) {
        if (is X y) {
            return this.matches(y);
        }
        else {
            return false;
        }
    }
        
}]]></programlisting>
        -->

        <para>The class <literal>Case</literal> is the supertype of anonymous 
        classes that may be cases in an <literal>of</literal> clause.</para>
        
        <programlisting><![CDATA[shared abstract class Case(String caseName=type.declarationName) 
        satisfies Matcher<Object> {
    
    shared actual Boolean matches(Object that) {
        return this===that;
    }
    
    shared actual default String string = caseName;
    
}]]></programlisting>

    </section>
    
    <section id="optionalandnull">
        <title>Optional and null values</title>
        
        <para>The class <literal>Optional</literal> represents a
        value that may be null.</para>
        
        <programlisting><![CDATA[shared abstract class Optional<out X>() 
        of Something<X> | Nothing<X>
        extends Void() {
    
    doc "The unary postfix existence operator 
         |x exists|."
    shared formal Boolean defined;
    
}]]></programlisting>

<!--
    doc "The binary default operator 
         |x ? y|."
    shared T default<T>(T defaultValue) 
            given T abstracts X;
-->

        <para>Expressions of type <literal>Object?</literal> support the 
        binary operators <literal>?.</literal> (nullsafe invoke) and 
        <literal>?</literal> (default) and the unary operator 
        <literal>exists</literal>.</para>
        
        <para>Note that <literal>Optional</literal> is not a subtype of 
        <literal>Object</literal>. Therefore it is not possible to apply 
        the <literal>is</literal> operator to an expression of type 
        <literal>Optional</literal>. The reason behind this is that 
        <literal>Optional</literal> and its subtypes are erased by the
        compiler, and null values are untyped at the virtual machine
        level.</para>
        
        <para>If an optional value is not null, it is represented by an
        instance of the subclass <literal>Something</literal>.</para>
        
        <programlisting><![CDATA[shared extension class Something<out X>(X this) 
        extends X?() {

    shared extension X value = this;
    
    shared actual Boolean defined { 
        return true;
    }
    
}]]></programlisting>

<!-- 
    shared actual T default<T>(T defaultValue) 
            given T abstracts X {
        return value;
    }
-->
        <para>If an optional value is null, it is represented by an instance 
        of the subclass <literal>Nothing</literal>.</para>

        <programlisting><![CDATA[shared class Nothing<out X>() 
        extends X?() {
        
    shared actual Boolean defined { 
        return false;
    }
    
}]]></programlisting>

        <para>Non-optional values are transparently assignable to optional
        values, since <literal>Something&lt;X&gt;</literal> is an extension of 
        <literal>X</literal> enabled in every compilation unit. Likewise, 
        instances of <literal>Something&lt;X&gt;</literal> are transparently 
        assignable to <literal>X</literal>.</para>
        
        <para>The value <literal>null</literal> is transparently assignable to 
        optional values, since <literal>Nothing&lt;X&gt;</literal> is an 
        extension of <literal>Null</literal> enabled in every compilation unit.</para>
        
        <programlisting><![CDATA[doc "Represents a null reference."  
shared object null 
        extends Void() {

    shared extension object matcher 
            satisfies Matcher<Object> {
        shared actual Boolean matches(Object value) {
            return false;
        }
    }
    
    shared extension Nothing<X> nothing<X>() {
        return Nothing<X>();
    }
     
}]]></programlisting>
        
<!--
    shared actual T default<T>(T defaultValue) 
            given T abstracts X {
        return defaultValue;
    }
-->    
        <para>Note that <literal>Optional</literal> is not a reified type. The compiler
        erases all references to <literal>Optional&lt;X&gt;</literal> to 
        <literal>X</literal> after performing type validation and before generating
        bytecode. The compiler also replaces references to <literal>null</literal>
        with the Java <literal>null</literal>. Therefore, none of the extensions defined 
        in this section are actually executed.</para>
        
    </section>
    
    <section id="exception">
        <title>Exceptions</title>
        
        <para>The class <literal>Exception</literal> is the base class for all
        exception types.</para>
        
        <programlisting><![CDATA[shared class Exception(Exception? cause=null, String? message=null) 
        extends IdentifiableObject() {
    
    shared String message = message ? cause?.message ? "";
    
    shared Exception cause = cause ? this;
    
    shared StackTrace stackTrace { return ... }
    
    shared actual String string {
        if (nonempty message) {
            return type.name + ": " + message;
        }
        else {
            return type.name;
        }
    }
    
}]]></programlisting>

    </section>

    <section id="usable">
        <title>Usables</title>
        
        <para>The interface <literal>Usable</literal> represents an
        object with a lifecycle controlled by <literal>try</literal>.</para>
        
        <programlisting><![CDATA[shared interface Usable {

    doc "Called before entry into a |try| block."
    shared formal void begin();
    
    doc "Called before normal exit from a |try| block."
    shared formal void end();

    doc "Called before exit from a |try| block when an
         exception occurs."
    shared default void abort(Exception e) {
        end();
    }
    
}]]></programlisting>
       
        <!--
        <para>An <literal>Usable</literal> is used according to the
        following idiom:</para>
            
        <programlisting><![CDATA[Transaction t = Transaction();
t.begin();
try {
    doSomething(t);
    t.end();
}
catch (Exception e) {
    t.end(e);
}]]></programlisting>
        -->
    </section>
    
    <section id="containersizedcategory">
        <title>Containers and categories</title>
        
        <para>The interface <literal>Container</literal> represents
        the abstract notion of an object that may be empty. Expressions
        of type <literal>Container?</literal> support the unary postfix 
        operator <literal>nonempty</literal>.</para>
        
        <programlisting><![CDATA[shared interface Container {
        
    doc "The nonempty operator. Determine if the container 
         is empty."
    shared formal Boolean empty;
    
}]]></programlisting>
        
        <para>The interface <literal>Sized</literal> represents a 
        <literal>Container</literal> whose number of elements may be 
        determined.</para>
        
        <programlisting>shared interface Sized satisfies Container {
        
    doc "The number of elements or entries belonging to the 
         container."
    shared formal Natural size;
    
    shared actual default Boolean empty {
        return size==0;
    }
    
}</programlisting>
    
        <para>The interface <literal>Category</literal> represents the 
        abstract notion of an object that contains other objects. An 
        expression of type <literal>Category</literal> may occur as the
        right hand argument of the <literal>in</literal> operator.</para>
        
        <programlisting><![CDATA[shared interface Category {
    
    doc "Determine if the given object belongs to the category.
         Return |true| iff the given object belongs to the 
         category."
    shared formal Boolean contains(Object obj);

    doc "Determine if the given objects belong to the category.
         Return |true| iff all the given objects belong to the 
         category."
    shared default Boolean contains(Object... objects) {
        return forAll(Object obj in objects) every (contains(obj));
    }

}]]></programlisting>
        
        <!--
        <programlisting><![CDATA[shared interface Category {
    
    doc "Determine if the given element belongs to the category."
    shared Boolean contains(Object element);

}]]></programlisting>

        <programlisting><![CDATA[shared extension class Categories(Category category) {
        
    doc "Determine if all the given elements belong to the 
         category."
    shared Boolean contains(Object... elements) {
        return forAll (Object elem in elements) every category.contains(elem);
    }
    
}]]></programlisting>
        -->
        
        <para>Any <literal>Object</literal> may belong to categories. The 
        following extension defines the binary <literal>in</literal>
        operator:</para>
    
    <programlisting><![CDATA[shared extension class Objects(Object this) {
    
    doc "Determine if this object belongs to the given |Category|.
         The binary |in| operator."
    see (Category)
    shared Boolean element(Category category) {
        return category.contains(this);
    }

}]]></programlisting>
    
        <para>There is a mutable subtype, representing a category to which 
        objects may be added.</para>
        
        <programlisting><![CDATA[shared interface OpenCategory<in X> 
        satisfies Category 
        given X satisfies Object {
    
    doc "Add the given objects to the category. Return the number of 
         objects which did not already belong to the category."
    shared Natural add(X... objects);

}]]></programlisting>

        <!--
        <programlisting><![CDATA[shared interface OpenCategory<in X> 
        satisfies Category {
    
    doc "Add the given element to the category. Return |true| if 
         the element did not already belong to the category."
    shared Boolean add(X element);

}]]></programlisting>

        <programlisting><![CDATA[shared extension class OpenCategories<in X>(OpenCategory<X> category) {
        
    doc "Add the given elements to the category. Return |true| if 
         at least one element did not already belong to the 
         category."
    shared Boolean add(X... elements) {
        Boolean added = false;
        for (X x in elements) {
            added |= category.add(x);
        }
        return added;
    }
    
}]]></programlisting>
        -->

    </section>
    
    <section id="iterableanditerator">
        <title>Iterable objects and iterators</title>
        
        <para>The interface <literal>Iterable</literal> represents an
        object which can produce a sequence of values, and which can
        be iterated using a <literal>for</literal> loop.</para>
        
        <programlisting><![CDATA[shared interface Iterable<out X> satisfies Container {
    
    doc "A sequence of objects belonging
         to the container."
    shared formal Iterator<X> iterator;
    
    shared actual default Boolean empty {
        return !(iterator.head exists);
    }

}]]></programlisting>
        
        <para>A Ceylon <literal>Iterator</literal> is a stateless object
        that produces a theoretically unbounded sequence of values.</para>
        
        <programlisting><![CDATA[shared interface Iterator<out X> {

    shared formal X? head;
    shared formal Iterator<X> tail;

}]]></programlisting>
        
        <para>An <literal>Iterator</literal> is used according to the
        following idiom:</para>
            
        <programlisting><![CDATA[variable local iter := iterable.iterator;
while (exists local value = iter.head) {
    ...
    iter.=tail;
}]]></programlisting>
    
    <para>The following interface allows <literal>Iterable</literal> objects
    to be used with the <literal>in</literal> operator.</para>
    
    <programlisting><![CDATA[shared interface FiniteCategory<T>
        satisfies Iterable<T> & Category
        given T satisfies Equality<T> {
        
    shared actual default Boolean contains(Object... objects) {
        for (Object obj in objects) {
            if (is T obj) {
                if ( forAll (Object elem in this) every (elem != obj) ) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        fail {
            return true;
        }
    }
    
}]]></programlisting>
    
        <comment><para>TODO: should we provide for mutation/removal during 
        iteration:</para>
        <programlisting><![CDATA[shared interface OpenIterable<X> 
        satisfies Iterable<X> {
    shared actual OpenIterator<X> iterator;
}]]></programlisting>
        <programlisting><![CDATA[shared interface OpenIterator<X> 
        satisfies Iterator<X> {
    shared actual variable X? head;
    shared void remove();
}]]></programlisting></comment>

        <comment><para>TODO: this alternate solution abstracts efficient 
        iteration of sequences and linked lists/trees, but suffers from
        the problem that the <literal>indexedValue()</literal> operation 
        accepts tokens from iterations of other objects, and is therefore 
        much less typesafe.</para>
        <programlisting><![CDATA[shared interface Indexed<out X, I> 
        given I satisfies Ordinal {
    
    shared formal I firstIndex;
    shared formal Gettable<X>? indexedValue(I index);
    
}]]></programlisting>
        <para>For example, a <literal>Sequence&lt;X&gt;</literal> would 
        be an <literal>Indexed&lt;X, Natural&gt;</literal> and a 
        <literal>LinkedList&lt;X&gt;</literal> would be an 
        <literal>Indexed&lt;X, Link&lt;X&gt;&gt;</literal>. The idiom
        would be:</para>
        <programlisting><![CDATA[variable local i := indexed.firstIndex;
while (exists local value = indexed.indexedValue(i)) {
    ...
    ++i;
}]]></programlisting>
        <para>Mutation/removal during iteration would also be possible.</para>
        <programlisting><![CDATA[shared interface OpenIndexed<X, I> 
        satisfies Indexed<X,I>
        given I satisfies Ordinal {
    shared actual variable Settable<X>? indexedValue(I index);
    shared void removeIndex(I index);
}]]></programlisting>
</comment>
    
    </section>
    
    <section id="entry">
        <title>Entries</title>
        
        <para>The <literal>Entry</literal> class represents a pair of 
        associated objects.</para>

        <para>Entries may be constructed using the <literal>-></literal> 
        operator.</para>

            <programlisting><![CDATA[shared class Entry<out U, out V>(U key, V value) 
        extends Object() 
        satisfies Equality<Entry<U,V>>
        given U satisfies Equality<U> 
        given V satisfies Equality<V> {
    
    doc "The key used to access the entry."
    shared U key = key;
    
    doc "The value associated with the key."
    shared V value = value;
    
    shared actual Boolean equals(Entry<U,V> that) {
        return this.key==that.key && this.value==that.value;
    }
    
    shared actual Integer hash = ... ; 

}]]></programlisting>

    </section>
    
    <section id="correspondence">
        <title>Correspondences</title>
        
        <para>The interface <literal>Correspondence</literal> represents
        the abstract notion of an object that maps value of one type to values
        of some other type. It supports the binary operator
        <literal>[key]</literal> (lookup).</para>

        <programlisting><![CDATA[shared interface Correspondence<in U, out V>
        is EnumerableCorrespondence<U,V>
        given U satisfies Equality<U> 
        given V satisfies Equality<V> {
    
    doc "Binary lookup operator x[key]. Returns the value defined
         for the given key, or |null| if there is no value defined
         for the given key."
    shared formal Gettable<V?> value(U key);
    
    doc "Binary sequenced lookup operator |x[keys]|. Return a list 
         of values defined for the given keys, in order."
    throws (UndefinedKeyException
            -> "if no value is defined for one of the given 
                keys")
    shared default V[] values(U... keys) {
        return from (U key in keys) select (this[key]);
    }
    
    doc "Binary iterated lookup operator |x[keys]|. Return an iterator
         of the values defined for the given keys."
    throws (UndefinedKeyException
            -> "if no value is defined for one of the given 
                keys")
    shared default Iterable<V> values(Iterable<U> keys) {
        return from (U key in keys) select (this[key]);
    }
    
    doc "Determine if there are values defined for the given keys.
         Return |true| iff there are values defined for all the
         given keys."
    shared default Boolean defines(U... keys) {
        return forAll (U key in keys) every (this[key] exists);
    }
    
}]]></programlisting>

        <!--     
        <programlisting><![CDATA[shared interface Correspondence<in U, out V> {
    
    doc "Binary lookup operator x[key]. Returns the value defined
         for the given key."
    shared V value(U key);
    
    doc "Determine if there is a value defined for the given key."
    shared Boolean defines(U key);
    
}]]></programlisting>

        <programlisting><![CDATA[shared extension class Correspondences<in U, out V>(Correspondence<U, V> correspondence) {

    doc "Binary lookup operator x[keys]. Returns a list of values 
         defined for the given keys, in order."
    shared List<V> values(List<U> keys) {
        return from (U key in keys) select correspondence.lookup(key);
    }
    
    doc "Binary lookup operator x[keys]. Returns a set of values 
         defined for the given set of keys."
    shared Set<V> values(Set<U> keys) {
        return ( from (U key in keys) select correspondence.lookup(key) ).elements;
    }
    
    doc "Determine if there are values defined for all the given 
    keys."
    shared Boolean defines(U... keys) {
        for (U key in keys) {
            if ( !correspondence.defines(key) ) {
                return false;
            }
        }
        fail {
            return true;
        }
    }
    
}]]></programlisting>
        -->
        
        <para>The metatype allows direct instantiation of the
        <literal>Correspondence</literal> interface:</para>
        
        <programlisting><![CDATA[shared interface EnumerableCorrespondence<U,V>
        satisfies Callable<Correspondence<U,V>,Entry<U,V>...>
        given U satisfies Equality<U> 
        given V satisfies Equality<V> {
    shared actual default Correspondence<U,V> call(Entry<U,V>... entries) {
        object correspondence 
                satisfies Correspondence<U,V> {
            ...
        }
        return correspondence;
    }
}]]></programlisting>
        
        <para>There is a mutable subtype, representing a correspondence
        for which new mappings may be defined, and existing mappings 
        modified. It provides for the use of element expressions in
        assignments.</para>
        
        <!-- Association? -->

        <programlisting><![CDATA[shared interface OpenCorrespondence<in U, V> 
        satisfies Correspondence<U, V> 
        given U satisfies Equality<U> 
        given V satisfies Equality<V> {
    
    shared actual Settable<V?> value(U key);
    
    doc "Add the given entries, overriding any definitions that 
         already exist."
    throws (UndefinedKeyException
            -> "if a value can not be defined for one of the 
                given keys")
    shared default void define(Entry<U, V>... definitions) {
        for (U key->V value in definitions) {
            this[key] := value;
        }
    }
    
    doc "Assign a value to the given key. Return the previous value 
         for the key, or |null| if there was no value defined."
    throws (UndefinedKeyException
            -> "if a value can not be defined for the given key")
    shared default V? define(U key -> V value) {
        Settable<V?> definition = this[key];
        V? result = definition;
        definition := value;
        return result;
    }

}]]></programlisting>
        
        <comment><para>TODO: Should we rename <literal>value()</literal>, <literal>define()</literal>
        and <literal>defines()</literal> to <literal>get()</literal>, <literal>set()</literal>
        and <literal>has()</literal>?</para></comment>
        
    </section>
    
    <section id="comparableandordinal">
        <title>Ordered values</title>
        
        <para>The <literal>Comparable</literal> interface 
        represents totally ordered types, and supports the binary operators 
        <literal>&gt;, &lt;, &lt;=, &gt;=</literal> and <literal>&lt;=&gt;</literal>
        (compare).</para>
        
        <programlisting><![CDATA[shared interface PartlyComparable<in T>
        given T satisfies PartlyComparable<T> {
    shared formal PartialComparison compare(T other);
}]]></programlisting>

        <programlisting><![CDATA[shared interface Comparable<in T> 
        satisfies Equality<T> & PartlyComparable<T>
        given T satisfies Comparable<T> {
    
    doc "The binary compare operator |<=>|. Compares this 
         object with the given object. Implementations must
         respect the constraint that if |x==y| then
         |x<=>y == Comparison.equal|, the constraint that 
         if |x>y| then |y<x|, and the constraint that if 
         |x>y| and |y>z| then |x>z|."
    shared actual formal Comparison compare(T other);
    
    doc "The binary |>| operator."
    shared Boolean largerThan(T other) {
        return compare(other)==larger;
    }
    
    doc "The binary |<| operator."
    shared Boolean smallerThan(T other) {
        return compare(other)==smaller;
    }
    
    doc "The binary |>=| operator."
    shared Boolean asLargeAs(T other) {
        return compare(other)!=smaller;
    }
    
    doc "The binary |<=| operator."
    shared Boolean asSmallAs(T other) {
        return compare(other)!=larger;
    }
    
}]]></programlisting>
        
        <programlisting><![CDATA[doc "The receiving object is larger than 
     the given object."
shared object larger extends Comparison() {}

doc "The receiving object is smaller than 
     the given object."
shared object smaller extends Comparison() {}

doc "The receiving object is exactly equal 
     to the given object."
shared object equal extends Comparison() {}

doc "The receiving object is not comparable 
     to the given object."
shared object uncomparable extends PartialComparison() {}

doc "The result of a comparison between two
     |PartlyComparable| objects."
partial abstract class PartialComparison()
        of uncomparable | Comparison
        extends Case() {}

doc "The result of a comparison between two
     |Comparable| objects."
shared abstract class Comparison() 
        of larger | smaller | equal 
        extends PartialComparison() {}]]></programlisting>

        <comment><para>TODO: should we support partial orders? Give
        <literal>Comparison</literal> an extra <literal>uncomparable</literal>
        value, or let <literal>compare()</literal> return 
        <literal>null</literal>?</para></comment>
        
        <comment><para>TODO: if so, why not just move <literal>compare()</literal>
        up to <literal>Object</literal> to simplify things?</para></comment>
        
        <para>The toplevel methods <literal>min()</literal> and <literal>max()</literal>
        return the minimum and maximum values of a list of <literal>Comparable</literal>s.</para>
        
        <programlisting><![CDATA[shared X min<X>(X x, X... xs) 
        given X satisfies Comparable<X> {
    variable X min := x;
    for (X y in xs) { 
        if (y<min) { 
            min:=y;
        }
    }
    return min;
}]]></programlisting>

        <programlisting><![CDATA[shared X max<X>(X x, X... xs) 
        given X satisfies Comparable<X> {
    variable X max := x;
    for (X y in xs) { 
        if (y>max) { 
            max:=y;
        }
    }
    return max;
}]]></programlisting>

        <para>The <literal>Ordinal</literal> interface represents 
        objects in a sequence, and supports the binary operator 
        <literal>..</literal> (range). In addition, variables support 
        the postfix unary operators <literal>++</literal> (increment) 
        and <literal>--</literal> (decrement) and prefix unary 
        operators <literal>++</literal> (successor) and 
        <literal>--</literal> (predecessor).</para>
        
        <programlisting><![CDATA[shared interface Ordinal {

    doc "The unary |++| operator. The successor of this instance."
    throws (OutOfRangeException
            -> "if this is the maximum value")
    shared formal subtype successor;
    
    doc "The unary |--| operator. The predecessor of this instance."
    throws (OutOfRangeException
            -> "if this is the minimum value")
    shared formal subtype predecessor;
    
}]]></programlisting>

    </section>
    
    <section id="bounded">
        <title>Bounded</title>
        
        <para>The <literal>Bounded</literal> class represents a value
        from an upper-bounded list of natural numbers.</para>
        
        <programlisting><![CDATA[shared class Bounded<M>(Bounded<M> b)
       extends Object()
       satisfies Comparable<Bounded<M>> & Number 
       given M satisfies Dimension {
   
    doc "The |Natural| representing this natural
         number."
    shared extension Natural natural { ... }

    shared actual Comparison compare(Bounded<M> other) {
        return natural.compare(other.natural);
    }

    doc "This natural number, as a |Bounded<N>| where
         |N>=M|."
    shared extension Bounded<M+I> bounded<I>() 
            given I satisfies Dimension { ... }
   
}]]></programlisting>
        
        <para><literal>Bounded&lt;#n&gt;</literal> does not satisfy 
        <literal>Ordinal</literal>, so the type 
        <literal>Range&lt;Bounded&lt;#n&gt;&gt;</literal> does not exist.
        Instead, the following utility method is provided:</para> 
        
        <programlisting><![CDATA[doc "A sequence of |Bounded<N+#1>| from
     from |#0| to |N|."
shared BoundedSequence<Bounded<N+#1>,N+#1> zeroTo<N>() 
        given N satisfies Dimension  { ... }]]></programlisting>

    </section>
    
    <section id="sequence">
        <title>Sequences</title>
        
        <para>A <literal>Sequence</literal> is a correspondence from 
        a bounded progression of natural numbers. Sequences support the 
        binary operators <literal>[].</literal> (spread), <literal>+</literal> 
        (join) and <literal>[i...]</literal> (upper range) and the ternary 
        operator <literal>[i..j]</literal> (subrange) in addition to operators 
        inherited from <literal>Correspondence</literal>:</para>

        <programlisting><![CDATA[shared interface Sequence<out X> 
        is EnumerableSequence<X>
        satisfies Correspondence<Natural, X> & FiniteCategory<X> & Sized
        given X satisfies Equality<X> {

    doc "The index of the last element of the sequence,
         or |null| if the sequence has no elements."
    shared formal Natural? lastIndex;
    
    shared actual default Iterator<X> iterator {
        class SequenceIterator(Natural from) 
                satisfies Iterator<X> {
            shared actual X? head { 
                return this[from];
            }
            shared actual Iterable<X> tail {
                return SequenceIterator(from+1);
            }
        }
        if (is Iterable<X> sequence) {
            return this.iterator;
        }
        else {
            return SequenceIterator(0);
        }
    }
    
    shared actual default Boolean size {
        if (exists lastIndex) {
            return lastIndex+1;
        }
        else {
            return 0;
        } 
    }
    
    shared actual default Boolean empty {
        return !(this.lastIndex exists);
    }
    
    shared actual default Boolean contains(Object obj) {
        if (is X obj) {
            return forAny (X x in this) some (x==obj);
        }
        else {
            return false;
        }
    }
    
    doc "The first element of the sequence, or
         |null| if the sequence has no elements."
    shared default X? first {
        return this[0];
    }
    
    doc "The rest of the sequence, after removing 
         the first element."
    shared default X[] rest {
        return this[1...];
    }

    doc "The last element of the sequence, or
         |null| if the sequence has no elements."
    shared default X? last {
        if (exists Natural index = sequence.lastIndex) {
            return this[index];
        }
        else {
            return null;
        }
    }
   
}]]></programlisting>
        
        <para>The metatype allows direct instantiation of <literal>X[]</literal>:</para>
        
        <programlisting><![CDATA[shared interface EnumerableSequence<X>
        satisfies Callable<X[],X...> 
        given X satisfies Equality<X> {
    shared actual default X[] call(X... elements) {
        return elements;
    }
}]]></programlisting>
        
        <para>The following extension provides access to the indices 
        of the sequence in a <literal>for</literal> loop.</para>
        
        <programlisting><![CDATA[shared extension class SequenceEntryIterable<X>(X[] this)
        satisfies Iterable<Entry<Natural,X>> 
        given X satisfies Equality<X> {
        
    shared actual Iterator<Entry<Natural,X>> iterator {
        class EntryIterator(Natural from) 
                satisfies Iterator<Entry<Natural,X>> {
            shared actual Entry<Natural,X>? head {
                if (exists X x = this[from]) {
                    return from->x;
                }
                else {
                    return null;
                }
            }
            shared actual Iterable<Entry<Natural,X>> tail {
                return EntryIterator(from+1);
            }
        }
        return EntryIterator(0);
    }
    
}]]></programlisting>

        <comment><para>TODO: or should we just directly make <literal>X[]</literal> 
        assignable to <literal>Entry&lt;Natural,X&gt;[]</literal>?</para></comment>
        
        <para>The compiler is permitted to optimize away the call to these 
        extensions in a loop such as:</para>
        
        <programlisting><![CDATA[for (local elem in sequence) { 
    ...
}]]></programlisting>
        
        <para>or even:</para>
        
        <programlisting><![CDATA[for (Natural n -> local elem in sequence) {
    ...
}]]></programlisting>
        
        <para>which are both equivalent to:</para>
        
        <programlisting><![CDATA[if (exists Natural last=sequence.lastIndex) {
    variable Natural n := 0;
    while (n<=last) { 
        local elem = sequence[n];
        ...
        ++n;
    }
}]]></programlisting>        
        
        <comment><para>TODO: for some kinds of sequences, especially linked
        lists, access by index is very inefficient. How can we make iteration
        of these kinds of sequences efficient?</para></comment>
        
        <para>Toplevel methods define the join and range operators, for 
        sequence types:</para>

        <programlisting><![CDATA[doc "The binary join operator |x + y|. The returned 
     sequence does not reflect changes to the original 
     sequences."
shared T[] join<T>(T[]... sequences) 
        given T satisfies Equality<T> {
            
    object joinedSequence satisfies T[] {
        shared actual Natural? lastIndex {
            variable Natural? result := null;
            for (T[] s in sequences) {
                if (exists Natural last = s.lastIndex) {
                    if (exists result) {
                        result += last;
                    }
                    else {
                        result := last;
                    }
                }
            }
            return result;
        }
        shared actual Gettable<T?> value(Natural index) {
            T? value {
                variable Natural i := index;
                for (T[] s in sequences) {
                    if (exists Natural last = s.lastIndex) {
                        if (i<=last) {
                            return s[i];
                        }
                        else {
                            i-=last;
                        }
                    }
                }
                return null;
                
            }
            return value;
        }
    }
    
    return copy(joinedSequence); //take a shallow copy
    
}]]></programlisting>
        
        <programlisting><![CDATA[doc "The ternary range operator |x[from..to]|, along
     with the binary upper range |x[from...]| operator. 
     The returned sequence does not reflect changes 
     to the original sequence."
shared T[] range<T>(T[] sequence, Natural from, Natural? to=sequence.lastIndex) 
        given T satisfies Equality<T> {
         
    object rangeSequence satisfies T[] {
        shared actual Natural? lastIndex {
            if (exists Natural last = sequence.lastIndex) {
                if (exists to) {
                    if (to<last) {
                        return to-from;
                    }
                    else {
                        return last-from;
                    }
                }
            }
            else {
                return null;
            }
        } 
        shared actual Gettable<T?> value(Natural index) {
            T? value {
                if (exists to) {
                    if (index>to) {
                        return null;
                    }
                }
                return sequence[index+from];
            }
            return value;
        }
     }

    return copy(rangeSequence); //take a shallow copy
    
}]]></programlisting>
        
        <para>There is a mutable subtype which allows assignment to
        an index.</para>
        
        <programlisting><![CDATA[shared interface OpenSequence<X>
        satisfies X[] & OpenCorrespondence<Natural,X> 
        given X satisfies Equality<X> {}]]></programlisting>

        <para>A <literal>BoundedSequence</literal> adds a typesafe bound
        to the indices, allowing use of indices of type <literal>Bounded&lt;#n&gt;</literal>.</para>
        
        <programlisting><![CDATA[shared interface BoundedSequence<out X, N>
        satisfies X[] 
        given X satisfies Equality<X> 
        given N satisfies Dimension {
        
    shared formal Gettable<X> value(Bounded<N> index);
    shared actual default Bounded<N>? lastIndex;
    
}]]></programlisting>

        <para>The following extension provides access to the indices 
        of the bounded sequence in a <literal>for</literal> loop. The
        indices are of type <literal>Bounded&lt;N&gt;</literal>.</para>
        
        <programlisting><![CDATA[shared extension class SequenceEntryIterable<X,N>(BoundedSequence<X,N> this)
        satisfies Iterable<Entry<Bounded<N>,X>> 
        given X satisfies Equality<X> 
        given N satisfies Dimension {
        
    shared actual Iterator<Entry<Bounded<N>,X>> iterator {
        class EntryIterator(Bounded<N> from) 
                satisfies Iterator<Entry<Bounded<N>,X>> {
            shared actual Entry<Bounded<N>,X>? head {
                return from->this[from];
            }
            shared actual Iterable<Entry<Bounded<N>,X>> tail {
                if ( from+1 < natural<N>() ) {
                    return EntryIterator(from.successor);
                }
                else {
                    return none;
                }
            }
        }
        return EntryIterator(0);
    }
    
}]]></programlisting>

        <!--
        <para>A helper class adds a useful convenience attribute.</para>
        
        <programlisting><![CDATA[shared extension class BoundSequences<out X,n>(X[n] sequence) {
   
    doc "A sequence of all indices of the the sequence."
    shared Bounded<n>[n] indices {
        return when (n>0)
            then (Bounded<n>(0)..Bounded<n>(n-1))
            otherwise none;
    }
   
}]]></programlisting>
        -->
        
        <para>There is a mutable subtype which allows assignment to an index.</para>
        
        <programlisting><![CDATA[shared interface OpenBoundedSequence<X,N>
        satisfies BoundedSequence<X,N> & OpenSequence<X> 
        given X satisfies Equality<X> {
    shared Settable<X> value(Bounded<N> index);
}]]></programlisting>

        <para>The value <literal>none</literal> is transparently assignable to 
        <literal>X[]</literal> and <literal>X[0]</literal>.</para>
        
        <programlisting><![CDATA[doc "Represents an empty sequence."
shared object none {

    shared extension class EmptySequence<out X>() 
            satisfies X[0] 
            given X satisfies Equality<X> {
        
        shared actual Natural? lastIndex = null;
        
        shared actual Gettable<X?> value(Natural index) {
            X? nullValue = null;
            return nullValue;
        }
        
        shared actual Gettable<X> value(Bounded<#0> index) {
            throw Exception();
        }
        
    }
    
}]]></programlisting>
        
        <para>The <literal>zip()</literal> function combines <literal>BoundedSequence</literal>s 
        into a single <literal>BoundedSequence</literal>.</para>

        <programlisting><![CDATA[shared BoundedSequence<T,N> zip<T,X,Y,N>(BoundedSequence<X,N> x, BoundedSequence<Y,N> y, T producing(X x, Y y))
        given N satisfies Dimension {
    return from (Bounded<N> i in zeroTo<N>()) 
                select (producing(x[i],y[i]));
}]]></programlisting>

        <programlisting><![CDATA[shared BoundedSequence<Entry<X,Y>,N> zip<X,Y,N>(BoundedSequence<X,N> x, BoundedSequence<Y,N> y) 
        given N satisfies Dimension {
    return zip(x,y,Entry);
}]]></programlisting>

        <programlisting><![CDATA[shared T[n] zip<T,X,N>(BoundedSequence<X,N> lists..., T producing(X x...))  
        given N satisfies Dimension {
    return from (Bounded<N> i in zeroTo<N>()) 
                select (producing(from (BoundedSequence<X,N> list in lists) select (list[i]));
}]]></programlisting>

<!--
        <programlisting><![CDATA[shared T[][n] zip<T,X,n>(X[n] lists...) {
    return zip(lists,ArrayList)
}]]></programlisting>
-->
    </section>
    
    <section id="range">
        <title>Ranges</title>
        
        <para>Ranges satisfy <literal>Sequence</literal>, therefore they 
        support the join, subrange, contains and lookup operators, among 
        others. Ranges may be constructed using the <literal>..</literal> 
        operator:</para> 
        
        <programlisting><![CDATA[shared class Range<X>(X first, X last) 
        extends Object() 
        satisfies X[] & Matcher<X> & Equality<Range<X>>
        given X satisfies Ordinal & Comparable<X> & Equality<X> { 
    
    doc "The first value in the range."
    shared X first = first;
    
    doc "The last value in the range."
    shared X last = last;
    
    doc "Return a |Sequence| of values in the range, 
         beginning at the first value, and 
         incrementing by a constant step size,
         until a value outside the range is
         reached."
    shared X[] by(Natural stepSize) { 
        return from (Natural index->X value in this) 
                    where (index%stepSize == 0)
                    select (value);
    }
    
    shared Natural? index(X x) {
        if (x<first || x>last) {
            return null;
        }
        else {
            //optimize this for numbers!
            variable Natural index:=0;
            variable X value:=first;
            while (value<x) {
                ++index;
                ++value;
            }
            return index;
        }
    }
    
    shared actual Iterator<X> iterator {
        class RangeIterator(X x) 
                satisfies Iterator<X> {
            shared actual X? head { 
                if (x>last) { 
                    return null;
                } 
                else { 
                    return x;
                }
            }
            shared actual Iterator<X> tail {
                return RangeIterator(x.successor);
            }
        }
        return RangeIterator(first);
    }
    
    shared actual Boolean empty = last<first;
    
    shared actual Boolean contains(Object... objects) {
        for (Object x in objects) {
            if (is X x) {
                if ( x<first || x>last ) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        fail {
            return true;
        } 
    }
    
    shared actual Boolean matches(X x) {
        return x>first && x<last;
    }
    
    shared actual Natural? lastIndex = index(last);
    
    shared actual Gettable<X?> value(Natural n) {
        //optimize this for numbers!
        variable Natural index:=0;
        variable X? value:=first;
        while (index<n) {
            ++index;
            ++value;
            if (value>last) {
                value := null;
                break;
            }
        }
        return value;
    }
    
    shared actual Boolean equals(Range<X> that) {
        return that.first==first && that.last==last;
    }
    
    ...
    
}]]></programlisting>
        
        <para>The compiler is permitted to optimize away creation of a
        <literal>Range</literal> in code such as the following:</para>
        
        <programlisting><![CDATA[i in min..max]]></programlisting>
        
        <para>which is equivalent to:</para>
        
        <programlisting><![CDATA[(i>=min && i<=max)]]></programlisting>
        
        <para>and:</para>
        
        <programlisting><![CDATA[for (local i in min..max) {
    ...
}]]></programlisting>
    
        <para>which is equivalent to:</para>
        
        <programlisting><![CDATA[variable local i := min;
while (i<=max) {
    ...
    i.=successor;
}]]></programlisting>
        
    </section>
    
    <section id="characterandstring">
        <title>Characters and strings</title>
        
        <para>UTF-16 Unicode Characters are represented by the following class:</para>

        <programlisting><![CDATA[shared class Character(small Natural utf16)
        extends Object()
        satisfies Ordinal & Comparable<Character> & Matcher<Character> { 
    ... 
    
    doc "The UTF-8 encoding"
    shared String utf8 { return ... }
    
    shared Character lowercase { return .. }
    shared Character uppercase { return .. }
    
    shared extension class StringToCharacter(String this) {
    
        doc "Parse the string representation of a |Character| in UTF-16"
        shared Character parseUtf16Character() { return ... }
    
        doc "Parse the string representation of a |Character| in UTF-8"
        shared Character parseUtf8Character() { return ... }
    
    }
 
}]]></programlisting>
        
        <para><literal>String</literal> satisfies <literal>Sequence</literal>, 
        and therefore supports the join, subrange, contains and lookup operators, 
        among others. Any <literal>Character[]</literal> may be transparently
        converted to <literal>String</literal>.</para> 
                
        <programlisting><![CDATA[shared extension class String(Character[] this) 
        extends Object() 
        satisfies Character[] & Comparable<String> & Matcher<String> & Format {
    
    Character[] chars;
    if (is String this) {
        chars = this;
    }
    else {
        chars = copy(this);
    }
    
    ... 
    
    doc "Split the string into tokens, using the given
         separator characters."
    shared Iterable<String> tokens(Iterable<Character> separators=" ,;\n\l\r\t") { return ... }
    
    doc "Split the string into lines of text."
    shared Iterable<String> lines() { return tokens("\n\l\r") }
    
    shared String replace(Character with(Character character)) { return ... }
    
    shared String replace(Character character -> Character replacement) {
        return replace() with (Character c) 
            (when (c==character) then (replacement) otherwise (c));
    }
    
    shared String replace(Correspondence<Character,Character> replacements) { 
        return replace() with (Character c) (replacements[c] ? c);
    }
    
    doc "The string, with all characters in lowercase."
    shared String lowercase {
        return replace() with (Character c) (c.lowercase);
    }
    
    doc "The string, with all characters in uppercase."
    shared String uppercase {
        return replace() with (Character c) (c.uppercase);
    }
    
    doc "Remove the given characters from the beginning 
         and end of the string.
    shared String strip(Character[] whitespace = " \n\l\r\t") { return ... }
    
    doc "Collapse substrings of the given characters into
         single space characters."
    shared String normalize(Character[] whitespace = " \n\l\r\t") { return ... }
    
    doc "Join the given strings, using this string as
         a separator."
    shared String join(String... strings) { return ... }
    
}]]></programlisting>
        
        <para>The extension class <literal>StringBuilder</literal> makes it more 
        efficient to produce a string using procedural code:</para>
        
        <programlisting><![CDATA[shared extension class StringBuilder(Character[] this) {
        
    Character[] with(Character[] appendedStrings...) {
        variable OpenList<Character> list = ArrayList<Character>(this);
        list.append(string);
        for (Character[] s in appendedStrings) {
            list.append(s);
        }
    }
    
    Character[] forEach<X>(iterated Iterable<X> objects, 
                           Character[] with(coordinated X x)) {
        variable OpenList<Character> list = ArrayList<Character>(this);
        for (X x in objects) {
            list.append(with(x));
        }
        return list;
    }
    
    Character[] forEach<X>(iterated Iterable<X> objects, 
                           Character[][] with(coordinated X x)) {
        variable OpenList<Character> list = ArrayList<Character>(this);
        for (X x in objects) {
            for (Character[] s in with(x)) {
                list.append(s);
            }
        }
        return list;
    }
       
}]]></programlisting>

        <comment><para>TODO: Is this OK, or is it going to need to be a mutable 
        class?</para></comment>
        
        <!--
        <para>A string template is represented by an instance of <literal>StringTemplate</literal>.</para>
        
        <programlisting>shared class StringTemplate(...) {
        
    doc "Evaluate all interpolated expressions, producing 
         a constant character string with no interpolated
         expressions."
    shared extension String interpolate() { return ... }

}</programlisting>
        -->
        
    </section>
    
    <section id="regex">
        <title>Regular expressions</title>
        
        <programlisting><![CDATA[shared extension class Regex(Quoted this)
        satisfies Matcher<String> { 
        
    doc "Return the substrings of the given string which
         match the parenthesized groups of the regex,
         ordered by the position of the opening parenthesis
         of the group." 
    shared Match? matchList(String string)() { return ... }
    
    doc "Determine if the given string matches the regex."
    shared actual Boolean matches(String string) { return ... }
    
    ... 
    
}]]></programlisting>
        
        <comment><para>TODO: I assume these are just Java (Perl 5-style) regular 
        expressions. Is there some other better syntax around? Something BNF-like,
        perhaps?</para></comment>

    </section>
    
    <section id="number">
        <title>Numbers</title>
        
        <para>Ceylon's numeric type system is designed to accommodate the following
        considerations:</para>
        
        <itemizedlist>
            <listitem>
                <para>The system is extensible and new numeric types may be defined
                by libraries. Numeric types defined by libraries should work the 
                same as built-in numeric types.</para>
            </listitem>
            <listitem>
                <para>Two values of different numeric types should be combinable
                using operators without the need for explicit type conversions, 
                but</para>
            </listitem>
            <listitem>
                <para>implicit type conversions should never lose information
                and</para>
            </listitem>
            <listitem>
                <para>binary operators must be symmetric.</para>
            </listitem>
            <listitem>
                <para>Furthermore, there should be no special cases in the language 
                definition or type checker to accommodate numeric types.</para>
            </listitem>
            <listitem>
                <para>However, it must be possible for the compiler to optimize 
                certain of the built-in numeric types to take advantage of the VM's 
                native support for numeric types.</para>
            </listitem>
            <listitem>
                <para>It is not necessary to encode information about the limits
                of the machine's representation of a numeric value into the type
                system. A single <literal>Integer</literal> class is sufficient
                to represent 32, 64, or 128 bit integer values. A single 
                <literal>Float</literal> class is sufficient to represent single
                and double precision floating point values. It is simply not
                possible for the compiler to detect numeric overflow or loss of
                significant precision.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <literal>Number</literal> interface is the abstract supertype
        of all classes which represent numeric values.</para>
        
        <programlisting><![CDATA[shared interface Number {
    
    doc "Determine if the number represents
         an integer value"
    shared formal Boolean integral;
    
    doc "Determine if the number is positive"
    shared formal Boolean positive;
    
    doc "Determine if the number is negative"    
    shared formal Boolean negative;

    doc "Determine if the number is zero"
    shared formal Boolean zero;
    
    doc "Determine if the number is one"
    shared formal Boolean unit;
    
    doc "The number, represented as a |Decimal|"
    shared formal Decimal decimal;

    doc "The number, represented as a |Float|"
    throws (FloatOverflowException
            -> "if the number is too large to be
                represented as a |Float|")
    shared formal Float float;
    
    doc "The number, represented as an |Whole|,
         after truncation of any fractional 
         part"
    shared formal Whole whole;
    
    doc "The number, represented as an |Integer|,
         after truncation of any fractional 
         part"
    throws (IntegerOverflowException
            -> "if the number is too large to be
                represented as an |Integer|")
    shared formal Integer integer;
    
    doc "The number, represented as a |Natural|,
         after truncation of any fractional 
         part"
    throws (NegativeNumberException
            -> "if the number is negative")
    shared formal Natural natural;
    
    doc "The magnitude of the number"
    shared formal subtype magnitude;
    
    doc "1 if the number is positive, -1 if it
         is negative, or 0 if it is zero."
    shared formal subtype sign;
    
    doc "The fractional part of the number,
         after truncation of the integral
         part"
    shared formal subtype fractionalPart;
    
    doc "The integral value of the number 
         after truncation of the fractional
         part"
    shared formal subtype wholePart;

}]]></programlisting>

        <comment><para>TODO: Actually, instead of throwing exceptions, the 
        type conversion operations should return optional values.</para></comment>

        <para>It is not possible to perform arithmetic or comparisons upon
        a <literal>Number</literal> without additional information about its
        type.</para>

        <para>The subtype <literal>Numeric</literal> supports the binary 
        operators <literal>+,-, *, /, **</literal>. In addition, 
        <literal>variable</literal> values of type <literal>Numeric</literal> 
        support the compound assignment operators 
        <literal>+=, -=, /=, *=</literal>.</para>

<programlisting><![CDATA[shared interface Numeric<N>
        satisfies Number & Comparable<N>
        given N satisfies Numeric<N> {

    doc "The binary |+| operator"
    shared formal N plus(N number);

    doc "The binary |-| operator"
    shared formal N minus(N number);

    doc "The binary |*| operator"
    shared formal N times(N number);

    doc "The binary |/| operator"
    shared formal N divided(N number);

    doc "The binary |**| operator"
    shared formal N power(N number);
    
}]]></programlisting>

        <comment><para>TODO: I suppose <literal>Numeric</literal> should not satisfy
        <literal>Comparable</literal>, since complex numbers are not comparable.</para></comment>

        <para>The subtype <literal>Integral</literal> supports the binary 
        operator <literal>%</literal>, and inherits the unary operators 
        <literal>++</literal> and <literal>--</literal> from 
        <literal>Ordinal</literal>.</para>

<programlisting><![CDATA[shared interface Integral<N>
        satisfies Numeric<N> & Ordinal
        given N satisfies Number {

    doc "The binary |%| operator"
    shared formal N remainder(N number);

}]]></programlisting>

        <para>The type <literal>Invertable</literal> supports the unary
        prefix <literal>-</literal> operator.</para>
        
        <programlisting><![CDATA[shared interface Invertable<I> 
    given I satisfies Number {
    
    doc "The unary |-| operator"
    shared formal I inverse;

}]]></programlisting>
        
        <para>Five numeric types are built in:</para>

        <para><literal>Natural</literal> represents 63 bit unsigned integers
        (including zero).</para>
        
        <programlisting><![CDATA[shared class Natural(Natural natural)
        extends Object() 
        satisfies Integral<Natural> & Invertable<Integer> & Matcher<Integer> { 
    ... 
    
    doc "Implicit type promotion to |Integer|"
    shared actual extension Integer integer { return ... }
    
    doc "Implicit type promotion to |Whole|"
    shared actual extension Whole whole { return ... }
    
    doc "Implicit type promotion to |Float|"
    shared actual extension Float float { return ... }
    
    doc "Implicit type promotion to |Decimal|"
    shared actual extension Decimal decimal { return ... }

    doc "Shift bits left by the given number of places"
    shared Natural leftShift(Natural digits) { return ... }
    
    doc "Shift bits right by the given number of places"
    shared Natural rightShift(Natural digits) { return ... }
    
    shared extension class StringToNatural(String this) {
    
        doc "Parse the string representation of a |Natural| in the given radix"
        shared Natural parseNatural(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <comment><para>TODO: the <literal>Numeric</literal> type is much more complicated
        because of <literal>Natural</literal>. As an alternative approach, we could replace
        <literal>Natural</literal> with a <literal>Binary</literal> type, and have 
        <literal>Integer</literal> literals instead of <literal>Natural</literal> 
        literals. I don't love this, because natural numbers are especially common in real
        applications.</para></comment>

        <para><literal>Integer</literal> represents 64 bit signed integers.</para>

        <programlisting><![CDATA[shared class Integer(Boolean sign, Natural natural)
        extends Object() 
        satisfies Integral<Integer> & Invertable<Integer> & Matcher<Integer> {
    ...
    
    doc "Implicit type promotion to |Whole|"
    shared actual extension Whole whole { return ... }
    
    doc "Implicit type promotion to |Float|"
    shared actual extension Float float { return ... }

    doc "Implicit type promotion to |Decimal|"
    shared actual extension Decimal decimal { return ... }

    shared extension class StringToInteger(String this) {
    
        doc "Parse the string representation of an |Integer| in the given radix"
        shared Integer parseInteger(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <para><literal>Whole</literal> represents arbitrary-precision
        signed integers.</para>

        <programlisting><![CDATA[shared class Whole(Boolean sign, small Natural... digits)
        extends Object() 
        satisfies Integral<Whole> & Invertable<Whole> {
    ...
    
    shared small Natural precision = ...;
    
    doc "Implicit type promotion to |Decimal|"
    shared actual extension Decimal decimal { return ... }
    
    shared extension class StringToWhole(String this) {
    
        doc "Parse the string representation of a |Whole| in the given radix"
        shared Whole parseWhole(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>
        
        <para><literal>Float</literal> represents 64 bit floating point
        values.</para>

        <programlisting><![CDATA[shared class Float(Float float)
        extends Object() 
        satisfies Numeric<Float> & Invertable<Float> { 
    ... 
    
    doc "The natural logarithm of the number"
    shared Float ln { return ... }
    
    doc "Implicit type promotion to |Decimal|"
    shared actual extension Decimal decimal { return ... }
    
    shared extension class StringToFloat(String this) {
    
        doc "Parse the string representation of a |Float| in the given radix"
        shared Float parseFloat(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <para><literal>Decimal</literal> represents arbitrary-precision
        and arbitrary-scale decimals.</para>

        <programlisting><![CDATA[shared class Decimal(Whole value, small Integer scale)
        extends Object() 
        satisfies Numeric<Decimal> & Invertable<Decimal> {
    ...

    shared small Natural precision = ...;
    shared small Integer scale = ...;
    
    shared extension class StringToDecimal(String this) {
    
        doc "Parse the string representation of a |Decimal| in the given radix"
        shared Decimal parseDecimal(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

    </section>
    
    <section id="slots">
        <title>Slotwise operations</title>
        
        <para>The interface <literal>Slots</literal> defines the slotwise 
        binary operators <literal>|, &amp;, ^</literal> and <literal>~</literal>. 
        For any implementation of <literal>Slots</literal>, there should be 
        a "slot" function that accepts a key and returns a 
        <literal>Boolean</literal>.</para>
        
        <programlisting><![CDATA[shared interface Slots<B>
        given B satisfies Slots<B> {
        
    doc "Slotwise or operator |x | y|. Implementations
         should respect the constraint that 
         |(x|y).slot(z)==(x.slot(z)||y.slot(z))|."
    shared formal B or(B bits);
    
    doc "Slotwise and operator |x & y|. Implementations
         should respect the constraint that 
         |(x&y).slot(z)==(x.slot(z)&&y.slot(z))|."
    shared formal B and(B bits);
    
    doc "Slotwise xor operator |x ^ y|. Implementations
         should respect the constraint that 
         |(x^y).slot(z)==((x|y).slot(z)&&!(x&y).slot(z))|."
    shared formal B xor(B bits);
    
    doc "Slotwise complement in operator |x ~ y|. 
         Implementations should respect the constraint 
         that |(x~y).slot(z)==(x.slot(z)&&!y.slot(z))|."
    shared formal B complement(B bits);
    
}]]></programlisting>

        <para><literal>Set</literal> extends <literal>Slots</literal>. 
        In the case of a set, <literal>|</literal> represents union, 
        <literal>&amp;</literal> represents intersection, and
        <literal>~</literal> represents set complement.</para>

        <para>The interface <literal>FixedSlots</literal> defines the 
        unary operator <literal>~</literal>.</para>
        
        <programlisting><![CDATA[shared interface FixedSlots<B> 
        satisfies Slots<B> {
        
    doc "Slotwise complement operator |~x|. 
         Implementations should respect the constraint 
         that |(~x).slot(z)==!x.slot(z)|."
    shared formal Bits<B> complement;
    
}]]></programlisting>

    </section>
        
    <section id="bitstrings">
        <title>Bit strings</title>
        
        <para>The interface <literal>Bits</literal> represents a fixed length
        string of boolean values, and supports the unary operator 
        <literal>~</literal>.</para>
        
        <programlisting><![CDATA[shared interface Bits<N> 
        satisfies BoundedSequence<Boolean,N> & Equality<Bits<N>> & FixedSlots<Bits<N>> 
        given N satisfies Dimension {}]]></programlisting>

        <comment><para>TODO: should we model <literal>Bits&lt;N&gt;</literal> as 
        a decorator of <literal>Boolean[n]</literal>, like what we do with 
        <literal>String</literal> and <literal>Character[]</literal>?</para></comment>

        <para>Boolean values are transparently converted to and from 
        <literal>Bits&lt;1&gt;</literal>.</para>

        <programlisting><![CDATA[shared extension class BooleanBit(Boolean this)
        satisfies Bits<1> {

    shared extension Boolean boolean { return this; }

    shared actual Bits<1> or(Bits<1> bit) {
        if (this) {
            return this;
        else {
            return bit;
        }
    }
    
    shared actual Bits<1> and(Bits<1> bit) {
        if (this) {
            return bit;
        else {
            return false;
        }
    }
    
    shared actual Bits<1> xor(Bits<1> bit) {
        if (this) {
            return bit.complement;
        else {
            return bit;
        }
    }
    
    shared actual Bits<1> complement(Bits<1> bit) {
        if (this) {
            return bit.complement;
        else {
            return this;
        }
    }
    
    shared actual Bits<1> complement {
        return BooleanBit(!this);
    }
    
    shared actual Gettable<Boolean> value(Bounded<1> index) {
        return this;
    }
    
    shared actual Gettable<Boolean?> value(Natural key) {
        Boolean? result;
        if (key==0) {
            result = boolean;
        }
        else {
            result = null;
        }
        return result;
    }
    
    shared actual Bounded<1> lastIndex {
        return 0;
    }
    
}]]></programlisting>

        <!--
        <programlisting><![CDATA[shared extension Bits<1> booleanToBits(Boolean b) { .... }]]></programlisting>
        <programlisting><![CDATA[shared extension Boolean bitsToBoolean(Bits<1> b) { return b[0] }]]></programlisting>
        -->

        <comment><para>TODO: we need a bunch of functions for converting bit 
        strings to and from numeric values, characters, etc.</para></comment>
        
    </section>
    
    <section id="metamodel">
        <title>Metamodel</title>
        
        <para>The metamodel (reflection API) reifies the schema of a type, making 
        it available to the program at runtime.</para>
        
        <comment><para>TODO: This whole API is over-complex because of the 
        <literal>in</literal> type parameter on <literal>Member</literal> and the
        lack of a <literal>bottom</literal> type. It forced me to introduce the
        <literal>*Declaration</literal> types in order to be able to hold a reference
        to a member of an unknown type. With a <literal>bottom</literal> type we would 
        be able to write <literal>Attribute&lt;bottom,String&gt;</literal> instead of 
        <literal>AttributeDeclaration&lt;String&gt;</literal>. Actually this API is
        the only place I have found myself wishing for Java-style wildcard types.</para></comment>
        
        <para>An <literal>Annotated</literal> program element may be asked for a
        list of its annotation values.</para>

        <programlisting><![CDATA[shared interface Annotated {

    doc "Return all the annotation values that are 
         assignable to the given type."
    shared formal T[] annotations<T>(Type<T> type = Object) 
            given T satisfies Object;
    
}]]></programlisting>

        <para>A <literal>Declaration</literal> has a name, and may be 
        <literal>shared</literal>.</para>

        <programlisting><![CDATA[shared interface Declaration
        satisfies Annotated {

    shared formal String name;
    
    shared formal Boolean shared;
    
}]]></programlisting>

        <para>A <literal>CallableDeclaration</literal> has formal parameters.</para>

        <programlisting><![CDATA[shared interface CallableDeclaration<R>
        satisfies Declaration {

    shared formal Type<R> returnType;
    
    shared formal Parameter<Object>[] parameters;
    
    shared formal R unsafeCall(Object obj);

}]]></programlisting>

        <para>A <literal>Parameter</literal> represents a parameter of a method 
        or class.</para>

        <programlisting><![CDATA[shared interface Parameter<out T> 
        satisfies Annotated {
        
    shared formal String name;
    
    shared formal Type<T> type;
    
}]]></programlisting>
        
        <para>A <literal>TypeDeclaration</literal> has members.</para>
        
        <programlisting><![CDATA[shared interface TypeDeclaration
        satisfies Declaration {
        
    doc "Return all matching members of the given type."
    shared formal Set<M> members<M>(Type<M> type = MemberDeclaration)
            given M satisfies MemberDeclaration;
            
}]]></programlisting>
        
        <para>A <literal>ClassDeclaration</literal> may be <literal>abstract</literal>.</para>
        
        <programlisting><![CDATA[shared interface ClassDeclaration<X>
        satisfies CallableDeclaration<X> & TypeDeclaration {
        
    shared formal Boolean abstract;
    
}]]></programlisting>

        <para>A <literal>MemberDeclaration</literal> is a declaration that 
        belongs to a type.</para>

        <programlisting><![CDATA[shared interface MemberDeclaration
        satisfies Declaration {
    
    shared formal Boolean default;
    shared formal Boolean formal;
    shared formal Boolean actual;
    
    shared formal TypeDeclaration declaringType;
        
}]]></programlisting>
        
        <para>A <literal>FunctionDeclaration</literal> includes a return type.</para>
        
        <programlisting><![CDATA[shared interface FunctionDeclaration<out R>
        satisfies CallableDeclaration<R> {}]]></programlisting>

        <para>A <literal>ValueDeclaration</literal> has a type, and may be
        <literal>variable</literal>.</para>
        
        <programlisting><![CDATA[shared interface ValueDeclaration<out T>
        satisfies Declaration {
        
     shared formal Boolean variable;
     
     shared formal Type<T> valueType;
     
     shared formal T unsafeGet(Object obj);
    
}]]></programlisting>

        <programlisting><![CDATA[shared interface MethodDeclaration<out R>
        satisfies MemberDeclaration & FunctionDeclaration<R> {}]]></programlisting>

        <programlisting><![CDATA[shared interface AttributeDeclaration<out T>
        satisfies MemberDeclaration & ValueDeclaration<T> {}]]></programlisting>
        
        <programlisting><![CDATA[shared interface MemberClassDeclaration<out X>
        satisfies MemberDeclaration & ClassDeclaration<X> {}]]></programlisting>

        <para>A <literal>Function</literal> represents a toplevel method.</para>

        <programlisting><![CDATA[shared interface Function<out R, P...> 
        satisfies Callable<R, P...> & FunctionDeclaration<R> {}]]></programlisting>

        <programlisting><![CDATA[shared interface OpenFunction<R, P...> satisfies Function<R, P...> {
        
    shared formal void intercept( R onInvoke(R proceed(P... args), P... args) )();
    
}]]></programlisting>

        <para>A <literal>Value</literal> represents a toplevel attribute.</para>

        <programlisting><![CDATA[shared interface Value<out T> 
        satisfies ValueDeclaration<T> {
        
    shared formal extension Gettable<T> value;

}]]></programlisting>
        
        <programlisting><![CDATA[shared interface OpenValue<T> satisfies Value<T> {
        
    shared formal void intercept( T onGet(T proceed()) )();
    
}]]></programlisting>
       
        <programlisting><![CDATA[shared interface MutableValue<T> 
        satisfies Value<T> {
        
    shared actual formal Settable<T> value;

}]]></programlisting>
        
        <programlisting><![CDATA[shared interface OpenMutableValue<T> 
        satisfies MutableValue<T> & OpenValue<T> {
        
    shared formal void intercept( void onSet(void proceed(T value), T value) )();
    
}]]></programlisting>

        <comment><para>TODO: should <literal>onSet()</literal> return the new value of
        the attribute instead of being <literal>void</literal>?</para></comment>
        
        <para>An instance of <literal>Type</literal> represent a type: an interface or 
        class, together with type arguments.</para>
        
        <programlisting><![CDATA[shared interface Type<out X> 
        satisfies TypeDeclaration {
    ...
}]]></programlisting>
        
        <para>An instance of <literal>Interface</literal> represents an interface.</para>
        
        <programlisting><![CDATA[shared interface Interface<out X> 
        satisfies Type<X> {}]]></programlisting>

        <para>An instance of <literal>Class</literal> represents a class.</para>
        
        <programlisting><![CDATA[shared interface Class<out X> 
        satisfies Type<X> & ClassDeclaration<X> {}]]></programlisting>

        <para>An instance of <literal>ConcreteClass</literal> represents a class
        which can be directly instantiated.</para>
        
        <programlisting><![CDATA[shared interface ConcreteClass<out X, P...> 
        satisfies Class<X> & Callable<X,P...> {}]]></programlisting>

        <programlisting><![CDATA[shared interface OpenConcreteClass<X, P...> 
        satisfies ConcreteClass<X> {
    
    shared formal intercept(X onInstantiate(X proceed(P... args), P... args))();
    
}]]></programlisting>

        <para>An instance of <literal>Member</literal> represents a method, attribute,
        or member type.</para>

        <programlisting><![CDATA[shared interface Member<in X, out T>
        satisfies MemberDeclaration & Callable<T,X> {}]]></programlisting>

        <para>A <literal>Method</literal> represents a method declaration.</para>

        <programlisting><![CDATA[shared interface Method<in X, out R, P...> 
        satisfies Member<X, Function<R, P...>> & MethodDeclaration<R> {}]]></programlisting>

        <programlisting><![CDATA[shared interface OpenMethod<in X, R, P...> 
        satisfies Method<in X, R, P...>> {

    shared formal void intercept<S>( R onInvoke(S instance, R proceed(P... args), P... args) )()
                    given S abstracts X;
    
}]]></programlisting>

        <para>An <literal>Attribute</literal> represents an attribute declaration.</para>

        <programlisting><![CDATA[shared interface Attribute<in X, out T> 
        satisfies Member<X, Value<T>> & AttributeDeclaration<T> {}]]></programlisting>

        <programlisting><![CDATA[shared interface OpenAttribute<in X, T> 
        satisfies Attribute<X, T> {
        
    shared formal void intercept<S>( T onGet(S instance, T proceed()) )()
                    given S abstracts X;
    
}]]></programlisting>

        <programlisting><![CDATA[shared interface MutableAttribute<in X, T> 
        satisfies Attribute<X, T> & Member<X, MutableValue<T>> {}]]></programlisting>
        
        <programlisting><![CDATA[shared interface OpenMutableAttribute<in X, T> 
        satisfies OpenAttribute<X, T> & MutableAttribute<X, T> {
        
    shared formal void intercept<S>( void onSet(S instance, void proceed(T value), T value) )()
                    given S abstracts X;
    
}]]></programlisting>

        <para>An instance of <literal>MemberType</literal> represents a member 
        type.</para>
        
        <programlisting><![CDATA[shared interface MemberType<in X, out Y> 
        satisfies Type<Y> & Member<X, Type<Y>> {}]]></programlisting>

        <para>An instance of <literal>MemberInterface</literal> represents a member 
        interface.</para>
        
        <programlisting><![CDATA[shared interface MemberInterface<in X, out Y> 
        satisfies MemberType<X, Y> & Member<X, Interface<Y>> {}]]></programlisting>

        <para>An instance of <literal>MemberClass</literal> represents a member 
        class.</para>
        
        <programlisting><![CDATA[shared interface MemberClass<in X, out Y> 
        satisfies MemberType<X, Y> & Member<X, Class<Y>> & MemberClassDeclaration<Y> {}]]></programlisting>

        <para>An instance of <literal>MemberConcreteClass</literal> represents a member 
        class that can be directly instantiated.</para>
        
        <programlisting><![CDATA[shared interface MemberConcreteClass<in X, out Y, P...> 
        satisfies MemberType<X, Y> & Member<X, ConcreteClass<Y,P...>> {}]]></programlisting>

        <programlisting><![CDATA[shared interface OpenMemberConcreteClass<in X, Y, P...> 
        satisfies MemberConcreteClass {
    
    shared formal void intercept<S>( Y onCreate(S instance, Y proceed(P... args), P... args) )()
                    given S abstracts X;
    
}]]></programlisting>

        <para>An interceptor may be removed by invoking the returned method reference:</para>

        <programlisting><![CDATA[void removeSayInterceptor() = person.say.intercept() 
    onInvoke(void proceed(String words), String words) { 
        proceed(words.uppercase);
    };
...
removeSayInterceptor();]]></programlisting>

    </section>
    
    <section id="process">
        <title>The current process</title>
        
        <para>The object <literal>process</literal> provides information about the
        current process, command line arguments, and access to the standard input 
        and output streams.</para>
        
        <programlisting><![CDATA[shared object process {
    
    shared List<String> args = ... ;
    
    shared Map<String,String> properties = ... ;
    
    shared extension OutputStream out = .... ;
    shared extension InputStream in = .... ;
    
}]]></programlisting>
        
        <programlisting>shared void writeLine(String line) = process.output.writeLine;</programlisting>
    
    </section>
    
    <section id="formattingobjects">
        <title>Formatting objects</title>
        
        <para>The interface <literal>Format</literal> defines a method
        to produce a <literal>String</literal> representation of a certain object.
        An expression of type <literal>FormattedObject</literal> may be the target
        of the format operator <literal>$</literal> or may be used in a string
        template. Classes should not satisfy <literal>FormattedObject</literal> 
        directly. Instead, an extension may decorate a class with a representation
        in a particular format.</para>
        
        <programlisting>shared interface Format {
    shared formal String formatted;
}</programlisting>

        <para>The package <literal>ceylon.language.util</literal>, which is not imported
        by default, defines a format useful only for debugging purposes:</para>
        
        <programlisting>shared extension class DebugFormat(Object? obj) 
        satisfies Format {
    shared actual String formatted {
        if (obj exists) {
            return obj.string;
        }
        else {
            return "null";
        }
    }
}</programlisting>

        <para>A compilation unit selects a format by enabling the corresponding  
        extension.</para>
        
    </section>
    
    <section id="logging">
        <title>Logging</title>
        
        <para>The class <literal>lang.Log</literal> allows all modules in an application
        to send log messages to a common output stream.</para>
        
        <programlisting><![CDATA[shared class Log(LogChannel channel, String category) {
    
    shared void log(LogPriority priority, Gettable<String> message) {
        if ( channel.enabled(priority) ) {
            send(priority, message);
        }
    }
    
    shared void log(LogPriority priority, String message) {
        if ( channel.enabled(priority) ) {
            send(priority, message);
        }
    }
    
    void send(LogPriority priority, String message) {
        channel.send( priority, LogMessage(priority, category, message) );
    }
    
}]]></programlisting>

        <para>The class <literal>LogPriority</literal> defines an extensible set of
        levels of importance for log messages.</para>

        <programlisting><![CDATA[shared object trace extends LogPriority("Trace", 100) {}
shared object info extends LogPriority("Info", 200) {}
shared object warn extends LogPriority("Warn", 300) {}
shared object error extends LogPriority("Error", 400) {}

doc "The severity of a log message."
shared abstract class LogPriority(String string, Natural priority) {
    shared actual String string = string;
    shared Natural priority = priority;
}]]></programlisting>

        <para>The class <literal>LogMessage</literal> describes a log message:</para>
        
        <programlisting><![CDATA[shared class LogMessage(LogPriority priority, String category, String message) {
    shared Priority priority = priority;
    shared String category = category;
    shared String message = message;
    shared Datetime datetime = currentDatetime();
}]]></programlisting>

        <para>The following extensions make it easy to log from any object:</para>
        
        <programlisting><![CDATA[shared extension class ObjectLog(Object this) {
    shared Log log { 
        return Log(defaultLogChannel, this.type.name);
    }
}]]></programlisting>

        <programlisting><![CDATA[shared extension class Logs(Log this) {
    shared void debug(Gettable<String> message) { this.log(debug, message); }
    shared void debug(String message) { this.log(debug, message); }
    shared void info(Gettable<String> message) { this.info(debug, message); }
    shared void info(String message) { this.info(debug, message); }
    shared void warn(Gettable<String> message) { this.warn(debug, message); }
    shared void warn(String message) { this.warn(debug, message); }
    shared void error(Gettable<String> message) { this.error(debug, message); }
    shared void error(String message) { this.error(debug, message); }
}]]></programlisting>
    
    </section>
    
    <!--
    
    <section id="datetime">
        <title>Instants, intervals and durations</title>
        
        <comment><para>TODO: this stuff is just for illustration, the real
        date/time API will be much more complex and fully internationalized.</para></comment>
        
        <programlisting><![CDATA[shared class Instant() {
    ...
}]]></programlisting>

        <programlisting><![CDATA[shared class Time(Natural hours, Natural minutes, 
        Natural? seconds=null, Natural? milliseconds=null,
        Timezone? timezone=null) 
        extends Instant() {
    shared Natural hours = hours;
    shared Natural minutes = minutes;
    shared Natural? seconds = seconds;
    shared Natural? milliseconds = milliseconds;
    shared Timezone? timezone = timezone;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[shared class Date(Integer year, Natural month, Natural day) 
        extends Instant() {
    shared Integer year = year;
    shared Natural month = month;
    shared Natural day = day;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[shared class Datetime(Time time, Date date) 
        extends Instant() {
    shared Time time = time;
    shared Date date = date;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[shared class Interval<X>(X start, X end) 
        given X satisfies Instant {
    shared X start = start;
    shared X end = end;
    shared Duration<X> duration { return ... }
    ...
}]]></programlisting>

        <programlisting><![CDATA[shared class Duration<X>(Map<Granularity<X>, Natural> magnitude) 
        given X satisfies Instant {

    shared Map<Granularity<X>, Natural> magnitude = magnitude;
    
    shared X before(X instant) { ... }
    shared X after(X instant) { ... }
    
    shared Datetime before(Datetime instant) { ... }
    shared Datetime after(Datetime instant) { ... }
    
    shared Duration<X> add(Duration<X> duration) { ... }
    shared Duration<X> subtract(Duration<X> duration) { ... }
    
    ...
}]]></programlisting>

        <programlisting><![CDATA[shared interface Granularity<X> 
        given X satisfies Instant {}]]></programlisting>

        <programlisting><![CDATA[shared class DateGranularity()
        satisfies Granularity<Date> {
    case year, 
    case month, 
    case week, 
    case day;
}]]></programlisting>

        <programlisting><![CDATA[shared class TimeGranularity()
        satisfies Granularity<Time> {
    case hour, 
    case minute, 
    case second, 
    case millisecond;
}]]></programlisting>
        
    </section>
    
    -->
    
    <section id="control">
        <title>Control expressions</title>
        
        <para>The <literal>ceylon.language.assertion</literal> package defines 
        support for assertions.</para>
        
        <programlisting><![CDATA[doc "Assert that the block evaluates to true. The block 
     is executed only when assertions are enabled. If
     the block evaluates to false, throw an 
     |AssertionException| with the given message."
shared void assert(Gettable<String> message, Boolean that()) {
    Boolean callerAssertionsEnabled  = ... ;
    if ( assertionsEnabled && !that() ) {
        throw AssertionException(message);
    }
}]]></programlisting>

        <comment><para>TODO: or should we do something more like what we do for
        logging, so that we get the caller class passed in?</para></comment>
    
        <para>The <literal>ceylon.language.conditional</literal> package defines 
        support for conditional expressions.</para>
        
        <!--
        <programlisting><![CDATA[doc "If the condition is true, evaluate first block,
     and return the result. Otherwise, return |null|."
shared Y? when<Y>(Boolean condition,
                  Y then()) {
    if (condition) {
        return then()
    }
    else {
        return null
    }
}]]></programlisting>
        -->
        <programlisting><![CDATA[doc "If the condition is true, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
shared Y when<Y>(Boolean condition,
                 Y then(), 
                 Y otherwise()=get(null)) {
    if (condition) {
        return then();
    }
    else {
        return otherwise();
    }
}]]></programlisting>
<!--
        <programlisting><![CDATA[doc "If the value is non-null, evaluate first block,
     and return the result. Otherwise, return |null|."
shared Y? with<X,Y>(specified X? value,
                    Y then(coordinated X x)) {
    if (exists value) {
        return then(value);
    }
    else {
        return null;
    }
}]]></programlisting>
-->
        <programlisting><![CDATA[doc "If the value is non-null, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
shared Y with<X,Y>(specified X? value,
                   Y then(coordinated X x), 
                   Y otherwise()=get(null)) {
    if (exists value) {
        return then(value);
    }
    else {
        return otherwise();
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the given list is nonempty, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
shared Y withFirst<X,Y>(X[] list,
                        Y pop(X first, X... rest), 
                        Y otherwise()=get(null)) {
    if (exists X first = list.first) {
        return pop(first, list.rest);
    }
    else {
        return otherwise();
    }
}]]></programlisting>

        <para>The <literal>ceylon.language.exceptional</literal> package defines 
        support for exceptional expressions.</para>
        
        <programlisting><![CDATA[doc "Attempt to evaluate the first block. If an 
     exception occurs that matches the second block, 
     evaluate the block."
shared Y attempt<Y,E>(Y seek(),
                      Y except(E e)) {
    try {
        return seek();
    }
    catch (E e) {
        return except(e);
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "Using the given resource, attempt to evaluate 
     the first block."
shared Y using<X,Y>(specified X resource,
                    Y seek(coordinated X x))
        given X satisfies Usable {
    try (resource) {
        return seek(resource);
    }
}]]></programlisting>

<!--
        <programlisting><![CDATA[doc "Using the given resource, attempt to evaluate 
     the first block. If an exception occurs that 
     matches the second block, evaluate the second 
     block."
shared Y using<X,Y,E>(specified X resource,
                      Y seek(coordinated X x),
                      Y except(E e))
        given X satisfies Usable {
    try (resource) {
        return seek(resource);
    }
    catch (E e) {
        return except(e);
    }
}]]></programlisting>
-->  
<!--

        <programlisting><![CDATA[doc "Evaluate the block which matches the selector value, and
     return the result of the evaluation. If no block matches
     the selector value, return a null value."
shared Y? select<X,Y>(X selector,
                              cases Iterable<Entry<Matcher<X>, functor Y()>> value) {
    for (Matcher<X> match -> X evaluate() in value) {
        if ( match.test(selector) ) {
            return evaluate(value);
        }
    }
    return null;
}]]></programlisting>

        <programlisting><![CDATA[doc "Evaluate the block which matches the selector value, and
     return the result of the evaluation. If no block matches
     the selector value, evaluate the last block and return
     the result of the evaluation."
shared Y select<X,Y>(X selector,
                     cases Iterable<Entry<Matcher<X>, functor Y()>> value,
                     Y otherwise()) {
    if (exists Y y = select(selector, value)) {
        return y;
    }
    else {
        return otherwise();
    }
}]]></programlisting>

-->

        <para>The <literal>ceylon.language.repetition</literal> package defines 
        support for loops.</para>
        
        <programlisting><![CDATA[doc "Repeat the block the given number of times."
shared void repeat(Natural repetitions, void times()) {
    variable Natural n:=0; 
    while (n<repetitions) {
        times();
        n++;
    }
}]]></programlisting>
    
        <para>The <literal>ceylon.language.quantification</literal> package defines 
        support for quantifiers.</para>
        
        <programlisting><![CDATA[doc "Count the elements for which the block 
     evaluates to true."
shared Natural count<X>(iterated Iterable<X> elements,
                        Boolean where(coordinated X x)) {
    variable Natural count := 0;
    for (X x in elements) {
        if ( where(x) ) {
            ++count;
        }
    }
    return count;
}]]></programlisting>

        <programlisting><![CDATA[doc "Return true iff for every element, the block 
     evaluates to true."
shared Boolean forAll<X>(iterated Iterable<X> elements,
                         Boolean every(coordinated X x)) {
    for (X x in elements) {
        if ( !every(x) ) {
            return false;
        }
    }
    return true;
}]]></programlisting>

        <programlisting><![CDATA[doc "Return true iff for some element, the block 
     evaluates to true."
shared Boolean forAny<X>(iterated Iterable<X> elements,
                         Boolean some(coordinated X x)) {
    Boolean where(X x) { return !some(x); }
    return !forAll(elements, where);
}]]></programlisting>

<!--
        <programlisting><![CDATA[doc "Return the first element for which the block 
     evaluates to true, or |null| if no such element 
     is found."
shared X? firstOrNull<X>(iterated Iterable<X> elements,
                   Boolean where(coordinated X x)) {
    for (X x in elements) {
        if ( where(x) ) {
            return x;
        }
    }
    return null;
}]]></programlisting>
-->
        <programlisting><![CDATA[doc "Return the first element for which the first 
     block evaluates to true, or the result of 
     evaluating the second block, if no such 
     element is found."
shared X first<X>(iterated Iterable<X> elements,
                  Boolean where(coordinated X x),
                  X otherwise()=get(null)) {
    if (exists X first = first(elements, where)) {
        return first;
    }
    else {
        return otherwise();
    }
}]]></programlisting>
        
        <para>The <literal>ceylon.language.comprehension.list</literal> package defines 
        support for <literal>List</literal> comprehensions, tabulations, and folds.</para>
        
        <programlisting><![CDATA[doc "Iterate elements and select those for which 
     the first block evaluates to true. For each of 
     these, evaluate the second block. Build a list 
     of the resulting values, ordered using the 
     third block, if specified."
shared List<Y> from<X,Y,C>(iterated Iterable<X> elements,
                           Boolean where(coordinated X x) = always, 
                           Y select(coordinated X x) = id,
                           C by(coordinated X x) = id) 
        given C satisfies Comparable<C> {
    OpenList<Y> list = ArrayList<Y>();
    for (X x in elements) {
        if ( where(x) ) {
            list.append( select(x) );
        }
    }
    list.sort(by);
    return list;
}]]></programlisting>

        <comment><para>TODO: rewrite <literal>from()</literal> to delegate to 
        <literal>list()</literal>.</para></comment>

        <programlisting><![CDATA[shared List<X> tabulate(Natural length, X containing(Natural index)) {
    OpenList<X> list = ArrayList<X>();
    for (Natural i in 0..length-1) {
        list.append(containing(i));
    }
    return list;
}]]></programlisting>
        
        <!--
        <programlisting><![CDATA[shared List<X> generate(X first, X? next(X previous)) {
    OpenList<X> list = ArrayList<X>();
    list.append(first);
    variable X? x := first;
    while (true) {
        x := element(x);
        if (exists x) {
            list.append(x);
        }
        else {
            return list;
        }
    }
}]]></programlisting>
        -->
        
        <programlisting><![CDATA[shared List<X> generate(Natural length, X first, X next(X previous)) {
    OpenList<X> list = ArrayList<X>();
    list.append(first);
    variable X x := first;
    for (Natural i in 0..length-1) {
        x := element(x);
        list.append(x);
    }
    return list;
}]]></programlisting>

        <comment><para>TODO: Actually, <literal>generate()</literal> should return just a
        lazily-evaluated <literal>Iterable</literal>. (Perhaps it should be a class 
        <literal>Generator</literal> instead of a method) Then to map its values into a 
        <literal>List</literal>, instantiate <literal>IteratorList</literal>.</para></comment>
        
        <programlisting><![CDATA[shared Y fold<X,Y>(Iterable<X> iterable, Y initial, Y using(Y y, X x)) {
    variable Y y:=initial;
    for (X x in iterable) {
        y:=using(y,x);
    }
    return y;
}]]></programlisting>
        
        <para>The <literal>ceylon.language.comprehension.map</literal> package defines 
        support for <literal>Map</literal> comprehensions.</para>
        
        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given key. Each |Entry| is constructed 
     from the key and the value result of the 
     evaluation."
shared Map<U,V> mapFrom<U,V>(iterated Iterable<U> keys,
                             V to(coordinated U key)) {
    Entry<U,V> of(U key) { return key->to(key); }
    return map(keys, of);
}]]></programlisting>

        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given value. Each |Entry| is constructed 
     from the value and the key result of the 
     evaluation."
shared Map<U,V> mapTo<U,V>(iterated Iterable<V> values,
                           U from(coordinated V value)) { 
    Entry<U,V> of(V value) { return from(value)->value; }
    return map(values, of);
}]]></programlisting>

        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given object and collecting the resulting 
     |Entry|s."
shared Map<U,V> map<X,U,V>(iterated Iterable<X> elements,
                           Entry<U,V> of(coordinated X element)) {
    OpenMap<U,V> map = HashMap<U,V>();
    for (X x in elements) {
        map.add( of(x) );
    }
}]]></programlisting>
    
    </section>
    
    </section>
    
    <section id="collectionsmodule">
        <title>The collections module</title>
        
        <para>The module <literal>ceylon.collection</literal> contains the collections
        framework.</para>
    
    <section id="collections">
        <title>Collections</title>
        
        <para>The interface <literal>Collection</literal> is the 
        root of the Ceylon collections framework.</para>
        
        <programlisting><![CDATA[shared interface Collection<out X> 
        satisfies Iterable<X> & Sized & Category
        given X satisfies Equality<X> {
        
    doc "Determine the number of times the given element
         appears in the collection."
    shared Natural count(Object element);
    
    doc "Determine the number of elements or entries for
         which the given condition evaluates to |true|."
    shared Natural count(Boolean where(X element));
    
    doc "Determine if the given condition evaluates to |true|
         for at least one element or entry."
    shared Boolean contains(Boolean where(X element));
    
    doc "The elements of the collection, as a |Set|."
    shared Set<X> elements;
    
    doc "The elements of the collection for which the given
         condition evaluates to |true|, as a |Set|."
    shared Set<X> elements(Boolean where(X element));
    
    shared default Partition<Collection<X>> partitioned(Boolean by(X element));
    
    doc "The elements of the collection, sorted using the given
         comparison."
    shared List<X> sortedElements(Comparison by(X x, X y));
    
    doc "An extension of the collection, with the given 
         elements. The returned collection reflects changes 
         made to the first collection."
    shared Collection<T> with<T>(T... elements) given T abstracts X;

    doc "A mutable copy of the collection."
    shared OpenCollection<T> openCopy<T>() given T abstracts X;
    
    doc "An immutable copy of the collection."
    shared Collection<T> copy<T>() given T abstracts X;
    
}]]></programlisting>

        <programlisting><![CDATA[shared interface Partition<T> 
        given T satisfies Collection<X>
        given X satisfies Equality<X> {
    shared T interior;
    shared T exterior;
}]]></programlisting>

<!-- shared Boolean containsAny(Object... objects); ??? -->

        <para>A decorator provides the ability to sort collections of
        <literal>Comparable</literal> values in natural order.</para>
        
        <programlisting><![CDATA[shared extension class CollectionsOfComparable<out X>(Collection<X> this) 
        given X satisfies Comparable<X> {
        
    doc "The elements of the collection, sorted in natural order."
    shared List<X> sortedElements() {
        return this.sortedElements() by (X x, X y) (x<=>y);
    }
    
}]]></programlisting>
        
        <para>Mutable collections satisfy <literal>OpenCollection</literal>:</para>
        
        <programlisting><![CDATA[shared interface OpenCollection<X> 
        satisfies OpenCategory<X>, Collection<X> 
        given X satisfies Equality<X> {
    
    doc "Remove all elements or entries of the collection,
         resulting in an empty collection."
    shared Boolean clear();
    
    doc "Remove the given elements from the collection.
         Return the number of elements which belonged
         to the collection."
    shared Natural remove(X... elements);
    
    doc "Remove all elements from the collection for which
         the given condition evaluates to |true|. Return 
         the number of elements which were removed."
    shared Natural remove(Boolean where(X element));
    
}]]></programlisting>

    </section>

        <section id="sets">
            <title>Sets</title>
            
            <para>Sets satisfy the following interface:</para>
            
            <programlisting><![CDATA[shared interface Set<out X> 
        satisfies Collection<X> 
        given X satisfies Equality<X> {
    
    doc "Determine if the set is a superset of the given set.
         Return |true| if it is a superset."
    shared Boolean superset(Set<Object> set);

    doc "Determine if the set is a subset of the given set.
         Return |true| if it is a subset."
    shared Boolean subset(Set<Object> set);
    
    shared actual Partition<Set<X>> partitioned(Boolean by(X element));
    
    shared actual Set<T> with<T>(T... elements) given T abstracts X;
    shared actual OpenSet<T> openCopy<T>() given T abstracts X;
    shared actual Set<T> copy<T>() given T abstracts X;    

    shared Set<T> union<T>(Set<T> set) 
            given T abstracts X;
    
    shared Set<X> intersection<T>(Set<T> set) 
            given T abstracts X;
    
    shared Set<T> exclusiveUnion<T>(Set<T> set) 
            given T abstracts X;
    
    shared Set<X> complement<T>(Set<T> set) 
            given T abstracts X;
    
}]]></programlisting>

            <para>The following extension defines the <literal>|, &amp;, ^, ~</literal>
            operators for <literal>Set</literal>s.</para>
            
            <programlisting><![CDATA[shared extension class SetSlots<X>(Set<X> this) 
        satisfies Slots<Set<X>> {
    
    shared actual Set<X> or(Set<X> set) {
        return this.union(set);
    }
    
    shared actual Set<X> and(Set<X> set) {
        return this.intersection(set);
    }
    
    shared actual Set<X> xor(Set<X> set) {
        return this.exclusiveUnion(set);
    
    }
    
    shared actual Set<X> complement(Set<X> set) {
        return this.complement(set);
    }
    
}]]></programlisting>

            <para>This extension allows direct instantiation of the interface:</para>

            <programlisting><![CDATA[shared extension Set<T> newSet<T>(Type<Set<T>> this)(T... elements) {
    return HashSet(elements);
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[shared interface OpenSet<X> 
        satisfies Set<X> & OpenCollection<X> 
        given X satisfies Equality<X> {}]]></programlisting>

        </section>
        
        <section id="lists">
            <title>Lists</title>
            
            <para>Lists satisfy the following interface, and support the 
            operators inherited from <literal>Collection</literal> and 
            <literal>Sequence</literal>:</para>
            
            <programlisting><![CDATA[shared interface List<out X> 
        satisfies Collection<X> & X[] 
        given X satisfies Equality<X> {
    
    doc "The index of the first element of the list
         which satisfies the condition, or |null| if 
         no element satsfies the condition."
    shared Natural? firstIndex(Boolean where(X element));

    doc "The index of the last element of the list
         which satisfies the condition, or |null| if 
         no element satsfies the condition."
    shared Natural? lastIndex(Boolean where(X element));
    
    doc "The elements of the list for which the given condition 
         evaluates to |true|, as a |List| with the original 
         order."
    shared List<X> elementList(Boolean where(X element));
    
    doc "A sublist beginning with the element at the first given 
         index up to and including the element at the second given 
         index. The size of the returned sublist is one more than 
         the difference between the two indexes. The returned list 
         does reflect changes to the original list."
    shared List<X> sublist(Natural from, Natural to=lastIndex);
    
    doc "A sublist of the given length beginning with the 
         first element of the list. The returned list does 
         reflect changes to the original list."
    shared List<X> leading(Natural length=1);
    
    doc "A sublist of the given length ending with the 
         last element of the list. The returned list does 
         reflect changes to the original list."
    shared List<X> trailing(Natural length=1);
    
    doc "Split the list into sublists, each beginning at an
         element for which the predicate returns true."
    shared Iterable<List<X>> sublists(Boolean split(X element));
    
    doc "Split the list into sublists, each beginning at an
         element for which the predicate returns true. The 
         predicate may examine elements to the left and 
         right of the element under consideration."
    shared Iterable<List<X>> sublists( 
            Boolean split(
                      doc "The current element, which
                           will be the first element
                           of the sublist if |split()|
                           returns |true|." 
                      X element, 
                      doc "The elements to the left,
                           beginning with the immediately
                           adjacent element." 
                      X[] left, 
                      doc "The elements to the right,
                           beginning with the immediately
                           adjacent element." 
                      X[] right
                  )
              );
    
    shared actual Partition<List<X>> partitioned(Boolean by(X element));
    
    doc "An extension of the list with the given elements
         at the end of the list. The returned list does 
         reflect changes to the original list."
    shared actual List<T> with<T>(T... elements) given T abstracts X;
    
    doc "An extension of the list with the given elements
         at the start of the list. The returned list does 
         reflect changes to the original list."
    shared List<T> withInitial<T>(T... elements) given T abstracts X;
    
    doc "The list in reverse order. The returned list does 
         reflect changes to the original list."
    shared List<X> reversed;
    
    doc "The unsorted elements of the list. The returned 
         bag does reflect changes to the original list."
    shared Bag<X> unsorted;
    
    doc "A map from list index to element. The returned 
         map does reflect changes to the original list."
    shared Map<Natural,X> map;
    
    doc "Produce a new list by applying an operation to
         every element of the list."
    shared List<Y> transform<Y>(Y select(X element));
    
    shared actual OpenList<T> openCopy<T>() given T abstracts X;
    shared actual List<T> copy<T>() given T abstracts X;    

}]]></programlisting>

            <para>This extension allows direct instantiation of the interface:</para>

            <programlisting><![CDATA[shared extension List<T> newList<T>(Type<List<T>> this)(T... elements) {
    return ArrayList(elements);
}]]></programlisting>

            <para>Any <literal>Sequence</literal> may be transparently converted to a 
            <literal>List</literal>:</para>
            
            <programlisting>shared extension List&lt;X&gt; sequenceToList(X[] this) {
    if (is List&lt;X&gt; this) {
        return this;
    }
    else {
        return SequenceList(this);
    }
}</programlisting>
            
<!--
            <para>Here's an implementation of the well-know quicksort algorithm 
            for a <literal>List</literal>:</para>
            
            <programlisting><![CDATA[doc "Quicksort for |List|s."
shared List<X> quickSort<X>(List<X> list, Boolean byIncreasing(X x, X y)) {
    if (exists X pivot = list.first) {
        local createPartition = quickSort(list.rest.elementList);  
                //i.e. List<X> createPartition(Boolean where(X X)) = ...
        local smaller = byIncreasing.partial(pivot);                       
                //i.e. Boolean smaller(X x) = ...
        return createPartition(smaller) + {x} + createPartition(Boolean.complement(smaller));
    }
    else {
        return none;
    }
}]]></programlisting>

            <para>For example:</para>
            
            <programlisting>List&lt;String&gt; sortedNames = quickSort(unsortedNames) byIncreasing (String x, String y) (x>y);</programlisting>
-->
            
            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[shared interface OpenList<X> 
        satisfies List<X> & OpenCollection<X> & OpenSequence<X> 
        given X satisfies Equality<X> {

    doc "Remove the element at the given index, decrementing
         the index of every element with an index greater
         than the given index by one. Return the removed
         element."
    throws (UndefinedKeyException
            -> "if the index is not in the list")
    shared X removeIndex(Natural at);
    
    doc "Add the given elements at the end of the list."
    shared void append(X... elements);
    
    doc "Add the given elements at the start of the list,
         incrementing the index of every existing element
         by the number of given elements."
    shared void prepend(X... elements);

    doc "Insert the given elements beginning at the given
         index, incrementing the index of every existing 
         element with that index or greater by the number 
         of given elements."
    throws (UndefinedKeyException
            -> "if the index is not in the list")
    shared void insert(Natural at, X... elements);
    
    doc "Remove elements beginning with the first given index 
         up to and including the second given index,
         decrementing the indexes of all elements after
         with the second given index by one more than the 
         difference between the two indexes."
    throws (UndefinedKeyException
            -> "if the index is not in the list")
    shared void delete(Natural from, Natural to=lastIndex);
    
    doc "Remove and return the first element, decrementing
         the index of every other element by one."
    throws (EmptyException
            -> "if the list is empty")
    shared X removeFirst();

    doc "Remove and return the last element."
    throws (EmptyException
            -> "if the list is empty")
    shared X removeLast();
    
    doc "Reverse the order of the list."
    shared void reverse();
    
    doc "Reorder the elements of the list, according to the 
         given comparison."
    shared void resort(Comparison by(X x, X y));
    
    shared actual OpenList<X> leading(Natural length);
    shared actual OpenList<X> trailing(Natural length);
    shared actual OpenList<X> sublist(Natural from, Natural to);
    shared actual OpenList<X> reversed;
    shared actual OpenMap<Natural,X> map;
    
}]]></programlisting>
            
        <para>A decorator provides the ability to resort lists of
        <literal>Comparable</literal> values in natural order.</para>
        
        <programlisting><![CDATA[shared extension class OpenListsOfComparable<out X>(OpenList<X> this) 
        given X satisfies Comparable<X> {
        
    doc "Reorder the elements of the list, according to the 
         natural order."
    shared void resort() {
        this.resort() by (X x, X y) (x<=>y);
    }
    
}]]></programlisting>
        
        </section>
            
        <section id="maps">
            <title>Maps</title>
            
            <para>Maps satisfy the following interface:</para>
            
            <comment><para>TODO: is it OK that maps are not contravariant 
            in the key type?</para></comment>
            
            <programlisting><![CDATA[shared interface Map<U, out V>
        satisfies Collection<Entry<U,V>> & Correspondence<U,V> 
        given U satisfies Equality<U> 
        given V satisfies Equality<V> {
    
    doc "The keys of the map, as a |Set|."
    shared Set<U> keys;
    
    doc "The values of the map, as a |Bag|."
    shared Bag<V> values;
    
    doc "A |Map| of each value belonging to the map, to the 
         |Set| of all keys at which that value occurs."
    shared Map<V, Set<U>> inverse;
    
    doc "Produce a new map by applying an operation to every 
         element of the map."
    shared Map<U, W> transform<W>(W? select(U key -> V value));
    
    doc "The entries of the map for which the given condition 
         evaluates to |true|, as a |Map|."
    shared Map<U, V> entries(Boolean where(U key -> V value));
    
    shared actual Partition<Map<U,V>> partitioned(Boolean by(X element));
    
    shared actual Map<U,T> with<U,T>(Entry<U,T>... entries) given T abstracts V;
    shared actual OpenMap<U,T> openCopy<T>() given T abstracts V;
    shared actual Map<U,T> copy<U,T>() given T abstracts X;    
    
}]]></programlisting>

            <para>This extension allows direct instantiation of the interface:</para>

            <programlisting><![CDATA[shared extension Map<U,V> newMap<U,V>(Type<Map<U,V>> this)(Entry<U,V>... elements) {
    return HashMap(elements);
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[shared interface OpenMap<U,V> 
        satisfies Map<U,V> & OpenCollection<Entry<U,V>> & OpenCorrespondence<U, V> 
        given U satisfies Equality<U> 
        given V satisfies Equality<V> {
    
    doc "Remove the entry for the given key, returning the 
         value of the removed entry."
    throws (UndefinedKeyException
            -> "if no value is defined for the given key")   
    shared V remove(U key);
    
    doc "Remove all entries from the map which have keys for 
         which the given condition evaluates to |true|. Return 
         entries which were removed."
    shared Map<U,V> remove(Boolean where(U key));
    
    shared actual OpenSet<U> keys;
    shared actual OpenBag<V> values;
    shared actual OpenMap<V, Set<U>> inverse;
    
}]]></programlisting>
            
        </section>
        
        <section id="bags">
            <title>Bags</title>
            
            <para>Bags satisfy the following interface:</para>
            
            <programlisting><![CDATA[shared interface Bag<out X> 
        satisfies Collection<X> 
        given X satisfies Equality<X> {
    
    doc "A map from element to the number of occurrences of 
         the element. The returned map reflects changes to 
         the original bag."
    shared Map<X,Natural> map;
    
    shared actual Partition<Bag<X>> partitioned(Boolean by(X element));
    
    shared actual Bag<T> with<T>(T... elements) given T abstracts X;
    shared actual OpenBag<T> openCopy<T>() given T abstracts X;
    shared actual Bag<T> copy<T>() given T abstracts X;    
    
}]]></programlisting>

            <para>This extension allows direct instantiation of the interface:</para>

            <programlisting><![CDATA[shared extension Bag<T> newBag<T>(Type<Bag<T>> this)(T... elements) {
    return HashBag(elements);
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[shared interface OpenBag<X> 
        satisfies Bag<X> & OpenCollection<X> 
        given X satisfies Equality<X> {
        
    shared actual OpenMap<X,Natural> map;
    
}]]></programlisting>
            
        </section>
        
    </section>
    
</chapter>