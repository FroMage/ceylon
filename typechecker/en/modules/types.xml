<chapter id="types">
    <title>Basic types</title>
    
    <para>There are no primitive types in Ceylon, however, there are certain
    important types provided by the package <literal>lang</literal>. Many
    of these types support <emphasis>operators</emphasis>.</para>
        
    <section>
        <title>The root type</title>
        
        <para>The <literal>lang.Object</literal> class is the root of the type 
        hierarchy and supports the binary operators <literal>==</literal> (equals),
        <literal>!=</literal> (not equals), <literal>===</literal> (identity equals), 
        <literal>.</literal> (invoke), <literal>^.</literal> (chain invoke),
        <literal>in</literal> (in), <literal>is</literal> (is), the unary prefix 
        operator <literal>$</literal> (render), and the binary operator 
        <literal>:=</literal> (assign).</para>
        
        <para>In addition, references of type <literal>optional:Object</literal>
        support the binary operators <literal>?.</literal> (nullsafe invoke) 
        and <literal>?</literal> (default)
        <!-- and <literal>?:</literal> (null default) -->and the unary operator
        <literal>exists</literal>, along with the binary operators 
        <literal>==</literal> (equals), <literal>!=</literal> (not equals), 
        <literal>===</literal> (identity equals) and <literal>=</literal> (assign).</para>
        
        <programlisting><![CDATA[public abstract class Object {
        
    doc "The equals operator x == y. Default implementation compares
         attributes annotated |id|, or performs identity comparison."
    see #id
    public Boolean equals(Object that) {
        ...;
    }
    
    doc "Compares the given attributes of this instance with the given
         attributes of the given instance."
    public Boolean equals(Object that, Attribute... attributes) { ... }
    
    doc "The hash code of the instance. Default implementation compares
         attributes annotated |id|, or assumes identity equality."
    see #id
    public Integer hash {
        return ...;
    }
    
    doc "Computes the hash code of the instance using the given attributes."
    public Integer hash(Attribute... attributes) { ... }
        
    doc "The unary render operator $x. A developer-friendly string 
         representing the instance. By default, the string contains
         the name of the type, and the values of all attributes 
         annotated |id|."
    public String string { ... }
    
    doc "Determine if the instance belongs to the given Category."
    see #Category
    public Boolean in<Y>(Category<Y> cat)
            where (Y<=X) {
        return cat.contains(this);
    }
    
    doc "Determine if the instance belongs to the given Iterable
         object."
    see #Iterable
    public Boolean in<Y>(Iterable<Y> iterable) 
            where (Y<=X) {
        return forAny (Object elem in iterable) elem == this;
    }
    
    doc "The Type of the instance."
    public Type<X+> type { ... }
    
    doc "Binary assignability operator x is Y. Determine if the instance 
         is of the given Type."
    public Boolean instanceOf(Type<Object+> type) {
        return this.type.assignableTo(type);
    }
    
    doc "Return a reference to the instance, of the given
         Type, or throw an exception if the instance is not
         of the given type."
    public T as<T>(Type<T> type) { ... }
    
    doc "A log obect for the type."
    public static Log log = Log(type);
        
    ...
        
}]]></programlisting>

    </section>
    
    <section>
        <title>Types</title>
        
        <programlisting><![CDATA[public interface Type<X> 
        satisfies Case<Object> {
    ...
}]]></programlisting>
        
    </section>
    
    <section>
        <title>Boolean values</title>
        
        <para>The <literal>lang.Boolean</literal> class represents
        boolean values, and supports the binary <literal>||, &amp;&amp;, =>,
        |, &amp;, ^</literal> and unary <literal>!</literal> operators.</para>
        
        <programlisting>public final class Boolean {
    instances true, false;

    doc "The binary or operator x | y"
    public Boolean or(Boolean boolean) { ... }
    
    doc "The binary and operator x &amp; y"
    public Boolean and(Boolean boolean) { ... }
    
    doc "The binary xor operator x ^ y"
    public Boolean xor(Boolean boolean) { ... }

    doc "The unary not operator !x"
    public Boolean negation {
        return switch(this) {
            case (true) false
            case (false) true
        };
    }
    
}</programlisting>

    </section>
    
    <section>
        <title>Values and callables</title>
        
        <para>The interface <literal>Callable</literal>
        represents a callable reference.</para>
        
        <programlisting>public interface Callable&lt;S&gt;
        where S >= Functor {
    public S invoke;
    public onCall( ... );
}</programlisting>
        
        <para>The interface <literal>Value</literal> models a 
        readable value.</para>
        
        <programlisting>public interface Value&lt;T&gt; {
    public F&lt;(), T&gt; get;
    public onGet( F&lt;(T t), T&gt; interceptor );
}</programlisting>

        <para>The interface <literal>OpenValue</literal> models 
        a readable and writeable value.</para>
        
        <programlisting>public interface OpenValue&lt;T&gt; 
        satisfies Value&lt;T&gt; {
    public (T) void set;
    public onSet( F&lt;(T t), T&gt; interceptor );
}</programlisting>

    </section>
    
    <section>
        <title>Methods and attributes</title>
        
        <programlisting>public interface Annotated {
    public Boolean annotated(Type&lt;Object+&gt; type);
    public T annotation&lt;T&gt;(Type&lt;T&gt; type);
    public Set&lt;Object&gt; annotations;
}</programlisting>
        
        <programlisting>public interface Member&lt;X&gt; 
        satisfies Annotated {
    public Type&lt;X&gt; declaringType;
    public String name;
    public Visibility visibility;
    public Boolean abstract;
    public Boolean override;
}</programlisting>
        
        <programlisting>public interface Method&lt;X,S&gt;
        where S >= Functor 
        satisfies Member&lt;X&gt; {
    public Type&lt;Object+&gt; returnType;
    public List&lt;Type&lt;Object+&gt;&gt; parameterTypes;
    public Callable&lt;S&gt; curry(X instance);
    public Boolean static;
    public Boolean once;
    public onCall( ... );
}</programlisting>
        
        <programlisting>public interface Attribute&lt;X,T&gt; 
        satisfies Member&lt;X&gt; {
    public Type&lt;T&gt; attributeType;
    public boolean mutable;
    public Value&lt;T&gt; curry(X instance);
    public onGet( F&lt;(X x,T t), T&gt; interceptor );
}</programlisting>
                
        <programlisting>public interface MutableAttribute&lt;X,T&gt;
        satisfies Attribute&lt;X,T&gt; {
    public override OpenValue&lt;T&gt; curry(X instance);
    public onSet( F&lt;(X x,T t), T&gt; interceptor );
}</programlisting>
                
    </section>
    
    <section>
        <title>Iterable objects and iterators</title>
        
        <para>The <literal>lang.Iterable&lt;X&gt;</literal> interface
        represents a type that may be iterated over using a
        <literal>lang.Iterator&lt;X&gt;</literal>. It supports the
        binary operator <literal>*.</literal> (spread).<!--  ,
        <literal>*&lt;, *&gt;, *&lt;=, *&gt;=, *==, *!=</literal>
        (spread comparison)--> <!--and <literal>*~></literal> (all in).--></para>
        
        <programlisting>public interface Iterable&lt;X&gt; {
    
    doc "Produce an iterator."
    public Iterator&lt;X&gt; iterator();
    
}</programlisting>

        <programlisting>public interface Iterator&lt;X&gt; {

    public Boolean more;
    public X current;
    public X next();
    
}</programlisting>

        <para>The following decorator exists:</para>

        <!--programlisting><![CDATA[public decorator Iterables<X> (Iterable<X> iterable) {

    public void each((X) void each) { ... }
    public Integer count((X) produce Boolean test) { ... }
    public Boolean isAll((X) produce Boolean test) { ... }
    public Boolean isAny((X) produce Boolean test) { ... }
    
    public optional X first((X) produce Boolean test) { ... }
    
    public Y accumulate<Y>(Y initial, (Y,X) produce Y accumulate) { ... }
    
    public Collection<X> select((X) produce Boolean test) { ... }
    public Collection<X> reject((X) produce Boolean test) { ... }
    
    public Bag<Y> transform<Y>((X) produce Y transform) { ... }
    public List<Y> transform<Y>((X) produce Y transform, (Y,Y) produce Comparison compare) { ... }
    public Set<Y> collect<Y>((X) produce Y transform) { ... }
    public Map<X, Y> map<Y>((X) produce Y transform) { ... }
    public List<X> list((X,X) produce Comparison compare) { ... }
    
}]]></programlisting-->

        <para>Some iterable objects may support element removal during iteration.</para>
        
        <programlisting>public mutable interface OpenIterable&lt;X&gt; 
        satisfies Iterable&lt;X&gt; {
        
    public override OpenIterator&lt;X&gt; iterator();
    
}</programlisting>

        <programlisting>public mutable interface OpenIterator&lt;X&gt; 
        satisfies OpenIterator&lt;X&gt; {

    public void remove();
    
}</programlisting>

        <!--programlisting><![CDATA[public decorator OpenIterables (OpenIterable iterable) {

    public Integer remove((X) produce Boolean test) { ... }
    public Integer retain((X) produce Boolean test) { ... }
    
}]]></programlisting-->

    </section>
    
    <section>
        <title>Cases and Selectors</title>
        
        <para>The interface <literal>lang.Case&lt;X&gt;</literal> represents a
        type that may be used as a case in the <literal>switch</literal>
        construct.</para>
        
        <programlisting>public interface Case&lt;X&gt; {

    public Boolean test(X value);
    
}</programlisting>

        <para>Classes with enumerated instances implicitly extend <literal>lang.Selector</literal></para>
        
        <programlisting>public abstract class Selector&lt;X&gt;(String name, int ordinal)
        satisfies Case&lt;X&gt;
        where X >= Selector&lt;X&gt; { ... }</programlisting>
        
    </section>
    
    <section>
        <title>Usables</title>
        
        <para>The interface <literal>lang.Usable</literal> represents an
        object with a lifecycle controlled by <literal>try</literal>.</para>
        
        <programlisting>public interface Usable {

    public void begin();
    public void end();
    public void end(Exception e);
    
}</programlisting>        
       
    </section>
    
    <section>
        <title>Category, Correspondence and Container</title>
        
        <para>The interface <literal>lang.Category</literal> represents
        the abstract notion of an object that contains other objects.</para>
        
        <programlisting>public interface Category&lt;X&gt; {
    
    doc "Determine if the given element belongs to the category."
    public Boolean contains(X element);

}</programlisting>

        <programlisting>public decorator Categories&lt;X&gt; (Category&lt;X&gt; category) {
        
    doc "Determine if all the given elements belong to the category."
    public Boolean contains(Iterable&lt;X&gt; elements) {
        return forAll (X x in elements) category.contains(x);
    }
    
}</programlisting>

        <para>There is a mutable subtype, representing a category to which 
        objects may be added.</para>
        
        <programlisting>public mutable interface OpenCategory&lt;X&gt; 
        satisfies Category&lt;X&gt; {
    
    doc "Add the given element to the category."
    public Boolean add(X element);

}</programlisting>

        <programlisting>public decorator OpenCategories&lt;X&gt; (OpenCategory&lt;X&gt; category) {
        
    doc "Add the given elements to the category."
    public Boolean add(Iterable&lt;X&gt; elements) {
        Boolean added = false;
        for (X x in elements) 
            added |= category.add(x);
        return added;
    }
    
}</programlisting>

        <para>The interface <literal>lang.Correspondence</literal> represents
        the abstract notion of an object that maps value of one type to values
        of some other type. It supports the binary operator
        <literal>[key]</literal> (lookup).</para>
        
        <programlisting>public interface Correspondence&lt;U, V&gt; {
    
    doc "Binary lookup operator x[key]. Returns the value associated 
         with the given key."
    public V value(U key);
    
    doc "Determine if there is a value associated with the given key."
    public Boolean defines(U key);
    
}</programlisting>

        <programlisting>public decorator Correspondences&lt;X&gt; (Correspondence&lt;X&gt; correspondence) {

    doc "Binary lookup operator x[keys]. Returns a list of values 
         associated with the given keys, in order."
    public List&lt;V&gt; values(List&lt;U&gt; keys) {
        return from (U key in keys) select correspondence.lookup(key);
    }
    
    doc "Binary lookup operator x[keys]. Returns a set of values 
         associated with the given set of keys."
    public Set&lt;V&gt; values(Set&lt;U&gt; keys) {
        return ( from (U key in keys) select correspondence.lookup(key) ).elements;
    }
    
    doc "Determine if there are values associated with all the given keys."
    public Boolean defines(Collection&lt;U&gt; keys) {
        for (U key in keys) 
            if ( !correspondence.defines(key) ) return false
        fail return true;
    }
    
}</programlisting>

        <para>There is a mutable subtype, representing a correspondence
        for which new mappings may be defined, and existing mappings 
        modified. It provides for the use of element expressions in
        assignments.</para>
        
        <!-- Association? -->

        <programlisting>public mutable interface OpenCorrespondence&lt;U, V&gt; 
        satisfies Correspondence&lt;U, V&gt; {
        
     doc "Element assignment x[key] = value. Assign a value to the given 
          key."
     public optional V define(U key, V value);

}</programlisting>

        <programlisting>public decorator OpenCorrespondences&lt;X&gt; (OpenCorrespondence&lt;X&gt; correspondence) {

     doc "Assign the given values to the given keys."
     public void define(Iterable&lt;Entry&lt;U, V&gt;&gt; definitions);
    
     doc "Add the given entry."
     public void define(U key -> V value);
    
}</programlisting>

        <para>The interface <literal>lang.Container</literal> represents
        the abstract notion of an object that may be empty. It supports 
        the unary postfix operator <literal>nonempty</literal><!--and
        the binary operator <literal>??:</literal> (empty default)-->.</para>
        
        <programlisting>public interface Container {
        
    doc "Determine if the container is empty."
    Boolean empty;
    
}</programlisting>

    </section>
    
    <section>
        <title>Entries</title>
        
        <para>The <literal>Entry</literal> class represents a pair of 
        associated objects.</para>

        <para>Entries may be constructed using the <literal>-></literal> 
        operator.</para>

            <programlisting><![CDATA[public class Entry<U,V>(U key, V value) {

    public U key = key;
    public V value = value;
    
    override public Boolean equals(Object that) {
        return equals(that, Entry#key, Entry#value);
    }
        
    override public Integer hash {
        return hash(Entry#key, Entry#value);
    }

}]]></programlisting>

    </section>
    
    <section>
        <title>Collections</title>
        
        <para>The interface <literal>lang.Collection</literal> is the 
        root of the Ceylon collections framework.</para>
        
        <programlisting><![CDATA[public interface Collection<X> 
        satisfies Iterable<X>, Category<X>, Container {
    
    public Integer size;

    public Integer count(X element);
    
    public Set<X> elements;

    public OpenCollection<X> copy();
    
}]]></programlisting>

        
        <para>Mutable collections implement <literal>lang.OpenCollection</literal>:</para>
        
        <programlisting><![CDATA[public mutable interface OpenCollection<X> 
        satisfies OpenIterable<X>, OpenCategory<X>, Collection<X> {
    
    public Boolean clear();

    public Boolean remove(X element);
    public Integer remove(Collection<X> elements);    
    public Integer retain(Collection<X> elements);    

}]]></programlisting>

        <section>
            <title>Sets</title>
            
            <para>Sets implement the following interface<!--  ,
            and support the binary operators <literal>+</literal>
            (union), <literal>~</literal> (intersect), 
            <literal>-</literal> (complement),
            <literal>>=</literal> (superset),
            <literal>&lt;=</literal> (subset),
            <literal>></literal> (proper superset) and
            <literal>&lt;</literal> (proper subset),
            in addition to inherited operators-->:</para>
            
            <programlisting><![CDATA[public interface Set<X> 
        satisfies Collection<X>, Correspondence<X, Boolean> {
    
    public Set<X> union(Set<X> set);
    public Set<X> intersection(Set<X> set);
    public Set<X> complement(Set<X> set);
    
    public Boolean superset(Set<X> set);
    public Boolean subset(Set<X> set);
    
    public OpenSet<X> copy();

}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenSet<X> 
        satisfies Set<X>, OpenCollection<X>, OpenCorrespondence<X, Boolean> {}]]></programlisting>

        </section>
        
        <section>
            <title>Lists</title>
            
            <para>Lists implement the following interface, and support 
            the binary operators <literal>+</literal> (join),
            <literal>[...j], [i...]</literal> (lower, upper range) and the 
            ternary operator <literal>[i..j]</literal> (subrange) in addition
            to operators inherited from <literal>Collection</literal>
            and <literal>Correspondence</literal>:</para>
            
            <programlisting><![CDATA[public interface List<X> 
        satisfies Collection<X>, Correspondence<Integer, X> {
    
    public X first;    
    public X last;
    
    public optional X firstOrNull;    
    public optional X lastOrNull;
    
    public Integer firstIndex;
    public Integer lastIndex;
    
    public Integer firstIndex(X element);
    public Integer lastIndex(X element);
    
    public List<X> head();
    public List<X> tail();
    public List<X> head(Integer to);
    public List<X> tail(Integer from);
    
    doc "The binary range operator x[from..to]"
    public List<X> range(Integer from, Integer to);

    doc "The binary join operator x + y"
    public List<X> join(List<X> elements);
    
    public List<X> sublist(Integer from, Integer to);
    
    public List<X> reversed();
    
    public Map<Integer,X> map;
    
    public OpenList<X> copy();

}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenList<X> 
        satisfies List<X>, OpenCollection<X>, OpenCorrespondence<Integer, X> {

    public void prepend(X element);
    public void prepend(List<X> elements);
    public void append(X element);
    public void append(List<X> elements);

    public void insert(Integer key, X element);
    public void truncate(Integer from, Integer to);
    
    public X removeFirst();
    public X removeLast();
    
    public void reverse();
    public void sort(F<(X x, X y), Comparison> compare);
    
    public OpenList<X> sublist(Integer from, Integer to);
    
}]]></programlisting>
            
        </section>
            
        <section>
            <title>Maps</title>
            
            <para>Maps implement the following interface:</para>
            
            <programlisting><![CDATA[public interface Map<U,V> 
    satisfies Collection<Entry<U,V>>, Correspondence<U, V> {
    
    public Set<U> keys;
    public Bag<V> values;    
    public Map<V, Set<U>> inverse;
    
    public optional V valueOrNull(U key);

    //public Set<Entry<U,V>> entries;
    
    public OpenMap<X> copy();
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenMap<U,V> 
        satisfies Map<U,V>, OpenCollection<Entry<U,V>>, OpenCorrespondence<U, V> {
    
    public OpenSet<U> keys;
    public OpenBag<V> values;
    public OpenMap<V, Set<U>> inverse;

    public Integer removeKeys(Collection<U> keys);
    public Integer retainKeys(Collection<U> keys);
    
}]]></programlisting>
            
        </section>
        
        <section>
            <title>Bags</title>
            
            <para>Bags implement the following interface:</para>
            
            <programlisting><![CDATA[public interface Bag<X> 
        satisfies Collection<X>, Correspondence<X, Integer> {
    
    public OpenBag<X> copy();
    
    public Map<X,Integer> map;
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenBag<X> 
        satisfies Bag<X>, OpenCollection<X>, OpenCorrespondence<X, Integer> {}]]></programlisting>
            
        </section>
        
    </section>
    
    <section>
        <title>Ordered values</title>
        
        <para>The <literal>lang.Comparable&lt;T&gt;</literal> interface 
        represents totally ordered types, and supports the binary operators 
        <literal>&gt;, &lt;, &lt;=, &gt;=</literal> and <literal>&lt;=&gt;</literal>
        (compare).</para>
        
        <programlisting>public interface Comparable&lt;T&gt; {
    
    doc "The binary compare operator &lt;=&gt;. Compares this 
         instance with the given instance."
    public Comparison compare(T other);
    
}</programlisting>
        
        <programlisting>public class Comparison {
        
    instances larger, smaller, equal;
        
    public Boolean larger return this==larger;
    public Boolean smaller return this==smaller;
    public Boolean equal return this==equal;
    public Boolean unequal return this!=equal;
    public Boolean largeAs return this!=smaller;
    public Boolean smallAs return this!=larger;
    
}</programlisting>

        <para>The <literal>lang.Ordinal&lt;T&gt;</literal> interface 
        represents objects in a sequence, and supports the binary
        operator <literal>..</literal> (range) and postfix unary 
        operators <literal>++</literal> (successor) and 
        <literal>--</literal> (predecessor). In addition, variables 
        support the prefix unary operators <literal>++</literal> 
        (increment) and <literal>--</literal> (decrement).</para>
        
        <programlisting>public interface Ordinal&lt;T&gt; {

    doc "The unary "++" operator. The successor of this instance."
    public T successor;
    
    doc "The unary "--" operator. The predecessor of this instance."
    public T predecessor;
    
}</programlisting>

    </section>
    
    <section>
        <title>Ranges and enumerations</title>
        
        <para>Ranges and enumerations both implement <literal>List</literal>,
        therefore they support the join, subrange, contains and lookup operators, 
        among others. Ranges may be constructed using the <literal>..</literal> 
        operator:</para> 
        
        <programlisting>public class Range&lt;X&gt;(X first, X last) 
        satisfies List&lt;X&gt;, Case&lt;X&gt;
        where X>=Ordinal &amp; X>=Comparable { 

    public X first = first;
    public X last = last;
    
    ... 
}</programlisting>

        <para>Enumerations represent an explicit list of values and may be constructed 
        using a simplified syntax:</para>
        
        <programlisting>public class Enumeration&lt;X&gt;(X... values)
        satisfies List&lt;X&gt;, Case&lt;X&gt; {
    ... 
}</programlisting>

        <para>Enumerations may be freely converted to sets or maps:</para>
        
        <programlisting>public Map&lt;U, V&gt; converter EnumerationToMap(Enumeration&lt;Entry&lt;U,V&gt;&gt; enum) { ... }</programlisting>

        <programlisting>public Set&lt;X&gt; converter EnumerationToSet(Enumeration&lt;X&gt; enum) { ... }</programlisting>

        <programlisting>public OpenMap&lt;U, V&gt; converter EnumerationToOpenMap(Enumeration&lt;Entry&lt;U,V&gt;&gt; enum) { ... }</programlisting>

        <programlisting>public OpenSet&lt;X&gt; converter EnumerationToOpenSet(Enumeration&lt;X&gt; enum) { ... }</programlisting>

        <programlisting>public OpenList&lt;X&gt; converter EnumerationToOpenList(Enumeration&lt;X&gt; enum) { ... }</programlisting>

        <para>Furthermore, any object may be transparently promoted to an enumeration:</para>
        
        <programlisting>public Enumeration&lt;T&gt; converter ObjectToEnumeration(Object object) { return Enumeration(object); }</programlisting>
        
    </section>
    
    <section>
        <title>Characters and strings</title>
        
        <para>Characters are represented by the following class:</para>

        <programlisting>public class Character 
        satisfies Ordinal&lt;Character&gt;, Comparable&lt;Character&gt;, Case&lt;Character&gt; { ... }</programlisting>
        
        <para>Strings implement <literal>List</literal>, therefore they 
        support the join, subrange, contains and lookup operators, 
        among others.</para> 
                
        <programlisting>public class String(Character... characters) 
        satisfies Comparable&lt;String&gt;, List&lt;Character&gt;, Case&lt;String&gt; {
    
    ... 
    
    public Iterable&lt;String&gt; tokens(Iterable&lt;Character&gt; separators=" ,;") { return ...; }
    public String join(String... strings);
    public String join(Iterable&lt;String&gt; strings);
    
}</programlisting>

        <comment><para>TODO: do we need character ranges, like <literal>'a'..'z'</literal>, or is 
        it enough that we have regular expressions like <literal>`[a-z]`</literal>?</para></comment>

    </section>
    
    <section>
        <title>Regular expressions</title>
        
        <programlisting>public class Regex 
        satisfies Case&lt;String&gt; { 
    public List&lt;Match&gt; matchList(String string);
    public Boolean matches(String string);
    ... 
}</programlisting>
        
        <comment><para>TODO: I assume these are just Java (Perl 5-style) regular expressions. Is
        there some other better syntax around?</para></comment>

    </section>
    
    <section>
        <title>Numbers</title>
        
        <para>
        The <literal>lang.Number&lt;T&gt;</literal> interface 
        represents numeric values, and supports the binary operators 
        <literal>+,-, *, /, %, **</literal>, and the unary prefix operators 
        <literal>-, +</literal>. In addition, variables of type 
        <literal>lang.Number</literal> support 
        <literal>+=, -=, /=, *=</literal>.
        </para>
        
        <programlisting>public interface Number&lt;T&gt; 
        satisfies Comparable&lt;Number&lt;?&gt;&gt;, Ordinal&lt;T&gt; {
    
    //binary "+" operator
    public T add(T number);
    public Number add(Number number);

    //binary "-" operator
    public T subtract(T number);
    public Number subtract(Number number);

    //binary "*" operator
    public T multiply(T number);
    public Number multiply(Number number);

    //binary "/" operator
    public T divide(T number);
    public T divide(Number number);
    
    //binary "%" operator
    public T remainder(T number);
    public T remainder(Number number);
    
    //unary "-" operator 
    public T inverse;
    
    public T magnitude;
    
    public Boolean integral;
    public Boolean positive;
    public Boolean negative;
    public Boolean zero;
    public Boolean unit;
    
    public Exact exact;
    public Whole whole;
    public Natural natural;
    public Integer integer;
    public Float float;
    public Double double;
    public Long long;

    public Exact fractionalPart;
    public Integer scale;
    public Integer precision;
    
}</programlisting>

        <para>Seven numeric types are built in:</para>

        <programlisting>public final class Natural 
        satisfies Number&lt;Natural&gt;, Case&lt;Natural&gt; { ... }</programlisting>

        <programlisting>public final class Integer
        satisfies Number&lt;Integer&gt;, Case&lt;Integer&gt; {
    ...
    
    public void times(Iteration iteration) { ... }
    public void upto(Integer max, Iteration iteration) { ... }
    public void downto(Integer min, Iteration iteration) { ... }
    
}</programlisting>

        <programlisting>public final class Long 
        satisfies Number&lt;Long&gt;, Case&lt;Long&gt; { ... }</programlisting>

        <programlisting>public final class Float 
        satisfies Number&lt;Float&gt; { ... }</programlisting>

        <programlisting>public final class Double 
        satisfies Number&lt;Double&gt; { ... }</programlisting>

        <programlisting>public class Exact 
        satisfies Number&lt;Exact&gt; { ... }</programlisting>

        <programlisting>public class Whole 
        satisfies Number&lt;Whole&gt;, Case&lt;Whole&gt; { ... }</programlisting>

    </section>
    
    <section>
        <title>Instants, intervals and durations</title>
        
        <comment><para>TODO: this stuff is just for illustration, the real
        date/time API will be much more complex and fully internationalized.</para></comment>
        
        <programlisting>public class Instant {
    ...
}</programlisting>

        <programlisting>public class Time(Integer hours, Integer minutes, 
        optional Integer seconds=null, optional Integer milliseconds=null,
        optional Integer timezone=null) 
        extends Instant {
    public Integer hours = hours;
    public Integer minutes = minutes;
    public optional Integer seconds = seconds;
    public optional Integer milliseconds = milliseconds;
    public optional Timezone timezone = timezone;
    ...
}</programlisting>
        
        <programlisting>public class Date(Integer year, Integer month, Integer day) 
        extends Instant {
    public Integer year = year;
    public Integer month = month;
    public Integer day = day;
    ...
}</programlisting>
        
        <programlisting>public class Datetime(Time time, Date date) 
        extends Instant {
    public Time time = time;
    public Date date = date;
    ...
}</programlisting>
        
        <programlisting>public class Interval&lt;X&gt;(X start, X end) 
        where X >= Instant {
    public X start = start;
    public X end = end;
    public Duration&lt;X&gt; duration { return ...; }
    ...
}</programlisting>

        <programlisting>public class Duration&lt;X&gt;(Map&lt;Granularity&lt;X&gt;, Integer&gt; magnitude) 
        where X >= Instant {

    public Map&lt;Granularity&lt;X&gt;, Integer&gt; magnitude = magnitude;
    
    public X before(X instant) { ... }
    public X after(X instant) { ... }
    
    public Datetime before(Datetime instant) { ... }
    public Datetime after(Datetime instant) { ... }
    
    public Duration&lt;X&gt; add(Duration&lt;X&gt; duration) { ... }
    public Duration&lt;X&gt; subtract(Duration&lt;X&gt; duration) { ... }
    
    ...
}</programlisting>

        <programlisting>public interface Granularity&lt;X&gt; 
        where X >= Instant {}</programlisting>

        <programlisting>public class DateGranularity 
        satisfies Granularity&lt;Date&gt;
        instances year, month, week, day {}</programlisting>

        <programlisting>public class DateGranularity 
        satisfies Granularity&lt;Time&gt;
        instances hour, minute, second, millisecond {}</programlisting>
        
    </section>
    
    <section>
        <title>Control expressions</title>
        
        <para>The <literal>lang.Util</literal> class defines several methods
        for building complex expressons.</para>
        
        <programlisting><![CDATA[public class Util {
        
    doc "Evaluate the block. Useful for turning a series
         of statements into an expression."
    public static X evaluate<X>(F<(), X> do) { ... }

    doc "Assert that the block evaluates to true. The block 
         is executed only when assertions are enabled."
    public static void assert(F<(), Boolean> evaluate) { ... }

    doc "If the condition is true, evaluate first block,
         and return the result. Otherwise, return a null
         value."
    public static optional Y ifTrue<Y>(Boolean condition,
                                       F<(), Y> then) 
                             { ... }

    doc "If the condition is true, evaluate first block,
         otherwise, evaluate second block. Return result
         of evaluation."
    public static Y ifTrue<Y>(Boolean condition,
                              F<(), Y> then, 
                              F<(), Y> otherwise) 
                    { ... }

    doc "If the value is non-null, evaluate first block,
         and return the result. Otherwise, return a null
         value."
    public static optional Y ifExists<X,Y>(specified optional X value,
                                           coordinated F<(X x), Y> then) 
                             { ... }

    doc "If the value is non-null, evaluate first block,
         otherwise, evaluate second block. Return result
         of evaluation."
    public static Y ifExists<X,Y>(specified optional X value,
                                  coordinated F<(X x), Y> then, 
                                  F<(), Y> otherwise) 
                    { ... }

    doc "Iterate elements and return those for which the first
         block evaluates to true, ordered using the second block,
         if specified."
    public static List<X> from<X>(iterated Iterable<X> elements,
                                  coordinated F<(X x), Boolean> having,
                                  optional coordinated F<(X x), Comparable> by = null) 
                          { ... }

    doc "Iterate elements and for each element evaluate the first block. 
         Build a list of the resulting values, ordered using the second 
         block, if specified."
    public static List<Y> from<X,Y>(iterated Iterable<X> elements,
                                    coordinated F<(X x), Y> select,
                                    optional coordinated F<(X x), Comparable> by = null) 
                          { ... }

    doc "Iterate elements and select those for which the first block 
         evaluates to true. For each of these, evaluate the second block. 
         Build a list of the resulting values, ordered using the third 
         block, if specified."
    public static List<Y> from<X,Y>(iterated Iterable<X> elements,
                                    coordinated F<(X x), Boolean> having, 
                                    coordinated F<(X x), Y> select,
                                    optional coordinated F<(X x), Comparable> by = null) 
                          { ... }

    doc "Return the first element for which the block evaluates to true,
         or a null value if no such element is found."
    public static optional X first<X>(iterated Iterable<X> elements,
                                      coordinated F<(X x), Boolean> having) 
                             { ... }
    
    doc "Return the first element for which the first block evaluates to 
         true, or the result of evaluating the second block, if no such
         element is found."
    public static X first<X>(iterated Iterable<X> elements,
                             coordinated F<(X x), Boolean> having
                             F<(), X> otherwise) 
                    { ... }
    
    doc "Count the elements for with the block evaluates to true."
    public static Integer count<X>(iterated Iterable<X> elements,
                                   coordinated F<(X x), Boolean> having) 
                          { ... }
    
    doc "Return true iff for every element, the block evaluates to true."
    public static Boolean forAll<X>(iterated Iterable<X> elements,
                                    coordinated F<(X x), Boolean> every) 
                          { ... }

    doc "Return true iff for some element, the block evaluates to true."
    public static Boolean forAny<X>(iterated Iterable<X> elements,
                                    coordinated F<(X x), Boolean> some) 
                          { ... }
    
    doc "Using the given resource, attempt to evaluate the first block.
         If an exception occurs, and there is a matching block, evaluate
         the exception block."
    public static Y using<X,Y>(specified X resource,
                               coordinated F<(X x), Y> seek,
                               F<(E e), Y> where E>=Exception... except)
                    where X >= Usable { ... }

}]]></programlisting>
    
    </section>
    
    <section>
        <title>Primitive type optimization</title>
        
    <para>For certain types, the Ceylon compiler is permitted to transform
    local declarations to Java primitive types, literal values to Java literals, 
    and operator invocations to use of native Java operators, as long as the
    transformation does not affect the semantics of the code.</para>
    
    <para>For this example:</para>
    
    <programlisting>Integer calc(Integer j) {
    Integer i = list.size;
    i++;
    return i * j + 1000;
}</programlisting>
    
    <para>the following equivalent Java code is acceptable:</para>
    
    <programlisting>Integer calc(Integer j) {
    int i = list.size().get();
    i++;
    return new Integer( i * lang.Util.intValue(j) + 1000 );
}</programlisting>

    <para>The following optimizations are allowed:</para>
    
    <itemizedlist>
        <listitem><literal>lang.Integer</literal> to Java <literal>int</literal></listitem>
        <listitem><literal>lang.Long</literal> to Java <literal>long</literal></listitem>
        <listitem><literal>lang.Float</literal> to Java <literal>float</literal></listitem>
        <listitem><literal>lang.Double</literal> to Java <literal>double</literal></listitem>
        <listitem><literal>lang.Boolean</literal> to Java <literal>boolean</literal></listitem>
    </itemizedlist>
    
    <para>However, these optimizations may never be performed for locals, attributes
    or method types declared <literal>optional</literal>.</para>
    
    <para>The following operators may be optimized: 
    <literal>+, -, *, /, ++, --, +=, -=, *=, /=, 
    &gt;, &lt;, &lt;=, &gt;=, ==, &amp;&amp;, ||, !</literal>.</para>
    
    <para>Finally, integer, float and boolean literals may be optimized.</para>
    
    </section>
    
</chapter>