<chapter id="types">
    <title>Basic types</title>
    
    <para>There are no primitive types in Ceylon, however, there are certain
    important types provided by the package <literal>lang</literal>. Many
    of these types support <emphasis>operators</emphasis>.</para>
        
    <section>
        <title>The root type</title>
        
        <para>The <literal>lang.Object</literal> class is the root of the type 
        hierarchy and supports the binary operators <literal>==</literal> (equals),
        <literal>!=</literal> (not equals), <literal>===</literal> (identity equals), 
        <literal>.</literal> (invoke), <literal>^.</literal> (chain invoke),
        <literal>in</literal> (in), <literal>is</literal> (is), the unary prefix 
        operator <literal>$</literal> (render), and the binary operator 
        <literal>:=</literal> (assign).</para>
        
        <para>In addition, references of type <literal>optional:Object</literal>
        support the binary operators <literal>?.</literal> (nullsafe invoke) 
        and <literal>?</literal> (default)
        <!-- and <literal>?:</literal> (null default) -->and the unary operator
        <literal>exists</literal>, along with the binary operators 
        <literal>==</literal> (equals), <literal>!=</literal> (not equals), 
        <literal>===</literal> (identity equals) and <literal>=</literal> (assign).</para>
        
        <programlisting><![CDATA[public abstract class Object {
        
    doc "The equals operator x == y. Default implementation compares
         attributes annotated |id|, or performs identity comparison."
    see #id
    public Boolean equals(Object that) {
        ...;
    }
    
    doc "Compares the given attributes of this instance with the given
         attributes of the given instance."
    public Boolean equals(Object that, Attribute... attributes) { ... }
    
    doc "The hash code of the instance. Default implementation compares
         attributes annotated |id|, or assumes identity equality."
    see #id
    public Integer hash {
        return ...;
    }
    
    doc "Computes the hash code of the instance using the given attributes."
    public Integer hash(Attribute... attributes) { ... }
        
    doc "The unary render operator $x. A developer-friendly string 
         representing the instance. By default, the string contains
         the name of the type, and the values of all attributes 
         annotated |id|."
    public String string { ... }
    
    doc "Determine if the instance belongs to the given Category."
    see #Category
    public Boolean in<Y>(Category<Y> cat)
            where (Y<=X) {
        return cat.contains(this);
    }
    
    doc "Determine if the instance belongs to the given Iterable
         object."
    see #Iterable
    public Boolean in<Y>(Iterable<Y> iterable) 
            where (Y<=X) {
        return forAny (Object elem in iterable) some elem == this;
    }
    
    doc "The Type of the instance."
    public Type<X+> type { ... }
    
    doc "Binary assignability operator x is Y. Determine if the instance 
         is of the given Type."
    public Boolean instanceOf(Type<Object+> type) {
        return this.type.assignableTo(type);
    }
    
    doc "A log obect for the type."
    public static Log log = Log(type);
        
    ...
        
}]]></programlisting>

<!-- 
    doc "Return a reference to the instance, of the given
         Type, or throw an exception if the instance is not
         of the given type."
    public T as<T>(Type<T> type) { ... }
-->

    </section>

<!--
    <section>
        <title>Types</title>
        
        <programlisting><![CDATA[public interface Type<X> 
        satisfies Case<Object> {
    ...
}]]></programlisting>

    </section>
--> 
    
    <section>
        <title>Boolean values</title>
        
        <para>The <literal>lang.Boolean</literal> class represents
        boolean values, and supports the binary <literal>||, &amp;&amp;, =>,
        |, &amp;, ^</literal> and unary <literal>!</literal> operators.</para>
        
        <programlisting>public final class Boolean 
        satisfies Case&lt;Boolean&gt; {
    instances true, false;

    doc "The binary or operator x | y"
    public Boolean or(Boolean boolean) { ... }
    
    doc "The binary and operator x &amp; y"
    public Boolean and(Boolean boolean) { ... }
    
    doc "The binary xor operator x ^ y"
    public Boolean xor(Boolean boolean) { ... }

    doc "The unary not operator !x"
    public Boolean negation {
        return switch(this) {
            case (true) false
            case (false) true
        };
    }
    
}</programlisting>

    </section>
    
    <section>
        <title>Values and callables</title>
        
        <para>The interface <literal>Callable</literal>
        represents a callable reference.</para>
        
        <programlisting>public interface Callable&lt;out S&gt;
        where S >= Functor {
    public S invoke;
    public onCall( ... );
}</programlisting>
        
        <para>The interface <literal>Value</literal> models a 
        readable value.</para>
        
        <programlisting>public interface Value&lt;out T&gt; {
    public functor T() get;
    public onGet( functor T(T value) interceptor );
}</programlisting>

        <para>The interface <literal>OpenValue</literal> models 
        a readable and writeable value.</para>
        
        <programlisting>public interface OpenValue&lt;T&gt; 
        satisfies Value&lt;T&gt; {
    public functor void(T value) set;
    public onSet( functor T(T value) interceptor );
}</programlisting>

    </section>
    
    <section>
        <title>Methods and attributes</title>
        
        <programlisting>public interface Annotated {
    public Boolean annotated(Type&lt;Object+&gt; type);
    public T annotation&lt;T&gt;(Type&lt;T&gt; type);
    public Set&lt;Object&gt; annotations;
}</programlisting>
        
        <programlisting>public interface Member&lt;in X&gt; 
        satisfies Annotated {
    public Type&lt;X&gt; declaringType;
    public String name;
    public Visibility visibility;
    public Boolean abstract;
    public Boolean override;
}</programlisting>
        
        <programlisting>public interface Method&lt;in X, out S&gt;
        where S >= Functor 
        satisfies Member&lt;X&gt; {
    public Type&lt;Object+&gt; returnType;
    public List&lt;Type&lt;Object+&gt;&gt; parameterTypes;
    public Callable&lt;S&gt; curry(X instance);
    public Boolean static;
    public Boolean once;
    public onCall( ... );
}</programlisting>
        
        <programlisting>public interface Attribute&lt;in X, out T&gt; 
        satisfies Member&lt;X&gt; {
    public Type&lt;T&gt; attributeType;
    public boolean mutable;
    public Value&lt;T&gt; curry(X instance);
    public onGet( functor T(X instance, T value) interceptor );
}</programlisting>
                
        <programlisting>public interface MutableAttribute&lt;in X, T&gt;
        satisfies Attribute&lt;X,T&gt; {
    public override OpenValue&lt;T&gt; curry(X instance);
    public onSet( functor T(X instance,T value) interceptor );
}</programlisting>
                
    </section>
    
    <section>
        <title>Iterable objects and iterators</title>
        
        <para>The <literal>lang.Iterable&lt;X&gt;</literal> interface
        represents a type that may be iterated over using a
        <literal>lang.Iterator&lt;X&gt;</literal>. It supports the
        binary operator <literal>*.</literal> (spread).<!--  ,
        <literal>*&lt;, *&gt;, *&lt;=, *&gt;=, *==, *!=</literal>
        (spread comparison)--> <!--and <literal>*~></literal> (all in).--></para>
        
        <programlisting>public interface Iterable&lt;out X&gt; {
    
    doc "Produce an iterator."
    public Iterator&lt;X&gt; iterator();
    
}</programlisting>

        <programlisting>public interface Iterator&lt;out X&gt; {

    public Boolean more;
    public X current;
    public X next();
    
}</programlisting>

<!--
        <para>The following decorator exists:</para>

        <programlisting><![CDATA[public decorator Iterables<X> (Iterable<X> iterable) {

    public void forEach(functor void(X) each) { ... }
    public Integer count(functor Boolean(X) test) { ... }
    public Boolean forAll(functor Boolean(X) test) { ... }
    public Boolean forAny(functor Boolean(X) test) { ... }
    
    public optional X first(functor Boolean(X) test) { ... }
    
    public Y accumulate<Y>(Y initial, functor Y(Y current, X element) accumulate) { ... }
    
    public Collection<X> select(functor Boolean(X) test) { ... }
    public Collection<X> reject(functor Boolean(X) test) { ... }
    
    public Bag<Y> transform<Y>(functor Y(X) transform) { ... }
    public List<Y> transform<Y>(functor Y(X) transform, functor Comparison(Y x,Y y) comparison) { ... }
    public Set<Y> collect<Y>(functor Y(X) transform) { ... }
    public Map<X, Y> map<Y>(functor Y(X) transform) { ... }
    public List<X> list(functor Comparison(X,X) compare) { ... }
    
}]]></programlisting>
-->
        <para>Some iterable objects may support element removal during iteration.</para>
        
        <programlisting>public mutable interface OpenIterable&lt;X&gt; 
        satisfies Iterable&lt;X&gt; {
        
    public override OpenIterator&lt;X&gt; iterator();
    
}</programlisting>

        <programlisting>public mutable interface OpenIterator&lt;X&gt; 
        satisfies OpenIterator&lt;X&gt; {

    public void remove();
    public Boolean replace(X replacement);
    
}</programlisting>

        <!--programlisting><![CDATA[public decorator OpenIterables (OpenIterable iterable) {

    public Integer remove((X) produce Boolean test) { ... }
    public Integer retain((X) produce Boolean test) { ... }
    
}]]></programlisting-->

    </section>
    
    <section>
        <title>Cases and Selectors</title>
        
        <para>The interface <literal>lang.Case&lt;X&gt;</literal> represents a
        type that may be used as a case in the <literal>switch</literal>
        construct.</para>
        
        <programlisting>public interface Case&lt;in X&gt; {

    public Boolean test(X value);
    
}</programlisting>

        <para>Classes with enumerated instances implicitly extend <literal>lang.Selector</literal></para>
        
        <programlisting>public abstract class Selector&lt;X&gt;(String name, int ordinal)
        satisfies Case&lt;X&gt;
        where X >= Selector&lt;X&gt; { ... }</programlisting>
        
    </section>
    
    <section>
        <title>Usables</title>
        
        <para>The interface <literal>lang.Usable</literal> represents an
        object with a lifecycle controlled by <literal>try</literal>.</para>
        
        <programlisting>public interface Usable {

    public void begin();
    public void end();
    public void end(Exception e);
    
}</programlisting>        
       
    </section>
    
    <section>
        <title>Category, Correspondence and Container</title>
        
        <para>The interface <literal>lang.Category</literal> represents
        the abstract notion of an object that contains other objects.</para>
        
        <programlisting>public interface Category {
    
    doc "Determine if the given element belongs to the category."
    public Boolean contains(Object element);

}</programlisting>

        <programlisting>public extension Categories(Category category) {
        
    doc "Determine if all the given elements belong to the category."
    public Boolean contains(Iterable&lt;Object&gt; elements) {
        return forAll (X x in elements) every category.contains(x);
    }
    
}</programlisting>

        <para>There is a mutable subtype, representing a category to which 
        objects may be added.</para>
        
        <programlisting>public mutable interface OpenCategory&lt;in X&gt; 
        satisfies Category&lt;X&gt; {
    
    doc "Add the given element to the category."
    public Boolean add(X element);

}</programlisting>

        <programlisting>public extension OpenCategories&lt;in X&gt;(OpenCategory&lt;X&gt; category) {
        
    doc "Add the given elements to the category."
    public Boolean add(Iterable&lt;X&gt; elements) {
        Boolean added = false;
        for (X x in elements) {
            added |= category.add(x);
        }
        return added;
    }
    
}</programlisting>

        <para>The interface <literal>lang.Correspondence</literal> represents
        the abstract notion of an object that maps value of one type to values
        of some other type. It supports the binary operator
        <literal>[key]</literal> (lookup).</para>
        
        <programlisting>public interface Correspondence&lt;in U, out V&gt; {
    
    doc "Binary lookup operator x[key]. Returns the value associated 
         with the given key."
    public V value(U key);
    
    doc "Determine if there is a value associated with the given key."
    public Boolean defines(U key);
    
}</programlisting>

        <programlisting>public extension Correspondences&lt;in U, out V&gt;(Correspondence&lt;U, V&gt; correspondence) {

    doc "Binary lookup operator x[keys]. Returns a list of values 
         associated with the given keys, in order."
    public List&lt;V&gt; values(List&lt;U&gt; keys) {
        return from (U key in keys) select correspondence.lookup(key);
    }
    
    doc "Binary lookup operator x[keys]. Returns a set of values 
         associated with the given set of keys."
    public Set&lt;V&gt; values(Set&lt;U&gt; keys) {
        return ( from (U key in keys) select correspondence.lookup(key) ).elements;
    }
    
    doc "Determine if there are values associated with all the given keys."
    public Boolean defines(Iterable&lt;U&gt; keys) {
        for (U key in keys) {
            if ( !correspondence.defines(key) ) {
                return false
            }
        }
        fail {
            return true;
        }
    }
    
}</programlisting>

        <para>There is a mutable subtype, representing a correspondence
        for which new mappings may be defined, and existing mappings 
        modified. It provides for the use of element expressions in
        assignments.</para>
        
        <!-- Association? -->

        <programlisting>public mutable interface OpenCorrespondence&lt;in U, V&gt; 
        satisfies Correspondence&lt;U, V&gt; {
        
     doc "Element assignment x[key] = value. Assign a value to the given 
          key."
     public optional V define(U key, V value);

}</programlisting>

        <programlisting>public extension OpenCorrespondences&lt;in U, V&gt;(OpenCorrespondence&lt;U, V&gt; correspondence) {

     doc "Assign the given values to the given keys."
     public void define(Iterable&lt;Entry&lt;U, V&gt;&gt; definitions) {
         for (U key->V value) {
             correspondence.define(key, value);
         }
     }
    
     doc "Add the given entry."
     public void define(U key -> V value) {
         correspondence.define(key, value);
     }
    
}</programlisting>

        <para>The interface <literal>lang.Container</literal> represents
        the abstract notion of an object that may be empty. It supports 
        the unary postfix operator <literal>nonempty</literal><!--and
        the binary operator <literal>??:</literal> (empty default)-->.</para>
        
        <programlisting>public interface Container {
        
    doc "Determine if the container is empty."
    public Boolean empty;
    
}</programlisting>

    </section>
    
    <section>
        <title>Entries</title>
        
        <para>The <literal>Entry</literal> class represents a pair of 
        associated objects.</para>

        <para>Entries may be constructed using the <literal>-></literal> 
        operator.</para>

            <programlisting><![CDATA[public class Entry<out U, out V>(U key, V value) {

    public U key = key;
    public V value = value;
    
    override public Boolean equals(Object that) {
        return equals(that, Entry#key, Entry#value);
    }
    
    override public Integer hash {
        return hash(Entry#key, Entry#value);
    }

}]]></programlisting>

    </section>
    
    <section>
        <title>Collections</title>
        
        <para>The interface <literal>lang.Collection</literal> is the 
        root of the Ceylon collections framework.</para>
        
        <programlisting><![CDATA[public interface Collection<out X> 
        satisfies Iterable<X>, Category, Container {
    
    public Integer size;
    
    public Integer count(Object element);
    public Integer count(functor Boolean(X element) having);
    
    public Boolean contains(functor Boolean(X element) having);
    
    public Set<X> elements;
    public Set<X> elements(functor Boolean(X element) having);
    
    public List<X> sort();
    public List<X> sort(functor Comparison(X x, X y) by);
    
    public OpenCollection<T> copy<T>() where T <= X;
    
}]]></programlisting>

<!--
    public Collection<T> subcollection<T>(functor T(X element) restriction) where T >= X;
-->
        
        <para>Mutable collections implement <literal>lang.OpenCollection</literal>:</para>
        
        <programlisting><![CDATA[public mutable interface OpenCollection<X> 
        satisfies OpenIterable<X>, OpenCategory<X>, Collection<X> {
    
    public Boolean clear();
    
    public Boolean remove(X element);
    public Integer remove(functor Boolean(X element) having);
    
}]]></programlisting>

        <section>
            <title>Sets</title>
            
            <para>Sets implement the following interface<!--  ,
            and support the binary operators <literal>+</literal>
            (union), <literal>~</literal> (intersect), 
            <literal>-</literal> (complement),
            <literal>>=</literal> (superset),
            <literal>&lt;=</literal> (subset),
            <literal>></literal> (proper superset) and
            <literal>&lt;</literal> (proper subset),
            in addition to inherited operators-->:</para>
            
            <programlisting><![CDATA[public interface Set<out X> 
        satisfies Collection<X>, Correspondence<Object, Boolean> {
    
    public Boolean superset(Set<Object> set);
    public Boolean subset(Set<Object> set);
        
    public OpenSet<T> copy<T>() where T <= X;

}]]></programlisting>

            <!--    
    public Set<T> union(Set<T> set) where T<=X;
    public Set<X> intersection(Set<Object> set);
    public Set<X> complement(Set<Object> set);
            -->

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenSet<X> 
        satisfies Set<X>, OpenCollection<X>, OpenCorrespondence<Object, Boolean> {}]]></programlisting>

        </section>
        
        <section>
            <title>Lists</title>
            
            <para>Lists implement the following interface, and support 
            the binary operators <literal>+</literal> (join),
            <literal>[...j], [i...]</literal> (lower, upper range) and the 
            ternary operator <literal>[i..j]</literal> (subrange) in addition
            to operators inherited from <literal>Collection</literal>
            and <literal>Correspondence</literal>:</para>
            
            <programlisting><![CDATA[public interface List<out X> 
        satisfies Collection<X>, Correspondence<Integer, X> {
    
    public X first;    
    public X last;
    
    public optional X firstOrNull;
    public optional X lastOrNull;
    
    public Integer firstIndex;
    public Integer lastIndex;
    
    public Integer firstIndex(functor Boolean(X element) having);
    public Integer lastIndex(functor Boolean(X element) having);
    
    public optional Integer firstIndexOrNull(functor Boolean(X element) having);
    public optional Integer lastIndexOrNull(functor Boolean(X element) having);
    
    public List<X> head(Integer to=firstIndex);
    public List<X> tail(Integer from=lastIndex);
    
    doc "The binary range operator x[from..to]"
    public List<X> range(Integer from, Integer to);

    doc "The binary join operator x + y"
    public List<T> join(List<T> elements) where T<=X;
    
    public List<X> sublist(Integer from, Integer to);
    public List<X> reversed;
    public Bag<X> unsorted;
    public Map<Integer,X> map;
    
    public List<Y> transform<Y>(functor Y(X element) select);
    
    public OpenList<T> copy<T>() where T <= X;

}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenList<X> 
        satisfies List<X>, OpenCollection<X>, OpenCorrespondence<Integer, X> {

    public void prepend(X element);
    public void prepend(List<X> elements);
    public void append(X element);
    public void append(List<X> elements);

    public void insert(Integer at, X element);
    public X removeIndex(Integer at);
    
    public void delete(Integer from, Integer to);
    public void truncate(Integer from);
    
    public X removeFirst();
    public X removeLast();
    
    public void reverse();
    public void resort();
    public void resort(functor Comparison(X x, X y) by);
    
    override public OpenList<X> sublist(Integer from, Integer to);
    override public OpenList<X> reversed;
    override public OpenMap<Integer,X> map;
    
}]]></programlisting>
            
        </section>
            
        <section>
            <title>Maps</title>
            
            <para>Maps implement the following interface:</para>
            
            <comment><para>TODO: is it OK that maps are not contravariant in U?</para></comment>
            
            <programlisting><![CDATA[public interface Map<U, out V>
    satisfies Collection<Entry<U,V>>, Correspondence<U, V> {
    
    public Set<U> keys;
    public Bag<V> values;
    public Map<V, Set<U>> inverse;
    
    public optional V valueOrNull(U key);
    
    public Map<U, W> transform<W>(functor optional W(U key -> V value) select);
    
    public Map<U, V> entries(functor Boolean(U key -> V value) having);
    
    public OpenMap<U,T> copy<U,T>() where T <= V;
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenMap<U,V> 
        satisfies Map<U,V>, OpenCollection<Entry<U,V>>, OpenCorrespondence<U, V> {
    
    override public OpenSet<U> keys;
    override public OpenBag<V> values;
    override public OpenMap<V, Set<U>> inverse;
    
    public optional V removeKey(U key);
    public Bag<V> removeKeys(functor Boolean(U key) having);
    
}]]></programlisting>
            
        </section>
        
        <section>
            <title>Bags</title>
            
            <para>Bags implement the following interface:</para>
            
            <programlisting><![CDATA[public interface Bag<out X> 
        satisfies Collection<X>, Correspondence<Object, Integer> {
    
    public OpenBag<T> copy<T>() where T <= X;
    
    public Map<X,Integer> map;
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenBag<X> 
        satisfies Bag<X>, OpenCollection<X>, OpenCorrespondence<Object, Integer> {
        
    override public OpenMap<X,Integer> map;
    
}]]></programlisting>
            
        </section>
        
        <section>
            <title>Collection operations</title>
            
            <programlisting><![CDATA[public Collections {
            
    public static List<X> join<X>(List<X> list...) {
        return new List<X> {
            ...
        };
    }
    
    public static Bag<X> union<X>(Bag<X> bag...) {
        return new Bag<X> {
            ...
        };
    }
    
    public static Set<X> union<X>(Set<X> set...) {
        return new Set<X> {
            ...
        };
    }
    
    public static Set<X> intersection<X>(Set<X> set...) {
        return new Set<X> {
            ...
        };
    }
    
    public static Set<X> complement<X>(Set<X> set, Set<Object> sets...) {
        return new Set<X> {
            ...
        };
    }    
            
}]]></programlisting>
            
        </section>
        
    </section>
    
    <section>
        <title>Ordered values</title>
        
        <para>The <literal>lang.Comparable&lt;T&gt;</literal> interface 
        represents totally ordered types, and supports the binary operators 
        <literal>&gt;, &lt;, &lt;=, &gt;=</literal> and <literal>&lt;=&gt;</literal>
        (compare).</para>
        
        <programlisting>public interface Comparable&lt;in T&gt; {
    
    doc "The binary compare operator &lt;=&gt;. Compares this 
         instance with the given instance."
    public Comparison compare(T other);
    
}</programlisting>
        
        <programlisting>public class Comparison {
        
    instances larger, smaller, equal;
        
    public Boolean larger return this==larger;
    public Boolean smaller return this==smaller;
    public Boolean equal return this==equal;
    public Boolean unequal return this!=equal;
    public Boolean largeAs return this!=smaller;
    public Boolean smallAs return this!=larger;
    
}</programlisting>

        <para>The <literal>lang.Ordinal&lt;T&gt;</literal> interface 
        represents objects in a sequence, and supports the binary
        operator <literal>..</literal> (range) and postfix unary 
        operators <literal>++</literal> (successor) and 
        <literal>--</literal> (predecessor). In addition, variables 
        support the prefix unary operators <literal>++</literal> 
        (increment) and <literal>--</literal> (decrement).</para>
        
        <programlisting>public interface Ordinal&lt;T&gt; {

    doc "The unary "++" operator. The successor of this instance."
    public T successor;
    
    doc "The unary "--" operator. The predecessor of this instance."
    public T predecessor;
    
}</programlisting>

    </section>
    
    <section>
        <title>Ranges and enumerations</title>
        
        <para>Ranges and enumerations both implement <literal>List</literal>,
        therefore they support the join, subrange, contains and lookup operators, 
        among others. Ranges may be constructed using the <literal>..</literal> 
        operator:</para> 
        
        <programlisting>public class Range&lt;X&gt;(X first, X last) 
        satisfies List&lt;X&gt;, Case&lt;Object&gt;
        where X>=Ordinal &amp; X>=Comparable { 

    public X first = first;
    public X last = last;
    
    ... 
}</programlisting>

        <para>Enumerations represent an explicit list of values and may be constructed 
        using a simplified syntax:</para>
        
        <programlisting>public class Enumeration&lt;out X&gt;(X... values)
        satisfies List&lt;X&gt;, Case&lt;Object&gt; {
    ...

    public static extension 
    OpenMap&lt;U, V&gt; toOpenMap&lt;U, V&gt;(Enumeration&lt;Entry&lt;U,V&gt;&gt; enum) {
        return HashMap(enum);
    }

    public extension 
    OpenSet&lt;X&gt; toOpenSet&lt;X&gt;() {
        return elements.copy();
    }

    public extension 
    OpenList&lt;X&gt; toOpenList&lt;X&gt;() {
        return copy();
    }

    public static extension 
    Enumeration&lt;T&gt; singleton&lt;T&gt;(T object) { 
        return Enumeration(object); 
    }
    
}</programlisting>
    
    </section>
    
    <section>
        <title>Characters and strings</title>
        
        <para>Characters are represented by the following class:</para>

        <programlisting>public class Character 
        satisfies Ordinal&lt;Character&gt;, Comparable&lt;Character&gt;, Case&lt;Character&gt; { ... }</programlisting>
        
        <para>Strings implement <literal>List</literal>, therefore they 
        support the join, subrange, contains and lookup operators, 
        among others.</para> 
                
        <programlisting>public class String(Character... characters) 
        satisfies Comparable&lt;String&gt;, List&lt;Character&gt;, Case&lt;String&gt; {
    
    ... 
    
    public Iterable&lt;String&gt; tokens(Iterable&lt;Character&gt; separators=" ,;\n\l\r\t") { return ...; }
    
    public String lowercase { return ...; }
    public String uppercase { return ...; }
    
    public String strip(Iterable&lt;Character&gt; whitespace = " \n\l\r\t") { return ...; }
    public String normalize(Iterable&lt;Character&gt; whitespace = " \n\l\r\t") { return ...; }
    
    public String join(String... strings) { return ...; }
    public String join(Iterable&lt;String&gt; strings) { return ...; }
    
}</programlisting>

        <comment><para>TODO: do we need character ranges, like <literal>'a'..'z'</literal>, or is 
        it enough that we have regular expressions like <literal>`[a-z]`</literal>?</para></comment>

    </section>
    
    <section>
        <title>Regular expressions</title>
        
        <programlisting>public class Regex 
        satisfies Case&lt;String&gt; { 
    public List&lt;Match&gt; matchList(String string);
    public Boolean matches(String string);
    ... 
}</programlisting>
        
        <comment><para>TODO: I assume these are just Java (Perl 5-style) regular expressions. Is
        there some other better syntax around?</para></comment>

    </section>
    
    <section>
        <title>Numbers</title>
        
        <para>
        The <literal>lang.Number&lt;T&gt;</literal> interface 
        represents numeric values, and supports the binary operators 
        <literal>+,-, *, /, %, **</literal>, and the unary prefix operators 
        <literal>-, +</literal>. In addition, variables of type 
        <literal>lang.Number</literal> support 
        <literal>+=, -=, /=, *=</literal>.
        </para>
        
        <programlisting>public interface Number&lt;T&gt; 
        satisfies Comparable&lt;Number&lt;?&gt;&gt;, Ordinal&lt;T&gt; {
    
    //binary "+" operator
    public T add(T number);
    public Number add(Number number);

    //binary "-" operator
    public T subtract(T number);
    public Number subtract(Number number);

    //binary "*" operator
    public T multiply(T number);
    public Number multiply(Number number);

    //binary "/" operator
    public T divide(T number);
    public T divide(Number number);
    
    //binary "%" operator
    public T remainder(T number);
    public T remainder(Number number);
    
    //unary "-" operator 
    public T inverse;
    
    public T magnitude;
    
    public Boolean integral;
    public Boolean positive;
    public Boolean negative;
    public Boolean zero;
    public Boolean unit;
    
    public Exact exact;
    public Whole whole;
    public Natural natural;
    public Integer integer;
    public Float float;

    public Exact fractionalPart;
    public Integer scale;
    public Integer precision;
    
}</programlisting>

        <para>Five numeric types are built in:</para>

        <programlisting>public final class Natural 
        satisfies Number&lt;Natural&gt;, Case&lt;Natural&gt; { 
    ... 
    
    public Natural leftShift(Natural digits) { ... }
    public Natural rightShift(Natural digits) { ... }
        
}</programlisting>

        <programlisting>public final class Integer
        satisfies Number&lt;Integer&gt;, Case&lt;Integer&gt; {
    ...
    
    public void times(Iteration iteration) { ... }
    public void upto(Integer max, Iteration iteration) { ... }
    public void downto(Integer min, Iteration iteration) { ... }
    
}</programlisting>

        <programlisting>public final class Float 
        satisfies Number&lt;Float&gt; { ... }</programlisting>

        <programlisting>public class Exact 
        satisfies Number&lt;Exact&gt; { ... }</programlisting>

        <programlisting>public class Whole 
        satisfies Number&lt;Whole&gt;, Case&lt;Whole&gt; { ... }</programlisting>

    </section>
    
    <section>
        <title>Instants, intervals and durations</title>
        
        <comment><para>TODO: this stuff is just for illustration, the real
        date/time API will be much more complex and fully internationalized.</para></comment>
        
        <programlisting>public class Instant {
    ...
}</programlisting>

        <programlisting>public class Time(Integer hours, Integer minutes, 
        optional Integer seconds=null, optional Integer milliseconds=null,
        optional Integer timezone=null) 
        extends Instant {
    public Integer hours = hours;
    public Integer minutes = minutes;
    public optional Integer seconds = seconds;
    public optional Integer milliseconds = milliseconds;
    public optional Timezone timezone = timezone;
    ...
}</programlisting>
        
        <programlisting>public class Date(Integer year, Integer month, Integer day) 
        extends Instant {
    public Integer year = year;
    public Integer month = month;
    public Integer day = day;
    ...
}</programlisting>
        
        <programlisting>public class Datetime(Time time, Date date) 
        extends Instant {
    public Time time = time;
    public Date date = date;
    ...
}</programlisting>
        
        <programlisting>public class Interval&lt;X&gt;(X start, X end) 
        where X >= Instant {
    public X start = start;
    public X end = end;
    public Duration&lt;X&gt; duration { return ...; }
    ...
}</programlisting>

        <programlisting>public class Duration&lt;X&gt;(Map&lt;Granularity&lt;X&gt;, Integer&gt; magnitude) 
        where X >= Instant {

    public Map&lt;Granularity&lt;X&gt;, Integer&gt; magnitude = magnitude;
    
    public X before(X instant) { ... }
    public X after(X instant) { ... }
    
    public Datetime before(Datetime instant) { ... }
    public Datetime after(Datetime instant) { ... }
    
    public Duration&lt;X&gt; add(Duration&lt;X&gt; duration) { ... }
    public Duration&lt;X&gt; subtract(Duration&lt;X&gt; duration) { ... }
    
    ...
}</programlisting>

        <programlisting>public interface Granularity&lt;X&gt; 
        where X >= Instant {}</programlisting>

        <programlisting>public class DateGranularity 
        satisfies Granularity&lt;Date&gt;
        instances year, month, week, day {}</programlisting>

        <programlisting>public class DateGranularity 
        satisfies Granularity&lt;Time&gt;
        instances hour, minute, second, millisecond {}</programlisting>
        
    </section>
    
    <section>
        <title>Control expressions</title>
        
        <para>The <literal>lang</literal> package defines several classes
        containing static methods for building complex expressons.</para>
        
        <!-- 
    doc "Evaluate the block. Useful for turning a series
         of statements into an expression."
    public static X evaluate<X>(functor X() do) {
        return do();
    }
         -->
        
        
        <programlisting><![CDATA[public class Assertions {

    doc "Assert that the block evaluates to true. The block 
         is executed only when assertions are enabled. If
         the block evaluates to false, throw an 
         |AssertionException| with the given message."
    public static void assert(functor String() message
                              functor Boolean() that) {
        if ( assertionsEnabled() && !evaluate() ) {
            throw new AssertionException( message() );
        }
    }

}]]></programlisting>
    
        <programlisting><![CDATA[public class Conditionals {
        
    doc "If the condition is true, evaluate first block,
         and return the result. Otherwise, return a null
         value."
    public static optional Y ifTrue<Y>(Boolean condition,
                                       functor Y() then) {
        if (condition) {
            return then();
        }
        else {
            return null;
        }
    }

    doc "If the condition is true, evaluate first block,
         otherwise, evaluate second block. Return result
         of evaluation."
    public static Y ifTrue<Y>(Boolean condition,
                              functor Y() then, 
                              functor Y() otherwise) {
        if (condition) {
            return then();
        }
        else {
            return otherwise();
        }
    }

    doc "If the value is non-null, evaluate first block,
         and return the result. Otherwise, return a null
         value."
    public static optional Y ifExists<X,Y>(specified optional X value,
                                           coordinated functor Y(X x) then) {
        if (exists value) {
            return then(value);
        }
        else {
            return null;
        }
    }

    doc "If the value is non-null, evaluate first block,
         otherwise, evaluate second block. Return result
         of evaluation."
    public static Y ifExists<X,Y>(specified optional X value,
                                  coordinated functor Y(X x) then, 
                                  functor Y() otherwise) {
        if (exists value) {
            return then(value);
        }
        else {
            return otherwise();
        }
    }
    
    doc "Evaluate the block which matches the selector value, and
         return the result of the evaluation. If no block matches
         the selector value, return a null value."
    public static optional Y select<X,Y>(X selector,
                                         cases Iterable<Entry<Case<X>, functor Y()>> value) {
        for (Case<X> match -> functor X() evaluate in value) {
            if ( match.test(selector) ) {
                return evaluate(value);
            }
        }
        return null;
    }

    doc "Evaluate the block which matches the selector value, and
         return the result of the evaluation. If no block matches
         the selector value, evaluate the last block and return
         the result of the evaluation."
    public static Y select<X,Y>(X selector,
                                cases Iterable<Entry<Case<X>, functor Y()>> value
                                functor Y() otherwise) {
        if (exists Y y = select(selector, value)) {
            return y;
        }
        else {
            return otherwise();
        }
    }

}]]></programlisting>
    
        <programlisting><![CDATA[public class Quantifiers {

    doc "Count the elements for with the block evaluates to true."
    public static Integer count<X>(iterated Iterable<X> elements,
                                   coordinated functor Boolean(X x) having) {
        mutable Integer count := 0;
        for (X x in elements) {
            if ( having(x) ) {
                ++count;
            }
        }
        return count;
    }
    
    doc "Return true iff for every element, the block evaluates to true."
    public static Boolean forAll<X>(iterated Iterable<X> elements,
                                    coordinated functor Boolean(X x) every) {
        for (X x in elements) {
            if ( !every(x) ) {
                return false;
            }
        }
        return true;
    }
    
    doc "Return true iff for some element, the block evaluates to true."
    public static Boolean forAny<X>(iterated Iterable<X> elements,
                                    coordinated functor Boolean(X x) some) { 
        return !forAll(elements, (X x) !some(x)); 
    }
    
    doc "Return the first element for which the block evaluates to true,
         or a null value if no such element is found."
    public static optional X first<X>(iterated Iterable<X> elements,
                                      coordinated functor Boolean(X x) having) {
        for (X x in elements) {
            if ( having(x) ) {
                return x;
            }
        }
        return null;
    }
    
    doc "Return the first element for which the first block evaluates to 
         true, or the result of evaluating the second block, if no such
         element is found."
    public static X first<X>(iterated Iterable<X> elements,
                             coordinated functor Boolean(X x) having
                             functor X() otherwise) {
        if(exists X first = first(elements, having)) {
            return first;
        }
        else {
            return otherwise();
        }
    }
    
}]]></programlisting>
        
        <programlisting><![CDATA[public class ListComprehensions {
        
    doc "Iterate elements and return those for which the first
         block evaluates to true, ordered using the second block,
         if specified."
    public static List<X> from<X>(iterated Iterable<X> elements,
                                  coordinated functor Boolean(X x) having,
                                  optional coordinated functor Comparison(X x, X y) by = null) {
        return from(elements, having, (X x) x, by);
    }

    doc "Iterate elements and for each element evaluate the first block. 
         Build a list of the resulting values, ordered using the second 
         block, if specified."
    public static List<Y> from<X,Y>(iterated Iterable<X> elements,
                                    coordinated functor Y(X x) select,
                                    optional coordinated functor Comparable(X x) by = null)  {
        return from(elements, (X x) true, select, by);
    }

    doc "Iterate elements and select those for which the first block 
         evaluates to true. For each of these, evaluate the second block. 
         Build a list of the resulting values, ordered using the third 
         block, if specified."
    public static List<Y> from<X,Y>(iterated Iterable<X> elements,
                                    coordinated functor Boolean(X x) having, 
                                    coordinated functor Y(X x) select,
                                    optional coordinated functor Comparable(Y x, Y y) by = null) {
        OpenList<Y> list = ArrayList<Y>();
        for (X x in elements) {
            if ( having(x) ) {
                list.add( select(x) );
            }
        }
        if (exists by) {
            list.sort(by);
        }
        return list;
    }

}]]></programlisting>
        
        <programlisting><![CDATA[public class MapComprehensions {
        
    doc "Construct a |Map| by evaluating the block for each given key.
         Each |Entry| is constructed from the key and the value result 
         of the evaluation."
    public static Map<U,V> mapFrom<U,V>(iterated Iterable<U> keys,
                                        coordinated functor V(U key) to) { 
        return map(keys, (U key) key->to(key)); 
    }

    doc "Construct a |Map| by evaluating the block for each given value.
         Each |Entry| is constructed from the value and the key result 
         of the evaluation."
    public static Map<U,V> mapTo<U,V>(iterated Iterable<V> values,
                                      coordinated functor V(U key) from) { 
        return map(values, (V value) value->from(value)); 
    }

    doc "Construct a |Map| by evaluating the block for each given object
         and collecting the resulting |Entry|s."
    public static Map<U,V> map<X,U,V>(iterated Iterable<X> elements,
                                      coordinated functor Entry<U,V>(X element) of) {
        OpenMap<U,V> map = HashMap<U,V>();
        for (X x in elements) {
            map.add( of(x) );
        }
    }

}]]></programlisting>
    
        <programlisting><![CDATA[public class Handlers {
        
    doc "Attempt to evaluate the first block. If an exception occurs that 
         matches the second block, evaluate the block."
    public static Y seek<Y,E>(functor Y() seek,
                              functor Y(E e) except) {
        try {
            return seek();
        }
        catch (E e) {
            return except(e);
        }
    }
    
    doc "Using the given resource, attempt to evaluate the first block."
    public static Y using<X,Y>(specified X resource,
                               coordinated functor Y(X x) seek)
                    where X >= Usable {
        try (resource) {
            return seek(resource);
        }
    }
    
    doc "Using the given resource, attempt to evaluate the first block.
         If an exception occurs that matches the block, evaluate the 
         second block."
    public static Y using<X,Y,E>(specified X resource,
                                 coordinated functor Y(X x) seek,
                                 functor Y(E e) except)
                    where X >= Usable {
        try (resource) {
            return seek(resource);
        }
        catch (E e) {
            return except(e);
        }
    }
    
}]]></programlisting>
    
    </section>
    
    <section>
        <title>Primitive type optimization</title>
        
    <para>For certain types, the Ceylon compiler is permitted to transform
    local declarations to Java primitive types, literal values to Java literals, 
    and operator invocations to use of native Java operators, as long as the
    transformation does not affect the semantics of the code.</para>
    
    <para>For this example:</para>
    
    <programlisting>Integer calc(Integer j) {
    Integer i = list.size;
    i++;
    return i * j + 1000;
}</programlisting>
    
    <para>the following equivalent Java code is acceptable:</para>
    
    <programlisting>Integer calc(Integer j) {
    int i = list.size().get();
    i++;
    return new Integer( i * lang.Util.intValue(j) + 1000 );
}</programlisting>

    <para>The following optimizations are allowed:</para>
    
    <itemizedlist>
        <listitem><literal>lang.Boolean</literal> to Java <literal>boolean</literal></listitem>

        <listitem><literal>byte lang.Natural</literal> to Java <literal>byte</literal></listitem>
        <listitem><literal>short lang.Natural</literal> to Java <literal>short</literal></listitem>
        <listitem><literal>int lang.Natural</literal> to Java <literal>int</literal></listitem>
        <listitem><literal>lang.Natural</literal> to Java <literal>long</literal></listitem>
        
        <listitem><literal>byte lang.Integer</literal> to Java <literal>byte</literal></listitem>
        <listitem><literal>short lang.Integer</literal> to Java <literal>short</literal></listitem>
        <listitem><literal>int lang.Integer</literal> to Java <literal>int</literal></listitem>
        <listitem><literal>lang.Integer</literal> to Java <literal>long</literal></listitem>
        
        <listitem><literal>float lang.Float</literal> to Java <literal>float</literal></listitem>
        <listitem><literal>lang.Float</literal> to Java <literal>double</literal></listitem>
    </itemizedlist>
    
    <para>However, these optimizations may never be performed for locals, attributes
    or method types declared <literal>optional</literal>.</para>
    
    <para>The following operators may be optimized: 
    <literal>+, -, *, /, ++, --, +=, -=, *=, /=, 
    &gt;, &lt;, &lt;=, &gt;=, ==, &amp;&amp;, ||, !</literal>.</para>
    
    <para>Finally, integer, float and boolean literals may be optimized.</para>
    
    </section>
    
</chapter>