<chapter id="types">
    <title>Basic types</title>
    
    <para>There are no primitive types in Ceylon, however, there are certain
    important types provided by the package <literal>lang</literal>. Many
    of these types support <emphasis>operators</emphasis>.</para>
        
    <section>
        <title>The root type</title>
        
        <para>The <literal>lang.Object</literal> class is the root of the
        type hierarchy and supports the binary operators <literal>==</literal> (equals),
        <literal>!=</literal> (not equals), <literal>===</literal> (identity equals), 
        <literal>.</literal> (invoke), <literal>^.</literal> (chain invoke),
        <literal>in</literal> (in), the unary prefix 
        operator <literal>$</literal> (render), and the binary operator 
        <literal>=</literal> (assign).</para>
        
        <para>In addition, references of type <literal>optional:Object</literal>
        support the binary operators <literal>?.</literal> (nullsafe invoke) 
        and <literal>default</literal>
        <!-- and <literal>?:</literal> (null default) -->and the unary operator
        <literal>exists</literal>, along with the binary operators 
        <literal>==</literal> (equals), <literal>!=</literal> (not equals), 
        <literal>===</literal> (identity equals) and <literal>=</literal> (assign).</para>
        
        <programlisting><![CDATA[public abstract: class Object<X> {
        
    /**
     * The equals operator x == y.
     *
     * Default implementation performs identity comparison.
     */
    public: Boolean equals(Object that) {
        return this===that;    
    }
    
    /**
     * Compares the given attributes of this instance with the given
     * attributes of the given instance.
     */
    public: Boolean equals(Object that, Attribute... attributes) { ... }
    
    /**
     * The hash code of the instance. Default implementation assumes 
     * identity equality.
     */
    public: Integer hash {
        return identityHash(this);
    }
    
    /**
     * Computes the hash code of the instance using the given attributes.
     */
    public: Integer hash(Attribute... attributes) { ... }
        
    /**
     * The unary render operator $x.
     *
     * A developer-friendly string representing the instance.
     */
    public: String string { ... }
    
    /**
     * Determine if the instance belongs to the given Category.
     */
    public: Boolean in<Y>(Category<Y> cat)
            where (Y<=X) {
        return cat.contains(this);
    }
    
    /**
     * Determine if the instance belongs to the given Iterable
     * object.
     */
    public: Boolean in<Y>(Iterable<Y> iterable) 
            where (Y<=X) {
        return for any ( Object elem in iterable ) 
            elem == this;
    }
    
    /**
     * The Type of the instance.
     */
    public: Type<X> type { ... }
    
    /**
     * Determine if the instance is of the given Type.
     */
    public: Boolean is(Type<?> type) {
        return this.type.assignableTo(type);
    }
    
    /**
     * Return a reference to the instance, of the given
     * Type, or throw an exception if the instance is not
     * of the given type.
     */
    public: T as<T>(Type<T> type) { ... }
    
    /**
     * A log obect for the type.
     */
    public static: Log log = Log(type);
        
    ...
        
}]]></programlisting>

    </section>
    
    <section>
        <title>Boolean values</title>
        
        <para>The <literal>lang.Boolean</literal> class represents
        boolean values, and supports the binary <literal>||, &amp;&amp;, =>,
        |, &amp;, ^</literal> and unary <literal>!</literal> operators.</para>
        
        <programlisting>public final: class Boolean 
        instances true, false {

    /**
     * The binary or operator x | y
     */
    public: Boolean or(Boolean boolean) { ... }
    
    /**
     * The binary and operator x &amp; y
     */
    public: Boolean and(Boolean boolean) { ... }
    
    /**
     * The binary xor operator x ^ y
     */
    public: Boolean xor(Boolean boolean) { ... }

    /**
     * The unary not operator !x
     */
    public: Boolean negation {
        return switch(this) {
            case (true) false
            case (false) true
        };
    }
    
}</programlisting>

    </section>
    
    <section>
        <title>Iterable objects and iterators</title>
        
        <para>The <literal>lang.Iterable&lt;X&gt;</literal> interface
        represents a type that may be iterated over using a
        <literal>lang.Iterator&lt;X&gt;</literal>. It supports the
        binary operator <literal>*.</literal> (spread).<!--  ,
        <literal>*&lt;, *&gt;, *&lt;=, *&gt;=, *==, *!=</literal>
        (spread comparison)--> <!--and <literal>*~></literal> (all in).--></para>
        
        <programlisting>public: interface Iterable&lt;X&gt; {
    
    /**
     * Produce an iterator.
     */
    public: Iterator&lt;X&gt; iterator();
    
}</programlisting>

        <programlisting>public: interface Iterator&lt;X&gt; {

    public: Boolean more;
    public: X current;
    public: X next();
    
}</programlisting>

        <para>The following decorator exists:</para>

        <programlisting><![CDATA[public: decorator Iterables<X> (Iterable<X> iterable) {

    public: void each(Do<X> each) { ... }
    public: Integer count(Test<X> test) { ... }
    public: Boolean isAll(Test<X> test) { ... }
    public: Boolean isAny(Test<X> test) { ... }
    
    public optional: X first(Test<X> test) { ... }
    
    public: Y accumulate<Y>(Y initial, Accumulate<Y,X> accumulate) { ... }
    
    public: Collection<X> select(Test<X> test) { ... }
    public: Collection<X> reject(Test<X> test) { ... }
    
    public: Bag<Y> transform<Y>(Transform<X, Y> transform) { ... }
    public: List<Y> transform<Y>(Transform<X, Y> transform, Compare<X,Y> compare) { ... }
    public: Set<Y> collect<Y>(Transform<X, Y> transform) { ... }
    public: Map<X, Y> map<Y>(Transform<X, Y> transform) { ... }
    public: List<X> list(Compare<X,Y> compare) { ... }
    
}]]></programlisting>

        <programlisting>public: void functor Do&lt;X&gt;(X element);</programlisting>
        <programlisting>public: Boolean functor Test&lt;X&gt;(X element);</programlisting>
        <programlisting>public: Y functor Transform&lt;X,Y&gt;(X element);</programlisting>
        <programlisting>public: Y functor Accumulate&lt;X,Y&gt;(Y current, X element);</programlisting>
        <programlisting>public: Comparison functor Compare&lt;X&gt;(X x, Y y);</programlisting>
        
        <para>Some iterable objects may support element removal during iteration.</para>
        
        <programlisting>public mutable: interface OpenIterable&lt;X&gt; 
        satisfies Iterable&lt;X&gt; {
        
    public override: OpenIterator&lt;X&gt; iterator();
    
}</programlisting>

        <programlisting>public mutable: interface OpenIterator&lt;X&gt; 
        satisfies OpenIterator&lt;X&gt; {

    public: void remove();
    
}</programlisting>

        <programlisting><![CDATA[public: decorator OpenIterables (OpenIterable iterable) {

    public: Integer remove(Test<X> test) { ... }
    public: Integer retain(Test<X> test) { ... }
    
}]]></programlisting>

    </section>
    
    <section>
        <title>Cases and Selectors</title>
        
        <para>The interface <literal>lang.Case&lt;X&gt;</literal> represents a
        type that may be used as a case in the <literal>switch</literal>
        construct.</para>
        
        <programlisting>public: interface Case&lt;X&gt; {

    public: Boolean test(X value);
    
}</programlisting>

        <para>Classes with enumerated instances implicitly extend <literal>lang.Selector</literal>:</para>
        
        <programlisting>public: class Selector&lt;X&gt;(String name, int ordinal)
        satisfies Case&lt;X&gt;
        where X >= Selector&lt;X&gt; { ... }</programlisting>
        
    </section>
    
    <section>
        <title>Usables</title>
        
        <para>The interface <literal>lang.Usable</literal> represents an
        object with a lifecycle controlled by <literal>try</literal>.</para>
        
        <programlisting>public: interface Usable {

    public: void begin();
    public: void end();
    public: void end(Exception e);
    
}</programlisting>        
       
    </section>
    
    <section>
        <title>Category, Correspondence and Container</title>
        
        <para>The interface <literal>lang.Category</literal> represents
        the abstract notion of an object that contains other objects.</para>
        
        <programlisting>public: interface Category&lt;X&gt; {
    
    /**
     * Determine if the given element belongs to the category.
     */
    public: Boolean contains(X element);

}</programlisting>

        <programlisting>public: decorator Categories&lt;X&gt; (Category&lt;X&gt; category) {
        
    /**
     * Determine if all the given elements belong to the category.
     */
    public: Boolean contains(Iterable&lt;X&gt; elements) {
        return for all (X x in elements) 
            category.contains(x);
    }
    
}</programlisting>

        <para>There is a mutable subtype, representing a category to which 
        objects may be added.</para>
        
        <programlisting>public mutable: interface OpenCategory&lt;X&gt; 
        satisfies Category&lt;X&gt; {
    
    /**
     * Add the given element to the category.
     */
    public: Boolean add(X element);

}</programlisting>

        <programlisting>public: decorator OpenCategories&lt;X&gt; (OpenCategory&lt;X&gt; category) {
        
    /**
     * Add the given elements to the category.
     */
    public: Boolean add(Iterable&lt;X&gt; elements) {
        return find (Boolean added = false)
            for (X x in elements) 
                added |= category.add(x);
    }
    
}</programlisting>

        <para>The interface <literal>lang.Correspondence</literal> represents
        the abstract notion of an object that maps value of one type to values
        of some other type. It supports the binary operator
        <literal>[key]</literal> (lookup).</para>
        
        <programlisting>public: interface Correspondence&lt;U, V&gt; {
    
    /**
     * Binary lookup operator x[key]
     *
     * Returns the value associated with the given key.
     */
    public: V value(U key);
    
    /**
     * Determine if there is a value associated with the given key.
     */
    public: Boolean defines(U key);
    
}</programlisting>

        <programlisting>public: decorator Correspondences&lt;X&gt; (Correspondence&lt;X&gt; correspondence) {

    /**
     * Binary lookup operator x[keys]
     *
     * Returns a list of values associated with the given keys,
     * in order.
     */
    public: List&lt;V&gt; values(List&lt;U&gt; keys) {
        return for (U key in keys) 
            correspondence.lookup(key);
    }
    
    /**
     * Binary lookup operator x[keys]
     *
     * Returns a set of values associated with the given set of keys.
     */
    public: Set&lt;V&gt; values(Set&lt;U&gt; keys) {
        return ( for (U key in keys) correspondence.lookup(key) ).elements;
    }
    
    /**
     * Determine if there are values associated with all the given keys.
     */
    public: Boolean defines(Collection&lt;U&gt; keys) {
        return for (U key in keys) 
                if ( !correspondence.defines(key) ) found false
            fail true;
    }
    
}</programlisting>

        <para>There is a mutable subtype, representing a correspondence
        for which new mappings may be defined, and existing mappings 
        modified. It provides for the use of element expressions in
        assignments.</para>
        
        <!-- Association? -->

        <programlisting>public mutable: interface OpenCorrespondence&lt;U, V&gt; 
        satisfies Correspondence&lt;U, V&gt; {
        
    /**
     * Element assignment x[key] = value
     *
     * Assign a value to the given key.
     */
     public optional: V define(U key, V value);

}</programlisting>

        <programlisting>public: decorator OpenCorrespondences&lt;X&gt; (OpenCorrespondence&lt;X&gt; correspondence) {

     /**
      * Assign the given values to the given keys.
      */
     public: void define(Iterable&lt;Entry&lt;U, V&gt;&gt; definitions);
    
}</programlisting>

        <para>The interface <literal>lang.Container</literal> represents
        the abstract notion of an object that may be empty. It supports 
        the unary postfix operator <literal>nonempty</literal><!--and
        the binary operator <literal>??:</literal> (empty default)-->.</para>
        
        <programlisting>public: interface Container {
        
    /**
     * Determine if the container is empty.
     */
    Boolean empty;
    
}</programlisting>

    </section>
    
    <section>
        <title>Entries</title>
        
        <para>The <literal>Entry</literal> class represents a pair of 
        associated objects.</para>

        <para>Entries may be constructed using the <literal>-></literal> 
        operator:</para>

            <programlisting><![CDATA[public: class Entry<U,V>(U key, V value) {

    public: U key = key;
    public: V value = value;
    
    override public: Boolean equals(Object that) {
        return equals(that, Entry#key, Entry#value);
    }
        
    override public: Integer hash {
        return hash(Entry#key, Entry#value);
    }

}]]></programlisting>

    </section>
    
    <section>
        <title>Collections</title>
        
        <para>The interface <literal>lang.Collection</literal> is the 
        root of the Ceylon collections framework.</para>
        
        <programlisting><![CDATA[public: interface Collection<X> 
        satisfies Iterable<X>, Category<X>, Container {
    
    public: Integer size;

    public: Integer count(X element);
    
    public: Set<X> elements;

    public: OpenCollection<X> copy();
    
}]]></programlisting>

        
        <para>Mutable collections implement <literal>lang.OpenCollection</literal>:</para>
        
        <programlisting><![CDATA[public mutable: interface OpenCollection<X> 
        satisfies OpenIterable<X>, OpenCategory<X>, Collection<X> {
    
    public: Boolean clear();

    public: Boolean remove(X element);
    public: Integer remove(Collection<X> elements);    
    public: Integer retain(Collection<X> elements);    

}]]></programlisting>

        <section>
            <title>Sets</title>
            
            <para>Sets implement the following interface<!--  ,
            and support the binary operators <literal>+</literal>
            (union), <literal>~</literal> (intersect), 
            <literal>-</literal> (complement),
            <literal>>=</literal> (superset),
            <literal>&lt;=</literal> (subset),
            <literal>></literal> (proper superset) and
            <literal>&lt;</literal> (proper subset),
            in addition to inherited operators-->:</para>
            
            <programlisting><![CDATA[public: interface Set<X> 
        satisfies Collection<X>, Correspondence<X, Boolean> {
    
    public: Set<X> union(Set<X> set);
    public: Set<X> intersection(Set<X> set);
    public: Set<X> complement(Set<X> set);
    
    public: Boolean superset(Set<X> set);
    public: Boolean subset(Set<X> set);
    
    public: OpenSet<X> copy();

    //public: Set<X> select(Test<X> test);
    //public: Set<X> reject(Test<X> test);
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable: interface OpenSet<X> 
        satisfies Set<X>, OpenCollection<X>, OpenCorrespondence<X, Boolean> {}]]></programlisting>

        </section>
        
        <section>
            <title>Lists</title>
            
            <para>Lists implement the following interface, and support 
            the binary operators <literal>+</literal> (join),
            <literal>[...j], [i...]</literal> (lower, upper range) and the 
            ternary operator <literal>[i..j]</literal> (subrange) in addition
            to operators inherited from <literal>Collection</literal>
            and <literal>Correspondence</literal>:</para>
            
            <programlisting><![CDATA[public: interface List<X> 
        satisfies Collection<X>, Correspondence<Integer, X> {
    
    public: X first;    
    public: X last;
    
    public optional: X firstOrNull;    
    public optional: X lastOrNull;
    
    public: Integer firstIndex;
    public: Integer lastIndex;
    
    public: Integer firstIndex(X element);
    public: Integer lastIndex(X element);
    
    public: List<X> head();
    public: List<X> tail();
    public: List<X> head(Integer to);
    public: List<X> tail(Integer from);
    
    /**
     * range operator x[from..to] 
     */
    public: List<X> range(Integer from, Integer to);

    /**
     * join operator x + y
     */
    public: List<X> join(List<X> elements);
    
    public: List<X> sublist(Integer from, Integer to);
    
    public: List<X> reversed();
    
    public: OpenList<X> copy();

    //public: List<X> select(Test<X> test);
    //public: List<X> reject(Test<X> test);
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable: interface OpenList<X> 
        satisfies List<X>, OpenCollection<X>, OpenCorrespondence<Integer, X> {

    public: void prepend(X element);
    public: void prepend(List<X> elements);
    public: void append(X element);
    public: void append(List<X> elements);

    public: void insert(Integer key, X element);
    public: void truncate(Integer from, Integer to);
    
    public: X removeFirst();
    public: X removeLast();
    
    public: void reverse();
    public: void sort(Compare<X,Y> compare);
    
    public: OpenList<X> sublist(Integer from, Integer to);
    
}]]></programlisting>
            
        </section>
            
        <section>
            <title>Maps</title>
            
            <para>Maps implement the following interface:</para>
            
            <programlisting><![CDATA[public: interface Map<U,V> 
    satisfies Collection<Entry<U,V>>, Correspondence<U, V> {
    
    public: Set<U> keys;
    public: Bag<V> values;    
    public: Map<V, Set<U>> inverse;
    
    public optional: V valueOrNull(U key);

    //public: Set<Entry<U,V>> entries;
    
    public: OpenMap<X> copy();
    
    //public: Map<U,V> select(Test<Entry<U,V>> test);
    //public: Map<U,V> reject(Test<Entry<U,V>> test);
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable: interface OpenMap<U,V> 
        satisfies Map<U,V>, OpenCollection<Entry<U,V>>, OpenCorrespondence<U, V> {
    
    public: OpenSet<U> keys;
    public: OpenBag<V> values;
    public: OpenMap<V, Set<U>> inverse;

    public: Integer removeKeys(Collection<U> keys);
    public: Integer retainKeys(Collection<U> keys);
    
}]]></programlisting>
            
        </section>
        
        <section>
            <title>Bags</title>
            
            <para>Bags implement the following interface:</para>
            
            <programlisting><![CDATA[public: interface Bag<X> 
        satisfies Collection<X>, Correspondence<X, Integer> {
    
    public: OpenBag<X> copy();
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable: interface OpenBag<X> 
        satisfies Bag<X>, OpenCollection<X>, OpenCorrespondence<X, Integer> {}]]></programlisting>
            
        </section>
        
    </section>
    
    <section>
        <title>Ordered values</title>
        
        <para>The <literal>lang.Comparable&lt;T&gt;</literal> interface 
        represents totally ordered types, and supports the binary operators 
        <literal>&gt;, &lt;, &lt;=, &gt;=</literal> and <literal>&lt;=&gt;</literal>
        (compare).</para>
        
        <programlisting>public: interface Comparable&lt;T&gt; {
    
    /**
     * The binary compare operator &lt;=&gt;
     *
     * Compares this instance with the given instance.
     */
    public: Comparison compare(T other);
    
}</programlisting>
        
        <programlisting>public: class Comparison 
        instances larger, smaller, equal { 
        
    public: Boolean larger return this==larger;
    public: Boolean smaller return this==smaller;
    public: Boolean equal return this==equal;
    public: Boolean unequal return this!=equal;
    public: Boolean largeAs return this!=smaller;
    public: Boolean smallAs return this!=larger;
    
}</programlisting>

        <para>The <literal>lang.Ordinal&lt;T&gt;</literal> interface 
        represents objects in a sequence, and supports the binary
        operator <literal>..</literal> (range) and postfix unary 
        operators <literal>++</literal> (successor) and 
        <literal>--</literal> (predecessor). In addition, variables 
        support the prefix unary operators <literal>++</literal> 
        (increment) and <literal>--</literal> (decrement).</para>
        
        <programlisting>public: interface Ordinal&lt;T&gt; {

    /**
     * The unary "++" operator 
     *
     * The successor of this instance.
     */
    public: T successor;
    
    /**
     * The unary "--" operator 
     *
     * The predecessor of this instance.
     */
    public: T predecessor;
    
}</programlisting>

    </section>
    
    <section>
        <title>Ranges and enumerations</title>
        
        <para>Ranges and enumerations both implement <literal>List</literal>,
        therefore they support the join, subrange, contains and lookup operators, 
        among others. Ranges may be constructed using the <literal>..</literal> 
        operator:</para> 
        
        <programlisting>public: class Range&lt;X&gt;(X first, X last) 
        satisfies List&lt;X&gt;, Case&lt;X&gt;
        where X>=Ordinal &amp; X>=Comparable { 

    public: X first = first;
    public: X last = last;
    
    ... 
    
}</programlisting>

        <para>Enumerations represent an explicit list of values and may be constructed 
        using a simplified syntax:</para>
        
        <programlisting>public: class Enumeration&lt;X&gt;(X... values)
        satisfies List&lt;X&gt;, Case&lt;X&gt; {
    
    ... 

    static: Enumeration&lt;Y&gt; emptyEnumeration&lt;Y&gt;() {
        return Enumeration&lt;X&gt;();
    }
    
}</programlisting>

        <para>Enumerations may be freely converted to sets or maps:</para>
        
        <programlisting>public: Map&lt;U, V&gt; converter EnumerationToMap(Enumeration&lt;Entry&lt;U,V&gt;&gt; enum) { ... }</programlisting>

        <programlisting>public: Set&lt;X&gt; converter EnumerationToSet(Enumeration&lt;X&gt; enum) { ... }</programlisting>

        <programlisting>public: OpenMap&lt;U, V&gt; converter EnumerationToOpenMap(Enumeration&lt;Entry&lt;U,V&gt;&gt; enum) { ... }</programlisting>

        <programlisting>public: OpenSet&lt;X&gt; converter EnumerationToOpenSet(Enumeration&lt;X&gt; enum) { ... }</programlisting>

        <programlisting>public: OpenList&lt;X&gt; converter EnumerationToOpenList(Enumeration&lt;X&gt; enum) { ... }</programlisting>

        <para>Furthermore, any object may be transparently promoted to an enumeration:</para>
        
        <programlisting>public: Enumeration&lt;T&gt; converter ObjectToEnumeration(Object object) { return Enumeration(object); }</programlisting>
        
    </section>
    
    <section>
        <title>Characters, character strings and ranges</title>
        
        <para>Characters are represented by the following class:</para>

        <programlisting>public: class Character 
        satisfies Ordinal&lt;Character&gt;, Comparable&lt;Character&gt;, Case&lt;Character&gt; { ... }</programlisting>
        
        <para>Strings implement <literal>List</literal>, therefore they 
        support the join, subrange, contains and lookup operators, 
        among others.</para> 
                
        <programlisting>public: class String(Character... characters) 
        satisfies Comparable&lt;String&gt;, List&lt;Character&gt;, Case&lt;String&gt; {

    public: List&lt;Character&gt; characters = characters;
    
    ... 
    
    public: Iterable&lt;String&gt; tokens(Iterable&lt;Character&gt; separators=" ,;:") { return ...; }
    public: String join(String... strings);
    public: String join(Iterable&lt;String&gt; strings);
    
}</programlisting>

    </section>
    
    <section>
        <title>Regular expressions</title>
        
        <programlisting>public: class Regex 
        satisfies Case&lt;String&gt; { 
    public: List&lt;Match&gt; matchList(String string);
    public: Boolean matches(String string);
    ... 
}</programlisting>
        
    </section>
    
    <section>
        <title>Numbers</title>
        
        <para>
        The <literal>lang.Number&lt;T&gt;</literal> interface 
        represents numeric values, and supports the binary operators 
        <literal>+,-, *, /, %, **</literal>, and the unary prefix operators 
        <literal>-, +</literal>. In addition, variables of type 
        <literal>lang.Number</literal> support 
        <literal>+=, -=, /=, *=</literal>.
        </para>
        
        <programlisting>public: interface Number&lt;T&gt; 
        satisfies Comparable&lt;Number&lt;?&gt;&gt;, Ordinal&lt;T&gt; {
    
    //binary "+" operator
    public: T add(T number);
    public: Number add(Number number);

    //binary "-" operator
    public: T subtract(T number);
    public: Number subtract(Number number);

    //binary "*" operator
    public: T multiply(T number);
    public: Number multiply(Number number);

    //binary "/" operator
    public: T divide(T number);
    public: T divide(Number number);
    
    //binary "%" operator
    public: T remainder(T number);
    public: T remainder(Number number);
    
    //unary "-" operator 
    public: T inverse;
    
    public: T magnitude;
    
    public: Boolean integral;
    public: Boolean positive;
    public: Boolean negative;
    public: Boolean zero;
    public: Boolean unit;
    
    public: Exact exact;
    public: Whole whole;
    public: Natural natural;
    public: Integer integer;
    public: Float float;
    public: Double double;
    public: Long long;

    public: Exact fractionalPart;
    public: Integer scale;
    public: Integer precision;
    
}</programlisting>

        <para>Seven numeric types are built in:</para>

        <programlisting>public final: class Natural 
        satisfies Number&lt;Natural&gt;, Case&lt;Natural&gt; { ... }</programlisting>

        <programlisting>public final: class Integer
        satisfies Number&lt;Integer&gt;, Case&lt;Integer&gt; {
    ...
    
    public: void times(Iteration iteration) { ... }
    public: void upto(Integer max, Iteration iteration) { ... }
    public: void downto(Integer min, Iteration iteration) { ... }
    
}</programlisting>

        <programlisting>public final: class Long 
        satisfies Number&lt;Long&gt;, Case&lt;Long&gt; { ... }</programlisting>

        <programlisting>public final: class Float 
        satisfies Number&lt;Float&gt; { ... }</programlisting>

        <programlisting>public final: class Double 
        satisfies Number&lt;Double&gt; { ... }</programlisting>

        <programlisting>public: class Exact 
        satisfies Number&lt;Exact&gt; { ... }</programlisting>

        <programlisting>public: class Whole 
        satisfies Number&lt;Whole&gt;, Case&lt;Whole&gt; { ... }</programlisting>

    </section>
    
    <section>
        <title>Instants, intervals and durations</title>
        
        <programlisting>public: class Instant {
    ...
}</programlisting>

        <programlisting>public: class Time(Integer hours, Integer minutes, 
        optional: Integer seconds=null, optional: Integer milliseconds=null,
        optional: Integer timezone=null) 
        extends Instant {
    public: Integer hours = hours;
    public: Integer minutes = minutes;
    public optional: Integer seconds = seconds;
    public optional: Integer milliseconds = milliseconds;
    public optional: Timezone timezone = timezone;
    ...
}</programlisting>
        
        <programlisting>public: class Date(Integer year, Integer month, Integer day) 
        extends Instant {
    public: Integer year = year;
    public: Integer month = month;
    public: Integer day = day;
    ...
}</programlisting>
        
        <programlisting>public: class Datetime(Time time, Date date) 
        extends Instant {
    public: Time time = time;
    public: Date date = date;
    ...
}</programlisting>
        
        <programlisting>public: class Interval&lt;X&gt;(X start, X end) 
        where X >= Instant {
    public: X start = start;
    public: X end = end;
    public: Duration&lt;X&gt; duration { return ...; }
    ...
}</programlisting>

        <programlisting>public: class Duration&lt;X&gt;(Map&lt;Granularity&lt;X&gt;, Integer&gt; magnitude) 
        where X >= Instant {

    public: Map&lt;Granularity&lt;X&gt;, Integer&gt; magnitude = magnitude;
    
    public: X before(X instant) { ... }
    public: X after(X instant) { ... }
    
    public: Datetime before(Datetime instant) { ... }
    public: Datetime after(Datetime instant) { ... }
    
    public: Duration&lt;X&gt; add(Duration&lt;X&gt; duration) { ... }
    public: Duration&lt;X&gt; subtract(Duration&lt;X&gt; duration) { ... }
    
    ...
}</programlisting>

        <programlisting>public: interface Granularity&lt;X&gt; 
        where X >= Instant {}</programlisting>

        <programlisting>public: class DateGranularity 
        satisfies Granularity&lt;Date&gt;
        instances year, month, week, day {}</programlisting>

        <programlisting>public: class DateGranularity 
        satisfies Granularity&lt;Time&gt;
        instances hour, minute, second, millisecond {}</programlisting>
        
    </section>
    -->
    
    <section>
        <title>Primitive type optimization</title>
        
    <para>For certain types, the Ceylon compiler is permitted to transform
    local declarations to Java primitive types, literal values to Java literals, 
    and operator invocations to use of native Java operators, as long as the
    transformation does not affect the semantics of the code.</para>
    
    <para>For this example:</para>
    
    <programlisting>Integer calc(Integer j) {
    Integer i = list.size();
    i++;
    return i * j + 1000;
}</programlisting>
    
    <para>the following equivalent Java code is acceptable:</para>
    
    <programlisting>Integer calc(Integer j) {
    int i = list.size();
    i++;
    return new Integer( i * lang.Util.intValue(j) + 1000 );
}</programlisting>

    <para>The following optimizations are allowed:</para>
    
    <itemizedlist>
        <listitem><literal>lang.Integer</literal> to Java <literal>int</literal></listitem>
        <listitem><literal>lang.Long</literal> to Java <literal>long</literal></listitem>
        <listitem><literal>lang.Float</literal> to Java <literal>float</literal></listitem>
        <listitem><literal>lang.Double</literal> to Java <literal>double</literal></listitem>
        <listitem><literal>lang.Boolean</literal> to Java <literal>boolean</literal></listitem>
    </itemizedlist>
    
    <para>However, these optimizations may never be performed for locals, attributes
    or method types declared <literal>optional</literal>.</para>
    
    <para>The following operators may be optimized: 
    <literal>+, -, *, /, ++, --, +=, -=, *=, /=, 
    &gt;, &lt;, &lt;=, &gt;=, ==, &amp;&amp;, ||, !</literal>.</para>
    
    <para>Finally, integer, float and boolean literals may be optimized.</para>
    
    </section>
    
</chapter>