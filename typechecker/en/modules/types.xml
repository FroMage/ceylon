<chapter id="types">
    <title>Basic types</title>
    
    <para>There are no primitive types in Ceylon, however, there are certain
    important types provided by the SDK modules <literal>ceylon.lang</literal>
    and <literal>ceylon.collection</literal>. Many of these types support 
    operators.</para>
    
    <section id="languagemodule">
        <title>The language module</title>
        
        <para>The module <literal>ceylon.lang</literal> contains types which
        are referred to in the language definition.</para>
        
        <comment><para>Note: we will probably need to do the following erasures:</para>
        <itemizedlist>
            <listitem>
                <para><literal>Optional&lt;T&gt;</literal>, <literal>Something&lt;T&gt;</literal>
                and <literal>Nothing&lt;T&gt;</literal> to <literal>T</literal></para>
            </listitem>
            <listitem>
                <para><literal>Void</literal>, <literal>Object</literal> and 
                <literal>IdentifiableObject</literal> to <literal>java.lang.Object</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>Exception</literal> to <literal>java.lang.Throwable</literal>.</para>
            </listitem>
        </itemizedlist>
        <para>Therefore the members declared by <literal>Object</literal> and
        <literal>Exception</literal> will require special handling in the compiler.</para>
        </comment>
    
    <section id="void">
        <title>The void type</title>
        
        <para>The class <literal>Void</literal> is the root of the type
        system. All types are assignable to <literal>Void</literal>, which
        supports the the operator <literal>.</literal> (member selection), 
        along with <literal>is</literal> (assignability).</para>
        
        <programlisting>public abstract class Void extends null {}</programlisting>
        
        <para>The special syntax <literal>extends null</literal> indicates
        that <literal>Void</literal> has no superclass.</para>
        
    </section>
    
    <section id="object">
        <title><literal>Object</literal>, <literal>IdentifiableObject</literal>,
        and <literal>BaseObject</literal></title>
        
        <para>The class <literal>Object</literal> represents a definite value. 
        All interface types are assignable to <literal>Object</literal>.</para>
        
        <programlisting><![CDATA[public abstract class Object() 
        extends Void() {
    
    doc "The |Type| of the instance."
    public Type<subtype> type {
        return ... 
    }
        
    doc "The equals operator |x = y|."
    public Boolean equals(Object that);
    
    doc "The hash code of the instance. Implementations of |hash| 
         must respect the constraint that if |x=y| then 
         |x.hash=y.hash|."
    public Integer hash;
    
    doc "A developer-friendly string representing the instance. 
         By default, the string contains the name of the type, 
         and the values of all attributes annotated |id|."
    public String string;
    
    ...
        
}]]></programlisting>
    
        <para>Classes which are optimized by the compiler to Java primitive 
        types extend <literal>Object</literal> directly, since there is no 
        well-defined notion of identity for these types. Most other types
        are subclasses of <literal>IdentityObject</literal>.</para>
    
        <para>An <literal>Object</literal> may belong to categories. The 
        following extensions define the binary <literal>in</literal>
        operator:</para>
    
    <programlisting><![CDATA[public extension class Objects(Object object) {
    
    doc "Determine if this object belongs to the given |Category|.
         The binary |in| operator."
    see (Category)
    public Boolean in(Category category) {
        return category.contains(object)
    }
        
    doc "Determine if this object is produced by the |Iterable|.
         The binary |in| operator."
    see (Iterable<Object>)
    public Boolean in(Iterable<Object> objects) {
        if (is Category cat = objects) {
            return in(cat)
        }
        else {
            return forAny (Object elem in objects) some (elem = object)
        }
    }

}]]></programlisting>
    
    
<!-- 
    doc "Binary assignability operator |x is Y|. Determine if the 
         instance is of the given |Type|."
    public Boolean instanceOf(Type<Object> type) {
        return this.type.assignableTo(type)
    }    
 -->
<!--
    doc "A log object for the type."
    public default Log log { 
        return type.log 
    }
 -->
    
        <para>The class <literal>IdentifiableObject</literal> represents a type 
        whose values are always passed by reference. Expressions of type 
        <literal>IdentifiableObject</literal> support the binary operator 
        <literal>==</literal> (identity equals).</para>
        
        <programlisting><![CDATA[public abstract class IdentifiableObject() 
        extends Object() {}]]></programlisting>
        
        <para>The following toplevel methods expose the notion of object 
        identity:</para>
    
        <programlisting>public Boolean identical(IdentifiableObject x, IdentifiableObject y) { return ... }</programlisting>
        <programlisting>public Integer identityHash(IdentifiableObject x) { return ... }</programlisting>
    
        <comment><para>Note: Java classes would be subtypes of 
        <literal>IdentifiableObject</literal>.</para></comment>
    
        <para>User-written classes usually extend <literal>BaseObject</literal>.
        Expressions of type <literal>BaseObject</literal> have a default
        implementation of <literal>equals()</literal>, <literal>hash</literal>
        and <literal>string</literal> provided for them.</para>
        
        <programlisting><![CDATA[public abstract class BaseObject() 
        extends Object() {
        
    Attribute<subtype,Object>[] idAttributes() {
        return from ( Attribute<subtype,Object> a in type.attributes() ) 
                    where ( nonempty a.annotations(Id) );
    }
    
    doc "The equals operator |x = y|. Default implementation compares
         attributes annotated |id|, or performs identity comparison."
    see (id)
    default override Boolean equals(Object that) {
        Attribute<subtype,Object>[] idAttributes = idAttributes();
        if (nonempty idAttributes) {
            return equals(that, idAttributes)
        }
        else {
            return this==that
        }
    }
    
    doc "Compares the given attributes of this instance with the given
         attributes of the given instance."
    public Boolean equals(Object that, Attribute<subtype,Object>... attributes) {
        if (is subtype that) {
            return forAll (Attribute<subtype,Object> a in attributes)
                        every ( a(this) = a(that) )
        }
        else {
            return false
        }
    }
    
    doc "The hash code of the instance. Default implementation compares
         attributes annotated |id|, or assumes identity equality."
    see (id)
    default override Integer hash { 
        Attribute<subtype,Object>[] idAttributes = idAttributes();
        if (nonempty idAttributes) {
            return hash(idAttributes)
        }
        else {
            return identityHash(this)
        }
    }
    
    doc "Computes the hash code of the instance using the given 
         attributes."
    public Integer hash(Attribute<subtype,Object>... attributes) { ... }
        
    doc "A developer-friendly string representing the instance. 
         By default, the string contains the name of the type, 
         and the values of all attributes annotated |id|."
    default override String string {
        return string(idAttributes())
    }
    
    doc "A developer-friendly string representing the instance,
         containing the name of the type, and the value of the
         given attributes." 
    public default String string(Attribute<subtype,Object>... attributes) {
        mutable Character[] result := "";
        result .= with (type.name, "{");
        result .= forEach (Attribute<subtype,Object> a in attributes)
                    with ({ a.name, "=", $a(this), ";" });
        result .= with ("}");
        return result 
    }
    
    doc "Transform the given object to a string. Override to
         customize the render operator and character string 
         template expression interpolation."
    public default String string(Object? object) {
        return (object ? nullString).string
    }
    
    doc "The string representation of a null value. Override 
         to customize the render operator and character string 
         template expression interpolation."
    public default String nullString = "null";
        
    ...
        
}]]></programlisting>
    
    </section>
    
    <section id="callable">
        <title>Callable references</title>
        
        <para>The type <literal>Callable</literal> represents an executable
        operation. Expressions of type <literal>Callable</literal> may be the 
        subject of the argument specification operators <literal>()</literal> 
        and <literal>{}</literal>.</para>
        
        <programlisting><![CDATA[public interface Callable<out R, P...> {
    public R call(P... args);
    public void intercept( R onInvoke(R proceed(P... args), P... args) )();
}]]></programlisting>
    
        <para>An interceptor may be removed by invoking the returned method reference:</para>

        <programlisting><![CDATA[void removeSayInterceptor() = person.say.intercept() 
    onInvoke(void proceed(String words), String words) { 
        proceed(words.uppercase);
    };
...
removeSayInterceptor();]]></programlisting>

        <para>The following extension provides function <emphasis>composition</emphasis>, 
        combining a <literal>Callable&lt;Y,X&gt;</literal> with a <literal>Callable&lt;X,P...&gt;</literal>
        to produce a <literal>Callable&lt;Y,P...&gt;</literal>:</para>
        
        <programlisting><![CDATA[public extension Y composeable<X,Y,P...>(Y f(X x))(X g(P... args))(P... args) {
    Y compose(X g(P... args))(P... args) {
        Y composition(P... args) {
            return f(g(args))
        }
        return composition
    }
    return compose
}]]></programlisting>

       <para>For example:</para>
       
       <programlisting>void logFormatted(Date date) = log.info(DateFormat('dd/mm/yyyy').format);</programlisting>

       <para>The next extension allows the first parameter of any function with multiple 
       parameters to be <emphasis>curried</emphasis>, transforming a 
       <literal>Callable&lt;R,T,P...&gt;</literal> into a
       <literal>Callable&lt;Callable&lt;R,P...&gt;,T&gt;</literal>:</para>

       <programlisting><![CDATA[public extension class Curryable<R,T,P...>(R f(T t, P... args)) {
    R partial(T t)(P... p) {
        R curried(P... p) {
            return f(t, args)
        }
        return curried
    }
}]]></programlisting>
       
       <para>For example:</para>
       
       <programlisting>void info(String message) = log.message.partial(Level.info);
void hello() = info.partial("Hello!");</programlisting>
       
       <para>This extension does the reverse, transforming a 
       <literal>Callable&lt;Callable&lt;R,P...&gt;,T&gt;</literal> into a
       <literal>Callable&lt;R,T,P...&gt;</literal>:</para>

       <programlisting><![CDATA[public extension class Flattenable<R,T,P...>(R f(T t)(P... args)) {
    R flatten(T t, P... p) {
        return f(t)(p)
    }
}]]></programlisting>
       
       <para>For example:</para>
       
       <programlisting>void say(Person p, String words) = Person.say.flatten;</programlisting>
       
       <para>Finally, this extension swaps the first and second formal parameter lists of
       a function with multiple parameter lists, transforming a 
       <literal>Callable&lt;Callable&lt;R,Q...&gt;,P...&gt;</literal> into a
       <literal>Callable&lt;Callable&lt;R,P...&gt;,Q...&gt;</literal>:</para>
       
       <programlisting><![CDATA[public extension class Shuffleable<R,P...,Q...>(R f(P... p)(Q... q)) {
   R shuffle(Q... q)(P... p) {
       R shuffled(P... p) {
           return f(p)(q)
       }
       return shuffled
   }
}]]></programlisting>
        
        <para>For example:</para>
        
        <programlisting>Float sqr(Float x) = Float.power.shuffle(2);
void say(String words, Person p) = Person.say.shuffle.flatten;</programlisting>
        
    </section>
    
    <section id="evaluableandassignable">
        <title>Evaluable and assignable values</title>
        
        <para>The class <literal>Gettable</literal> represents a reference which may 
        be evaluated to produce a value, allowing pass by reference and lazy evaluation 
        semantics. Instances of <literal>Gettable&lt;T&gt;</literal> are transparently 
        assignable to <literal>T</literal> (evaluation).</para>
        
        <programlisting><![CDATA[public abstract class Gettable<out T>()
        extends Void() {    
    public void intercept( T onGet(T proceed()) )();
}]]></programlisting>
        
        <para>Note that <literal>Gettable</literal> is not a subclass of 
        <literal>Object</literal>.</para>
        
        <para>The following method allows a <literal>Gettable&lt;T&gt;</literal>
        to be treated as a <literal>Callable&lt;T&gt;</literal>:</para>

        <programlisting><![CDATA[public T get<T>(Gettable<T> value)() { 
    return value 
}]]></programlisting>
    
        <para>The subtype <literal>Settable</literal> represents a reference
        to an assignable value, allowing pass by reference semantics for assignable
        values. Expressions of type <literal>Settable</literal> support the binary
        operator <literal>:=</literal> (assign).</para>
        
        <programlisting><![CDATA[public abstract class Settable<T>()
        extends Gettable<T>() {
    public void intercept( void onSet(void proceed(T value), T value) )();
}]]></programlisting>

        <para>The following method allows an <literal>Settable&lt;T&gt;</literal>
        to be treated as a <literal>Callable&lt;T,T&gt;</literal>:</para>

        <programlisting><![CDATA[public T set<T>(Settable<T> value)(T newValue) { 
    return value := newValue; 
}]]></programlisting>
    
        <comment><para>TODO: should <literal>onSet()</literal> return the new value of
        the attribute instead of being <literal>void</literal>?</para></comment>

    </section>
    
    <section id="boolean">
        <title>Boolean values</title>
        
        <para>The <literal>Boolean</literal> class represents
        boolean values. Expressions of type <literal>Boolean</literal> support 
        the binary <literal>||</literal> and <literal>&amp;&amp;</literal> 
        operators and the unary <literal>!</literal> operator.</para>
        
        <programlisting><![CDATA[public class Boolean()
        satisfies Case<Boolean> {
        
    case true, case false;
    
    override Boolean test(Boolean value) {
        return this==value
    }

}]]></programlisting>

    </section>
    
    <section id="casesandselectors">
        <title>Cases and selectors</title>
        
        <para>The interface <literal>Case</literal> represents a
        type that may be used as a <literal>case</literal> in the 
        <literal>switch</literal> construct.</para>
        
        <programlisting><![CDATA[public interface Case<in X> {

    doc "Determine if the given value matches
         this case, returning |true| iff the
         value matches."
    public Boolean test(X value);
    
}]]></programlisting>

        <comment><para>TODO: the two extensions that follow don't actually
        work, since they overload the <literal>test()</literal> method of
        <literal>Case</literal> in a way that doesn't permit resolution
        according to the rules we have written down.</para></comment>

        <para>An extension allows <literal>Case&lt;X&gt;</literal> to 
        function as <literal>Case&lt;X?&gt;</literal>.</para>
        
        <programlisting><![CDATA[public extension
class CaseOptional<X>(Case<X> c) 
        satisfies Case<X?> {
        
    override Boolean test(X? x) {
        if (exists value) {
            return c.test(x)
        }
        else {
            return false;
        }
    }
        
}]]></programlisting>

        <para>An extension allows <literal>Case&lt;X&gt;</literal> to 
        function as <literal>Case&lt;Y&gt;</literal> where <literal>X</literal> 
        is assignable to <literal>Y</literal>.</para>
        
        <programlisting><![CDATA[public extension
class CaseSuper<X,Y>(Case<X> c) 
        satisfies Case<Y> 
        given X satisfies Y {
        
    override Boolean test(Y y) {
        if (is X y) {
            return c.test(y)
        }
        else {
            return false;
        }
    }
        
}]]></programlisting>

        <para>Classes with enumerated <literal>case</literal>s implicitly implement 
        <literal>Selector</literal></para>
        
        <programlisting><![CDATA[public interface Selector {
    public String name;
    public small Integer ordinal;
}]]></programlisting>

        <para>The implementations of <literal>equals()</literal>, <literal>hash</literal>
        and <literal>string</literal> provided by the <literal>BaseObject</literal> class 
        handle subclasses that implement <literal>Selector</literal> as a special case.</para>

        <para>This extension allows selectors to be used as cases in a <literal>switch</literal>
        statement:</para>
        
        <programlisting>public extension class SelectorCase&lt;X&gt;(X selector)
        given X extends Selector {
    override Boolean test(X x) {
        return x.ordinal = selector.ordinal
    }
}</programlisting>

        <para>Of course, the compiler is permitted to optimize away the call to this
        extension.</para>

    </section>
    
    <section id="optionalandnull">
        <title>Optional and null values</title>
        
        <para>The class <literal>Optional</literal> represents a
        value that may be null.</para>
        
        <programlisting><![CDATA[public abstract class Optional<out X>() 
        extends Void() {
    
    doc "The unary postfix exists operator 
         |x exists|."
    public Boolean valueExists;
    
    doc "The binary default operator 
         |x ? y|."
    public T default<T>(T defaultValue) 
            given T abstracts X;
    
}]]></programlisting>

        <para>Expressions of type <literal>Object?</literal> support the 
        binary operators <literal>?.</literal> (nullsafe invoke) and 
        <literal>?</literal> (default), the unary operator <literal>exists</literal>, 
        the unary operator <literal>$</literal> (render) and the the binary 
        operators <literal>=</literal> (equals) and <literal>!=</literal> 
        (not equals).</para>
        
         <para>Note that <literal>Optional</literal> is not a subtype
        of <literal>Object</literal>.</para>
        
        <para>If an optional value is not null, it is represented by an
        instance of the subclass <literal>Something</literal>.</para>
        
        <programlisting><![CDATA[public extension 
class Something<out X>(X x) 
        extends Optional<X>() {

    public extension X value = x;
    
    override Boolean valueExists { 
        return true 
    }
    
    override T default<T>(T defaultValue) 
            given T abstracts X {
        return value;
    }
    
}]]></programlisting>

        <para>Non-optional values are transparently assignable to optional
        values, since <literal>Something&lt;X&gt;</literal> is an extension of 
        <literal>X</literal> enabled in every compilation unit. Likewise, 
        instances of <literal>Something&lt;X&gt;</literal> are transparently 
        assignable to <literal>X</literal>.</para>
        
        <para>If an optional value is null, it is represented by an
        instance of the subclass <literal>Nothing</literal>.</para>
        
        <programlisting><![CDATA[public extension 
class Nothing<out X>(Null null) 
        extends Optional<X>() {

    override Boolean valueExists { 
        return false 
    }
    
    override T default<T>(T defaultValue) 
            given T abstracts X {
        return defaultValue;
    }
    
}]]></programlisting>

        <para>The value <literal>Null.null</literal> is transparently 
        assignable to optional values, since <literal>Nothing&lt;X&gt;</literal> 
        is an extension of <literal>Null</literal> enabled in every 
        compilation unit.</para>
        
        <programlisting><![CDATA[public class Null() {
        
    doc "Represents a null reference."
    case null;
    
}]]></programlisting>

        <para>The decorator <literal>NullCase</literal> allows <literal>null</literal>
        to appear as a <literal>case</literal> expression in a <literal>switch</literal>
        statement.</para>
        
        <programlisting><![CDATA[public extension 
class NullCase<X>(Null null) satisfies Case<Optional<X>> {

    override Boolean test(Optional<X> value) {
        return value is Nothing<X>;
    }
    
}]]></programlisting>
        
        <para>Note that <literal>Optional</literal> is not a reified type. The compiler
        erases all references to <literal>Optional&lt;X&gt;</literal> to 
        <literal>X</literal> after performing type validation and before generating
        bytecode. The compiler also replaces references to <literal>Null.null</literal>
        with the Java <literal>null</literal>. Therefore, none of the extensions defined 
        in this section are actually executed.</para>
        
    </section>
    
    <section id="exception">
        <title>Exceptions</title>
        
        <para>The class <literal>Exception</literal> is the base class for all
        exception types.</para>
        
        <programlisting><![CDATA[public class Exception(Exception? cause=null, String? message=null) 
        extends IdentifiableObject() {
    
    public String message = message ? cause?.message ? "";
    
    public Exception cause = cause ? this;
    
    public StackTrace stackTrace { return ... }
    
    override String string {
        if (nonempty message) {
            return type.name + ": " + message
        }
        else {
            return type.name
        }
    }
    
}]]></programlisting>

    </section>

    <section id="usable">
        <title>Usables</title>
        
        <para>The interface <literal>Usable</literal> represents an
        object with a lifecycle controlled by <literal>try</literal>.</para>
        
        <programlisting><![CDATA[public interface Usable {

    doc "Called before entry into a |try| block."
    public void begin();
    
    doc "Called before normal exit from a |try| block."
    public void end();

    doc "Called before exit from a |try| block when an
         exception occurs."
    public void end(Exception e);
    
}]]></programlisting>
       
        <!--
        <para>An <literal>Usable</literal> is used according to the
        following idiom:</para>
            
        <programlisting><![CDATA[Transaction t = Transaction();
t.begin();
try {
    doSomething(t);
    t.end();
}
catch (Exception e) {
    t.end(e);
}]]></programlisting>
        -->
    </section>
    
    <section id="iterableanditerator">
        <title>Iterable objects and iterators</title>
        
        <para>The interface <literal>Iterable</literal> represents an
        object which can produce a sequence of values, and which can
        be iterated using a <literal>for</literal> loop.</para>
        
        <programlisting><![CDATA[public interface Iterable<out X> {
    
    doc "A sequence of objects belonging
         to the container."
    public Iterator<X> iterator();
    
}]]></programlisting>
        
        <para>A Ceylon <literal>Iterator</literal> is a stateless object
        that produces a theoretically unbounded sequence of values.</para>
        
        <programlisting><![CDATA[public interface Iterator<out X> {
    public X? head;
    public Iterator<X> tail;
}]]></programlisting>
        
        <para>An <literal>Iterator</literal> is used according to the
        following idiom:</para>
            
        <programlisting><![CDATA[mutable local iter := iterable.iterator();
while (exists local value = iter.head) {
    ...
    iter.=tail;
}]]></programlisting>

        <comment><para>TODO: should we provide for mutation/removal during 
        iteration:</para>
        <programlisting><![CDATA[public mutable interface OpenIterable<X> 
        satisfies Iterable<X> {
    override OpenIterator<X> iterator();
}]]></programlisting>
        <programlisting><![CDATA[public mutable interface OpenIterator<X> 
        satisfies Iterator<X> {
    override mutable X? head;
    public void remove();
}]]></programlisting></comment>

        <comment><para>TODO: this alternate solution abstracts efficient 
        iteration of sequences and linked lists/trees, but suffers from
        the problem that the <literal>indexedValue()</literal> operation 
        accepts tokens from iterations of other objects, and is therefore 
        much less typesafe.</para>
        <programlisting><![CDATA[public interface Indexed<out X, I> 
        given I satisfies Ordinal {
    
    public I firstIndex;
    public Gettable<X>? indexedValue(I index);
    
}]]></programlisting>
        <para>For example, a <literal>Sequence&lt;X&gt;</literal> would 
        be an <literal>Indexed&lt;X, Natural&gt;</literal> and a 
        <literal>LinkedList&lt;X&gt;</literal> would be an 
        <literal>Indexed&lt;X, Link&lt;X&gt;&gt;</literal>. The idiom
        would be:</para>
        <programlisting><![CDATA[mutable local i := indexed.firstIndex;
while (exists local value = indexed.indexedValue(i)) {
    ...
    ++i;
}]]></programlisting>
        <para>Mutation/removal during iteration would also be possible.</para>
        <programlisting><![CDATA[public mutable interface OpenIndexed<X, I> 
        satisfies Indexed<X,I>
        given I satisfies Ordinal {
    override mutable Settable<X>? indexedValue(I index);
    public void removeIndex(I index);
}]]></programlisting>
</comment>

    </section>
    
    <section id="category">
        <title>Containers and categories</title>
        
        <para>The interface <literal>Container</literal> represents
        the abstract notion of an object that may be empty. Expressions
        of type <literal>Container?</literal> support the unary postfix 
        operator <literal>nonempty</literal>.</para>
        
        <programlisting><![CDATA[public interface Container {
        
    doc "The nonempty operator. Determine 
         if the container is empty."
    public Boolean empty;
    
}]]></programlisting>
    
        <para>The interface <literal>Category</literal> represents
        the abstract notion of an object that contains other objects.</para>
        
        <programlisting><![CDATA[public interface Category {
    
    doc "Determine if the given objects belong to the category.
         Return |true| iff all the given objects belong to the 
         category."
    public Boolean contains(Object... objects);

}]]></programlisting>
        
        <!--
        <programlisting><![CDATA[public interface Category {
    
    doc "Determine if the given element belongs to the category."
    public Boolean contains(Object element);

}]]></programlisting>

        <programlisting><![CDATA[public extension class Categories(Category category) {
        
    doc "Determine if all the given elements belong to the 
         category."
    public Boolean contains(Object... elements) {
        return forAll (Object elem in elements) every category.contains(elem)
    }
    
}]]></programlisting>
        -->
        
        <para>There is a mutable subtype, representing a category to which 
        objects may be added.</para>
        
        <programlisting><![CDATA[public mutable interface OpenCategory<in X> 
        satisfies Category 
        given X satisfies Object {
    
    doc "Add the given objects to the category. Return the number of 
         objects which did not already belong to the category."
    public Natural add(X... objects);

}]]></programlisting>

        <!--
        <programlisting><![CDATA[public mutable interface OpenCategory<in X> 
        satisfies Category {
    
    doc "Add the given element to the category. Return |true| if 
         the element did not already belong to the category."
    public Boolean add(X element);

}]]></programlisting>

        <programlisting><![CDATA[public extension class OpenCategories<in X>(OpenCategory<X> category) {
        
    doc "Add the given elements to the category. Return |true| if 
         at least one element did not already belong to the 
         category."
    public Boolean add(X... elements) {
        Boolean added = false;
        for (X x in elements) {
            added |= category.add(x);
        }
        return added
    }
    
}]]></programlisting>
        -->

    </section>
    
    <section id="entry">
        <title>Entries</title>
        
        <para>The <literal>Entry</literal> class represents a pair of 
        associated objects.</para>

        <para>Entries may be constructed using the <literal>-></literal> 
        operator.</para>

            <programlisting><![CDATA[public class Entry<out U, out V>(U key, V value) 
        extends Object() {
    
    doc "The key used to access the entry."
    public U key = key;
    
    doc "The value associated with the key."
    public V value = value;
    
    override Boolean equals(Object that) {
        return equals(that, Entry.key, Entry.value)
    }
    
    override Integer hash {
        return hash(Entry.key, Entry.value)
    }

}]]></programlisting>

    </section>
    
    <section id="correspondence">
        <title>Correspondences</title>
        
        <para>The interface <literal>Correspondence</literal> represents
        the abstract notion of an object that maps value of one type to values
        of some other type. It supports the binary operator
        <literal>[key]</literal> (lookup).</para>

        <programlisting><![CDATA[public interface Correspondence<in U, out V> 
        given U satisfies Object {
    
    doc "Binary lookup operator x[key]. Returns the value defined
         for the given key, or |null| if there is no value defined
         for the given key."
    public Gettable<V?> value(U key);
    
}]]></programlisting>

        <para>A decorator allows retrieval of lists and sets of values.</para>

        <programlisting><![CDATA[public extension class Correspondences<in U, out V>(Correspondence<U, V> correspondence)
        given U satisfies Object {

    doc "Binary sequenced lookup operator |x[keys]|. Return a list 
         of values defined for the given keys, in order."
    throws (UndefinedKeyException
            -> "if no value is defined for one of the given 
                keys")
    public V[] values(U... keys) {
        return from (U key in keys) select (correspondence[key])
    }
    
    doc "Binary iterated lookup operator |x[keys]|. Return an iterator
         of the values defined for the given keys."
    throws (UndefinedKeyException
            -> "if no value is defined for one of the given 
                keys")
    public Iterable<V> values(Iterable<U> keys) {
        return from (U key in keys) select (correspondence[key])
    }
    
    doc "Determine if there are values defined for the given keys.
         Return |true| iff there are values defined for all the
         given keys."
    public Boolean defines(U... keys) {
        return forAll (U key in keys) every (correspondence[key] exists)
    }
    
}]]></programlisting>

        <!--     
        <programlisting><![CDATA[public interface Correspondence<in U, out V> {
    
    doc "Binary lookup operator x[key]. Returns the value defined
         for the given key."
    public V value(U key);
    
    doc "Determine if there is a value defined for the given key."
    public Boolean defines(U key);
    
}]]></programlisting>

        <programlisting><![CDATA[public extension class Correspondences<in U, out V>(Correspondence<U, V> correspondence) {

    doc "Binary lookup operator x[keys]. Returns a list of values 
         defined for the given keys, in order."
    public List<V> values(List<U> keys) {
        return from (U key in keys) select correspondence.lookup(key)
    }
    
    doc "Binary lookup operator x[keys]. Returns a set of values 
         defined for the given set of keys."
    public Set<V> values(Set<U> keys) {
        return ( from (U key in keys) select correspondence.lookup(key) ).elements
    }
    
    doc "Determine if there are values defined for all the given 
    keys."
    public Boolean defines(U... keys) {
        for (U key in keys) {
            if ( !correspondence.defines(key) ) {
                return false
            }
        }
        fail {
            return true
        }
    }
    
}]]></programlisting>
        -->
        
        <para>There is a mutable subtype, representing a correspondence
        for which new mappings may be defined, and existing mappings 
        modified. It provides for the use of element expressions in
        assignments.</para>
        
        <!-- Association? -->

        <programlisting><![CDATA[public mutable interface OpenCorrespondence<in U, V> 
        satisfies Correspondence<U, V> 
        given U satisfies Object {
    
    override Settable<V?> value(U key);
    
}]]></programlisting>

        <para>A decorator allows addition of multiple <literal>Entry</literal>s.</para>

        <programlisting><![CDATA[public extension class OpenCorrespondences<in U, V>(OpenCorrespondence<U, V> correspondence) 
        given U satisfies Object {

    doc "Add the given entries, overriding any definitions that 
         already exist."
    throws (UndefinedKeyException
            -> "if a value can not be defined for one of the 
                given keys")
    public void define(Entry<U, V>... definitions) {
        for (U key->V value in definitions) {
            correspondence[key] := value;
        }
    }
    
    doc "Assign a value to the given key. Return the previous value 
         for the key, or |null| if there was no value defined."
    throws (UndefinedKeyException
            -> "if a value can not be defined for the given key")
    public V? define(U key, V value) {
        Settable<V?> definition = correspondence[key];
        V? result = definition;
        definition := value;
        return result;
    }

}]]></programlisting>
       
    </section>
    
    <section id="comparableandordinal">
        <title>Ordered values</title>
        
        <para>The <literal>Comparable</literal> interface 
        represents totally ordered types, and supports the binary operators 
        <literal>&gt;, &lt;, &lt;=, &gt;=</literal> and <literal>&lt;=&gt;</literal>
        (compare).</para>
        
        <programlisting><![CDATA[public interface Comparable<in T> 
        given T satisfies Object {
    
    doc "The binary compare operator |<=>|. Compares this 
         object with the given object."
    public Comparison compare(T other);
    
}]]></programlisting>
        
        <programlisting><![CDATA[public class Comparison() {
    
    doc "The receiving object is larger than 
         the given object."
    case larger, 
    
    doc "The receiving object is smaller than 
         the given object."
    case smaller, 
    
    doc "The receiving object is exactly equal 
         to the given object."
    case equal;
        
    public Boolean larger { return this=larger }
    public Boolean smaller { return this=smaller }
    public Boolean equal { return this=equal }
    public Boolean unequal { return this!=equal }
    public Boolean largeAs { return this!=smaller }
    public Boolean smallAs { return this!=larger }
    
}]]></programlisting>

        <comment><para>TODO: should we support partial orders? Give
        <literal>Comparison</literal> an extra <literal>uncomparable</literal>
        value, or let <literal>compare()</literal> return 
        <literal>null</literal>?</para></comment>
        
        <comment><para>TODO: if so, why not just move <literal>compare()</literal>
        up to <literal>Object</literal> to simplify things?</para></comment>
        
        <para>The toplevel methods <literal>min()</literal> and <literal>max()</literal>
        return the minimum and maximum values of a list of <literal>Comparable</literal>s.</para>
        
        <programlisting><![CDATA[public X min<X>(X x, X... xs) 
        given X satisfies Comparable<X> {
    mutable X min := x;
    for (X y in xs) { 
        if (y<min) { 
            min:=y;
        }
    }
    return min
}]]></programlisting>

        <programlisting><![CDATA[public X max<X>(X x, X... xs) 
        given X satisfies Comparable<X> {
    mutable X max := x;
    for (X y in xs) { 
        if (y>max) { 
            max:=y;
        }
    }
    return max
}]]></programlisting>

        <para>The <literal>Ordinal</literal> interface represents 
        objects in a sequence, and supports the binary operator 
        <literal>..</literal> (range). In addition, variables support 
        the postfix unary operators <literal>++</literal> (increment) 
        and <literal>--</literal> (decrement) and prefix unary 
        operators <literal>++</literal> (successor) and 
        <literal>--</literal> (predecessor).</para>
        
        <programlisting><![CDATA[public interface Ordinal {

    doc "The unary |++| operator. The successor of this instance."
    throws (OutOfRangeException
            -> "if this is the maximum value")
    public subtype successor;
    
    doc "The unary |--| operator. The predecessor of this instance."
    throws (OutOfRangeException
            -> "if this is the minimum value")
    public subtype predecessor;
    
}]]></programlisting>

    </section>
    
    <section id="bounded">
        <title>Bounded</title>
        
        <para>The <literal>Bounded</literal> class represents a value
        from an upper-bounded list of natural numbers.</para>
        
        <programlisting><![CDATA[public class Bounded<#max>(Bounded<#max> b)
       extends Object()
       satisfies Comparable<Bounded<#max>>, Number {
   
    doc "The |Natural| representing this natural
         number."
    public extension Natural natural { ... }

    override Comparison compare(Bounded<#max> other) {
        return natural.compare(other.natural)
    }

    doc "This natural number, as a |Bounded<#nmax>| where
         |nmax>=max|."
    public extension Bounded<#max+inc> bounded<#inc>() { ... }
   
}]]></programlisting>
        
        <para><literal>Bounded&lt;#n&gt;</literal> does not implement 
        <literal>Ordinal</literal>, so the type 
        <literal>Range&lt;Bounded&lt;#n&gt;&gt;</literal> does not exist.
        Instead, the following utility method is provided:</para> 
        
        <programlisting><![CDATA[doc "A sequence of |Bounded<#n+1>| from
     from |0| to |n|."
public Bounded<#n+1>[n+1] zeroTo<#n>() { ... }]]></programlisting>

    </section>
    
    <section id="sequence">
        <title>Sequences</title>
        
        <para>A <literal>Sequence</literal> is a correspondence from 
        a bounded progression of natural numbers. Sequences support the 
        binary operators <literal>[].</literal> (spread), <literal>+</literal> 
        (join) and <literal>[i...]</literal> (upper range) and the ternary 
        operator <literal>[i..j]</literal> (subrange) in addition to operators 
        inherited from <literal>Correspondence</literal>:</para>

        <programlisting><![CDATA[public interface Sequence<out X> 
        satisfies Correspondence<Natural, X> {

    doc "The index of the last element of the sequence,
         or |null| if the sequence has no elements."
    public Natural? lastIndex;
    
}]]></programlisting>

        <para>Any <literal>Sequence</literal> is <literal>Iterable</literal>
        and is a <literal>Container</literal>, according to the following 
        decorator:</para>
        
        <programlisting><![CDATA[public extension
SequenceIterable<X>(X[] sequence) 
        satisfies Iterable<X>, Container {
    override Iterator<X> iterator() {
        class SequenceIterator(Natural from) 
                satisfies Iterator<X> {
            override X? head { 
                return sequence[from] 
            }
            override Iterable<X> tail {
                return SequenceIterator(from+1)
            }
        }
        if (is Iterable<X> sequence) {
            return sequence.iterator()
        else {
            return SequenceIterator(0)
        }
    }
    override Boolean empty {
        return !(sequence.lastIndex exists)
    }
}]]></programlisting>
        
        <para>The following extension provides access to the indices 
        of the sequence in a <literal>for</literal> loop.</para>
        
        <programlisting><![CDATA[public extension
class SequenceEntryIterable<X>(X[] sequence)
        satisfies Iterable<Entry<Natural,X>> {
    override Iterator<Entry<Natural,X>> iterator() {
        class EntryIterator(Natural from) 
                satisfies Iterator<Entry<Natural,X>> {
            override Entry<Natural,X>? head {
                if (exists X x = sequence[from]) {
                    return from->x
                }
                else {
                    return null;
                }
            }
            override Iterable<Entry<Natural,X>> tail {
                return EntryIterator(from+1)
            }
        }
        return EntryIterator(0)
    }
}]]></programlisting>

        <comment><para>TODO: or should we just directly make <literal>X[]</literal> 
        assignable to <literal>Entry&lt;Natural,X&gt;[]</literal>?</para></comment>
        
        <para>The compiler is permitted to optimize away the call to these 
        extensions in a loop such as:</para>
        
        <programlisting><![CDATA[for (local elem in sequence) { 
    ...
}]]></programlisting>
        
        <para>or even:</para>
        
        <programlisting><![CDATA[for (Natural n -> local elem in sequence) {
    ...
}]]></programlisting>
        
        <para>which are both equivalent to:</para>
        
        <programlisting><![CDATA[if (exists Natural last=sequence.lastIndex) {
    mutable Natural n := 0;
    while (n<=last) { 
        local elem = sequence[n];
        ...
        ++n;
    }
}]]></programlisting>        
        
        <comment><para>TODO: for some kinds of sequences, especially linked
        lists, access by index is very inefficient. How can we make iteration
        of these kinds of sequences efficient?</para></comment>
        
        <para>Toplevel methods define the join and range operators, for 
        sequence types:</para>

        <programlisting><![CDATA[doc "The binary join operator |x + y|. The returned 
     sequence does not reflect changes to the original 
     sequences."
public T[] join<T>(T[]... sequences) {
            
    class JoinedSequence() 
            satisfies T[] {
        override Natural? lastIndex {
            mutable Natural? result := null;
            for (T[] s in sequences) {
                if (exists Natural last = s.lastIndex) {
                    if (exists result) {
                        result += last;
                    }
                    else {
                        result := last;
                    }
                }
            }
            return result
        }
        override Gettable<T?> value(Natural index) {
            T? value {
                mutable Natural i := index;
                for (T[] s in sequences) {
                    if (exists Natural last = s.lastIndex) {
                        if (i<=last) {
                            return s[i]
                        }
                        else {
                            i-=last;
                        }
                    }
                }
                return null
                
            }
            return value
        }
    }
    
    return copy(JoinedSequence()) //take a shallow copy
    
}]]></programlisting>
        
        <programlisting><![CDATA[doc "The ternary range operator |x[from..to]|, along
     with the binary upper range |x[from...]| operator. 
     The returned sequence does not reflect changes 
     to the original sequence."
public T[] range<T>(T[] sequence, Natural from, Natural? to=sequence.lastIndex) {
         
    class RangeSequence() 
            satisfies T[] {
        override Natural? lastIndex {
            if (exists Natural last = sequence.lastIndex) {
                if (exists to) {
                    if (to<last) {
                        return to-from
                    }
                    else {
                        return last-from
                    }
                }
            }
            else {
                return null
            }
        } 
        override Gettable<T?> value(Natural index) {
            T? value {
                if (exists to) {
                    if (index>to) {
                        return null
                    }
                }
                return sequence[index+from]
            }
            return value
        }
     }

    return copy(RangeSequence()) //take a shallow copy
    
}]]></programlisting>
        
        <para>A helper class decorates <literal>Sequence</literal> with 
        some convenience attributes:</para>

        <programlisting><![CDATA[public extension class Sequences<out X>(X[] sequence) {

    doc "The first element of the sequence, or
         |null| if the sequence has no elements."
    public X? first {
        return sequence[0]
    }
    
    doc "The rest of the sequence, after removing 
         the first element."
    public X[] rest {
        return sequence[1...]
    }

    doc "The last element of the sequence, or
         |null| if the sequence has no elements."
    public X? last {
        if (exists Natural index = sequence.lastIndex) {
            return sequence[index]
        }
        else {
            return null
        }
    }
   
}]]></programlisting>

        <para>There is a mutable subtype which allows assignment to
        an index.</para>
        
        <programlisting><![CDATA[public mutable interface OpenSequence<X>
        satisfies X[], OpenCorrespondence<Natural,X> {}]]></programlisting>

        <para>A <literal>BoundedSequence</literal> adds a typesafe bound
        to the indices, allowing use of indices of type <literal>Bounded&lt;#n&gt;</literal>.</para>
        
        <programlisting><![CDATA[public interface BoundedSequence<out X, #n>
        satisfies X[] {
    public Gettable<X> value(Bounded<#n> index);
    override Bounded<#n>? lastIndex;
}]]></programlisting>

        <para>The following extension provides access to the indices 
        of the bounded sequence in a <literal>for</literal> loop. The
        indices are of type <literal>Bounded&lt;#n&gt;</literal>.</para>
        
        <programlisting><![CDATA[public extension
class SequenceEntryIterable<X>(X[n] sequence)
        satisfies Iterable<Entry<Bounded<#n>,X>> {
    override Iterator<Entry<Bounded<#n>,X>> iterator() {
        class EntryIterator(Bounded<#n> from) 
                satisfies Iterator<Entry<Bounded<#n>,X>> {
            override Entry<Bounded<#n>,X>? head {
                return from->sequence[from]
            }
            override Iterable<Entry<Bounded<#n>,X>> tail {
                if (from+1<n) {
                    return EntryIterator(from.successor)
                }
                else {
                    return none
                }
            }
        }
        return EntryIterator(0)
    }
}]]></programlisting>

        <!--
        <para>A helper class adds a useful convenience attribute.</para>
        
        <programlisting><![CDATA[public extension class BoundSequences<out X,n>(X[n] sequence) {
   
    doc "A sequence of all indices of the the sequence."
    public Bounded<n>[n] indices {
        return ifTrue(n>0)
            then Bounded<n>(0)..Bounded<n>(n-1)
            otherwise {}
    }
   
}]]></programlisting>
        -->
        
        <para>There is a mutable subtype which allows assignment to
        an index.</para>
        
        <programlisting><![CDATA[public mutable interface OpenBoundedSequence<X,#n>
        satisfies X[n], OpenSequence<X> {
    public Settable<X> value(Bounded<#n> index);
}]]></programlisting>

        <para>The value <literal>None.none</literal> is transparently
        assignable to <literal>X[]</literal> and <literal>X[0]</literal>.</para>
        
        <programlisting><![CDATA[public class None() {
        
    doc "Represents an empty sequence. The value of 
         the empty sequence enumeration |{}|."
    case none;
    
    public extension 
    class EmptySequence<out X>() satisfies X[0] {
        override Natural? lastIndex = null;
        override Gettable<X?> value(Natural index) {
            X? nullValue = null;
            return nullValue 
        }
        override Gettable<X> value(Bounded<#0> index) {
            throw Exception()
        }
    }
    
}]]></programlisting>
        
        <para>The <literal>zip()</literal> function combines <literal>BoundedSequence</literal>s 
        into a single <literal>BoundedSequence</literal>.</para>

        <programlisting><![CDATA[public T[n] zip<T,X,Y,n>(X[n] x, Y[n] y, T producing(X x, Y y)) {
    return from (Bounded<#n> i in zeroTo<#n>()) 
                select (producing(x[i],y[i]))
}]]></programlisting>

        <programlisting><![CDATA[public Entry<X,Y>[n] zip<X,Y,n>(X[n] x, Y[n] y) {
    return zip(x,y,Entry)
}]]></programlisting>

        <programlisting><![CDATA[public T[n] zip<T,X,n>(X[n] lists..., T producing(X x...)) {
    return from (Bounded<#n> i in zeroTo<#n>()) 
                select (producing(from (X[n] list in lists) select (list[i]));
}]]></programlisting>

<!--
        <programlisting><![CDATA[public T[][n] zip<T,X,n>(X[n] lists...) {
    return zip(lists,ArrayList)
}]]></programlisting>
-->
    </section>
    
    <section id="range">
        <title>Ranges</title>
        
        <para>Ranges implement <literal>Sequence</literal>, therefore they 
        support the join, subrange, contains and lookup operators, among 
        others. Ranges may be constructed using the <literal>..</literal> 
        operator:</para> 
        
        <programlisting><![CDATA[public class Range<X>(X first, X last) 
        extends Object() 
        satisfies Category, X[], Case<X>, Iterable<X>
        given X satisfies Ordinal, Comparable<X> { 
    
    doc "The first value in the range."
    public X first = first;
    
    doc "The last value in the range."
    public X last = last;
    
    doc "Return a |Sequence| of values in the range, 
         beginning at the first value, and 
         incrementing by a constant step size,
         until a value outside the range is
         reached."
    public X[] by(Natural stepSize) { 
        return from (Natural index->X value in this) 
                    where (index%stepSize=0) 
    }
    
    public Natural? index(X x) {
        if (x<first || x>last) {
            return null
        }
        else {
            //optimize this for numbers!
            mutable Natural index:=0;
            mutable X value:=first;
            while (value<x) {
                ++index;
                ++value;
            }
            return index
        }
    }
    
    override Iterator<X> iterator() {
        class RangeIterator(X x) satisfies Iterator<X> {
            X? head { 
                if (x>last) { 
                    return null 
                } 
                else { 
                    return x 
                }
            }
            Iterator<X> tail {
                return RangeIterator(x.successor)
            }
        }
        return RangeIterator(first)
    }
    
    override Boolean empty = last<first;
    
    override Boolean contains(Object... objects) {
        for (x in objects) {
            if (is X x) {
                if ( x<first || x>last ) ) {
                    return false
                }
            }
            else {
                return false
            }
        }
        fail {
            return true
        } 
    }
    
    override Boolean test(X x) {
        return x>first && x<last
    }
    
    override Natural? lastIndex = index(last);
    
    override Gettable<X?> value(Natural n) {
        //optimize this for numbers!
        mutable Natural index:=0;
        mutable X? value:=first;
        while (index<n) {
            ++index;
            ++value;
            if (value>last) {
                value := null;
                break
            }
        }
        return value
    }
    
    override Boolean equals(Object that) {
        if (is Range<X> that) {
            return that.first=first && that.last=last
        }
        else {
            return false
        }
    }
    
    ...
    
}]]></programlisting>
        
        <para>The compiler is permitted to optimize away creation of a
        <literal>Range</literal> in code such as the following:</para>
        
        <programlisting><![CDATA[i in min..max]]></programlisting>
        
        <para>which is equivalent to:</para>
        
        <programlisting><![CDATA[(i>=min && i<=max)]]></programlisting>
        
        <para>and:</para>
        
        <programlisting><![CDATA[for (local i in min..max) {
    ...
}]]></programlisting>
    
        <para>which is equivalent to:</para>
        
        <programlisting><![CDATA[mutable local i := min;
while (i<=max) {
    ...
    i.=successor;
}]]></programlisting>
        
    </section>
    
    <section id="characterandstring">
        <title>Characters and strings</title>
        
        <para>UTF-32 Unicode Characters are represented by the following class:</para>

        <programlisting><![CDATA[public class Character(small Natural utf32)
        extends Object()
        satisfies Ordinal, Comparable<Character>, Case<Character> { 
    ... 
    
    doc "The UTF-16 encoding"
    public String utf16;
    
    doc "The UTF-8 encoding"
    public String utf8;
    
    public Character lowercase { return .. }
    public Character uppercase { return .. }
    
    public extension class StringToCharacter(String string) {
    
        doc "Parse the string representation of a |Character| in UTF-16"
        public Character parseUtf16Character() { return ... }
    
        doc "Parse the string representation of a |Character| in UTF-8"
        public Character parseUtf8Character() { return ... }
    
    }
 
}]]></programlisting>
        
        <para><literal>String</literal> implements <literal>Sequence</literal>, 
        and therefore supports the join, subrange, contains and lookup operators, 
        among others. Any <literal>Character[]</literal> may be transparently
        converted to <literal>String</literal>.</para> 
                
        <programlisting><![CDATA[public extension 
class String(Character[] characters) 
        extends Object() 
        satisfies Character[], Comparable<String>, Case<String> {
    
    Character[] chars;
    if (is String characters) {
        chars = characters;
    }
    else {
        chars = copy(characters)
    }
    
    ... 
    
    doc "Split the string into tokens, using the given
         separator characters."
    public Iterable<String> tokens(Iterable<Character> separators=" ,;\n\l\r\t") { return ... }
    
    doc "Split the string into lines of text."
    public Iterable<String> lines() { return tokens("\n\l\r") }
    
    public String replace(Character with(Character character)) { return ... }
    
    public String replace(Character character -> Character replacement) {
        return replace() with (Character c) 
            (ifTrue (c=character) then (replacement) otherwise (c))
    }
    
    public String replace(Correspondence<Character,Character> replacements) { 
        return replace() with (Character c) (replacements[c] ? c)
    }
    
    doc "The string, with all characters in lowercase."
    public String lowercase {
        return replace() with (Character c) (c.lowercase)
    }
    
    doc "The string, with all characters in uppercase."
    public String uppercase {
        return replace() with (Character c) (c.uppercase)
    }
    
    doc "Remove the given characters from the beginning 
         and end of the string.
    public String strip(Character[] whitespace = " \n\l\r\t") { return ... }
    
    doc "Collapse substrings of the given characters into
         single space characters."
    public String normalize(Character[] whitespace = " \n\l\r\t") { return ... }
    
    doc "Join the given strings, using this string as
         a separator."
    public String join(String... strings) { return ... }
    
}]]></programlisting>
        
        <comment><para>TODO: What encoding is the default for Ceylon strings? Are there 
        performance advantages to going with UTF-16 like Java? Can we easily abstract
        this stuff? Does the JVM do all kinds of optimizations for 
        <literal>java.String</literal>?</para></comment>
        
        <para>The extension class <literal>StringBuilder</literal> makes it more 
        efficient to produce a string using procedural code:</para>
        
        <programlisting><![CDATA[public extension class StringBuilder(Character[] string) {
        
    Character[] string = string;
    
    Character[] with(Character[] appendedStrings...) {
        mutable OpenList<Character> list = ArrayList<Character>(string);
        list.append(string);
        for (Character[] s in appendedStrings) {
            list.append(s);
        }
    }
    
    Character[] forEach<X>(iterated Iterable<X> objects, 
                           Character[] with(coordinated X x)) {
        mutable OpenList<Character> list = ArrayList<Character>(string);
        for (X x in objects) {
            list.append(with(x));
        }
        return list 
    }
    
    Character[] forEach<X>(iterated Iterable<X> objects, 
                           Character[][] with(coordinated X x)) {
        mutable OpenList<Character> list = ArrayList<Character>(string);
        for (X x in objects) {
            for (Character[] s in with(x)) {
                list.append(s);
            }
        }
        return list 
    }
       
}]]></programlisting>

        <comment><para>TODO: Is this OK, or is it going to need to be a <emphasis>mutable</emphasis> 
        class?</para></comment>
        
        <!--
        <para>A string template is represented by an instance of <literal>StringTemplate</literal>.</para>
        
        <programlisting>public class StringTemplate(...) {
        
    doc "Evaluate all interpolated expressions, producing 
         a constant character string with no interpolated
         expressions."
    public extension String interpolate() { return ... }

}</programlisting>
        -->
        
    </section>
    
    <section id="regex">
        <title>Regular expressions</title>
        
        <programlisting><![CDATA[public extension class Regex(Quoted expression)
        satisfies Case<String> { 
        
    doc "Return the substrings of the given string which
         match the parenthesized groups of the regex,
         ordered by the position of the opening parenthesis
         of the group." 
    public Match? matchList(String string)() { return ... }
    
    doc "Determine if the given string matches the regex."
    public Boolean matches(String string) { return ... }
    
    ... 
    
}]]></programlisting>
        
        <comment><para>TODO: I assume these are just Java (Perl 5-style) regular 
        expressions. Is there some other better syntax around? Something BNF-like,
        perhaps?</para></comment>

    </section>
    
    <section id="number">
        <title>Numbers</title>
        
        <para>The <literal>Number</literal> interface is the abstract supertype
        of all classes which represent numeric values.</para>
        
        <programlisting><![CDATA[public interface Number {
    
    doc "Determine if the number represents
         an integer value"
    public Boolean integral;
    
    doc "Determine if the number is positive"
    public Boolean positive;
    
    doc "Determine if the number is negative"    
    public Boolean negative;

    doc "Determine if the number is zero"
    public Boolean zero;
    
    doc "Determine if the number is one"
    public Boolean unit;
    
    doc "The number, represented as a |Decimal|"
    public Decimal decimal;

    doc "The number, represented as a |Float|"
    throws (FloatOverflowException
            -> "if the number is too large to be
                represented as a |Float|")
    public Float float;
    
    doc "The number, represented as an |Whole|,
         after truncation of any fractional 
         part"
    public Whole whole;
    
    doc "The number, represented as an |Integer|,
         after truncation of any fractional 
         part"
    throws (IntegerOverflowException
            -> "if the number is too large to be
                represented as an |Integer|")
    public Integer integer;
    
    doc "The number, represented as a |Natural|,
         after truncation of any fractional 
         part"
    throws (NegativeNumberException
            -> "if the number is negative")
    public Natural natural;
    
    doc "The magnitude of the number"
    public subtype magnitude;
    
    doc "1 if the number is positive, -1 if it
         is negative, or 0 if it is zero."
    public subtype sign;
    
    doc "The fractional part of the number,
         after truncation of the integral
         part"
    public subtype fractionalPart;
    
    doc "The integral value of the number 
         after truncation of the fractional
         part"
    public subtype wholePart;

}]]></programlisting>

        <para>The subtype <literal>Numeric</literal> supports the binary 
        operators <literal>+,-, *, /, **</literal>. In addition, 
        <literal>mutable</literal> values of type <literal>Numeric</literal> 
        support the compound assignment operators 
        <literal>+=, -=, /=, *=</literal>.</para>

<programlisting><![CDATA[public interface Numeric<N>
        satisfies Number, Comparable<N>
        given N satisfies Number {

    doc "The binary |+| operator"
    public N plus(N number);

    doc "The binary |-| operator"
    public N minus(N number);

    doc "The binary |*| operator"
    public N times(N number);

    doc "The binary |/| operator"
    public N divided(N number);

    doc "The binary |**| operator"
    public N power(N number);
    
}]]></programlisting>

        <comment><para>TODO: I suppose <literal>Numeric</literal> should not extend
        <literal>Comparable</literal>, since complex numbers are not comparable.</para></comment>

        <para>The subtype <literal>Integral</literal> supports the binary 
        operator <literal>%</literal>, and inherits the unary operators 
        <literal>++</literal> and <literal>--</literal> from 
        <literal>Ordinal</literal>.</para>

<programlisting><![CDATA[public interface Integral<N>
        satisfies Numeric<N>, Ordinal
        given N satisfies Number {

    doc "The binary |%| operator"
    public N remainder(N number);

}]]></programlisting>

        <para>The type <literal>Invertable</literal> supports the unary
        prefix <literal>-</literal> operator.</para>
        
        <programlisting><![CDATA[public interface Invertable<I> 
    given I satisfies Number {
    
    doc "The unary |-| operator"
    public I inverse;

}]]></programlisting>
        
        <para>Five numeric types are built in:</para>

        <para><literal>Natural</literal> represents 63 bit unsigned integers
        (including zero).</para>
        
        <programlisting><![CDATA[public class Natural(Natural natural)
        extends Object() 
        satisfies Integral<Natural>, Invertable<Integer>, Case<Integer> { 
    ... 
    
    doc "Implicit type promotion to |Integer|"
    override extension Integer integer { return ... }
    
    doc "Implicit type promotion to |Whole|"
    override extension Whole whole { return ... }
    
    doc "Implicit type promotion to |Float|"
    override extension Float float { return ... }
    
    doc "Implicit type promotion to |Decimal|"
    override extension Decimal decimal { return ... }

    doc "Shift bits left by the given number of places"
    public Natural leftShift(Natural digits) { return ... }
    
    doc "Shift bits right by the given number of places"
    public Natural rightShift(Natural digits) { return ... }
    
    public extension class StringToNatural(String string) {
    
        doc "Parse the string representation of a |Natural| in the given radix"
        public Natural parseNatural(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <comment><para>TODO: the <literal>Numeric</literal> type is much more complicated
        because of <literal>Natural</literal>. As an alternative approach, we could replace
        <literal>Natural</literal> with a <literal>Binary</literal> type, and have 
        <literal>Integer</literal> literals instead of <literal>Natural</literal> 
        literals. I don't love this, because natural numbers are especially common in real
        applications.</para></comment>

        <para><literal>Integer</literal> represents 64 bit signed integers.</para>

        <programlisting><![CDATA[public class Integer(Boolean sign, Natural natural)
        extends Object() 
        satisfies Integral<Integer>, Invertable<Integer>, Case<Integer> {
    ...
    
    doc "Implicit type promotion to |Whole|"
    override extension Whole whole { return ... }
    
    doc "Implicit type promotion to |Float|"
    override extension Float float { return ... }

    doc "Implicit type promotion to |Decimal|"
    override extension Decimal decimal { return ... }

    public extension class StringToInteger(String string) {
    
        doc "Parse the string representation of an |Integer| in the given radix"
        public Integer parseInteger(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <para><literal>Whole</literal> represents arbitrary-precision
        signed integers.</para>

        <programlisting><![CDATA[public class Whole(Boolean sign, small Natural... digits)
        extends Object() 
        satisfies Integral<Whole>, Invertable<Whole> {
    ...
    
    public small Natural precision = ...;
    
    doc "Implicit type promotion to |Decimal|"
    override extension Decimal decimal { return ... }
    
    public extension class StringToWhole(String string) {
    
        doc "Parse the string representation of a |Whole| in the given radix"
        public Whole parseWhole(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>
        
        <para><literal>Float</literal> represents 64 bit floating point
        values.</para>

        <programlisting><![CDATA[public class Float(Float float)
        extends Object() 
        satisfies Numeric<Float>, Invertable<Float> { 
    ... 
    
    doc "The natural logarithm of the number"
    public Float ln { return ... }
    
    doc "Implicit type promotion to |Decimal|"
    override extension Decimal decimal { return ... }
    
    public extension class StringToFloat(String string) {
    
        doc "Parse the string representation of a |Float| in the given radix"
        public Float parseFloat(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <para><literal>Decimal</literal> represents arbitrary-precision
        and arbitrary-scale decimals.</para>

        <programlisting><![CDATA[public class Decimal(Whole value, small Integer scale)
        extends Object() 
        satisfies Numeric<Decimal>, Invertable<Decimal> {
    ...

    public small Natural precision = ...;
    public small Integer scale = ...;
    
    public extension class StringToDecimal(String string) {
    
        doc "Parse the string representation of a |Decimal| in the given radix"
        public Decimal parseDecimal(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

    </section>
    
    <section id="bits">
        <title>Bit strings</title>
        
        <para>The interface <literal>Bits</literal> represents a fixed length
        string of boolean values, and supports the binary 
        <literal>|, &amp;, ^</literal> and unary <literal>~</literal> 
        operators.</para>
        
        <programlisting><![CDATA[public interface Bits<#n> 
        satisfies Boolean[n] {
        
    doc "Bitwise or operator |x | y|"
    public Bits<#n> or(Bits<#n> bits);
    
    doc "Bitwise and operator |x & y|"
    public Bits<#n> and(Bits<#n> bits);
    
    doc "Bitwise xor operator |x ^ y|"
    public Bits<#n> xor(Bits<#n> bits);
    
    doc "Bitwise complement operator |~x|"
    public Bits<#n> complement;
    
}]]></programlisting>

        <comment><para>TODO: should we model <literal>Bits&lt;#n&gt;</literal> as 
        a decorator of <literal>Boolean[n]</literal>, like what we do with 
        <literal>String</literal> and <literal>Character[]</literal>?</para></comment>

        <para>Boolean values are transparently converted to and from <literal>Bits&lt;1&gt;</literal>.</para>

        <programlisting><![CDATA[public extension class BooleanBit(Boolean boolean)
        satisfies Bits<1> {

    public extension Boolean boolean = boolean;

    override Bits<1> or(Bits<1> bit) {
        if (boolean) {
            return this
        else {
            return bit
        }
    }
    
    override Bits<1> and(Bits<1> bit) {
        if (boolean) {
            return bit
        else {
            return false
        }
    }
    
    override Bits<1> xor(Bits<1> bit) {
        if (boolean) {
            return bit.complement
        else {
            return bit
        }
    }
    
    override Bits<1> complement {
        return BooleanBit(!boolean)
    }
    
    override Gettable<Boolean> value(Bounded<1> index) {
        return boolean
    }
    
    override Gettable<Boolean?> value(Natural key) {
        Boolean? result;
        if (key=0) {
            result = boolean 
        }
        else {
            result = null
        }
        return result
    }
    
    override Bounded<1> lastIndex {
        return 0
    }
    
}]]></programlisting>

        <!--
        <programlisting><![CDATA[public extension Bits<1> booleanToBits(Boolean b) { .... }]]></programlisting>
        <programlisting><![CDATA[public extension Boolean bitsToBoolean(Bits<1> b) { return b[0] }]]></programlisting>
        -->

        <comment><para>TODO: we need a bunch of functions for converting bit 
        strings to and from numeric values, characters, etc.</para></comment>
        
    </section>
    
    <section id="metamodel">
        <title>Metamodel</title>
        
        <para>The metamodel (reflection API) reifies the schema of a type, making it
        available to the program at runtime.</para>
        
        <para>A <literal>Function</literal> represents a toplevel method.</para>

        <programlisting><![CDATA[public interface Function<R, P...> 
        satisfies Callable<R, P...>, Annotated {
        
    public String name;
    
    public Boolean extension;
    
    public Visiblity visibility;
    
    public Type<R> returnType;
    public Parameter<Object>[] parameters;
    
}]]></programlisting>

        <para>An instance of <literal>Type</literal> represent a type: an interface, class 
        or alias, together with type arguments.</para>
        
        <programlisting><![CDATA[public interface Type<out X> 
        satisfies Annotated {
        
    public String name;
    
    public Boolean mutable;
    
    public Visiblity visibility;
    
    doc "Return all the attributes of the given 
         type."
    public Set<Attribute<X,T>> attributes<T>(Type<T> type = Object);
    
    doc "Return all the methods of the given 
         callable type."
    public Set<Method<X,R,P...>> methods<R,P...>(Type<Callable<R,P...>> type);
    
    doc "Return all the member classes of the 
         given callable type."
    public Set<MemberClass<X,Y,P...>> classes<Y,P...>(Type<Callable<Y,P...>> type);
    
    public Log log;
    
    ...
    
}]]></programlisting>
        
        <para>An instance of <literal>Interface</literal> represents an interface.</para>
        
        <programlisting><![CDATA[public interface Interface<out X> 
        satisfies Type<X> {}]]></programlisting>

        <para>An instance of <literal>Class</literal> represents a class.</para>
        
        <programlisting><![CDATA[public interface Class<out X, P...> 
        satisfies Type<X>, Callable<X,P...> {
    
    public Boolean abstract;
    public Boolean extension;
    
    public Parameter<Object>[] parameters;
    
}]]></programlisting>

        <para>An instance of <literal>Member</literal> represents a method or attribute.</para>

        <programlisting><![CDATA[public interface Member<in X, out T> 
        satisfies Annotated, Callable<T,X> {
    
    public String name;
    
    public Boolean abstract;
    public Boolean default;
    public Boolean default;
    public Boolean override;
    public Boolean extension;
    
    public Visiblity visibility;
    
    public Type<T> memberType;
    
}]]></programlisting>

        <para>A <literal>Method</literal> represents a method declaration.</para>

        <programlisting><![CDATA[public interface Method<in X, R, P...> 
        satisfies Member<X, Function<R, P...>> {
        
    public Type<R> returnType;
    public Parameter<Object>[] parameters;
    
    public void intercept<S>( R onInvoke(S instance, R proceed(P... args), P... args) )()
                    given S abstracts X;
    
}]]></programlisting>

        <para>An <literal>Attribute</literal> represents an attribute declaration.</para>

        <programlisting><![CDATA[public interface Attribute<in X, T> 
        satisfies Member<X, Gettable<T>> {
        
    public Boolean mutable;
    
    public void intercept<S>( T onGet(S instance, T proceed()) )()
                    given S abstracts X;
    
}]]></programlisting>

        <programlisting><![CDATA[public interface MutableAttribute<in X, T> 
        extends Attribute<X, T>
        satisfies Member<X, Settable<T>> {  //this is OK since Member is covariant in T
        
    public void intercept<S>( void onSet(S instance, void proceed(T value), T value) )()
                    given S abstracts X;
    
}]]></programlisting>

        <para>An instance of <literal>MemberClass</literal> represents a member 
        class.</para>
        
        <programlisting><![CDATA[public interface MemberClass<X, Y, P...> 
        satisfies Type<Y>, Member<X, Class<Y,P...>> {
    
    public Parameter<Object>[] parameters;
    
    public void intercept<S>( Y onCreate(S instance, Y proceed(P... args), P... args) )()
                    given S abstracts X;
    
}]]></programlisting>

        <para>A <literal>Parameter</literal> represents a formal parameter of a method 
        or class.</para>

        <programlisting><![CDATA[public interface Parameter<out T> 
        satisfies Annotated {
    public String name;
    public Type<T> type;
}]]></programlisting>

        <para>An <literal>Annotated</literal> program element may be asked for a
        list of its annotation values.</para>

        <programlisting><![CDATA[public interface Annotated {
    doc "Return all the annotation values that are 
         assignable to the given type."
    public T[] annotations<T>(Type<T> type = Object) 
            given T satisfies Object;
}]]></programlisting>

    </section>
    
    <section id="logging">
        <title>Logging</title>
        
        <para>The class <literal>lang.Log</literal> allows all modules in an application
        to send log messages to a common output stream.</para>
        
        <programlisting><![CDATA[public class Log(LogChannel channel, String category) {
    
    public void log(LogPriority priority, Gettable<String> message) {
        if ( channel.enabled(priority) ) {
            send(priority, message) );
        }
    }
    
    public void log(LogPriority priority, String message) {
        if ( channel.enabled(priority) ) {
            send(priority, message) );
        }
    }
    
    void send(LogPriority priority, String message) {
        channel.send( priority, LogMessage(priority, category, message) );
    }
    
}]]></programlisting>

        <para>The class <literal>LogPriority</literal> defines an extensible set of
        levels of importance for log messages.</para>

        <programlisting><![CDATA[public class LogPriority() {
    case debug, case info, case warn, case error ...
}]]></programlisting>

        <para>The class <literal>LogMessage</literal> describes a log message:</para>
        
        <programlisting><![CDATA[public class LogMessage(LogPriority priority, String category, String message) {
    public Priority priority = priority;
    public String category = category;
    public String message = message;
    public Datetime datetime = currentDatetime();
}]]></programlisting>

        <para>The following extensions make it easy to log from any object:</para>
        
        <programlisting><![CDATA[public extension class ObjectLog(Object object) {
    public Log log =  object.type.log;
}]]></programlisting>

        <programlisting><![CDATA[public extension class Logs(Log log) {
    public void debug(Gettable<String> message) { log.log(debug, message); }
    public void debug(String message) { log.log(debug, message); }
    public void info(Gettable<String> message) { log.info(debug, message); }
    public void info(String message) { log.info(debug, message); }
    public void warn(Gettable<String> message) { log.warn(debug, message); }
    public void warn(String message) { log.warn(debug, message); }
    public void error(Gettable<String> message) { log.error(debug, message); }
    public void error(String message) { log.error(debug, message); }
}]]></programlisting>

        <comment><para>TODO: I would really like to turn <literal>Type.log</literal> 
        into an extension. But where would it get its <literal>LogChannel</literal>
        from? There is no shared state in Ceylon! We need a toplevel attribute 
        somewhere.</para></comment>
    
    </section>
    
    <!--
    
    <section id="datetime">
        <title>Instants, intervals and durations</title>
        
        <comment><para>TODO: this stuff is just for illustration, the real
        date/time API will be much more complex and fully internationalized.</para></comment>
        
        <programlisting><![CDATA[public class Instant() {
    ...
}]]></programlisting>

        <programlisting><![CDATA[public class Time(Natural hours, Natural minutes, 
        Natural? seconds=null, Natural? milliseconds=null,
        Timezone? timezone=null) 
        extends Instant() {
    public Natural hours = hours;
    public Natural minutes = minutes;
    public Natural? seconds = seconds;
    public Natural? milliseconds = milliseconds;
    public Timezone? timezone = timezone;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[public class Date(Integer year, Natural month, Natural day) 
        extends Instant() {
    public Integer year = year;
    public Natural month = month;
    public Natural day = day;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[public class Datetime(Time time, Date date) 
        extends Instant() {
    public Time time = time;
    public Date date = date;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[public class Interval<X>(X start, X end) 
        given X satisfies Instant {
    public X start = start;
    public X end = end;
    public Duration<X> duration { return ... }
    ...
}]]></programlisting>

        <programlisting><![CDATA[public class Duration<X>(Map<Granularity<X>, Natural> magnitude) 
        given X satisfies Instant {

    public Map<Granularity<X>, Natural> magnitude = magnitude;
    
    public X before(X instant) { ... }
    public X after(X instant) { ... }
    
    public Datetime before(Datetime instant) { ... }
    public Datetime after(Datetime instant) { ... }
    
    public Duration<X> add(Duration<X> duration) { ... }
    public Duration<X> subtract(Duration<X> duration) { ... }
    
    ...
}]]></programlisting>

        <programlisting><![CDATA[public interface Granularity<X> 
        given X satisfies Instant {}]]></programlisting>

        <programlisting><![CDATA[public class DateGranularity()
        satisfies Granularity<Date> {
    case year, 
    case month, 
    case week, 
    case day;
}]]></programlisting>

        <programlisting><![CDATA[public class TimeGranularity()
        satisfies Granularity<Time> {
    case hour, 
    case minute, 
    case second, 
    case millisecond;
}]]></programlisting>
        
    </section>
    
    -->
    
    <section id="control">
        <title>Control expressions</title>
        
        <para>The <literal>ceylon.lang.assertion</literal> package defines 
        support for assertions.</para>
        
        <programlisting><![CDATA[doc "Assert that the block evaluates to true. The block 
     is executed only when assertions are enabled. If
     the block evaluates to false, throw an 
     |AssertionException| with the given message."
public void assert(Gettable<String> message, Boolean that()) {
    if ( assertionsEnabled() && !that() ) {
        throw AssertionException(message)
    }
}]]></programlisting>
    
        <para>The <literal>ceylon.lang.conditional</literal> package defines 
        support for conditional expressions.</para>
        
        <programlisting><![CDATA[doc "If the condition is true, evaluate first block,
     and return the result. Otherwise, return |null|."
public Y? ifTrue<Y>(Boolean condition,
                    Y then()) {
    if (condition) {
        return then()
    }
    else {
        return null
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the condition is true, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
public Y ifTrue<Y>(Boolean condition,
                   Y then(), 
                   Y otherwise()) {
    if (condition) {
        return then()
    }
    else {
        return otherwise()
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the value is non-null, evaluate first block,
     and return the result. Otherwise, return |null|."
public Y? ifExists<X,Y>(specified X? value,
                        Y then(coordinated X x)) {
    if (exists value) {
        return then(value)
    }
    else {
        return null
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the value is non-null, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
public Y ifExists<X,Y>(specified X? value,
                       Y then(coordinated X x), 
                       Y otherwise()) {
    if (exists value) {
        return then(value)
    }
    else {
        return otherwise()
    }
}]]></programlisting>

        <para>The <literal>ceylon.lang.exceptional</literal> package defines 
        support for exceptional expressions.</para>
        
        <programlisting><![CDATA[doc "Attempt to evaluate the first block. If an 
     exception occurs that matches the second block, 
     evaluate the block."
public Y seek<Y,E>(Y seek(),
                   Y except(E e)) {
    try {
        return seek()
    }
    catch (E e) {
        return except(e)
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "Using the given resource, attempt to evaluate 
     the first block."
public Y using<X,Y>(specified X resource,
                    Y seek(coordinated X x))
        given X satisfies Usable {
    try (resource) {
        return seek(resource)
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "Using the given resource, attempt to evaluate 
     the first block. If an exception occurs that 
     matches the second block, evaluate the second 
     block."
public Y using<X,Y,E>(specified X resource,
                      Y seek(coordinated X x),
                      Y except(E e))
        given X satisfies Usable {
    try (resource) {
        return seek(resource)
    }
    catch (E e) {
        return except(e)
    }
}]]></programlisting>
    
<!--

        <programlisting><![CDATA[doc "Evaluate the block which matches the selector value, and
     return the result of the evaluation. If no block matches
     the selector value, return a null value."
public Y? select<X,Y>(X selector,
                              cases Iterable<Entry<Case<X>, functor Y()>> value) {
    for (Case<X> match -> X evaluate() in value) {
        if ( match.test(selector) ) {
            return evaluate(value)
        }
    }
    return null;
}]]></programlisting>

        <programlisting><![CDATA[doc "Evaluate the block which matches the selector value, and
     return the result of the evaluation. If no block matches
     the selector value, evaluate the last block and return
     the result of the evaluation."
public Y select<X,Y>(X selector,
                     cases Iterable<Entry<Case<X>, functor Y()>> value,
                     Y otherwise()) {
    if (exists Y y = select(selector, value)) {
        return y
    }
    else {
        return otherwise()
    }
}]]></programlisting>

-->

        <para>The <literal>ceylon.lang.repetition</literal> package defines 
        support for loops.</para>
        
        <programlisting><![CDATA[doc "Repeat the block the given number of times."
public void repeat(Natural repetitions, void times()) {
    do(mutable Natural n:=0) 
    while (n<repetitions) {
        times();
        n++;
    }
}]]></programlisting>
    
        <para>The <literal>ceylon.lang.quantification</literal> package defines 
        support for quantifiers.</para>
        
        <programlisting><![CDATA[doc "Count the elements for which the block 
     evaluates to true."
public Natural count<X>(iterated Iterable<X> elements,
                        Boolean where(coordinated X x)) {
    mutable Natural count := 0;
    for (X x in elements) {
        if ( where(x) ) {
            ++count;
        }
    }
    return count
}]]></programlisting>

        <programlisting><![CDATA[doc "Return true iff for every element, the block 
     evaluates to true."
public Boolean forAll<X>(iterated Iterable<X> elements,
                         Boolean every(coordinated X x)) {
    for (X x in elements) {
        if ( !every(x) ) {
            return false
        }
    }
    return true
}]]></programlisting>

        <programlisting><![CDATA[doc "Return true iff for some element, the block 
     evaluates to true."
public Boolean forAny<X>(iterated Iterable<X> elements,
                         Boolean some(coordinated X x)) {
    Boolean where(X x) { return !some(x) }
    return !forAll(elements, where)
}]]></programlisting>

        <programlisting><![CDATA[doc "Return the first element for which the block 
     evaluates to true, or |null|if no such element 
     is found."
public X? first<X>(iterated Iterable<X> elements,
                   Boolean where(coordinated X x)) {
    for (X x in elements) {
        if ( where(x) ) {
            return x
        }
    }
    return null
}]]></programlisting>

        <programlisting><![CDATA[doc "Return the first element for which the first 
     block evaluates to true, or the result of 
     evaluating the second block, if no such 
     element is found."
public X first<X>(iterated Iterable<X> elements,
                  Boolean where(coordinated X x),
                  X otherwise()) {
    if (exists X first = first(elements, where)) {
        return first
    }
    else {
        return otherwise()
    }
}]]></programlisting>
        
        <para>The <literal>ceylon.lang.comprehension.list</literal> package defines 
        support for <literal>List</literal> comprehensions.</para>
        
        <programlisting><![CDATA[doc "Iterate elements and return those for which 
     the first block evaluates to true, ordered 
     using the second block, if specified."
public List<X> from<X>(iterated Iterable<X> elements,
                       Boolean where(coordinated X x),
                       Comparable by(coordinated X x) = naturalOrder) {
    X select(X x) { return x }
    return from(elements, where, select, by)
}]]></programlisting>

        <programlisting><![CDATA[doc "Iterate elements and for each element evaluate 
     the first block. Build a list of the resulting 
     values, ordered using the second block, if 
     specified."
public List<Y> from<X,Y>(iterated Iterable<X> elements,
                         Y select(coordinated X x),
                         Comparable by(coordinated X x) = naturalOrder)  {
    Boolean where(X x) { return true }
    return from(elements, where, select, by)
}]]></programlisting>

        <programlisting><![CDATA[doc "Iterate elements and select those for which 
     the first block evaluates to true. For each of 
     these, evaluate the second block. Build a list 
     of the resulting values, ordered using the 
     third block, if specified."
public List<Y> from<X,Y>(iterated Iterable<X> elements,
                         Boolean where(coordinated X x), 
                         Y select(coordinated X x),
                         Comparable by(coordinated X x) = naturalOrder) {
    OpenList<Y> list = ArrayList<Y>();
    for (X x in elements) {
        if ( where(x) ) {
            list.append( select(x) );
        }
    }
    if (exists by) {
        list.sort(by);
    }
    return list
}]]></programlisting>
        
        <para>The <literal>ceylon.lang.comprehension.map</literal> package defines 
        support for <literal>Map</literal> comprehensions.</para>
        
        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given key. Each |Entry| is constructed 
     from the key and the value result of the 
     evaluation."
public Map<U,V> mapFrom<U,V>(iterated Iterable<U> keys,
                             V to(coordinated U key)) {
    Entry<U,V> of(U key) { return key->to(key) }
    return map(keys, of)
}]]></programlisting>

        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given value. Each |Entry| is constructed 
     from the value and the key result of the 
     evaluation."
public Map<U,V> mapTo<U,V>(iterated Iterable<V> values,
                           U from(coordinated V value)) { 
    Entry<U,V> of(V value) { return from(value)->value }
    return map(values, of)
}]]></programlisting>

        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given object and collecting the resulting 
     |Entry|s."
public Map<U,V> map<X,U,V>(iterated Iterable<X> elements,
                           Entry<U,V> of(coordinated X element)) {
    OpenMap<U,V> map = HashMap<U,V>();
    for (X x in elements) {
        map.add( of(x) );
    }
}]]></programlisting>
    
    </section>
    
    </section>
    
    <section id="collectonsmodule">
        <title>The collections module</title>
        
        <para>The module <literal>ceylon.collection</literal> contains the collections
        framework.</para>
    
    <section id="collections">
        <title>Collections</title>
        
        <para>The interface <literal>Collection</literal> is the 
        root of the Ceylon collections framework.</para>
        
        <programlisting><![CDATA[public interface Collection<out X> 
        satisfies Iterable<X>, Container, Category 
        given X satisfies Object {
    
    doc "The number of elements or entries belonging to the 
         collection."
    public Natural size;
    
    doc "Determine the number of times the given element
         appears in the collection."
    public Natural count(Object element);
    
    doc "Determine the number of elements or entries for
         which the given condition evaluates to |true|."
    public Natural count(Boolean where(X element));
    
    doc "Determine if the given condition evaluates to |true|
         for at least one element or entry."
    public Boolean contains(Boolean where(X element));
    
    doc "The elements of the collection, as a |Set|."
    public Set<X> elements;
    
    doc "The elements of the collection for which the given
         condition evaluates to |true|, as a |Set|."
    public Set<X> elements(Boolean where(X element));
    
    doc "The elements of the collection, sorted using the given
         comparison."
    public List<X> sortedElements(Comparison by(X x, X y));
    
    doc "An extension of the collection, with the given 
         elements. The returned collection reflects changes 
         made to the first collection."
    public Collection<T> with<T>(T... elements) given T abstracts X;

    doc "A mutable copy of the collection."
    public OpenCollection<T> copy<T>() given T abstracts X;
    
}]]></programlisting>

<!-- public Boolean containsAny(Object... objects); ??? -->

        <para>A decorator provides the ability to sort collections of
        <literal>Comparable</literal> values in natural order.</para>
        
        <programlisting><![CDATA[public extension class CollectionsOfComparable<out X>(Collection<X> collection) 
        given X satisfies Comparable<X> {
        
    doc "The elements of the collection, sorted in natural order."
    public List<X> sortedElements() {
        return collection.sortedElements() by (X x, X y) (x<=>y)
    }
    
}]]></programlisting>
        
        <para>Mutable collections implement <literal>OpenCollection</literal>:</para>
        
        <programlisting><![CDATA[public mutable interface OpenCollection<X> 
        satisfies OpenCategory<X>, Collection<X> 
        given X satisfies Object {
    
    doc "Remove all elements or entries of the collection,
         resulting in an empty collection."
    public Boolean clear();
    
    doc "Remove the given elements from the collection.
         Return the number of elements which belonged
         to the collection."
    public Natural remove(X... elements);
    
    doc "Remove all elements from the collection for which
         the given condition evaluates to |true|. Return 
         the number of elements which were removed."
    public Natural remove(Boolean where(X element));
    
}]]></programlisting>

    </section>

        <section id="sets">
            <title>Sets</title>
            
            <para>Sets implement the following interface<!--  ,
            and support the binary operators <literal>+</literal>
            (union), <literal>~</literal> (intersect), 
            <literal>-</literal> (complement),
            <literal>>=</literal> (superset),
            <literal>&lt;=</literal> (subset),
            <literal>></literal> (proper superset) and
            <literal>&lt;</literal> (proper subset),
            in addition to inherited operators-->:</para>
            
            <programlisting><![CDATA[public interface Set<out X> 
        satisfies Collection<X>, Correspondence<Object, Boolean> 
        given X satisfies Object {
    
    doc "Determine if the set is a superset of the given set.
         Return |true| if it is a superset."
    public Boolean superset(Set<Object> set);

    doc "Determine if the set is a subset of the given set.
         Return |true| if it is a subset."
    public Boolean subset(Set<Object> set);
    
    public override Set<T> with<T>(T... elements) given T abstracts X;
    public override OpenSet<T> copy<T>() given T abstracts X;

}]]></programlisting>

            <!--    
    public Set<T> union(Set<T> set) given T abstracts X;
    public Set<X> intersection(Set<Object> set);
    public Set<X> complement(Set<Object> set);
            -->

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenSet<X> 
        satisfies Set<X>, OpenCollection<X>, OpenCorrespondence<Object, Boolean> 
        given X satisfies Object {}]]></programlisting>

        </section>
        
        <section id="lists">
            <title>Lists</title>
            
            <para>Lists implement the following interface, and support the 
            operators inherited from <literal>Collection</literal> and 
            <literal>Sequence</literal>:</para>
            
            <programlisting><![CDATA[public interface List<out X> 
        satisfies Collection<X>, X[] 
        given X satisfies Object {
    
    doc "The index of the first element of the list
         which satisfies the condition, or |null| if 
         no element satsfies the condition."
    public Natural? firstIndex(Boolean where(X element));

    doc "The index of the last element of the list
         which satisfies the condition, or |null| if 
         no element satsfies the condition."
    public Natural? lastIndex(Boolean where(X element));
    
    doc "The elements of the list for which the given condition 
         evaluates to |true|, as a |List| with the original 
         order."
    public List<X> elementList(Boolean where(X element));
    
    doc "A sublist beginning with the element at the first given 
         index up to and including the element at the second given 
         index. The size of the returned sublist is one more than 
         the difference between the two indexes. The returned list 
         does reflect changes to the original list."
    public List<X> sublist(Natural from, Natural to=lastIndex);
    
    doc "A sublist of the given length beginning with the 
         first element of the list. The returned list does 
         reflect changes to the original list."
    public List<X> leading(Natural length=1);
    
    doc "A sublist of the given length ending with the 
         last element of the list. The returned list does 
         reflect changes to the original list."
    public List<X> trailing(Natural length=1);
    
    doc "Split the list into sublists, each beginning at an
         element for which the predicate returns true."
    public Iterable<List<X>> sublists(Boolean split(X element));
    
    doc "Split the list into sublists, each beginning at an
         element for which the predicate returns true. The 
         predicate may examine elements to the left and 
         right of the element under consideration."
    public Iterable<List<X>> sublists( 
            Boolean split(
                      doc "The current element, which
                           will be the first element
                           of the sublist if |split()|
                           returns |true|." 
                      X element, 
                      doc "The elements to the left,
                           beginning with the immediately
                           adjacent element." 
                      X[] left, 
                      doc "The elements to the right,
                           beginning with the immediately
                           adjacent element." 
                      X[] right
                  )
              );
    
    doc "An extension of the list with the given elements
         at the end of the list. The returned list does 
         reflect changes to the original list."
    public override List<T> with<T>(T... elements) given T abstracts X;
    
    doc "An extension of the list with the given elements
         at the start of the list. The returned list does 
         reflect changes to the original list."
    public List<T> withInitial<T>(T... elements) given T abstracts X;
    
    doc "The list in reverse order. The returned list does 
         reflect changes to the original list."
    public List<X> reversed;
    
    doc "The unsorted elements of the list. The returned 
         bag does reflect changes to the original list."
    public Bag<X> unsorted;
    
    doc "A map from list index to element. The returned 
         map does reflect changes to the original list."
    public Map<Natural,X> map;
    
    doc "Produce a new list by applying an operation to
         every element of the list."
    public List<Y> transform<Y>(Y select(X element));
    
    public override OpenList<T> copy<T>() given T abstracts X;

}]]></programlisting>

            <para>Any <literal>Sequence</literal> may be transparently converted to a 
            <literal>List</literal>:</para>
            
            <programlisting>public extension List&lt;X&gt; sequenceToList(X[] sequence) {
    if (is List&lt;X&gt; sequence) {
        return sequence
    }
    else {
        return SequenceList(sequence)
    }
}</programlisting>
            
<!--
            <para>Here's an implementation of the well-know quicksort algorithm 
            for a <literal>List</literal>:</para>
            
            <programlisting><![CDATA[doc "Quicksort for |List|s."
public List<X> quickSort<X>(List<X> list, Boolean byIncreasing(X x, X y)) {
    if (exists X pivot = list.first) {
        local createPartition = quickSort(list.rest.elementList);  
                //i.e. List<X> createPartition(Boolean where(X X)) = ...
        local smaller = byIncreasing.partial(pivot);                       
                //i.e. Boolean smaller(X x) = ...
        return createPartition(smaller) + {x} + createPartition(Boolean.complement(smaller))
    }
    else {
        return none
    }
}]]></programlisting>

            <para>For example:</para>
            
            <programlisting>List&lt;String&gt; sortedNames = quickSort(unsortedNames) byIncreasing (String x, String y) (x>y);</programlisting>
-->
            
            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenList<X> 
        satisfies List<X>, OpenCollection<X>, OpenSequence<X> 
        given X satisfies Object {

    doc "Remove the element at the given index, decrementing
         the index of every element with an index greater
         than the given index by one. Return the removed
         element."
    throws (UndefinedKeyException
            -> "if the index is not in the list")
    public X removeIndex(Natural at);
    
    doc "Add the given elements at the end of the list."
    public void append(X... elements);
    
    doc "Add the given elements at the start of the list,
         incrementing the index of every existing element
         by the number of given elements."
    public void prepend(X... elements);

    doc "Insert the given elements beginning at the given
         index, incrementing the index of every existing 
         element with that index or greater by the number 
         of given elements."
    throws (UndefinedKeyException
            -> "if the index is not in the list")
    public void insert(Natural at, X... elements);
    
    doc "Remove elements beginning with the first given index 
         up to and including the second given index,
         decrementing the indexes of all elements after
         with the second given index by one more than the 
         difference between the two indexes."
    throws (UndefinedKeyException
            -> "if the index is not in the list")
    public void delete(Natural from, Natural to=lastIndex);
    
    doc "Remove and return the first element, decrementing
         the index of every other element by one."
    throws (EmptyException
            -> "if the list is empty")
    public X removeFirst();

    doc "Remove and return the last element."
    throws (EmptyException
            -> "if the list is empty")
    public X removeLast();
    
    doc "Reverse the order of the list."
    public void reverse();
    
    doc "Reorder the elements of the list, according to the 
         given comparison."
    public void resort(Comparison by(X x, X y));
    
    override OpenList<X> leading(Natural length);
    override OpenList<X> trailing(Natural length);
    override OpenList<X> sublist(Natural from, Natural to);
    override OpenList<X> reversed;
    override OpenMap<Natural,X> map;
    
}]]></programlisting>
            
        <para>A decorator provides the ability to resort lists of
        <literal>Comparable</literal> values in natural order.</para>
        
        <programlisting><![CDATA[public extension class OpenListsOfComparable<out X>(OpenList<X> list) 
        given X satisfies Comparable<X> {
        
    doc "Reorder the elements of the list, according to the 
         natural order."
    public void resort() {
        list.resort() by (X x, X y) (x<=>y);
    }
    
}]]></programlisting>
        
        </section>
            
        <section id="maps">
            <title>Maps</title>
            
            <para>Maps implement the following interface:</para>
            
            <comment><para>TODO: is it OK that maps are not contravariant 
            in the key type?</para></comment>
            
            <programlisting><![CDATA[public interface Map<U, out V>
        satisfies Collection<Entry<U,V>>, Correspondence<U, V> 
        given U satisfies Object {
    
    doc "The keys of the map, as a |Set|."
    public Set<U> keys;
    
    doc "The values of the map, as a |Bag|."
    public Bag<V> values;
    
    doc "A |Map| of each value belonging to the map, to the 
         |Set| of all keys at which that value occurs."
    public Map<V, Set<U>> inverse;
    
    doc "Produce a new map by applying an operation to every 
         element of the map."
    public Map<U, W> transform<W>(W? select(U key -> V value));
    
    doc "The entries of the map for which the given condition 
         evaluates to |true|, as a |Map|."
    public Map<U, V> entries(Boolean where(U key -> V value));
    
    public override Map<U, T> with<T>(Entry<U, T>... entries) given T abstracts V;
    public override OpenMap<U,T> copy<T>() given T abstracts V;
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenMap<U,V> 
        satisfies Map<U,V>, OpenCollection<Entry<U,V>>, OpenCorrespondence<U, V> 
        given U satisfies Object {
    
    doc "Remove the entry for the given key, returning the 
         value of the removed entry."
    throws (UndefinedKeyException
            -> "if no value is defined for the given key")   
    public V remove(U key);
    
    doc "Remove all entries from the map which have keys for 
         which the given condition evaluates to |true|. Return 
         entries which were removed."
    public Map<U,V> remove(Boolean where(U key));
    
    override OpenSet<U> keys;
    override OpenBag<V> values;
    override OpenMap<V, Set<U>> inverse;
    
}]]></programlisting>
            
        </section>
        
        <section id="bags">
            <title>Bags</title>
            
            <para>Bags implement the following interface:</para>
            
            <programlisting><![CDATA[public interface Bag<out X> 
        satisfies Collection<X>, Correspondence<Object, Natural> 
        given X satisfies Object {
    
    doc "A map from element to the number of occurrences of 
         the element. The returned map reflects changes to 
         the original bag."
    public Map<X,Natural> map;
    
    public override Bag<T> with<T>(T... elements) given T abstracts X;
    public override OpenBag<T> copy<T>() given T abstracts X;
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenBag<X> 
        satisfies Bag<X>, OpenCollection<X>, OpenCorrespondence<Object, Natural> {
        
    override OpenMap<X,Natural> map;
    
}]]></programlisting>
            
        </section>
        
        <!--
        
        <section>
            <title>Collection operations</title>
            
            <programlisting><![CDATA[public Collections {
            
    public static List<X> join<X>(List<X> list...) {
        return new List<X> {
            ...
        }
    }
    
    public static Bag<X> union<X>(Bag<X> bag...) {
        return new Bag<X> {
            ...
        }
    }
    
    public static Set<X> union<X>(Set<X> set...) {
        return new Set<X> {
            ...
        }
    }
    
    public static Set<X> intersection<X>(Set<X> set...) {
        return new Set<X> {
            ...
        }
    }
    
    public static Set<X> complement<X>(Set<X> set, Set<Object> sets...) {
        return new Set<X> {
            ...
        }
    }    
            
}]]></programlisting>
            
        </section>
        
        -->
        
    </section>
    
</chapter>