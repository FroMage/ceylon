<chapter id="types">
    <title>Basic types</title>
    
    <para>There are no primitive types in Ceylon, however, there are certain
    important types provided by the package <literal>lang</literal>. Many
    of these types support <emphasis>operators</emphasis>.</para>
    
    <section>
        <title>The root type</title>
        
        <para>The <literal>lang.Object</literal> class is the root of the type 
        hierarchy and supports the binary operators <literal>==</literal> (equals),
        <literal>!=</literal> (not equals), <literal>===</literal> (identity equals), 
        <literal>.</literal> (invoke), <!--<literal>^.</literal> (chain invoke),-->
        <literal>in</literal> (in), <literal>is</literal> (is), <!--the unary prefix 
        operator <literal>$</literal> (render),--> and the binary operator 
        <literal>:=</literal> (assign).</para>
        
        <para>In addition, references of type <literal>Object?</literal>
        support the binary operators <literal>?.</literal> (nullsafe invoke) 
        and <literal>?</literal> (default) and the unary operator
        <literal>exists</literal>, along with the binary operators 
        <literal>==</literal> (equals), <literal>!=</literal> (not equals), 
        <literal>===</literal> (identity equals) and <literal>:=</literal> (assign).</para>
        
        <programlisting><![CDATA[public abstract class Object() {
        
    doc "The equals operator x == y. Default implementation compares
         attributes annotated |id|, or performs identity comparison."
    see #id
    public default Boolean equals(Object that) { return ... }
    
    doc "Compares the given attributes of this instance with the given
         attributes of the given instance."
    public Boolean equals(Object that, Attribute... attributes) { ... }
    
    doc "The hash code of the instance. Default implementation compares
         attributes annotated |id|, or assumes identity equality."
    see #id
    public default Integer hash { return ... }
    
    doc "Computes the hash code of the instance using the given 
         attributes."
    public Integer hash(Attribute... attributes) { ... }
        
    doc "A developer-friendly string representing the instance. 
         By default, the string contains the name of the type, 
         and the values of all attributes annotated |id|."
    public default String string { return ... }
    
    doc "A developer-friendly string representing the instance,
         containing the name of the type, and the value of the
         given attributes." 
    public default String string(Attribute... attributes) { ... }
    
    doc "Determine if the instance belongs to the given |Category|."
    see #Category
    public Boolean in(Category cat) {
        return cat.contains(this)
    }
    
    doc "Determine if the instance belongs to the given |Iterable|
         object or listed objects."
    see #Iterable
    public Boolean in(Object... objects) {
        return forAny (Object elem in objects) some elem == this
    }
    
    doc "The |Type| of the instance."
    public Type<subtype> type { return ... }
    
    doc "Binary assignability operator x is Y. Determine if the 
         instance is of the given |Type|."
    public Boolean instanceOf(Type<Object> type) {
        return this.type.assignableTo(type)
    }
    
    doc "A log obect for the type."
    public default Log log { return type.log }
    
    doc "Transform the given object to a string. Override to
         customize the render operator and character string 
         template expression interpolation."
    public default String string(Object? object) {
        return (object ? nullString).string
    }
    
    doc "The string representation of a null value. Override 
         to customize the render operator and character string 
         template expression interpolation."
    public default String nullString = "null";
        
    ...
        
}]]></programlisting>

        <comment><para>TODO: is this really the root type in Ceylon, or do we 
        need some other type sitting above <literal>lang.Object</literal> and 
        <literal>java.lang.Object</literal>, to accommodate classes from other 
        languages?</para></comment>

    </section>

    <section>
        <title>Referenceable and assignable values</title>
        
        <para>The class <literal>lang.Referenceable</literal> represents a value
        for which a reference can be obtained, allowing pass by reference semantics.</para>
        
        <programlisting><![CDATA[public abstract class Referenceable<out T> {
        
    doc "Obtain and return the value."
    extension T getIt();
    
}]]></programlisting>
        
        <para>Note that <literal>lang.Referenceable</literal> is not a subclass of 
        <literal>lang.Object</literal>.</para>
        
        <para>Instances of <literal>Referenceable&lt;T&gt;</literal> are transparently
        assignable to <literal>T</literal>, according to the <literal>extension</literal>.</para>
    
        <para>The subtype <literal>lang.Assignable</literal> represents a reference
        to an assignable value, allowing pass by reference semantics for assignable
        values.</para>
        
        <programlisting><![CDATA[public abstract class Assignable<T>() 
        extends Referenceable<T>() {
        
    doc "Assign the value, returning the new
         value after assignment. The binary
         assign operator |:=|."
    public T setIt(T t);
    
}]]></programlisting>
    
    </section>
    
    <section>
        <title>Callable references</title>
        
        <para>The type <literal>lang.Callable</literal> represents an executable
        operation.</para>
        
        <programlisting><![CDATA[public interface Callable<out R, P...> {
    public R call(P... args);
}]]></programlisting>
    
    </section>
    
    <section>
        <title>Boolean values</title>
        
        <para>The <literal>lang.Boolean</literal> class represents
        boolean values, supports the binary <literal>||, &amp;&amp;</literal> 
        and <literal>=></literal> operators and unary <literal>!</literal>
        operator and inherits the binary <literal>|, &amp;, ^</literal> and 
        unary <literal>~</literal> operators from <literal>Bits</literal>.</para>
        
        <programlisting><![CDATA[public class Boolean()
        satisfies Case<Boolean>, Bits<Boolean> {
    case true, case false;

    doc "The binary or operator x | y"
    override public Boolean or(Boolean boolean) {
        if (this) {
            return true
        }
        else {
            return boolean
        }
    }
    
    doc "The binary and operator x & y"
    override public Boolean and(Boolean boolean) {
        if (this) {
            return boolean
        }
        else {
            return false
        }
    }
    
    doc "The binary xor operator x ^ y"
    override public Boolean xor(Boolean boolean) {
        if (this) {
            return boolean.complement
        }
        else {
            return boolean
        }
    }
    
    doc "The unary not operator !x"
    override public Boolean complement { 
        if (this) {
            return false
        }
        else {
            return true
        }
    }
    
    override public List<Boolean> bits {
        return SingletonList(this)
    }
}]]></programlisting>

    </section>
    
    <section>
        <title>Cases and selectors</title>
        
        <para>The interface <literal>lang.Case</literal> represents a
        type that may be used as a case in the <literal>switch</literal>
        construct.</para>
        
        <programlisting><![CDATA[public interface Case<in X> {

    doc "Determine if the given value matches
         this case, returning |true| iff the
         value matches."
    public Boolean test(X value);
    
}]]></programlisting>

        <para>An extension allows <literal>Case&lt;X&gt;</literal> to 
        function as <literal>Case&lt;X?&gt;</literal>.</para>
        
        <programlisting><![CDATA[public extension
class CaseOptional<X>(Case<X> c) 
        satisfies Case<X?> {
        
    override Boolean test(Case<X> x) {
        if (exists value) {
            return c.test(x)
        }
        else {
            return false;
        }
    }
        
}]]></programlisting>

        <para>An extension allows <literal>Case&lt;X&gt;</literal> to 
        function as <literal>Case&lt;Y&gt;</literal> where <literal>X</literal> 
        is assignable to <literal>Y</literal>.</para>
        
        <programlisting><![CDATA[public extension
class CaseSuper<X,Y>(Case<X> c) 
        satisfies Case<Y> 
        where X satisfies Y {
        
    override Boolean test(Case<Y> y) {
        if (is X y) {
            return c.test(y)
        }
        else {
            return false;
        }
    }
        
}]]></programlisting>

        <para>Classes with enumerated <literal>case</literal>s implicitly extend 
        <literal>lang.Selector</literal></para>
        
        <programlisting><![CDATA[public abstract class Selector(String name, int ordinal)
        satisfies Case<subtype> { ... }]]></programlisting>
        
    </section>
    
    <section>
        <title>Optional and null values</title>
        
        <para>The class <literal>lang.Optional</literal> represents a
        value that may be null.</para>
        
        <programlisting><![CDATA[abstract class Optional<out X>() {
    
    doc "The unary postfix exists operator |x exists|."
    public Boolean valueExists;
    
    doc "The binary default operator |x ? y|."
    public T default(T defaultValue) where T abstracts X;
    
}]]></programlisting>

        <para>Note that <literal>lang.Optional</literal> is not a subtype
        of <literal>lang.Object</literal>.</para>
        
        <para>If an optional value is not null, it is represented by an
        instance of the subclass <literal>lang.Something</literal>.</para>
        
        <programlisting><![CDATA[public extension 
class Something<out X>(X x) extends Optional<X>() {

    public extension X value = x;
    
    override Boolean valueExists { 
        return true 
    }
    
    override T default(T defaultValue) where T abstracts X {
        return value;
    }
    
}]]></programlisting>

        <para>Non-optional values are transparently assignable to optional
        values, since <literal>Something&lt;X&gt;</literal> is an extension of 
        <literal>X</literal> enabled in every compilation unit. Likewise, 
        instances of <literal>Something&lt;X&gt;</literal> are transparently 
        assignable to <literal>X</literal>.</para>
        
        <para>If an optional value is null, it is represented by an
        instance of the subclass <literal>lang.Nothing</literal>.</para>
        
        <programlisting><![CDATA[public extension 
class Nothing<out X>(Null null) extends Optional<X>() {

    override Boolean valueExists { 
        return false 
    }
    
    override T default(T defaultValue) where T abstracts X {
        return defaultValue;
    }
    
}]]></programlisting>

        <para>The value <literal>Null.null</literal> is transparently 
        assignable to optional values, since <literal>Nothing&lt;X&gt;</literal> 
        is an extension of <literal>Null</literal> enabled in every 
        compilation unit.</para>
        
        <programlisting><![CDATA[public class Null() {
        
    doc "Represents a null reference."
    case null;
    
}]]></programlisting>

        <para>The decorator <literal>lang.NullCase</literal> allows <literal>null</literal>
        to appear as a <literal>case</literal> expression in a <literal>switch</literal>
        statement.</para>
        
        <programlisting><![CDATA[public extension 
class NullCase<X>(Null null) satisfies Case<Optional<X>> {

    override Boolean test(Optional<X> value) {
        return value is Nothing<X>;
    }
    
}]]></programlisting>
        
        <para>Note that <literal>Optional</literal> is not a reified type. The compiler
        erases all references to <literal>Optional&lt;X&gt;</literal> to 
        <literal>X</literal> after performing type validation and before generating
        bytecode. The compiler also replaces references to <literal>Null.null</literal>
        with the Java <literal>null</literal>. Therefore, none of the extensions defined 
        in this section are actually executed.</para>
        
    </section>
    
    <section>
        <title>Metamodel</title>
        
        <programlisting><![CDATA[interface Type<out X> 
        satisfies Annotated {
        
    String name;
    
    ...
    
}]]></programlisting>

        <programlisting><![CDATA[interface Class<X, P...> 
        satisfies Type<X>, Callable<X,P...> {
    
    Boolean mutable;
    Boolean abstract;
    
    Listener addListener( X onCreate(P... args, X proceed(P... args)) );
    
}]]></programlisting>

        <programlisting><![CDATA[interface Member<in X, out T> 
        satisfies Annotated, Callable<T,X> {
    
    Boolean abstract;
    Boolean default;
    Boolean mutable;
    
    Type<T> type;
    
}]]></programlisting>

        <!-- Reference<T> reference(X instance);
             T evaluate(X instance)  -->

        <programlisting><![CDATA[interface Method<in X, R, P...> 
        satisfies Member<Callable<R, P...>> {
        
    Type<R> returnType;
    Type<Object>[] parameterTypes;
    
    Listener addListener<S>( R onInvoke(S instance, R proceed(P... args), P... args) )
                   where S abstracts X;
    Listener addListener( X instance, R onInvoke(R proceed(P... args), P... args) );
    
}]]></programlisting>

        <programlisting><![CDATA[interface Attribute<in X, T> 
        satisfies Member<X, Reference<T>> {
        
    Listener addListener<S>( T onGet(S instance, T proceed()) );
                   where S abstracts X;
    Listener addListener( X instance, T onGet(T proceed()) );
    
}]]></programlisting>

        <programlisting><![CDATA[interface MutableAttribute<in X, T> 
        extends Attribute<X, T>
        satisfies Member<X, Assignable<T>> {  //this is OK since Member is covariant in T
        
    Listener addListener<S>( X onSet(S instance, X proceed(T value), T value) );
                   where S abstracts X;
    Listener addListener( X instance, X onSet(X proceed(T value), T value) );
    
}]]></programlisting>

       <programlisting>interface Listener {
    void remove();
}</programlisting>

    </section>
    
    <section>
        <title>Usables</title>
        
        <para>The interface <literal>lang.Usable</literal> represents an
        object with a lifecycle controlled by <literal>try</literal>.</para>
        
        <programlisting><![CDATA[public interface Usable {

    doc "Called before entry into a |try| block."
    public void begin();
    
    doc "Called before normal exit from a |try| block."
    public void end();

    doc "Called before exit from a |try| block when an
         exception occurs."
    public void end(Exception e);
    
}]]></programlisting>
       
    </section>
    
    <section>
        <title>Iterable objects and iterators</title>
        
        <para>The interface <literal>lang.Container</literal> represents
        the abstract notion of an object that may be empty. It supports 
        the unary postfix operator <literal>nonempty</literal><!--and
        the binary operator <literal>??:</literal> (empty default)-->.</para>
        
        <programlisting><![CDATA[public interface Container {
        
    doc "The nonempty operator. Determine 
         if the container is empty."
    public Boolean empty;
    
}]]></programlisting>

        <para>The <literal>lang.Iterable&lt;X&gt;</literal> interface
        represents a type that may be iterated over using a
        <literal>lang.Iterator&lt;X&gt;</literal>. It supports the
        binary operator <literal>[].</literal> (spread).<!--  ,
        <literal>*&lt;, *&gt;, *&lt;=, *&gt;=, *==, *!=</literal>
        (spread comparison)--> <!--and <literal>*~></literal> (all in).--></para>
        
        <programlisting><![CDATA[public interface Iterable<out X> satisfies Container {
    
    doc "Produce an iterator."
    public Iterator<X> iterator();
    
}]]></programlisting>

        <programlisting><![CDATA[public interface Iterator<out X> {

    doc "The status of the iterator. |true|
         indicates that the iterator contains
         more elements."
    public Boolean more;
    
    doc "The current element."
    public X current;

    doc "Advance to the next element, returning
         the next element."
    throw #ExhaustedIteratorException
          "if the iterator contains no
           more elements."
    public X next();
    
}]]></programlisting>

        <para>An iterator is used according to the following idiom:</para>
        
        <programlisting>Iterator i = list.iterator();
while (i.more) {
    doSomething( i.next() );
}</programlisting>

        <para>Some iterable objects may support element removal during iteration.</para>
        
        <programlisting><![CDATA[public mutable interface OpenIterable<X> 
        satisfies Iterable<X> {
    
    public override OpenIterator<X> iterator();
    
}]]></programlisting>

        <programlisting><![CDATA[public mutable interface OpenIterator<X> 
        satisfies OpenIterator<X> {
    
    doc "Remove the current element from the iterable
         object to which this iterator belongs."
    public void remove();
    
    doc "Replace the current element in the iterable
         object to which this iterator belongs with
         the given object."
    public assign current;
    
}]]></programlisting>

    </section>
    
    <section>
        <title>Categories</title>
        
        <para>The interface <literal>lang.Category</literal> represents
        the abstract notion of an object that contains other objects.</para>
        
        <programlisting><![CDATA[public interface Category {
    
    doc "Determine if the given objects belong to the category.
         Return |true| iff all the given objects belong to the 
         category."
    public Boolean contains(Object... objects);

}]]></programlisting>
        
        <!--
        <programlisting><![CDATA[public interface Category {
    
    doc "Determine if the given element belongs to the category."
    public Boolean contains(Object element);

}]]></programlisting>

        <programlisting><![CDATA[public extension class Categories(Category category) {
        
    doc "Determine if all the given elements belong to the 
         category."
    public Boolean contains(Object... elements) {
        return forAll (Object elem in elements) every category.contains(elem)
    }
    
}]]></programlisting>
        -->
        
        <para>There is a mutable subtype, representing a category to which 
        objects may be added.</para>
        
        <programlisting><![CDATA[public mutable interface OpenCategory<in X> 
        satisfies Category {
    
    doc "Add the given objects to the category. Return the number of 
         objects which did not already belong to the category."
    public Natural add(X... objects);

}]]></programlisting>

        <!--
        <programlisting><![CDATA[public mutable interface OpenCategory<in X> 
        satisfies Category {
    
    doc "Add the given element to the category. Return |true| if 
         the element did not already belong to the category."
    public Boolean add(X element);

}]]></programlisting>

        <programlisting><![CDATA[public extension class OpenCategories<in X>(OpenCategory<X> category) {
        
    doc "Add the given elements to the category. Return |true| if 
         at least one element did not already belong to the 
         category."
    public Boolean add(X... elements) {
        Boolean added = false;
        for (X x in elements) {
            added |= category.add(x);
        }
        return added
    }
    
}]]></programlisting>
        -->

    </section>
    
    <section>
        <title>Correspondences</title>
        
        <para>The interface <literal>lang.Correspondence</literal> represents
        the abstract notion of an object that maps value of one type to values
        of some other type. It supports the binary operator
        <literal>[key]</literal> (lookup).</para>

        <programlisting><![CDATA[public interface Correspondence<in U, out V> {
    
    doc "Binary lookup operator x[key]. Returns the value defined
         for the given key, or |null| if there is no value defined
         for the given key."
    public Referenceable<V?> value(U key);
    
    doc "Determine if there are values defined for the given keys.
         Return |true| iff there are values defined for all the
         given keys."
    public Boolean defines(U... keys);
    
}]]></programlisting>

        <para>A decorator allows retrieval of lists and sets of values.</para>

        <programlisting><![CDATA[public extension class Correspondences<in U, out V>(Correspondence<U, V> correspondence) {

    doc "Binary list lookup operator x[keys]. Returns a list of 
         values defined for the given keys, in order."
    throws #UndefinedKeyException
           "if no value is defined for one of the given keys"
    public List<V> values(List<U> keys) {
        return from (U key in keys) select (correspondence.lookup(key))
    }
    
    doc "Binary set lookup operator x[keys]. Returns a set of 
         values defined for the given set of keys."
    throws #UndefinedKeyException
           "if no value is defined for one of the given keys"
    public Set<V> values(Set<U> keys) {
        return ( from (U key in keys) select (correspondence.lookup(key)) ).elements
    }
    
}]]></programlisting>

         <comment><para>TODO: should we handle the list lookup and set
         lookup operators using a helper class that calls a constructor
         of the concrete subtype, like we do with <literal>Sequence</literal>?</para></comment>

        <!--     
        <programlisting><![CDATA[public interface Correspondence<in U, out V> {
    
    doc "Binary lookup operator x[key]. Returns the value defined
         for the given key."
    public V value(U key);
    
    doc "Determine if there is a value defined for the given key."
    public Boolean defines(U key);
    
}]]></programlisting>

        <programlisting><![CDATA[public extension class Correspondences<in U, out V>(Correspondence<U, V> correspondence) {

    doc "Binary lookup operator x[keys]. Returns a list of values 
         defined for the given keys, in order."
    public List<V> values(List<U> keys) {
        return from (U key in keys) select correspondence.lookup(key)
    }
    
    doc "Binary lookup operator x[keys]. Returns a set of values 
         defined for the given set of keys."
    public Set<V> values(Set<U> keys) {
        return ( from (U key in keys) select correspondence.lookup(key) ).elements
    }
    
    doc "Determine if there are values defined for all the given 
    keys."
    public Boolean defines(U... keys) {
        for (U key in keys) {
            if ( !correspondence.defines(key) ) {
                return false
            }
        }
        fail {
            return true
        }
    }
    
}]]></programlisting>
        -->
        
        <para>There is a mutable subtype, representing a correspondence
        for which new mappings may be defined, and existing mappings 
        modified. It provides for the use of element expressions in
        assignments.</para>
        
        <!-- Association? -->

        <programlisting><![CDATA[public mutable interface OpenCorrespondence<in U, V> 
        satisfies Correspondence<U, V> {
     
     override public Assignable<V?> value(U key);
     
     doc "Element assignment operator x[key] = value. Assign a value 
          to the given key. Return the previous value for the key,
          or |null| if there was no value defined."
     throws #UndefinedKeyException
            "if a value can not be defined for the given key"
     public V? define(U key, V value);

}]]></programlisting>

        <para>A decorator allows addition of multiple <literal>Entry</literal>s.</para>

        <programlisting><![CDATA[public extension class OpenCorrespondences<in U, V>(OpenCorrespondence<U, V> correspondence) {

     doc "Add the given entries, overriding any definitions that 
          already exist."
     throws #UndefinedKeyException
            "if a value can not be defined for one of the given 
             keys"
     public void define(Entry<U, V>... definitions) {
         for (U key->V value) {
             correspondence.define(key, value);
         }
     }
    
}]]></programlisting>
       
    </section>
    
    <section>
        <title>Sequences</title>
        
        <para>A <literal>lang.Sequence</literal> is a correspondence from 
        a bounded progression of natural numbers. Sequences support the 
        binary operators <literal>+</literal> (join), <literal>[i...]</literal> 
        (upper range) and the ternary operator <literal>[i..j]</literal> 
        (subrange) in addition to operators inherited from 
        <literal>Correspondence</literal>:</para>

        <programlisting><![CDATA[public interface Sequence<out X> 
        satisfies Correspondence<Natural, out X>, Iterable<X> {

    doc "The index of the last element of the sequence,
         or |null| if the sequence has no elements."
    public Natural? lastIndex;
    
}]]></programlisting>
        
        <para>The value <literal>None.none</literal> is transparently
        assignable to <literal>Sequence&lt;X&gt;</literal>.</para>
        
        <programlisting><![CDATA[public class None() {
        
    doc "Represents an empty sequence. The value of 
         the empty sequence enumeration |{}|."
    case none;
    
    public extension 
    class EmptySequence<out X>() satisfies X[] {
        ...
    }
    
}]]></programlisting>


        <para>Toplevel methods define the join and range operators, for 
        sequence types which have an appropriate constructor:</para>

<programlisting><![CDATA[doc "The binary join operator x + y. 
     The returned sequence does not reflect changes
     to the original sequences."
public S join<S,T>(S... sequences) 
        where S(T... elements) satisfies T[] {

    class JoinedIterable<T>
        implements Iterable<T> {  }

    return S( JoinedIterable() )
}]]></programlisting>
        
<programlisting><![CDATA[doc "The ternary range operator x[from..to], along
     with the binary upper range x[from...] operator. 
     The returned sequence does not reflect changes 
     to the original sequence."
public S range<S,T>(S sequence, Natural from, Natural to=sequence.lastIndex) 
         where S(T... elements) satisfies T[] {

    class SubrangeIterable<T>
        implements Iterable<T> {  }

    return S( SubrangeIterable() )
}]]></programlisting>
        
        <para>A helper class decorates <literal>Sequence</literal> with 
        some convenience attributes:</para>

        <programlisting><![CDATA[public extension class Sequences<out X>(X[] sequence) {

    doc "The first element of the sequence, or
         |null| if the sequence has no elements."
    public X? first {
        return sequence[0]
    }
    
    doc "The last element of the sequence, or
         |null| if the sequence has no elements.."
    public X? last {
        if (exists Natural index = sequence.lastIndex) {
            return sequence[index]
        }
        else {
            return null
        }
    }

}]]></programlisting>
        
        <para>There is a mutable subtype which allows assignment to
        an index.</para>
        
        <programlisting><![CDATA[public mutable interface OpenSequence<X>
        satisfies X[], OpenCorrespondence<Natural,X> {}]]></programlisting>

    </section>
    
    <section>
        <title>Entries</title>
        
        <para>The <literal>Entry</literal> class represents a pair of 
        associated objects.</para>

        <para>Entries may be constructed using the <literal>-></literal> 
        operator.</para>

            <programlisting><![CDATA[public class Entry<out U, out V>(U key, V value) {
    
    doc "The key used to access the entry."
    public U key = key;
    
    doc "The value associated with the key."
    public V value = value;
    
    override public Boolean equals(Object that) {
        return equals(that, #key, #value)
    }
    
    override public Integer hash {
        return hash(#key, #value)
    }

}]]></programlisting>

    </section>
    
    <section>
        <title>Collections</title>
        
        <para>The interface <literal>lang.Collection</literal> is the 
        root of the Ceylon collections framework.</para>
        
        <programlisting><![CDATA[public interface Collection<out X> 
        satisfies Iterable<X>, Category {
    
    doc "The number of elements or entries belonging to the 
         collection."
    public Natural size;
    
    doc "Determine the number of times the given element
         appears in the collection."
    public Natural count(Object element);
    
    doc "Determine the number of elements or entries for
         which the given condition evaluates to |true|."
    public Natural count(Boolean having(X element));
    
    doc "Determine if the given condition evaluates to |true|
         for at least one element or entry."
    public Boolean contains(Boolean having(X element));
    
    doc "The elements of the collection, as a |Set|."
    public Set<X> elements;
    
    doc "The elements of the collection for which the given
         condition evaluates to |true|, as a |Set|."
    public Set<X> elements(Boolean having(X element));
    
    doc "The elements of the collection, sorted using the given
         comparison."
    public List<X> sortedElements(Comparison by(X x, X y));
    
    doc "An extension of the collection, with the given 
         elements. The returned collection reflects changes 
         made to the first collection."
    public Collection<T> with<T>(T... elements) where T abstracts X;

    doc "A mutable copy of the collection."
    public OpenCollection<T> copy<T>() where T abstracts X;
    
}]]></programlisting>

<!-- public Boolean containsAny(Object... objects); ??? -->

        <para>A decorator provides the ability to sort collections of
        <literal>Comparable</literal> values in natural order.</para>
        
        <programlisting><![CDATA[public extension class CollectionsOfComparable<out X>(Collection<X> collection) 
        where X satisfies Comparable<X> {
        
    doc "The elements of the collection, sorted in natural order."
    public List<X> sortedElements() {
        return collection.sortedElements() by (X x, X y) (x<=>y)
    }
    
}]]></programlisting>
        
        <para>Mutable collections implement <literal>lang.OpenCollection</literal>:</para>
        
        <programlisting><![CDATA[public mutable interface OpenCollection<X> 
        satisfies OpenIterable<X>, OpenCategory<X>, Collection<X> {
    
    doc "Remove all elements or entries of the collection,
         resulting in an empty collection."
    public Boolean clear();
    
    doc "Remove the given elements from the collection.
         Return the number of elements which belonged
         to the collection."
    public Natural remove(X... elements);
    
    doc "Remove all elements from the collection for which
         the given condition evaluates to |true|. Return 
         the number of elements which were removed."
    public Natural remove(Boolean having(X element));
    
}]]></programlisting>

        <section>
            <title>Sets</title>
            
            <para>Sets implement the following interface<!--  ,
            and support the binary operators <literal>+</literal>
            (union), <literal>~</literal> (intersect), 
            <literal>-</literal> (complement),
            <literal>>=</literal> (superset),
            <literal>&lt;=</literal> (subset),
            <literal>></literal> (proper superset) and
            <literal>&lt;</literal> (proper subset),
            in addition to inherited operators-->:</para>
            
            <programlisting><![CDATA[public interface Set<out X> 
        satisfies Collection<X>, Correspondence<Object, Boolean> {
    
    doc "Determine if the set is a superset of the given set.
         Return |true| if it is a superset."
    public Boolean superset(Set<Object> set);

    doc "Determine if the set is a subset of the given set.
         Return |true| if it is a subset."
    public Boolean subset(Set<Object> set);
    
    public override Set<T> with<T>(T... elements) where T abstracts X;
    public override OpenSet<T> copy<T>() where T abstracts X;

}]]></programlisting>

            <!--    
    public Set<T> union(Set<T> set) where T abstracts X;
    public Set<X> intersection(Set<Object> set);
    public Set<X> complement(Set<Object> set);
            -->

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenSet<X> 
        satisfies Set<X>, OpenCollection<X>, OpenCorrespondence<Object, Boolean> {}]]></programlisting>

        </section>
        
        <section>
            <title>Lists</title>
            
            <para>Lists implement the following interface, and support the 
            operators inherited from <literal>Collection</literal> and 
            <literal>Sequence</literal>:</para>
            
            <programlisting><![CDATA[public interface List<out X> 
        satisfies Collection<X>, X[] {
    
    doc "The tail of the list. The returned list does 
         reflect changes to the original list."
    public List<X> rest;
    
    doc "The index of the first element of the list
         which satisfies the condition, or |null| if 
         no element satsfies the condition."
    public Natural? firstIndex(Boolean having(X element));

    doc "The index of the last element of the list
         which satisfies the condition, or |null| if 
         no element satsfies the condition."
    public Natural? lastIndex(Boolean having(X element));
    
    doc "A sublist beginning with the element at the first given 
         index up to and including the element at the second given 
         index. The size of the returned sublist is one more than 
         the difference between the two indexes. The returned list 
         does reflect changes to the original list."
    public List<X> sublist(Natural from, Natural to=lastIndex);
    
    doc "A sublist of the given length beginning with the 
         first element of the list. The returned list does 
         reflect changes to the original list."
    public List<X> leading(Natural length=1);
    
    doc "A sublist of the given length ending with the 
         last element of the list. The returned list does 
         reflect changes to the original list."
    public List<X> trailing(Natural length=1);
    
    doc "An extension of the list with the given elements
         at the end of the list. The returned list does 
         reflect changes to the original list."
    public override List<T> with<T>(T... elements) where T abstracts X;
    
    doc "An extension of the list with the given elements
         at the start of the list. The returned list does 
         reflect changes to the original list."
    public List<T> withInitial<T>(T... elements) where T abstracts X;
    
    doc "The list in reverse order. The returned list does 
         reflect changes to the original list."
    public List<X> reversed;
    
    doc "The unsorted elements of the list. The returned 
         bag does reflect changes to the original list."
    public Bag<X> unsorted;
    
    doc "A map from list index to element. The returned 
         map does reflect changes to the original list."
    public Map<Natural,X> map;
    
    doc "Produce a new list by applying an operation to
         every element of the list."
    public List<Y> transform<Y>(Y select(X element));
    
    public override OpenList<T> copy<T>() where T abstracts X;

}]]></programlisting>

            <para>It is possible to iterate lists without creating an iterator:</para>
            
            <programlisting><![CDATA[mutable List<Person> people := ... ;
while (people nonempty) {
    doSomething(people.first);
    people.=rest;
}]]></programlisting>
            
            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenList<X> 
        satisfies List<X>, OpenCollection<X>, OpenSequence<X> {

    doc "Remove the element at the given index, decrementing
         the index of every element with an index greater
         than the given index by one. Return the removed
         element."
    throws #UndefinedKeyException
           "if the index is not in the list"
    public X removeIndex(Natural at);
    
    doc "Add the given elements at the end of the list."
    public void prepend(X... elements);
    
    doc "Add the given elements at the start of the list,
         incrementing the index of every existing element
         by the number of given elements."
    public void append(X... elements);

    doc "Insert the given elements beginning at the given
         index, incrementing the index of every existing 
         element with that index or greater by the number 
         of given elements."
    throws #UndefinedKeyException
           "if the index is not in the list"
    public void insert(Natural at, X... elements);
    
    doc "Remove elements beginning with the first given index 
         up to and including the second given index,
         decrementing the indexes of all elements after
         with the second given index by one more than the 
         difference between the two indexes."
    throws #UndefinedKeyException
           "if the index is not in the list"
    public void delete(Natural from, Natural to=lastIndex);
    
    doc "Remove and return the first element, decrementing
         the index of every other element by one."
    throws #EmptyException
           "if the list is empty"
    public X removeFirst();

    doc "Remove and return the last element."
    throws #EmptyException
           "if the list is empty"
    public X removeLast();
    
    doc "Reverse the order of the list."
    public void reverse();
    
    doc "Reorder the elements of the list, according to the 
         given comparison."
    public void resort(Comparison by(X x, X y));
    
    override public OpenList<X> rest;
    override public OpenList<X> leading(Natural length);
    override public OpenList<X> trailing(Natural length);
    override public OpenList<X> sublist(Natural from, Natural to);
    override public OpenList<X> reversed;
    override public OpenMap<Natural,X> map;
    
}]]></programlisting>
            
        <para>A decorator provides the ability to resort lists of
        <literal>Comparable</literal> values in natural order.</para>
        
        <programlisting><![CDATA[public extension class OpenListsOfComparable<out X>(OpenList<X> list) 
        where X satisfies Comparable<X> {
        
    doc "Reorder the elements of the list, according to the 
         natural order."
    public void resort() {
        list.resort() by (X x, X y) (x<=>y);
    }
    
}]]></programlisting>
        
        </section>
            
        <section>
            <title>Maps</title>
            
            <para>Maps implement the following interface:</para>
            
            <comment><para>TODO: is it OK that maps are not contravariant 
            in the key type?</para></comment>
            
            <programlisting><![CDATA[public interface Map<U, out V>
        satisfies Collection<Entry<U,V>>, Correspondence<U, V> {
    
    doc "The keys of the map, as a |Set|."
    public Set<U> keys;
    
    doc "The values of the map, as a |Bag|."
    public Bag<V> values;
    
    doc "A |Map| of each value belonging to the map, to the 
         |Set| of all keys at which that value occurs."
    public Map<V, Set<U>> inverse;
    
    doc "Produce a new map by applying an operation to every 
         element of the map."
    public Map<U, W> transform<W>(W? select(U key -> V value));
    
    doc "The entries of the map for which the given condition 
         evaluates to |true|, as a |Map|."
    public Map<U, V> entries(Boolean having(U key -> V value));
    
    public override Map<U, T> with<T>(Entry<U, T>... entries) where T abstracts V;
    public override OpenMap<U,T> copy<T>() where T abstracts V;
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenMap<U,V> 
        satisfies Map<U,V>, OpenCollection<Entry<U,V>>, OpenCorrespondence<U, V> {
    
    doc "Remove the entry for the given key, returning the 
         value of the removed entry."
    throws #UndefinedKeyException
           "if no value is defined for the given key"    
    public V remove(U key);
    
    doc "Remove all entries from the map which have keys for 
         which the given condition evaluates to |true|. Return 
         entries which were removed."
    public Map<U,V> remove(Boolean having(U key));
    
    override public OpenSet<U> keys;
    override public OpenBag<V> values;
    override public OpenMap<V, Set<U>> inverse;
    
}]]></programlisting>
            
        </section>
        
        <section>
            <title>Bags</title>
            
            <para>Bags implement the following interface:</para>
            
            <programlisting><![CDATA[public interface Bag<out X> 
        satisfies Collection<X>, Correspondence<Object, Natural> {
    
    doc "A map from element to the number of occurrences of 
         the element. The returned map reflects changes to 
         the original bag."
    public Map<X,Natural> map;
    
    public override Bag<T> with<T>(T... elements) where T abstracts X;
    public override OpenBag<T> copy<T>() where T abstracts X;
    
}]]></programlisting>

            <para>There is a mutable subtype:</para>
            
            <programlisting><![CDATA[public mutable interface OpenBag<X> 
        satisfies Bag<X>, OpenCollection<X>, OpenCorrespondence<Object, Natural> {
        
    override public OpenMap<X,Natural> map;
    
}]]></programlisting>
            
        </section>
        
        <!--
        
        <section>
            <title>Collection operations</title>
            
            <programlisting><![CDATA[public Collections {
            
    public static List<X> join<X>(List<X> list...) {
        return new List<X> {
            ...
        }
    }
    
    public static Bag<X> union<X>(Bag<X> bag...) {
        return new Bag<X> {
            ...
        }
    }
    
    public static Set<X> union<X>(Set<X> set...) {
        return new Set<X> {
            ...
        }
    }
    
    public static Set<X> intersection<X>(Set<X> set...) {
        return new Set<X> {
            ...
        }
    }
    
    public static Set<X> complement<X>(Set<X> set, Set<Object> sets...) {
        return new Set<X> {
            ...
        }
    }    
            
}]]></programlisting>
            
        </section>
        
        -->
        
    </section>
    
    <section>
        <title>Ordered values</title>
        
        <para>The <literal>lang.Comparable</literal> interface 
        represents totally ordered types, and supports the binary operators 
        <literal>&gt;, &lt;, &lt;=, &gt;=</literal> and <literal>&lt;=&gt;</literal>
        (compare).</para>
        
        <programlisting><![CDATA[public interface Comparable<in T> {
    
    doc "The binary compare operator |<=>|. Compares this 
         object with the given object."
    public Comparison compare(T other);
    
}]]></programlisting>
        
        <programlisting><![CDATA[public class Comparison() {
    
    doc "The receiving object is larger than 
         the given object."
    case larger, 
    
    doc "The receiving object is smaller than 
         the given object."
    case smaller, 
    
    doc "The receiving object is exactly equal 
         to the given object."
    case equal;
        
    public Boolean larger { return this===larger }
    public Boolean smaller { return this===smaller }
    public Boolean equal { return this===equal }
    public Boolean unequal { return !this===equal }
    public Boolean largeAs { return !this===smaller }
    public Boolean smallAs { return !this===larger }
    
}]]></programlisting>

        <comment><para>TODO: should we support partial orders? Give
        <literal>Comparison</literal> an extra <literal>uncomparable</literal>
        value, or let <literal>compare()</literal> return 
        <literal>null</literal>?</para></comment>
        
        <comment><para>TODO: if so, why not just move <literal>compare()</literal>
        up to <literal>Object</literal> to simplify things?</para></comment>

        <para>The <literal>lang.Ordinal</literal> interface represents 
        objects in a sequence, and supports the binary operator 
        <literal>..</literal> (range). In addition, variables support 
        the postfix unary operators <literal>++</literal> (increment) 
        and <literal>--</literal> (decrement) and prefix unary 
        operators <literal>++</literal> (successor) and 
        <literal>--</literal> (predecessor).</para>
        
        <programlisting><![CDATA[public interface Ordinal {

    doc "The unary |++| operator. The successor of this instance."
    throws #OutOfRangeException
           "if this is the maximum value"
    public subtype successor;
    
    doc "The unary |--| operator. The predecessor of this instance."
    throws #OutOfRangeException
           "if this is the minimum value"
    public subtype predecessor;
    
}]]></programlisting>

    </section>
    
    <section>
        <title>Ranges</title>
        
        <para>Ranges implement <literal>Sequence</literal>, therefore they 
        support the join, subrange, contains and lookup operators, among 
        others. Ranges may be constructed using the <literal>..</literal> 
        operator:</para> 
        
        <programlisting><![CDATA[public class Range<X>(X first, X last) 
        satisfies Category, X[], Case<X>
        where X satisfies Ordinal, Comparable<X> { 
    
    doc "The first value in the range."
    public X first = first;
    
    doc "The last value in the range."
    public X last = last;
    
    ... 
    
    doc "Return a |Sequence| of values in the range, 
         beginning at the first value, and 
         incrementing by a constant step size,
         until a value outside the range is
         reached."
    public X[] by(Natural stepSize) { return ... } 
    
}]]></programlisting>
    
    </section>
    
    <section>
        <title>Characters and strings</title>
        
        <para>UTF-32 Unicode Characters are represented by the following class:</para>

        <programlisting><![CDATA[public class Character(small Natural utf32)
        satisfies Ordinal, Comparable<Character>, Case<Character> { 
    ... 
    
    doc "The UTF-16 encoding"
    public String utf16;
    
    doc "The UTF-8 encoding"
    public String utf8;
    
    public extension class StringToCharacter(String string) {
    
        doc "Parse the string representation of a |Character| in UTF-16"
        public extension Character parseUtf16Character() { return ... }
    
        doc "Parse the string representation of a |Character| in UTF-8"
        public extension Character parseUtf8Character() { return ... }
    
    }
 
}]]></programlisting>
        
        <para>Strings implement <literal>Sequence</literal>, therefore they support 
        the join, subrange, contains and lookup operators, among others.</para> 
                
        <programlisting><![CDATA[public class String(Character... characters) 
        satisfies Character[], Comparable<String>, Case<String> {
    
    ... 
    
    doc "Split the string into tokens, using the given
         separator characters."
    public Iterable<String> tokens(Iterable<Character> separators=" ,;\n\l\r\t") { return ... }
    
    doc "The string, with all characters in lowercase."
    public String lowercase { return ... }
    
    doc "The string, with all characters in uppercase."
    public String uppercase { return ... }
    
    doc "Remove the given characters from the beginning 
         and end of the string.
    public String strip(Character[] whitespace = " \n\l\r\t") { return ... }
    
    doc "Collapse substrings of the given characters into
         single space characters."
    public String normalize(Character[] whitespace = " \n\l\r\t") { return ... }
    
    doc "Join the given strings, using this string as
         a separator."
    public String join(String... strings) { return ... }
    
}]]></programlisting>
        
        <comment><para>What encoding is the default for Ceylon strings? Are there 
        performance advantages to going with UTF-16 like Java? Can we easily abstract
        this stuff? Does the JVM do all kinds of optimizations for 
        <literal>java.lang.String</literal>?</para></comment>
        
        <para>A string template is represented by an instance of <literal>StringTemplate</literal>.</para>
        
        <programlisting>public class StringTemplate(...) {
        
    doc "Evaluate all interpolated expressions, producing 
         a constant character string with no interpolated
         expressions."
    public extension String interpolate() { return ... }

}</programlisting>
        
    </section>
    
    <section>
        <title>Regular expressions</title>
        
        <programlisting><![CDATA[public extension class Regex(Quoted expression)
        satisfies Case<String> { 
        
    doc "Return the substrings of the given string which
         match the parenthesized groups of the regex,
         ordered by the position of the opening parenthesis
         of the group." 
    public Iterator<Match> matchList(String string) { return ... }
    
    doc "Determine if the given string matches the regex."
    public Boolean matches(String string) { return ... }
    
    ... 
    
}]]></programlisting>
        
        <comment><para>TODO: I assume these are just Java (Perl 5-style) regular expressions. Is
        there some other better syntax around?</para></comment>

    </section>
    
    <section>
        <title>Bit strings</title>
        
        <para>The interface <literal>Bits</literal> represents a fixed length
        string of boolean values, and supports the binary 
        <literal>|, &amp;, ^</literal> and unary <literal>~</literal> 
        operators.</para>
        
        <programlisting><![CDATA[public interface Bits<T> {
        
    doc "Bitwise or operator x|y"
    public T or(T bits);
    
    doc "Bitwise and operator x&y"
    public T and(T bits);
    
    doc "Bitwise xor operator x^y"
    public T xor(T bits);
    
    doc "Bitwise complement operator ~x"
    public T complement;
    
    doc "A list of the bits."
    public List<Boolean> bits;
    
}]]></programlisting>
        
    </section>
    
    <section>
        <title>Numbers</title>
        
        <para>The <literal>lang.Number</literal> interface is the abstract supertype
        of all classes which represent numeric values.</para>
        
        <programlisting><![CDATA[public interface Number {
    
    doc "Determine if the number represents
         an integer value"
    public Boolean integral;
    
    doc "Determine if the number is positive"
    public Boolean positive;
    
    doc "Determine if the number is negative"    
    public Boolean negative;

    doc "Determine if the number is zero"
    public Boolean zero;
    
    doc "Determine if the number is one"
    public Boolean unit;
    
    doc "The number, represented as a |Decimal|"
    public Decimal decimal;

    doc "The number, represented as a |Float|"
    throws #FloatOverflowException
           "if the number is too large to be
            represented as a |Float|"
    public Float float;
    
    doc "The number, represented as an |Whole|,
         after truncation of any fractional 
         part"
    public Whole whole;
    
    doc "The number, represented as an |Integer|,
         after truncation of any fractional 
         part"
    throws #IntegerOverflowException
           "if the number is too large to be
            represented as an |Integer|"
    public Integer integer;
    
    doc "The number, represented as a |Natural|,
         after truncation of any fractional 
         part"
    throws #NegativeNumberException
           "if the number is negative"
    public Natural natural;
    
    doc "The magnitude of the number"
    public subtype magnitude;
    
    doc "1 if the number is positive, -1 if it
         is negative, or 0 if it is zero."
    public subtype sign;
    
    doc "The fractional part of the number,
         after truncation of the integral
         part"
    public subtype fractionalPart;
    
    doc "The integral value of the number 
         after truncation of the fractional
         part"
    public subtype wholePart;

}]]></programlisting>

        <para>The subtype <literal>lang.Numeric</literal> supports the binary 
        operators <literal>+,-, *, /, **</literal>, and the unary prefix 
        operators <literal>-, +</literal>. In addition, <literal>mutable</literal> 
        values of type <literal>lang.Numeric</literal> support the compound
        assignment operators <literal>+=, -=, /=, *=</literal>.</para>

<programlisting><![CDATA[public interface Numeric<N, I>
        satisfies Number, Comparable<N> 
        where I satisfies Number
        where N satisfies Number {

    doc "The unary - operator"
    public I inverse;

    doc "The binary + operator"
    public N plus(N number);

    doc "The binary - operator"
    public I minus(N number);

    doc "The binary * operator"
    public N times(N number);

    doc "The binary / operator"
    public N divided(N number);

    doc "The binary ** operator"
    public N power(N number);
    
}]]></programlisting>

        <para>The subtype <literal>lang.Integral</literal> supports the binary 
        operator <literal>%</literal>, and inherits the unary operators 
        <literal>++</literal> and <literal>--</literal> from 
        <literal>Ordinal</literal>.</para>

<programlisting><![CDATA[public interface Integral<N, I>
        satisfies Numeric<N, I>, Ordinal 
        where I satisfies Number 
        where N satisfies Number {

    doc "The binary % operator"
    public N remainder(N number);

}]]></programlisting>

        <comment><para>TODO: should <literal>plus()</literal> and <literal>times()</literal>
        accept varargs, to minimize method calls?</para></comment>

        <para>Five numeric types are built in:</para>

        <para><literal>lang.Natural</literal> represents 63 bit unsigned integers
        (including zero).</para>
        
        <programlisting><![CDATA[public class Natural(Natural natural)
        satisfies Integral<Natural,Integer>, Case<Integral>, Bits<Natural> { 
    ... 
    
    doc "Implicit type promotion to |Integer|"
    override public extension Integer integer { return ... }
    
    doc "Implicit type promotion to |Whole|"
    override public extension Whole whole { return ... }
    
    doc "Implicit type promotion to |Float|"
    override public extension Float float { return ... }
    
    doc "Implicit type promotion to |Decimal|"
    override public extension Decimal decimal { return ... }

    doc "Shift bits left by the given number of places"
    public Natural leftShift(Natural digits) { return ... }
    
    doc "Shift bits right by the given number of places"
    public Natural rightShift(Natural digits) { return ... }
    
    public extension class StringToNatural(String string) {
    
        doc "Parse the string representation of a |Natural| in the given radix"
        public Natural parseNatural(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <comment><para>TODO: the <literal>Numeric</literal> type is much more complicated
        because of <literal>Natural</literal>. As an alternative approach, we could replace
        <literal>Natural</literal> with a <literal>Binary</literal> type, and have 
        <literal>Integer</literal> literals instead of <literal>Natural</literal> 
        literals. I don't love this, because natural numbers are especially common in real
        applications.</para></comment>

        <para><literal>lang.Integer</literal> represents 64 bit signed integers.</para>

        <programlisting><![CDATA[public class Integer(Boolean sign, Natural natural)
        satisfies Integral<Integer,Integer>, Case<Integral> {
    ...
    
    doc "Implicit type promotion to |Whole|"
    override public extension Whole whole { return ... }
    
    doc "Implicit type promotion to |Float|"
    override public extension Float float { return ... }

    doc "Implicit type promotion to |Decimal|"
    override public extension Decimal decimal { return ... }

    public extension class StringToInteger(String string) {
    
        doc "Parse the string representation of an |Integer| in the given radix"
        public Integer parseInteger(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <para><literal>lang.Whole</literal> represents arbitrary-precision
        signed integers.</para>

        <programlisting><![CDATA[public class Whole(Boolean sign, small Natural... digits)
        satisfies Integral<Whole,Whole> {
    ...
    
    public small Natural precision = ...;
    
    doc "Implicit type promotion to |Decimal|"
    override public extension Decimal decimal { return ... }
    
    public extension class StringToWhole(String string) {
    
        doc "Parse the string representation of a |Whole| in the given radix"
        public Whole parseWhole(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>
        
        <para><literal>lang.Float</literal> represents 64 bit floating point
        values.</para>

        <programlisting><![CDATA[public class Float(Float float)
        satisfies Numeric<Float,Float> { 
    ... 
    
    doc "Implicit type promotion to |Decimal|"
    override public extension Decimal decimal { return ... }
    
    public extension class StringToFloat(String string) {
    
        doc "Parse the string representation of a |Float| in the given radix"
        public Float parseFloat(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

        <para><literal>lang.Decimal</literal> represents arbitrary-precision
        and arbitrary-scale decimals.</para>

        <programlisting><![CDATA[public class Decimal(Whole value, small Integer scale)
        satisfies Numeric<Decimal,Decimal> {
    ...

    public small Natural precision = ...;
    public small Integer scale = ...;
    
    public extension class StringToDecimal(String string) {
    
        doc "Parse the string representation of a |Decimal| in the given radix"
        public Decimal parseDecimal(small Natural radix=10) { return ... }
        
    }

}]]></programlisting>

    </section>
    
    <section>
        <title>Instants, intervals and durations</title>
        
        <comment><para>TODO: this stuff is just for illustration, the real
        date/time API will be much more complex and fully internationalized.</para></comment>
        
        <programlisting><![CDATA[public class Instant() {
    ...
}]]></programlisting>

        <programlisting><![CDATA[public class Time(Natural hours, Natural minutes, 
        Natural? seconds=null, Natural? milliseconds=null,
        Timezone? timezone=null) 
        extends Instant() {
    public Natural hours = hours;
    public Natural minutes = minutes;
    public Natural? seconds = seconds;
    public Natural? milliseconds = milliseconds;
    public Timezone? timezone = timezone;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[public class Date(Integer year, Natural month, Natural day) 
        extends Instant() {
    public Integer year = year;
    public Natural month = month;
    public Natural day = day;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[public class Datetime(Time time, Date date) 
        extends Instant() {
    public Time time = time;
    public Date date = date;
    ...
}]]></programlisting>
        
        <programlisting><![CDATA[public class Interval<X>(X start, X end) 
        where X satisfies Instant {
    public X start = start;
    public X end = end;
    public Duration<X> duration { return ... }
    ...
}]]></programlisting>

        <programlisting><![CDATA[public class Duration<X>(Map<Granularity<X>, Natural> magnitude) 
        where X satisfies Instant {

    public Map<Granularity<X>, Natural> magnitude = magnitude;
    
    public X before(X instant) { ... }
    public X after(X instant) { ... }
    
    public Datetime before(Datetime instant) { ... }
    public Datetime after(Datetime instant) { ... }
    
    public Duration<X> add(Duration<X> duration) { ... }
    public Duration<X> subtract(Duration<X> duration) { ... }
    
    ...
}]]></programlisting>

        <programlisting><![CDATA[public interface Granularity<X> 
        where X satisfies Instant {}]]></programlisting>

        <programlisting><![CDATA[public class DateGranularity()
        satisfies Granularity<Date> {
    case year, 
    case month, 
    case week, 
    case day;
}]]></programlisting>

        <programlisting><![CDATA[public class TimeGranularity()
        satisfies Granularity<Time> {
    case hour, 
    case minute, 
    case second, 
    case millisecond;
}]]></programlisting>
        
    </section>
    
    <section>
        <title>Control expressions</title>
        
        <para>The <literal>lang.assertion</literal> package defines 
        support for assertions.</para>
        
        <programlisting><![CDATA[doc "Assert that the block evaluates to true. The block 
     is executed only when assertions are enabled. If
     the block evaluates to false, throw an 
     |AssertionException| with the given message."
public void assert(StringTemplate message, Boolean that()) {
    if ( assertionsEnabled() && !that() ) {
        throw new AssertionException(message)
    }
}]]></programlisting>
    
        <para>The <literal>lang.conditional</literal> package defines 
        support for conditional expressions.</para>
        
        <programlisting><![CDATA[doc "If the condition is true, evaluate first block,
     and return the result. Otherwise, return |null|."
public Y? ifTrue<Y>(Boolean condition,
                            Y then()) {
    if (condition) {
        return then()
    }
    else {
        return null
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the condition is true, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
public Y ifTrue<Y>(Boolean condition,
                   Y then(), 
                   Y otherwise()) {
    if (condition) {
        return then()
    }
    else {
        return otherwise()
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the value is non-null, evaluate first block,
     and return the result. Otherwise, return |null|."
public Y? ifExists<X,Y>(specified X? value,
                                Y then(coordinated X x)) {
    if (exists value) {
        return then(value)
    }
    else {
        return null
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "If the value is non-null, evaluate first block,
     otherwise, evaluate second block. Return result
     of evaluation."
public Y ifExists<X,Y>(specified X? value,
                       Y then(coordinated X x), 
                       Y otherwise()) {
    if (exists value) {
        return then(value)
    }
    else {
        return otherwise()
    }
}]]></programlisting>

        <para>The <literal>lang.exceptional</literal> package defines 
        support for exceptional expressions.</para>
        
        <programlisting><![CDATA[doc "Attempt to evaluate the first block. If an 
     exception occurs that matches the second block, 
     evaluate the block."
public Y seek<Y,E>(Y seek(),
                   Y except(E e)) {
    try {
        return seek()
    }
    catch (E e) {
        return except(e)
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "Using the given resource, attempt to evaluate 
     the first block."
public Y using<X,Y>(specified X resource,
                    Y seek(coordinated X x))
        where X satisfies Usable {
    try (resource) {
        return seek(resource)
    }
}]]></programlisting>

        <programlisting><![CDATA[doc "Using the given resource, attempt to evaluate 
     the first block. If an exception occurs that 
     matches the second block, evaluate the second 
     block."
public Y using<X,Y,E>(specified X resource,
                      Y seek(coordinated X x),
                      Y except(E e))
        where X satisfies Usable {
    try (resource) {
        return seek(resource)
    }
    catch (E e) {
        return except(e)
    }
}]]></programlisting>
    
<!--

        <programlisting><![CDATA[doc "Evaluate the block which matches the selector value, and
     return the result of the evaluation. If no block matches
     the selector value, return a null value."
public Y? select<X,Y>(X selector,
                              cases Iterable<Entry<Case<X>, functor Y()>> value) {
    for (Case<X> match -> X evaluate() in value) {
        if ( match.test(selector) ) {
            return evaluate(value)
        }
    }
    return null;
}]]></programlisting>

        <programlisting><![CDATA[doc "Evaluate the block which matches the selector value, and
     return the result of the evaluation. If no block matches
     the selector value, evaluate the last block and return
     the result of the evaluation."
public Y select<X,Y>(X selector,
                     cases Iterable<Entry<Case<X>, functor Y()>> value,
                     Y otherwise()) {
    if (exists Y y = select(selector, value)) {
        return y
    }
    else {
        return otherwise()
    }
}]]></programlisting>

-->

        <para>The <literal>lang.repetition</literal> package defines 
        support for loops.</para>
        
        <programlisting><![CDATA[doc "Repeat the block the given number of times."
public void repeat(Natural repetitions, void times()) {
    do(mutable Natural n:=0) 
    while (n<repetitions) {
        times();
        n++;
    }
}]]></programlisting>
    
        <para>The <literal>lang.quantification</literal> package defines 
        support for quantifiers.</para>
        
        <programlisting><![CDATA[doc "Count the elements for which the block 
     evaluates to true."
public Natural count<X>(iterated Iterable<X> elements,
                        Boolean having(coordinated X x)) {
    mutable Natural count := 0;
    for (X x in elements) {
        if ( having(x) ) {
            ++count;
        }
    }
    return count
}]]></programlisting>

        <programlisting><![CDATA[doc "Return true iff for every element, the block 
     evaluates to true."
public Boolean forAll<X>(iterated Iterable<X> elements,
                         Boolean every(coordinated X x)) {
    for (X x in elements) {
        if ( !every(x) ) {
            return false
        }
    }
    return true
}]]></programlisting>

        <programlisting><![CDATA[doc "Return true iff for some element, the block 
     evaluates to true."
public Boolean forAny<X>(iterated Iterable<X> elements,
                         Boolean some(coordinated X x)) {
    Boolean having(X x) { return !some(x) }
    return !forAll(elements, having)
}]]></programlisting>

        <programlisting><![CDATA[doc "Return the first element for which the block 
     evaluates to true, or |null|if no such element 
     is found."
public X? first<X>(iterated Iterable<X> elements,
                           Boolean having(coordinated X x)) {
    for (X x in elements) {
        if ( having(x) ) {
            return x
        }
    }
    return null
}]]></programlisting>

        <programlisting><![CDATA[doc "Return the first element for which the first 
     block evaluates to true, or the result of 
     evaluating the second block, if no such 
     element is found."
public X first<X>(iterated Iterable<X> elements,
                  Boolean having(coordinated X x),
                  X otherwise()) {
    if (exists X first = first(elements, having)) {
        return first
    }
    else {
        return otherwise()
    }
}]]></programlisting>
        
        <para>The <literal>lang.comprehension.list</literal> package defines 
        support for <literal>List</literal> comprehensions.</para>
        
        <programlisting><![CDATA[doc "Iterate elements and return those for which 
     the first block evaluates to true, ordered 
     using the second block, if specified."
public List<X> from<X>(iterated Iterable<X> elements,
                       Boolean having(coordinated X x),
                       Comparable by(coordinated X x) = naturalOrder) {
    X select(X x) { return x }
    return from(elements, having, select, by)
}]]></programlisting>

        <programlisting><![CDATA[doc "Iterate elements and for each element evaluate 
     the first block. Build a list of the resulting 
     values, ordered using the second block, if 
     specified."
public List<Y> from<X,Y>(iterated Iterable<X> elements,
                         Y select(coordinated X x),
                         Comparable by(coordinated X x) = naturalOrder)  {
    Boolean having(X x) { return true }
    return from(elements, having, select, by)
}]]></programlisting>

        <programlisting><![CDATA[doc "Iterate elements and select those for which 
     the first block evaluates to true. For each of 
     these, evaluate the second block. Build a list 
     of the resulting values, ordered using the 
     third block, if specified."
public List<Y> from<X,Y>(iterated Iterable<X> elements,
                         Boolean having(coordinated X x), 
                         Y select(coordinated X x),
                         Comparable by(coordinated X x) = naturalOrder) {
    OpenList<Y> list = ArrayList<Y>();
    for (X x in elements) {
        if ( having(x) ) {
            list.append( select(x) );
        }
    }
    if (exists by) {
        list.sort(by);
    }
    return list
}]]></programlisting>
        
        <para>The <literal>lang.comprehension.map</literal> package defines 
        support for <literal>Map</literal> comprehensions.</para>
        
        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given key. Each |Entry| is constructed 
     from the key and the value result of the 
     evaluation."
public Map<U,V> mapFrom<U,V>(iterated Iterable<U> keys,
                             V to(coordinated U key)) {
    Entry<U,V> of(U key) { return key->to(key) }
    return map(keys, of)
}]]></programlisting>

        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given value. Each |Entry| is constructed 
     from the value and the key result of the 
     evaluation."
public Map<U,V> mapTo<U,V>(iterated Iterable<V> values,
                           U from(coordinated V value)) { 
    Entry<U,V> of(V value) { return from(value)->value }
    return map(values, of)
}]]></programlisting>

        <programlisting><![CDATA[doc "Construct a |Map| by evaluating the block for 
     each given object and collecting the resulting 
     |Entry|s."
public Map<U,V> map<X,U,V>(iterated Iterable<X> elements,
                           Entry<U,V> of(coordinated X element)) {
    OpenMap<U,V> map = HashMap<U,V>();
    for (X x in elements) {
        map.add( of(x) );
    }
}]]></programlisting>
    
    </section>
    
</chapter>