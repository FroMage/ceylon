<chapter id="declarations">
    <title>Declarations</title>
    
    <para>Ceylon is a statically typed language. Classes, interfaces, aliases, methods, 
    attributes and locals must be declared. This allows the compiler to detect many
    errors, including:</para>
    
    <itemizedlist>
        <listitem><para>typing errors in identifier names,</para></listitem>
        <listitem><para>references to types which do not exist or are not visible,</para></listitem>
        <listitem><para>references to type members which do not exist or are not visible,</para></listitem>
        <listitem><para>argument lists which do not match formal parameter lists,</para></listitem>
        <listitem><para>type argument lists which do not match type parameter lists, and</para></listitem>
        <listitem><para>incompatible assignment of an expression of one type to a
        program element of a different type.</para></listitem>
    </itemizedlist>
    
    <para>All declarations follow a general pattern:</para>
        
    <programlisting>Annotation* 
keyword? Type? (TypeName|MemberName) TypeParams? FormalParams*
CaseTypes?
TypeClass?
ExtendedType?
SatisfiedTypes?
TypeConstraints?
Body?</programlisting>

    <para>A type parameter does not need an explicit declaration of this form unless it 
    has constraints. In the case that it does have constraints, the constraint declaration 
    does follow the general pattern.</para>
    
    <para>This consistent pattern for declarations, together with the strict block structure
    of the language, makes Ceylon a highly regular language.</para>

    <section id="compilationunitstructure">
        <title>Compilation unit structure</title>
        
        <para>A <emphasis>compilation unit</emphasis> is a text file, with the 
        filename extension <literal>.ceylon</literal>.</para>
        
        <para>A compilation unit consists of a list of imported types and methods, 
        followed by one or more toplevel type or method definitions or by a single 
        toplevel expression:</para>
        
        <programlisting>Import* (ToplevelDeclaration+ | ToplevelExpression)</programlisting>
        
        <section id="topleveldeclarations">
            <title>Toplevel declarations</title>
        
        <para>A <emphasis>toplevel declaration</emphasis> defines a type&mdash;a class, 
        interface or type alias&mdash;or a method.</para>
        
        <programlisting>ToplevelDeclaration := TypeDeclaration | Method | SimpleAttribute | AttributeGetter</programlisting>
        
        <programlisting>TypeDeclaration := Class | Object | Interface | Union | Alias</programlisting>
        
        <para>All toplevel declarations <!--with a visibility modifier less strict than
        <literal>private</literal>--> must have the same name as the compilation unit 
        filename (after removing the file suffix <literal>.ceylon</literal>). For 
        example, a <!--<literal>public</literal>--> toplevel class named <literal>Person</literal> 
        must be defined in a file named <literal>Person.ceylon</literal>. A 
        <!--<literal>public</literal>--> toplevel method named <literal>hello()</literal> 
        must be defined in a file named <literal>hello.ceylon</literal>. A toplevel
        attribute named <literal>pi</literal> must be defined in a file named
        <literal>pi.ceylon</literal>. Unlike Java, a compilation unit may contain multiple 
        toplevel class or method declarations with the same name.</para>
                    
        </section>
        
        <section id="toplevelexpressions">
            <title>Toplevel expressions</title>
        
        <para>A <emphasis>toplevel expression</emphasis> is a shorthand toplevel 
        method declaration.</para>
        
        <programlisting>ToplevelExpression := (Param ";")* Declaration* Expression</programlisting>
        
        <para>A toplevel expression is equivalent to a <literal>public</literal> 
        toplevel method declaration with the specified formal parameters, which returns 
        the specified expression. The name of the toplevel method is determined from 
        the name of the compilation unit (by removing the file suffix 
        <literal>.ceylon</literal>). For example:</para>
            
        <programlisting>String firstName; 
String lastName; 

"Hello" firstName " " lastName "!"</programlisting>

        <para>as a toplevel expression in the file <literal>hello.ceylon</literal> is 
        equivalent to:</para>
            
        <programlisting>public String hello(String firstName, String lastName) { 
    return "Hello " firstName " " lastName "!"
}</programlisting>
        
        <para>The compilation unit containing a toplevel expression may contain the 
        definition of attributes, methods, and types. These are interpreted as 
        block-local declarations of the method body. For example:</para>
        
        <programlisting>String firstName; 
String lastName; 
String name = firstName + " " + lastName;

"Hello" name "!"</programlisting>

        <para>is equivalent to:</para>
            
        <programlisting>public String hello(String firstName, String lastName) { 
    String name = firstName + " " + lastName;
    return "Hello " name "!"
}</programlisting>

        <comment><para>TODO: Alternatively, a toplevel expression could be a toplevel
        attribute.</para></comment>
        
        <comment><para>TODO: Should we allow statements in the compilation unit? If
        not, how do you write a "script" in Ceylon?</para></comment>
        
        </section>
        
    </section>
    
        <section id="imports">
            <title>Imports</title>
        
        <para>Each compilation unit belongs to exactly one <emphasis>package</emphasis>.
        Code in one compilation unit may refer to a toplevel declaration in another 
        compilation unit in the same package without explicitly importing the declaration. 
        It may refer to a declaration defined in a compilation unit in another package 
        only if it explicitly imports the declaration using the <literal>import</literal> 
        statement.</para>
        
        <programlisting>Import := "import" "extension"? FullPackageName "." ImportSpec ";"</programlisting>
        
        <para>A package is a namespace. A full package name is a period-separated list of 
        all-lowercase identifiers.</para>
        
        <programlisting>FullPackageName := PackageName ("." PackageName)*</programlisting>
        
        <para>An <literal>import</literal> statement may import either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a single (toplevel or member) type,</para>
            </listitem>
            <listitem>
                <para>a single toplevel method,</para>
            </listitem>
            <listitem>
                <para>a single toplevel attribute,</para>
            </listitem>
            <!--
            <listitem>
                <para>a single named enumerated instance of a class,</para>
            </listitem>
            -->
            <listitem>
                <para>all toplevel declarations of a specified package, or</para>
            </listitem>
            <listitem>
                <para>all <!--named enumerated instances and--> member types of a specified 
                class or interface.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>ImportSpec := TypeSpec | MethodSpec | PackageMembersSpec | TypeMembersSpec</programlisting>
        
        <para>Note that toplevel types, toplevel methods, toplevel attributes, <!--enumerated instances,--> 
        and extensions in the module <literal>ceylon.language</literal> never need to be 
        explicitly imported. They are implicitly imported by every compilation unit.</para>
        
        <para>If the <literal>extension</literal> annotation appears, the imported declaration
        must also be annotated <literal>extension</literal>.</para>
        
        <comment><para>TODO: Would it be better to specify that there is at most a single 
        <literal>import</literal> statement per source file, for example:</para>
        <programlisting>import my.query.Order, ceylon.collection.*, java.util.Map.Entry alias MapEntry;</programlisting></comment>
        
        <comment><para>TODO: Would it be better to enclose that the imported expressions
        in single quotes, as they would need to appear in the body of the source file,
        for example: <literal>'my.query.Order'</literal>, <literal>'ceylon.collection.*'</literal>,
        <literal>'java.util.Map.Entry' alias MapEntry</literal>.</para></comment>
        
        <section id="fullyexplicitimports">
            <title>Fully explicit imports</title>
        
        <para>An import statement that specifies a package name followed by a type
        name imports the type with that name from the given package.</para>
        
        <programlisting>TypeSpec := QualifiedTypeName ("alias" TypeName)?</programlisting>
        
        <para>The name of a member type must be qualified by the names of its containing
        types.</para>
        
        <programlisting>QualifiedTypeName := (TypeName ".")* TypeName</programlisting>
                
        <para>An import statement that specifies a package name followed by a method
        name imports the method with that name from the given package.</para>
        
        <programlisting>MethodSpec := MemberName ("alias" MemberName)?</programlisting>
        
        <!--
        <para>An import statement that specifies a package name followed by a type
        name and the name of an enumerated instance imports the named enumerated 
        instance.</para>
                
        <programlisting>InstanceSpec := QualifiedTypeName "." MemberName ("alias" MemberName)?</programlisting>
        -->
        
        <para>The optional <literal>alias</literal> clause in a fully-explicit import
        allows resolution of cross-namespace declaration name collisions.</para>
        
        <programlisting>import java.util.Map.Entry alias MapEntry;</programlisting>
        
        <programlisting>import my.math.fibonnacciNumber alias fib;</programlisting>
        
        <programlisting>import my.query.Order.descending alias desc;</programlisting>
        
        </section>
        
        <section id="wildcardimports">
            <title>Wildcard imports</title>
        
        <para>The character <literal>*</literal> acts as a wildcard in import statements.</para>
        
        <para>An import statement that specifies a package name followed by a wildcard
        imports all toplevel types of the package.</para>
        
        <programlisting>PackageMembersSpec := "*"</programlisting>
        
        <para>An import statement that specifies a type name followed by a wildcard
        imports all member types of the type.</para>
                
        <programlisting>TypeMembersSpec := QualifiedTypeName "." "*"</programlisting>
        
        <para>Overuse of wildcard imports is discouraged.</para>
        
        <programlisting>import ceylon.collection.*;</programlisting>
        
        <programlisting>import transaction.propagation.TxPropagationType.*;</programlisting>
        
        </section>
        
        </section>
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An <emphasis>interface</emphasis> is a type schema. Interfaces do not 
        specify the implementation of their members and may not be directly instantiated.</para>
        
        <programlisting>Interface :=
Annotation*
"interface" TypeName TypeParams?
CaseTypes?
TypeClass?
SatisfiedTypes?
TypeConstraints? 
InterfaceBody</programlisting>

        <para>To obtain a concrete instance of an interface, it is necessary to define 
        and instantiate a class that implements the interface, or define an object that
        implements the interface.</para>
        
        <!--<section id="interfacebodies">
            <title>Interface bodies</title>-->

        <para>The body of an interface contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (abstract method, abstract attribute, and member class) 
                declarations, and</para>
            </listitem>
            <listitem>
                <para>nested interface declarations.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>InterfaceBody := "{" AbstractDeclaration* "}"</programlisting>
        
        <programlisting>AbstractDeclaration := AbstractMethod | AbstractAttribute | Class | Interface</programlisting>

        <para>Interface method and attribute declarations may not specify implementation.</para>

        <comment><para>TODO: are member classes of interfaces required to be <literal>abstract</literal>?</para></comment>
        
        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>

        <!-- 
        <para>Which is equivalent to the following Java interface:</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>
        -->
        
        <comment><para>TODO: if methods of interfaces can define defaulted parameters,
        precisely how do we implement that?</para></comment>

        <section id="interfacemembervisibility">
            <title>Interface member visibility</title>
            
            <para>Interface members inherit the visibility modifier of the interface.</para>
        
            <comment><para>TODO: Refine this. Consider block-local interface declarations.</para></comment>
            
        </section>
        
        <section id="mutableinterfaces">
            <title>Mutable and immutable interfaces</title>
            
            <para>An interface may be annotated <literal>mutable</literal>. If an interface 
            is not annotated <literal>mutable</literal> it is called an <emphasis>immutable 
            type</emphasis>, and it may not:</para>
        
            <itemizedlist>
                <listitem>
                    <para>declare or inherit <literal>mutable</literal> attributes, or</para>
                </listitem>
                <listitem>
                    <para>extend an interface annotated <literal>mutable</literal>.</para>
                </listitem>
            </itemizedlist>
            
        </section>
            
        <section id="interfaceinheritance">
            <title>Interface inheritance</title>
            
            <para>An interface may extend any number of other interfaces.</para>
        
            <programlisting>public interface List&lt;T&gt;
        satisfies T[], Collection&lt;T&gt; {
    ...
}</programlisting>
        
            <para>The types listed after the <literal>satisfies</literal> keyword are the 
            supertypes. All supertypes of an interface must be interfaces. An interface 
            may not extend the same interface twice (not even with distinct type arguments).</para>
            
            <!--para>
            Since every class that implements an interface is a subclass of <literal>lang.Object</literal>,
            the interface type itself is considered assignable to <literal>lang.Object</literal>.
            </para-->
        
            <para>An interface inherits all members (methods, attributes and member types) 
            of every supertype.</para>
        
            <para>The schema of the inherited members is formed by substituting type arguments
            specified in the <literal>satisfies</literal> clause.</para>
        
            <!--
            <para>and the above declaration is equivalent to the following 
            Java declaration: 
            </para>
        
            <programlisting>public interface List&lt;T&gt; 
        extends Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
            -->
            
        </section>
        
    <section id="interfaceswithcases">
        <title>Interfaces with enumerated cases</title>
        
        <para>The <literal>of</literal> clause of an interface declaration specifies the 
        list of cases of the interface.</para>
        
        <programlisting>public interface class Node&lt;T&gt; of Root&lt;T&gt;, Branch&lt;T&gt;, Leaf&lt;T&gt; { ... }</programlisting>
        
        <para>The cases may be interfaces, classes, or anonymous classes. A case may be 
        an <literal>abstract</literal> class.</para>
        
        <para>If an anonymous class is a case of an interface type, it must extend
        <literal>ceylon.language.Case</literal>, directly or indirectly.</para>
        
        <para>If an interface has an <literal>of</literal> clause, then all subtypes of 
        the interface must be subtypes of one of the enumerated cases.</para>
                
    </section>
        
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A <emphasis>class</emphasis> is a stateful, instantiable type. It is a 
        type schema, together with implementation details of the members of the type.
        An ordinary class declaration specifies a list of formal parameters required 
        to instantiate the type.</para>
        
        <programlisting>Class :=
Annotation*
"class" TypeName TypeParams? FormalParams
CaseTypes?
TypeClass?
ExtendedType?
SatisfiedTypes?
TypeConstraints?
ClassBody</programlisting>

        <para>To obtain an instance of a class, it is necessary to instantiate the
        class, or a subclass of the class.</para> 
        
    <!--<section id="classbodies">
        <title>Class bodies</title>-->
        
        <para>The body of a class contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute, and member class) declarations,</para>
            </listitem>
            <listitem>
                <para>nested interface declarations, and</para>
            </listitem>
            <listitem>
                <para>instance initialization code.</para>
            </listitem>
        </itemizedlist>

        <programlisting>ClassBody := "{" (Declaration | Statement)* "}"</programlisting>
        
        <programlisting>Declaration := Method | SimpleAttribute | AttributeGetter | AttributeSetter | TypeDeclaration</programlisting>
        
        <!--
        <para>The body of a class may invoke, evaluate or assign members of the instance 
        being initialized&mdash;the current instance of the class&mdash;without explicitly 
        specifying the receiver.</para>
        
        <para>The body of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class or interface&mdash;the receiving instance 
        of the instantiation expression&mdash;without explicitly specifying the receiver.</para>
        
        <para>A class may be declared inside the body of a method, or attribute, in which 
        case the body of the class may refer to any non-<literal>mutable</literal> local, 
        block local attribute getter or block local method declared earlier within the 
        containing scope. It may not refer to <literal>mutable</literal> locals from the 
        containing scope.</para>
        -->

    <section id="initializerparameters">
        <title>Initializer parameters</title>
        
        <para>Ceylon classes do not support a Java-like constructor declaration syntax. 
        Instead, the body of the class declares <emphasis>initializer parameters</emphasis>. 
        An initializer parameter may be used anywhere in the class body, including in 
        method and attribute definitions.</para>
        
        <para>An initializer parameter may be used to specify or initialize the value 
        of an attribute:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock = lock;
}</programlisting>
        
        <programlisting>public class Counter(Natural start=0) {
    public mutable Natural count := start;
    public void inc() { count++; }
}</programlisting>
        
        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private final ReadAttribute&lt;Lock&gt; lock;
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) {
        this.lock = new SimpleReadAttribute&lt;Lock&gt;(lock); 
    }
    
}</programlisting>
         -->
        <para>An initializer parameter may even be used within the body of a method,
        attribute getter, or attribute setter:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock { return lock }
}</programlisting>

        <programlisting>public class Key(Lock lock) {
    public void lock() { lock.engage(this); }
    public void unlock() { lock.disengage(this); }
}</programlisting>

        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private Lock _lock;
        
    private final ReadAttribute&lt;Lock&gt; lock = new ReadAttribute&lt;Lock&gt;() {
        @Override public Lock get() { return _lock; }
    };
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) { 
        _lock = lock; 
    }
    
}</programlisting>
        -->
        

        <comment><para>TODO: should class initializer parameters be allowed to be declared 
        <literal>public/package/module</literal>, allowing a shortcut simple attribute 
        declaration like in Scala?</para></comment>
                
        <!--
        <section>
        <title>Annotations</title>
        
        <para>Every annotation is a toplevel (non-void) method call. This Ceylon class:</para>
        
        <programlisting>doc "Represents a person"
by "Gavin"
public class Person { ... }</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>public class Person { ... 

    static {
        Type&lt;Person&gt; type = Type.get(Person.class);
        type.addAnnotation( doc("Represents a person") );
        type.addAnnotation( by("Gavin") );
        type.addAnnotation( public() );
    }

    ...

}</programlisting>
        
        </section>
        -->

    </section>

    <section id="callabletypeofclass">
        <title>Callable type of a class</title>
        
        <para>The <emphasis>callable type</emphasis> of a class captures the type and formal parameter 
        types of the class. The callable type is <literal>Callable&lt;T,P...&gt;</literal>, where
        <literal>T</literal> is the class and <literal>P...</literal> are the formal parameter types 
        of the class. A sequenced parameter is considered of type <literal>T[]</literal>
        where <literal>T...</literal> is the declared sequenced type.</para>
        
        <para>An <literal>abstract</literal> class is not callable.</para>
    
    </section>
    
    <section id="initializersection">
        <title>Initializer section</title>
    
        <para>The initial part of the body of a class is called the <emphasis>initializer</emphasis> 
        and contains a mix of declarations, statements and control structures. The initializer 
        is executed every time the class is instantiated.</para>
           
        <para>A class initializer is responsible for initializing the state of the new 
        instance of the class, before a reference to the new instance is available to 
        clients.</para>
        
        <programlisting>public abstract class Point() {
    public Decimal x;
    public Decimal y;
}</programlisting>
        
        <programlisting>public class DiagonalPoint(Decimal distance) 
        extends Point() {
    
    Decimal pos = distance / 2**0.5;
    x = pos;
    y = pos;
    
    assert ("must have distance " distance " from origin") 
        that ( x**2 + y**2 &equals; distance**2 );
    
}</programlisting>
        
        <programlisting>public object Center 
        extends Point() {
    
    x = 0.0;
    y = 0.0;
    
}</programlisting>
        
        <!--
        <para>So the above class is equivalent to:</para>
        
        <programlisting>public class DiagonalPoint extends Point {
        
    public DiagonalPoint(final Decimal position) {
    
        x = y = sqrt( position.power(2).divided(2) ).times(position.sign);
        
        assert_(new F0&lt;String&gt;() {
                   public String call() { 
                       return "must have distance " + position + " from origin";
                   }
                },
                new F0&lt;Boolean&gt;() {
                   public Boolean call() { 
                       return ( x.power(2) + y.power(2) ).equals( position.power(2) );
                   }
                });
    }
    
}</programlisting>
        -->
        
        <para>The following restrictions apply to statements and declarations that appear 
        within the initializer of a class:</para>
        
        <itemizedlist>
           <listitem>
              <para>They may not evaluate attributes or invoke methods that are declared 
              later in the body of the class upon the instance that is being initialized 
              (including upon a self reference or outer instance reference).</para>
           </listitem>
           <listitem>
              <para>They may not pass a reference to the instance that is being initialized 
              (including a self reference or outer instance reference) as an argument of an 
              instantiation or method invocation or as the value of an attribute assignment.</para>
           </listitem>
           <!-- 
           <listitem>
              <para>They may not declare an <literal>abstract</literal> member class or an
              abstract method or attribute of the class.</para>
           </listitem>
           <listitem>
              <para>They may not declare a <literal>default</literal> member class, method, 
              or attribute of the class.</para>
           </listitem>
           -->
           <listitem>
              <para>They may not invoke or evaluate abstract or <literal>default</literal> 
              members of the instance that is being initialized, except via the special 
              <literal>super</literal> self reference.</para>
           </listitem>
        </itemizedlist>
        
        <para>It is acceptable to invoke or evaluate an abstract or <literal>default</literal> 
        member of a superclass that is overridden by a non-abstract, non-<literal>default</literal> 
        declaration of a different superclass or that appears earlier in the body of the 
        class.</para>
        
        <para>Non-abstract, non-<literal>default</literal> superclass members may be invoked, 
        evaluated or assigned anywhere inside the body of the class. The superclass initializer 
        is executed before the subclass initializer.</para>
        
        <para>For example, the following code fragments are not legal:</para>
        
        <programlisting>class Graph() {
    OpenList&lt;Node&gt; nodes = {};
    class Node() {
        nodes.add(this);    //compiler error (this reference in initializer)
    }
}</programlisting>
        
        <programlisting>class Graph() {
    class Node() {}
    Node createNode() {
        Node node = Node();
        nodes.add(node);    //compiler error (forward reference in initializer)
        return node
    }
    OpenList&lt;Node&gt; nodes = {};
}</programlisting>

        <para>But this code fragment is legal:</para>
        
        <programlisting>class Graph() {
    OpenList&lt;Node&gt; nodes = {};
    Node createNode() {
        Node node = Node();
        nodes.add(node);
        return node
    }
    class Node() {}
}</programlisting>

    </section>
    
    <section id="declarationsection">
        <title>Declaration section</title>
        
        <para>The remainder of the body of the class consists purely of declarations. <!--including
        abstract and <literal>default</literal> methods and attributes. --> It may not contain:</para>
        
        <itemizedlist>
            <listitem>
                <para>a statement or control structure, unless it is nested inside a method,
                attribute, or member class declaration,</para>
            </listitem>
            <listitem>
                <para>a declaration with a specifier or initializer, unless it is nested inside 
                a method, attribute, or member class declaration, or</para>
            </listitem>
            <listitem>
                <para>a specification or initialization statement for a member of the instance 
                being initialized (including a self reference or outer instance reference).</para>
            </listitem>
        </itemizedlist>
        
        <para>However, the declarations in this second section may freely use <literal>this</literal>, 
        and may invoke any method or evaluate any attribute of the class or its superclasses. 
        The usual restriction that a declaration may only be used by code that appears later in 
        the block containing the declaration is relaxed.</para>
        
        <comment><para>TODO: we could perhaps slightly relax the restrictions here. It's probably
        OK to let you have expression statements and control structures in the second part of the 
        class body, just not specification or initialization statements.</para></comment>
        
    </section>
           
    <section id="classmembervisibility">
        <title>Class member visibility</title>
        
        <para>Ordinarily, a declaration that occurs in a block of code is a block local
        declaration&mdash;it is visible only to statements and declarations that occur
        later in the same block. This rule is relaxed for certain declarations that occur 
        directly inside the body of a class:</para>
            
        <itemizedlist>
            <listitem>
                <para>declarations with explicit visibility modifiers&mdash;whose 
                visibility is determined by the modifier, and</para>
            </listitem>
            <listitem>
                <para>declarations that occur in the second part of the body of the 
                class, after the last statement of the initializer&mdash;which are visible 
                to all other declarations in the second part of the body of the class.</para>
            </listitem>
        </itemizedlist>
    </section>
        
    <section id="abstractclasses">
        <title>Abstract classes</title>
        
        <para>A class may be annotated <literal>abstract</literal> only if it is:</para>
        
        <itemizedlist>
            <listitem>
                <para>a toplevel class, or</para>
            </listitem>
            <listitem>
                <para>a member class of an <literal>abstract</literal> class.</para>
            </listitem>
        </itemizedlist>
        
        <para>If and only if a class is annotated <literal>abstract</literal> it may 
        declare:</para>
        
        <itemizedlist>
            <listitem>
                <para>abstract methods and attributes, and/or</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> member classes.</para>
            </listitem>
        </itemizedlist>
        
        <para>Classes annotated <literal>abstract</literal> may not be instantiated.</para>
        
    </section>
        
    <section id="mutableclasses">
        <title>Mutable and immutable classes</title>
        
        <para>A class may be annotated <literal>mutable</literal>. If a class is 
        annotated <literal>mutable</literal> it must (directly or indirectly) extend 
        <literal>ceylon.language.IdentifiableObject</literal>.</para>
        
        <para>If a class is not annotated <literal>mutable</literal> it is called an 
        <emphasis>immutable type</emphasis>, and it may not:</para>
        
        <itemizedlist>
            <listitem>
                <para>declare or inherit <literal>mutable</literal> attributes,</para>
            </listitem>
            <listitem>
                <para>extend a <literal>mutable</literal> superclass, or</para>
            </listitem>
            <listitem>
                <para>implement an interface annotated <literal>mutable</literal>.</para>
            </listitem>
        </itemizedlist>
    
    </section>
    
        <section id="classinheritance">
             <title>Class inheritance</title>
        
        <para>
        A class may extend another class, and implement any number of interfaces.
        </para>
        
        <programlisting>public mutable class Customer(Name name, Organization? org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>
        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt;, Identifier {
    ... 
}</programlisting>
        
        <para>
        The types listed after the <literal>satisfies</literal> keyword are the implemented
        interfaces. The type specified after the <literal>extends</literal> keyword is a 
        superclass. A class may not implement the same interface twice (not even with distinct
        type arguments).
        </para>
        
        <para>
        The semantics of class inheritance are exactly the same as Java. A class:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>inherits all members (methods, attributes, and member types) of 
                its superclass, except for members that it <emphasis>overrides</emphasis>,</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which its superclass is assignable,</para>
            </listitem-->
            <listitem>
                <para>must declare or inherit a member that overrides each member of 
                every interface it implements directly or indirectly, unless the class 
                is declared <literal>abstract</literal>, and</para>
            </listitem>
             <listitem>
                <para>must declare or inherit a member that overrides each abstract 
                member of its superclass, unless the class is declared 
                <literal>abstract</literal>.</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which any interface it implements is 
                assignable.</para>
            </listitem-->
        </itemizedlist>
        
        <para>The schema of the inherited members is formed by substituting type arguments
        specified in the <literal>extends</literal> clause.</para>
        
        <para>
        Furthermore, the initializer of the superclass is always executed before the
        initializer of the subclass whenever the subclass is instantiated.
        </para>
        
        <para>A subclass must pass values to each superclass initialization parameter in 
        the <literal>extends</literal> clause.</para>

        <programlisting>public class SpecialKey1()
        extends Key( SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>public class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>

        <!--
        <para>Which are equivalent to the Java:</para>
        
        <programlisting>public class SpecialKey1 
        extends Key {
    public SpecialKey1() { 
        super( SpecialLock() );
    }
    ... 
}</programlisting>

        <programlisting>public class SpecialKey2 
        extends Key {
    public SpecialKey2(Lock lock) { 
        super(lock);
    }
    ... 
}</programlisting>
        -->
        
        <!-- 
        <para>and the 
        above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>public class Customer 
        extends Person {
    public Customer(Name name) { this(name, null); }
    public Customer(Name name, Organization org) { super(name, org); }
    ... 
}</programlisting>
        
        <programlisting>class Token 
        extends Datetime 
        implements Comparable&lt;Token&gt;, Identifier {
    public Token() { super(); }
    ... 
}</programlisting>
         -->
        </section>
       
        <section id="overloadedclasses">
            <title>Overloaded classes</title>
            
            <para>Multiple toplevel classes belonging to the same package, or multiple 
            member classes of the same containing body may declare the same name. The 
            classes are called <emphasis>overloaded</emphasis>.</para>
            
            <para>For any class name and package or containing body, there must be a 
            single <emphasis>root class</emphasis> with the given name belonging to 
            the given package or body. Other classes with the same name belonging to the 
            same package or body:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must extend the root class,</para>
                </listitem>
                <listitem>
                    <para>must have distinct erased signatures,</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters, and</para>
                </listitem>
                <listitem>
                    <para>except for the root class, may not declare any member with a 
                    visibility modifier.</para>
                </listitem>
            </itemizedlist>
            
            <para>Then the class name always refers to the root class, except in 
            instantiation expressions. An instantiation expression is resolved to a 
            particular overloaded class declaration at compile time, using the argument 
            expression types.</para>
            
            <para>A package or body may not declare or inherit two classes with the 
            same name unless the classes are overloaded, or one class overrides the
            other class.</para>
        
        </section>
        
    <section id="overridingmemberclasses">
        <title>Overriding member classes</title>
        
        <para>Member class overriding is a unique feature of Ceylon, akin to the
        "factory method" pattern of many other languages.</para>
        
        <itemizedlist>
            <listitem>
                <para>A member class annotated <literal>default</literal> may be 
                overridden by any subtype of the class or interface which declares 
                the member class.</para>
            </listitem>
            <listitem>
                <para>A member class annotated <literal>abstract</literal> may be 
                overridden by any subtype of the class or interface which declares 
                the member class.</para>
            </listitem>
            <listitem>
                <para>A member class annotated <literal>abstract</literal> 
                <emphasis>must</emphasis> be overridden by every 
                non-<literal>abstract</literal> class which is a subtype of the 
                <literal>abstract</literal> class or interface that declares the 
                member class, unless the class inherits a 
                non-<literal>abstract</literal> member class from a superclass that 
                overrides the <literal>abstract</literal> member class.</para>
            </listitem>
        </itemizedlist>
        
        <para>To override a member class, the subtype must declare a member class:</para>
        
        <itemizedlist>
            <listitem>
                <para>annotated <literal>override</literal>,</para>
            </listitem>
            <listitem>
                <para>with the same name as the member class it overrides,</para>
            </listitem>
            <listitem>
                <para>that extends the member class it overrides, and</para>
            </listitem>
            <listitem>
                <para>with a formal parameter list with the same signature as the 
                member class it overrides, after substitution of type arguments
                specified in the <literal>extends</literal> or <literal>satisfies</literal>
                clause.</para>
            </listitem>
        </itemizedlist>
        
        <para>Finally, the overridden member class must be visible to the member
        class annotated <literal>override</literal>.</para>
        
        <para>Then instantiation of the member class is polymorphic, and the actual
        subtype instantiated depends upon the concrete type of the containing class
        instance.</para>
        
        <para>By default, the member class annotated <literal>override</literal> 
        has the same visibility modifier as the member class it overrides. The
        member class may not declare a stricter visibility modifier than the member 
        class it overrides.</para>
    
    </section>
    
    <section id="anonymousclasses">
        <title>Anonymous classes</title>
        
        <para>An <literal>object</literal> declaration makes it possible to define
        a class, instantiate an instance of the class, and declare an attribute 
        referring to the class instance in a single declaration.</para>
        
        <programlisting>Object :=
Annotation*
"object" MemberName
ExtendedType?
SatisfiedTypes?
ClassBody</programlisting>

         <para>An <literal>object</literal> declaration specifies the name of the
         attribute and the schema, supertypes, and implementation of the class. It
         does not specify a type name. Instead, the type has a name assigned 
         internally by the compiler that is not available at compilation time.</para>
         
         <para>An <literal>object</literal> class:</para>
         
         <itemizedlist>
             <!-- 
             <listitem>
                 <para>is implicitly <literal>final</literal>,</para>
             </listitem>
             -->
             <listitem>
                 <para>may not be extended by another class,</para>
             </listitem>
             <listitem>
                 <para>may not be <literal>abstract</literal>, and</para>
             </listitem>
             <listitem>
                 <para>may not declare <literal>default</literal> members.</para>
             </listitem>
         </itemizedlist>
         
         <para>If the <literal>object</literal> has a visibility modifier annotation, 
         the class has the specified visibility modifier. If the <literal>object</literal> 
         is annotated <literal>mutable</literal>, the class is a <literal>mutable</literal> 
         class.</para>
         
         <para>An <literal>object</literal> attribute:</para>
         
         <itemizedlist>
             <listitem>
                 <para>is non-<literal>mutable</literal>, and</para>
             </listitem>
             <listitem>
                 <para>may not be overridden or declared <literal>default</literal>.</para>
             </listitem>
         </itemizedlist>
         
         <para>If the <literal>object</literal> has a visibility modifier annotation, 
         the attribute has the specified visibility modifier. If the <literal>object</literal>
         is annotated <literal>override</literal>, it overrides an attribute of a
         supertype.</para>
         
         <para>The following declaration:</para>
         
         <programlisting>public object red extends Color('FF0000') {
     override String string = "Red";
}</programlisting>

         <para>Is exactly equivalent to:</para>
         
         <programlisting>class Color_red extends Color('FF0000') {
     override String string = "Red";
}

public Color_red red = Color_red();</programlisting>
         
         <para>Where <literal>Color_red</literal> is a name generated by the compiler.
         The algorithm for generating this name is not specified here.</para>
        
    </section>
    
    <section id="classeswithcases">
        <title>Classes with enumerated cases</title>
        
        <para>The <literal>of</literal> clause of a class declaration specifies the 
        list of cases of the class.</para>
        
        <programlisting>public abstract class Node(String name) of root, Branch, Leaf extends Case() { ... }</programlisting>
                
        <programlisting>public object true extends Boolean() {}
public object false extends Boolean() {}
public abstract class Boolean() of true, false extends Case() {}</programlisting>

        <para>The cases may be classes, or anonymous classes. A case may be an 
        <literal>abstract</literal> class.</para>
        
        <para>If an anonymous class is a case of a class, the class must extend
        <literal>ceylon.language.Case</literal>, directly or indirectly.</para>
        
        <para>If a class has an <literal>of</literal> clause, then all subtypes of the
        class must be subtypes of one of the enumerated cases.</para>
        
        <para>A non-<literal>abstract</literal> class may not have an <literal>of</literal> 
        clause.<!--A <literal>final</literal> class may not have an <literal>of</literal> 
        clause. --></para>
        
        <comment><para>TODO: We could let a non-<literal>abstract</literal> class
        limit its subtypes. In which case we could use the syntax <literal>of none</literal> 
        to mean <literal>final</literal>.</para></comment>
        
        <comment><para>TODO: Should we allow an abbreviated syntax like:</para>
        <programlisting>public abstract class Boolean() of case true, case false {}</programlisting>
        <para>Note that it must be <literal>case</literal> instead of <literal>object</literal>
        to resolve an ambiguity between an annotation and the class body followed by 
        a declaration.</para>
        </comment>
        
    </section>
        
    </section>
    
    <section id="unions">
        <title>Unions</title>
        
        <comment><para>NOTE: Unions are a proposed feature for a future version 
        of the language.</para></comment>
        
        <para>A <emphasis>union</emphasis> is a type with an enumerated list of
        subtypes, called the <emphasis>cases</emphasis> of the union. An instance 
        of any of these cases is an instance of union type. A union may also 
        <literal>satisfy</literal> one or more interfaces, in which case each case 
        type of the union must also satisfy these interfaces. A union itself 
        does not define members.</para>
        
        <programlisting>Union := 
Annotation* 
"choice" TypeName TypeParams?
CaseTypes
TypeClass?
SatisfiedTypes? 
TypeConstraints?
";"</programlisting>

        <!--<section id="unionbodies">
            <title>Union bodies</title>-->
            
        <para>The <literal>of</literal> clause of a union declaration specifies the 
        list of cases of the union type.</para>
        
        <programlisting>public choice Node of root, Branch, Leaf;</programlisting>
        
        <programlisting>choice Container&lt;T&gt; of T[], Set&lt;T&gt;;</programlisting>
        
        <para>The cases may be interfaces, classes, or anonymous classes. A case may 
        be an <literal>abstract</literal> class.</para>
        
        <!-- {
    
    abstract class Parent() {}
    
    object root extends Parent() {}
    
    class Branch(String name, Parent parent) 
            extends ParentNode() {
        String name = name;
        String parent = parent;
    }
    
    class Leaf(String name, Parent parent) { 
        String name = name;
        String parent = parent;
    }
    
}</programlisting> -->

        <para>If an anonymous class is a case of a union type, it must extend
        <literal>ceylon.language.Case</literal>, directly or indirectly.</para>
        
        <programlisting>public object true extends Case() {}
public object false extends Case() {}
public choice Boolean of true, false;</programlisting>
        
        <!--  
        <programlisting>public class DayOfWeek() {
    case sun,
    case mon, 
    case tues, 
    case wed, 
    case thurs, 
    case fri, 
    case sat; 
}</programlisting>

        <comment><para>TODO: Should we make the parens on the class declaration optional 
        in this case: a closed instance list with no parameters?</para></comment>

        <programlisting>public class DayOfWeek(String name) {
        
    doc "Sunday"
    case sun("Sunday"),
    
    doc "Monday" 
    case mon("Monday"),
    
    doc "Tuesday"
    case tues("Tuesday"),
    
    doc "Wednesday"
    case wed("Wednesday"),
    
    doc "Thursday"
    case thurs("Thursday"),
    
    doc "Friday"
    case fri("Friday"),
    
    doc "Saturday"
    case sat("Saturday");
       
    public String name = name;
    
}</programlisting>
-->

        <section id="mutableunions">
            <title>Mutable and immutable unions</title>
            
            <para>A union may be annotated <literal>mutable</literal>. If a union is not 
            annotated <literal>mutable</literal> it is called an <emphasis>immutable 
            type</emphasis>, and it may not:</para>
        
            <itemizedlist>
                <listitem>
                    <para>declare a <literal>mutable</literal> case, or</para>
                </listitem>
                <listitem>
                    <para>satisfy an interface annotated <literal>mutable</literal>.</para>
                </listitem>
            </itemizedlist>
            
        </section>
            
        <section id="unioninheritance">
            <title>Union inheritance</title>
            
            <para>A union may satisfy any number of other interfaces.</para>
        
        <programlisting>public choice Node of root, Branch, Leaf satisfies Observable;</programlisting>
        
        <!--  {
    
    abstract class ObservableNode()
            satisfies Observable {
        ...
    }
    
    abstract class Parent() 
            extends ObservableNode() {}
    
    object root extends Parent() {}
    
    class Branch(String name, Parent parent) 
            extends Parent() {
        String name = name;
        String parent = parent;
    }
    
    class Leaf(String name, Parent parent) 
             extends ObservableNode() { 
        String name = name;
        String parent = parent;
        ...
    }
    
}</programlisting> -->
        
            <para>The types listed after the <literal>satisfies</literal> keyword are 
            the supertypes. All supertypes of a union must be interfaces. A union may 
            not extend the same interface twice (not even with distinct type arguments).</para>
            
            <para>Every case of the union must be a subtype of every interface satisfied 
            by the union type.</para>
            
            <!--para>
            Since every class that implements an interface is a subclass of <literal>lang.Object</literal>,
            the interface type itself is considered assignable to <literal>lang.Object</literal>.
            </para-->
        
            <para>An union inherits all members (methods, attributes and member types) 
            of every supertype.</para>
        
            <para>The schema of the inherited members is formed by substituting type 
            arguments specified in the <literal>satisfies</literal> clause.</para>
            
        <!-- <programlisting>public interface TransactionPropagation {
    void propagate(Transaction tx);
}

public choice TransactionPropagationStyle 
        satisfies TransactionPropagation {
        
    abstract class BaseTransactionPropagation()
            satisfies TransactionPropagation {
        
        override void propagate(Transaction tx) {
            if (tx.inProgress) {
                inProgress(tx);
            }
            else {
                notInProgress(tx);
            }
        }
        
        package void inProgress(Transaction tx);
        
        package void notInProgress(Transaction tx);
        
    }
    
    public object required 
            extends BaseTransactionPropagation() { 
        override void inProgress(Transaction tx) {}
        override void notInProgress(Transaction tx) {
            tx.begin();
        }
    }
    
    public object supports 
            extends BaseTransactionPropagation() {
        override void inProgress(Transaction tx) {}
        override void notInProgress(Transaction tx) {}
    }
    
    public object mandatory 
            extends BaseTransactionPropagation() { 
        override void inProgress(Transaction tx) {}
        override void notInProgress(Transaction tx) {
            throw TransactionMandatory()
        }
    }
    
    public object notSupported 
            extends BaseTransactionPropagation() { 
        override void inProgress(Transaction tx) {
            throw TransactionNotSupported()
        }
        override void notInProgress(Transaction tx) {}
    }
    
    public object requiresNew 
            extends BaseTransactionPropagation() { 
        override void inProgress(Transaction tx) {
            throw TransactionRequiresNew()
        }
        override void notInProgress(Transaction tx) {
            tx.begin();
        }
    }
    
}</programlisting>-->
        
        </section>
        
    </section>
    
    <section id="methods">
        <title>Methods</title>
        
        <para>A <emphasis>method</emphasis> is a callable block of code. Methods may have 
        parameters and may return a value.</para>
        
        <programlisting>Method := MethodHeader ( Block | Specifier? ";" )</programlisting>
        
        <para>All method declarations specify the method name and one or more formal 
        parameter lists. A method declaration may specify a type, called the 
        <emphasis>return type</emphasis>, to which the values the method returns is 
        assignable, or it may specify that the method is a <literal>void</literal>
        method&mdash;a method which does not return a value. The return type of a
        <literal>void</literal> method is considered to be <literal>Void</literal>.</para>
        
        <programlisting>MethodHeader := Annotation* (InferableType | "void") MemberName TypeParams? FormalParams+ TypeConstraints?</programlisting>
        
        <para>The Ceylon compiler preserves the names of method parameters.</para>
        
        <!--<section id="methodbodies">
            <title>Method bodies</title>-->
        
        <para>A method implementation may be specified using either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a block of code, or</para>
            </listitem>
            <listitem>
                <para>a reference to another method.</para>
            </listitem>
        </itemizedlist>
        
        <!--
        <para>A member method body may invoke, evaluate or assign members of the instance
        being invoked&mdash;the current instance of the class which defines the 
        method&mdash;without explicitly specifying the receiver.</para>
        
        <para>A member method body of a member class may invoke, evaluate or assign members 
        of the current instance of the containing class or interface (the containing instance 
        of the instance upon which the method was invoked) without explicitly specifying the 
        receiver.</para>
        
        <para>A toplevel method body may not refer to <literal>this</literal> or 
        <literal>super</literal>, since there is no current instance.</para>
        
        <para>A method may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        -->
        
        <section id="callabletype">
            <title>Callable type of a method</title>
            
        <para>The <emphasis>callable type</emphasis> of a method captures the return
        type and formal parameter types of the method.</para>
        
        <itemizedlist>
        <listitem>
            <para>The callable type of a method with a single parameter list is 
            <literal>Callable&lt;T,P...&gt;</literal> where <literal>T</literal> is the 
            declared type of the method, or <literal>Void</literal> if the method is 
            <literal>void</literal>, and <literal>P...</literal> are the formal 
            parameter types of the method.</para>
        </listitem>
        <listitem>
            <para>The callable type of a method with multiple parameter lists is 
            <literal>Callable&lt;O,P...&gt;</literal>, where <literal>O</literal> is the
            callable type of a method produced by eliminating the first formal parameter
            list, and <literal>P...</literal> are the formal parameter types of the first 
            formal parameter list of the method.</para>
        </listitem>
        </itemizedlist>
        
        <para>A sequenced parameter is considered of type <literal>T[]</literal> where 
        <literal>T...</literal> is the declared sequenced type.</para>
        
        </section>
        
        <section id="methodswithblocks">
            <title>Methods with blocks</title>
            
        <para>A method implementation may be a block. If the method is a <literal>void</literal> 
        method, the block may not contain a <literal>return</literal> directive that 
        specifies an expression. Otherwise, every conditional execution path of the block 
        must end in a <literal>return</literal> directive that specifies an expression
        assignable to the return type of the method.</para>
        
        <programlisting>public Integer add(Integer x, Integer y) {
    return x + y
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token()
}</programlisting>

        <programlisting>public void print(Object... objects) {
    for (Object obj in objects) {
        log.info($obj);
    }
}</programlisting>

        <programlisting>public void addEntry(V key -> U value) {
    map.define(key,value);
}</programlisting>

        <programlisting>public Set&lt;T&gt; singleton&lt;T&gt;(T element) 
        given T satisfies Comparable&lt;T&gt; {
    return TreeSet(element)
}</programlisting>

        <programlisting>public Float[n] float&lt;#n&gt;(Decimal[n] decimals) {
    return Vector&lt;Float,#n&gt;() containing (Bounded&lt;#n&gt; i) (decimals[i].float)
}</programlisting>

        <para>Note that a method which declares the return type <literal>Void</literal>
        is not a <literal>void</literal> method. A method with declared type 
        <literal>Void</literal> must return a value of type <literal>Void</literal> 
        (any value will do).</para>
        
        <programlisting>void say(String) { ... }

void hello() {
    say("hello");
}
        
Void goodbye() {
    return say("goodbye")
}</programlisting>
        
        <para>A block local method with a single <literal>return</literal> directive may 
        be declared using the keyword <literal>local</literal> in place of the explicit 
        return type declaration. The type of the method is inferred to be the type of the 
        returned expression.</para>
        
        <programlisting>local add(Integer x, Integer y) {
    return x + y
}</programlisting>
        
        </section>
        
        <section id="methodswithspecifiers">
            <title>Methods with specifiers</title>
            
        <para>Alternatively, a method implementation may be an expression that evaluates 
        to a callable object, specified using <literal>=</literal>. The type of the 
        callable object must be assignable to the callable type of the method.</para>
        
        <programlisting>Float say(String words) = person.say;</programlisting>
        
        <programlisting>Float sqrt(Float x) = 2.root;</programlisting>
        
        <programlisting>Comparison order(String x, String y) = getOrder();</programlisting>
        
        <para>The callable object expression may not refer to formal parameters of the
        method.</para>
        
        <para>A block local method which specifies a callable object expression may be 
        declared using the keyword <literal>local</literal> in place of the explicit 
        return type declaration. The return type of the method is inferred to be the
        type of the type argument to the first type parameter of the expression type
        <literal>Callable</literal> (the return type).</para>
        
        <programlisting>local sqrt(Float x) = 2.root;</programlisting>
        
        </section>
                
        <section id="multipleparameterlists">
            <title>Methods with multiple parameter lists</title>
            
        <para>A method may declare multiple lists of formal parameters. A method which 
        declares more than one formal parameter list returns instances of 
        <literal>Callable</literal>, usually method references.</para>
        
        <para>The type of the expression specified by the <literal>return</literal> 
        directive may be be assignable to either:</para>
        
        <itemizedlist>
            <listitem><para>the callable type of a method produced by taking the 
            method with multiple parameter lists and eliminating the first formal 
            parameter list, or</para></listitem>
            <listitem><para>the declared return type of the method.</para></listitem>
        </itemizedlist>
        
        <para>If the <literal>return</literal> expression type is assignable to the 
        callable type of the method produced by eliminating the first formal parameter 
        list of the method, the method body may <emphasis>only</emphasis> refer to 
        parameters in the first parameter list. It may not refer to parameters of 
        other parameter lists. Parameters declared by parameter lists other than the 
        first parameter list are not considered visible inside the body of the 
        method.</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    Comparison order(Natural x, Natural y) { return x&lt;=&gt;y }
    return order
}</programlisting>

        <para>Otherwise, if the <literal>return</literal> expression type is assignable 
        to the declared return type of the method, the method body may refer to any
        formal parameter in any one of the formal parameter lists of the method. The 
        compiler automatically infers a series of nested methods, one for each parameter 
        list of the method. The declarations and statements in the method body form the 
        body of the most nested inferred method.</para>
        
        <para>This method declaration:</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    return x&lt;=&gt;y
}</programlisting>

        <para>is equivalent to the previous example. The compiler infers a method with
        the same signature and implementation as <literal>order()</literal> above.</para>

        <para>For a method with <literal>n</literal> parameter lists, there are 
        <literal>n</literal> inferred methods. The <literal>i</literal>th inferred 
        method:</para>
        
        <itemizedlist>
            <listitem>
                <para>has the same return type as the original declared method,</para>
            </listitem>
            <listitem>
                <para>has the same formal parameter lists as the declared method, after 
                eliminating the first <literal>i-1</literal> formal parameter lists, 
                and</para>
            </listitem>
            <listitem>
                <para>if <literal>i&lt;n</literal>, has a body which contains the
                definition of the <literal>i+1</literal>th inferred method and 
                simply returns a reference to that method, or</para>
            </listitem>
            <listitem>
                <para>otherwise, if <literal>i=n</literal>, has the body of the original
                declared method.</para>
            </listitem>
        </itemizedlist>
        
        <para>The first inferred method replaces the original declared method in the 
        definition of the class.</para>
        
        <para>This method declaration:</para>
        
        <programlisting>public String fullName(String firstName)(String middleName)(String lastName) {
    return firstName + " " + middleName + " " lastName
}</programlisting>
        
        <para>Is equivalent to:</para>
        
        <programlisting>public String fullName(String firstName)(String middleName)(String lastName) {
    String fullName2(String middleName)(String lastName) {
        String fullName3(String lastName) {
            return firstName + " " + middleName + " " + lastName
        }
        return fullName3
    }
    return fullName2
}</programlisting>
        
        <!--
        <programlisting>@FormalParameterNames({"x", "y"}) 
public Integer add(Integer x, Integer y) { ... }</programlisting>
        -->
                
        </section>
        
        <section id="overloadedmethods">
            <title>Overloaded methods</title>
            
            <para>Multiple toplevel methods belonging to the same package, or multiple 
            methods of the same containing body may may declare the same name. A class or
            interface may declare or inherit multiple methods with the same name. The 
            methods are called <emphasis>overloaded</emphasis>. Overloaded methods:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must have distinct erased signatures, and</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters.</para>
                </listitem>
            </itemizedlist>
            
            <para>A class may not not declare of inherit a method with the same name as
            an attribute it declares or inherits.</para>
            
            <para>An invocation expression is resolved to a particular overloaded method 
            declaration at compile time, using the argument expression types.</para>
            
            <para>A package or body may not declare or inherit two methods with the 
            same name unless the methods are overloaded, or one method overrides the
            other method.</para>
        
        </section>
        
       <section id="abstractmethods">
            <title>Interface methods and abstract methods</title>
            
            <para>If there is no method implementation in a method declaration, the implementation 
            of the method must be specified later in the block, or the class that declares 
            the method must be annotated <literal>abstract</literal>. If no implementation 
            is specified, the method is considered an <emphasis>abstract method</emphasis>.</para>
        
            <programlisting>public U? get(V key);</programlisting>
        
            <para>Methods declared by interfaces never specify an implementation:</para>
        
            <programlisting>AbstractMethod := MethodHeader ";"</programlisting>
            
            <para>A toplevel method declaration may not be abstract and must have a method
            implementation (a block of code, or a reference to another method).</para>

        </section>
        
        <section id="overridingmethods">
            <title>Overriding methods</title>
            
            <para>Method overriding is the foundation of polymorphism in Ceylon.</para>
            
            <itemizedlist>
            <listitem>
                <para>A method annotated <literal>default</literal> may be overridden by 
                any subtype of the class which declares the method.</para>
            </listitem>
            <listitem>
                <para>A method annotated <literal>fixed</literal> <emphasis>must</emphasis> 
                be overridden by every subtype of the class or interface which declares the
                method.</para>
            </listitem>
            <listitem>
                <para>An interface method or abstract method may be overridden by any subtype 
                of the class or interface which declares the method.</para>
            </listitem>
            <listitem>
                <para>An interface method or abstract method <emphasis>must</emphasis> be 
                overridden by every non-<literal>abstract</literal> class that is a subtype 
                of the interface or <literal>abstract</literal> class, unless the class 
                inherits a non-abstract method from a superclass which overrides the interface 
                method or abstract method.</para>
            </listitem>
            </itemizedlist>           
            
            <para>A method of a subtype <emphasis>overrides</emphasis> a method of
            a supertype if the method:</para>
            
            <itemizedlist>
                <listitem>
                    <para>is annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>has the same name as the method it overrides,</para>
                </listitem>
                <listitem>
                    <para>has the same number of formal parameter lists, with the same
                    signatures, as the method it overrides, after substitution of 
                    type arguments specified in the <literal>extends</literal> or 
                    <literal>satisfies</literal> clause of the class, and</para>
                </listitem>
                 <listitem>
                    <para>has a return type that is assignable to the return type 
                    of the method it overrides in the compilation unit containing
                    the method annotated <literal>override</literal>, after 
                    substitution of type arguments specified in the 
                    <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the overridden method must be visible to the method
            annotated <literal>override</literal>.</para>
            
            <para>If a method is annotated <literal>override</literal>, it must 
            override some method defined by a supertype, and the method it overrides 
            must be either abstract, <literal>default</literal>, or 
            <literal>fixed</literal>.</para>
            
            <para>A method may not, directly or indirectly, override two different
            methods not themselves annotated <literal>override</literal>.</para>
        
            <para>Then invocation of the method is polymorphic, and the actual
            method invoked depends upon the concrete type of the class instance.</para>
            
            <para>By default, the method annotated <literal>override</literal> has 
            the same visibility modifier as the method it overrides. The method may 
            not declare a stricter visibility modifier than the method it 
            overrides.</para>
            
            <programlisting>abstract public class AbstractSquareRooter() {
    public Float squareRoot(Float x);
}</programlisting>

            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    override Float squareRoot(Float x) { ... }
}</programlisting>
            
            <para>For interface methods or abstract methods, a special shortcut form
            of overriding is permitted. A subclass initializer may simply specify an 
            instance of <literal>Callable</literal> as the implementation of the 
            abstract method declared by the superclass. No formal parameter list, 
            return type declaration, or <literal>override</literal> annotation is 
            necessary.</para>
            
            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    Float sqrt(Float x) { ... }
    squareRoot = sqrt;
}</programlisting>
            
            <para>Toplevel methods cannot be overridden, and so toplevel method 
            invocation is never polymorphic.</para>
            
            <comment><para>TODO: are you allowed to override the default value of
            a defaulted parameter?</para></comment>
            
            <comment><para>TODO: are you required to have the same formal parameter
            names in the two methods? I don't see that this would be necessary. In
            a named parameter invocation, you just use the names declared by the
            member of the compile-time type, and they are mapped positionally to the
            parameters of the overriding method.</para></comment>
        
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to <emphasis>attribute</emphasis> 
        definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a 
                Java field or local variable).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived 
                attribute is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived 
                attribute is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be overridden by subclasses.</para>
        
        <para>All attributes have a type and name. The type of the attribute is specified
        by the simple attribute declaration or attribute getter declaration. An attribute 
        may be <literal>mutable</literal>, in which case its value can be assigned using 
        the <literal>:=</literal> and compound assignment operators. This is the case for
        simple attributes explicitly annotated <literal>mutable</literal>, or for 
        attributes with a setter declaration.</para>
            
        <programlisting>AttributeHeader := Annotation* InferableType MemberName</programlisting>
        
        <para>Note that an attribute declaration is essentially a method declaration with 
        zero formal parameter lists. Likewise, an attribute evaluation is essentially a 
        method invocation with zero argument lists.</para>
        
        <para>A toplevel attribute may not be <literal>mutable</literal>.</para>
        
        <para>An attribute of type <literal>Gettable</literal> or <literal>Settable</literal> 
        may not be <literal>mutable</literal>.</para>
        
        <para>There is no overloading for attributes. A class may not declare or inherit 
        multiple attributes with the same name.</para>
        
        <!--<section id="attributebodies">
            <title>Attribute bodies</title>-->
        <!-- 
        <para>A member attribute body may invoke, evaluate or assign members of the 
        instance being invoked&mdash;the current instance of the class which defines the 
        method&mdash;without explicitly specifying the receiver.</para>
        
        <para>A member attribute body of a member class may invoke, evaluate or assign 
        members of the current instance of the containing class or interface (the containing 
        instance of the instance upon which the attribute was invoked) without explicitly 
        specifying the receiver.</para>
        
        <para>A toplevel attribute body may not refer to <literal>this</literal> or 
        <literal>super</literal>, since there is no current instance.</para>
        
        <para>An attribute may be declared inside the body of another method or attribute, 
        in which case it may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier withing the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        -->
        <!--
        <para>
        An attribute declaration is equivalent to a Java method declaration together with 
        a Java field declaration, both of type <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal>, both with the same name as the attribute.
        </para>
        -->
        
        <section id="simpleattributesandlocals">
            <title>Simple attributes and locals</title>
            
        <para>A simple attribute defines state.</para>
        
        <programlisting>SimpleAttribute := AttributeHeader (Specifier | Initializer)? ";"</programlisting>
        
        <para>A simple attribute or local annotated <literal>mutable</literal> represents a
        value that can be assigned multiple times. A simple attribute or local not annotated
        <literal>mutable</literal> represents a value that can be specified exactly once.</para>
        
        <para>The value of a non-<literal>mutable</literal> attribute is specified using 
        <literal>=</literal>. A <literal>mutable</literal> attribute may be initialized using 
        the assignment operator <literal>:=</literal>.</para>

        <programlisting>Initializer := ":=" Expression</programlisting>

        <para>Formal parameters of classes and methods are also considered to be simple 
        attributes.</para>
        
        <!--
        <para>For a simple attribute that is not a local, the Java field is initialized to an 
        instance of <literal>lang.SimpleAttribute</literal> or 
        <literal>lang.SimpleReadAttribute</literal>. For example:</para> 
         -->
        
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; firstName = new SimpleAttribute&lt;String&gt;();
Attribute&lt;String&gt; firstName() { return firstName; }</programlisting>

        <para>While:</para>
         -->
         
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;Natural&gt; count = new SimpleAttribute&lt;Natural&gt;(0);
private Attribute&lt;Natural&gt; count() { return count; }</programlisting>

        <para>And:</para>
        -->
        
        <programlisting>public Integer max = 99;</programlisting>
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Integer&gt; max = new SimpleReadAttribute&lt;Integer&gt;(99);
public ReadAttribute&lt;Integer&gt; max() { return max; }</programlisting>
        -->

        <programlisting>public Decimal pi = calculatePi();</programlisting>
        
        <programlisting>public Natural[5] evenDigits = {0,2,4,6,8};</programlisting>

        <para>A simple attribute declared directly inside the body of a class represents state 
        associated with the instance of the class. Repeated evaluation of the attribute of a 
        particular instance of the class returns the same result until the attribute of the 
        instance is assigned a new value.</para>
        
        <para>A <emphasis>local</emphasis> represents state associated with execution of a
        particular block of code. A local is really just a special case of a simple attribute 
        declaration, but one whose state is not held across multiple executions of the block
        of code in which the local is defined.</para> 
        
        <itemizedlist>
            <listitem>
                <para>A simple attribute declared inside a block (the body of a method, attribute 
                getter or attribute setter) is a local.</para>
            </listitem>
             <listitem>
                <para>A block local simple attribute declared inside the body of a class is a 
                local if it is not used inside a method, attribute setter or attribute getter 
                declaration.</para>
            </listitem>
           <listitem>
                <para>A formal parameter of a class is a local if it is not used inside a method, 
                attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a method is a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>A local is a block local declaration&mdash;it is visible only to statements and 
        declarations that occur later in the same block or class body, and therefore it may not 
        declare a visibility modifier.</para>
        
        <para>The semantics of locals are identical to Java local variables.</para>
        
        <para>The compiler is permitted to optimize block local simple attributes to a simple 
        Java field declaration or local variable. Block local attributes may not be accessed 
        via reflection.</para>
        
        <para>A block local simple attribute with a specifier or initializer may be declared 
        using the keyword <literal>local</literal> in place of the explicit type declaration. 
        The type of the local or attribute is inferred to be the type of the specifier or
        initializer expression.</para>
        
        <programlisting>local names = List&lt;String&gt;();</programlisting>
        <programlisting>mutable local count:=0;</programlisting>
                
        </section>
        
         <section id="attributegetters">
            <title>Attribute getters</title>
            
            <para>An attribute getter is a callable block of code with no parameters,
            that returns a value.</para>
            
            <programlisting>AttributeGetter := AttributeHeader Block</programlisting>
            
            <para>An attribute getter defines how the value of a derived attribute is
            obtained.</para>
            
            <!--
            <para>For an attribute getter, the Java field is initialized to an instance 
            of an anonymous inner subclass of <literal>lang.Attribute</literal> or
            <literal>lang.ReadAttribute</literal> that overrides the <literal>get()</literal> 
            method with the content of the getter block. For example: </para>
            -->
                    
            <programlisting>public Float total {
    Float sum := 0.0;
    for (LineItem li in lineItems) {
        sum += li.amount;
    }
    return sum
}</programlisting>
        
            <para>If an attribute getter has a matching attribute setter, we say that 
            the attribute is <literal>mutable</literal>. Otherwise we say it is 
            non-<literal>mutable</literal>.</para>
            
            <!--
            <programlisting>public Float total { return items.totalPrice }</programlisting>
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final ReadAttribute&lt;Float&gt; total = new ReadAttribute&lt;Float&gt;() {
    @Override public Float get() { return items.get().totalPrice; }
};
public ReadAttribute&lt;Float&gt; total() { return total; }</programlisting>
            -->
            
            <para>A block local attribute getter with a single <literal>return</literal>
            directive may be declared using the keyword <literal>local</literal> in place of 
            the explicit type declaration. The type of the local or attribute is inferred to 
            be the type of the returned expression.</para>
        
            <programlisting>local name { 
    return Name(firstName, initial, lastName) 
}</programlisting>
                
        </section>
        
        <section id="attributesetters">
            <title>Attribute setters</title>
                    
            <para>An attribute setter is a callable block of code that accepts a
            single value and does not return a value.</para>
            
            <programlisting>AttributeSetter := Annotation* "assign" MemberName Block</programlisting>

            <para>An attribute setter defines how the value of a derived attribute is
            assigned. Every attribute setter must have a corresponding getter with the
            same name.</para>

            <programlisting>public String name { return join(firstName, lastName) }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
            
            <!--
            <para>For an attribute with a setter, the Java field is initialized to an 
            instance of an anonymous inner subclass of <literal>lang.Attribute</literal> 
            that overrides the <literal>set()</literal> method with the content of the 
            setter block. For example:
            </para>
            -->
            
            <comment><para>TODO: should we require that the corresponding getter be 
            annotated <literal>mutable</literal>?</para></comment>
            
            <comment><para>TODO: should we allow overloaded attribute setters, for example:</para>
            <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>
            </comment>
            
            <!--
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final Attribute&lt;String&gt; name = new Attribute&lt;String&gt;() {
    @Override public String get() { return join(firstName, lastName); }
    @Override public void set(String name) { firstName = first(name); lastName = last(name); }
};
public Attribute&lt;String&gt; name() { return name; }</programlisting>
            -->
        </section>
        
        <section id="abstractattributes">
            <title>Interface attributes and abstract attributes</title>
            
            <para>If there is no specifier, initializer or getter implementation, the value 
            or implementation of the attribute must be specified later in the block, or 
            the class that declares the attribute must be annotated <literal>abstract</literal>. 
            If no value or implementation is specified, the attribute is considered an 
            <emphasis>abstract attribute</emphasis>.</para>
        
            <programlisting>package mutable String firstName;</programlisting>

            <para>Attributes declared by interfaces never specify an initalizer, getter 
            or setter:</para>
        
            <programlisting>AbstractAttribute := AttributeHeader ";"</programlisting>
                        
            <para>A toplevel attribute declaration may not be abstract and must have a 
            specifier or getter implementation.</para>

        </section>
        
        <section id="overridingattributes">
            <title>Overriding attributes</title>
            
            <para>Ceylon allows attributes to be overridden, just like methods. This helps
            eliminate the need for Java-style getter and setter methods.</para>
            
            <itemizedlist>
            <listitem>
                <para>An attribute annotated <literal>default</literal> may be overridden by 
                any subtype of the class or interface which declares the method.</para>
            </listitem>
            <listitem>
                <para>A method annotated <literal>fixed</literal> <emphasis>must</emphasis> 
                be overridden by every subtype of the class or interface which declares the
                method.</para>
            </listitem>
            <listitem>
                <para>An interface attribute or abstract attribute may be overridden by any 
                subtype of the class or interface which declares the method.</para>
            </listitem>
            <listitem>
                <para>An interface attribute or abstract attribute <emphasis>must</emphasis> 
                be overridden by every non-<literal>abstract</literal> class that is a 
                subtype of the interface or <literal>abstract</literal> class, unless the 
                class inherits a non-abstract attribute from a superclass which overrides 
                the interface attribute or abstract attribute.</para>
            </listitem>
            </itemizedlist>
            
            <para>A non-<literal>mutable</literal> attribute may be overridden by a simple 
            attribute or attribute getter. A <literal>mutable</literal> attribute may be 
            overridden by a <literal>mutable</literal> simple attribute or by an attribute 
            getter and setter pair.</para>
            
            <para>An attribute of a subtype <emphasis>overrides</emphasis> an attribute of
            a supertype if the attribute:</para>
            
            <itemizedlist>
                <listitem>
                    <para>is annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>has the same name as the attribute it overrides,</para>
                </listitem>
                 <listitem>
                    <para>has a type that is assignable to the type of the attribute it 
                    overrides in the compilation unit containing the attribute annotated 
                    <literal>override</literal>, after substitution of type arguments 
                    specified in the <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class,</para>
                </listitem>
                 <listitem>
                    <para>or has <emphasis>exactly the same type</emphasis> as the 
                    attribute it overrides, after substitution of type arguments specified 
                    in the <literal>extends</literal> or <literal>satisfies</literal> clause
                    of the class, if the attribute it overrides is <literal>mutable</literal>, 
                    and</para>
                </listitem>
                <listitem>
                    <para>is <literal>mutable</literal>, if the attribute it overrides is 
                    <literal>mutable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the overridden attribute must be visible to the attribute
            annotated <literal>override</literal>.</para>
        
            <para>If an attribute is annotated <literal>override</literal>, it must 
            override some attribute defined by a supertype, and the attribute it 
            overrides must be either abstract, <literal>default</literal>, or 
            <literal>fixed</literal>.</para>
            
            <para>A method may not, directly or indirectly, override two different
            methods not themselves annotated <literal>override</literal>.</para>
        
            <para>A non-<literal>mutable</literal> attribute may be overridden by a 
            <literal>mutable</literal> attribute.</para>
            
            <comment><para>TODO: is that really allowed? It could break the superclass.
            Should we say that you are allowed to do it when you implement an interface
            attribute, but not when you override a superclass attribute?</para></comment>
            
            <para>Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance.</para>
            
            <para>By default, the attribute annotated <literal>override</literal>
            has the same visibility modifier as the attribute it overrides. The
            attribute may not declare a stricter visibility modifier than the 
            attribute it overrides.</para>
            
            <programlisting>abstract module class AbstractPi() {
    module Float pi;
}</programlisting>

            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    override Float pi { ... }
}</programlisting>
            
            <para>For interface attributes or abstract attributes, a special shortcut 
            form of overriding is permitted. A subclass initializer may simply specify 
            or assign a value to the attribute declared by the superclass. No type 
            declaration or <literal>override</literal> annotation is necessary.</para>
            
            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    Float calculatePi() { ... }
    pi = calculatePi();
}</programlisting>

            <comment><para>TODO: Why not also allow this for <literal>default</literal>
            attributes and methods??</para></comment>
            
            <para>Toplevel attribites cannot be overridden, and so toplevel attribute 
            evaluation and assignment is never polymorphic.</para>
            
        </section>
        
        <!--section id="getterandsettermethods">
            <title>Getter and setter methods</title>
            
            <para>For each attribute, one or two methods exist implicitly:</para>
            
            <itemizedlist>
                <listitem>
                    <para>a <emphasis>getter method</emphasis> with no parameters 
                    which returns the attribute type, and</para>
                </listitem>
                <listitem>
                    <para>a <literal>void</literal> <emphasis>setter method</emphasis> 
                    with a single parameter of the attribute type, if the attribute is 
                    <literal>mutable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>These methods may be referred to using the <literal>get</literal> and 
            <literal>set</literal> keywords, for example:</para>
            
            <programlisting>String name = get person.name();</programlisting>
            <programlisting>set person.name(newName);</programlisting>
            
        
        </section-->
                
    </section>
        
    <section id="typealiases">
       <title>Type aliases</title>
    
       <para>A <emphasis>type alias</emphasis> allows a type to be referred to more 
       compactly.</para>
       
       <programlisting>Alias := Annotation* "alias" TypeName TypeParams? SatisfiedTypes? TypeConstraints? ";"</programlisting>
       
       <para>A type alias may satisfy either a single interface or a single class.</para>
       
       <para>The alias type is assignable to the satisfied type, and the satisfied type 
       is assignable to the alias type.</para>
       
       <programlisting>public alias People satisfies List&lt;Person&gt;;</programlisting>
       <programlisting>alias Compare&lt;T&gt; satisfies Callable&lt;Comparison,T,T&gt;;</programlisting>
       
       <para>A shortcut is provided for definition of compilation unit local aliases.</para>
       
       <programlisting>import java.util.List alias JavaList;</programlisting>
       
       <para>Type aliases are not reified types. The metamodel reference for a type
       alias&mdash;for example, <literal>People</literal>&mdash; returns the metamodel 
       object for the aliased type&mdash;in this case, <literal>List&lt;Person&gt;</literal>.</para>
       
       <comment><para>TODO: Could we reify them? This would let us define type aliases
       that satisfy multiple interfaces. For example:</para>
       <programlisting>package alias ComparableCollection&lt;X&gt; satisfies Collection&lt;X&gt;, Comparable&lt;X&gt;;</programlisting>
       </comment>
       
       <comment><para>TODO: Could an alias have its own type class? Only if we decide to
       reify it.</para></comment>
    
    </section>
    
   <section id="declaration modifiers">
        <title>Declaration modifiers</title>
        
        <para>In Ceylon, all declaration modifiers are annotations.</para>
        
    <section id="compilerinstructions">
        <title>Summary of compiler instructions</title>
        
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>public</literal>, <literal>module</literal>
                and <literal>package</literal> <!-- <literal>private</literal> -->
                determine the visibility of a declaration (by default, the 
                declaration is visible only to statements and declarations 
                that appear later inside the same block).</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated<!--, or that a method or attribute of 
                an abstract class must be implemented by all 
                non-<literal>abstract</literal> subclasses-->.</para>
            </listitem>
            <listitem>
                <para><literal>default</literal> specifies that a method, 
                attribute, or member class may be overridden by subclasses.</para>
            </listitem>
            <listitem>
                <para><literal>override</literal> indicates that a method,
                attribute, or member type overrides a method, attribute, 
                or member type defined by a supertype.</para>
            </listitem>
            <listitem>
                <para><literal>mutable</literal> specifies that an attribute
                or local may be assigned, or that an interface or class has 
                assignable attributes.</para>
            </listitem>
            <listitem>
                <para><literal>fixed</literal> specifies that a method or
                attribute must be overridden by every subclass.</para>
            </listitem>
            <!-- 
            <listitem>
                <para><literal>final</literal> specifies that a class may not 
                be extended.</para>
            </listitem>
             -->
            <listitem>
                <para><literal>extension</literal> specifies that a method or
                attribute getter is a converter, or that a class is a decorator.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated. It accepts an optional
                <literal>String</literal> argument.</para>
            </listitem>
            <listitem>
                <para><literal>volatile</literal> indicates a volatile simple 
                attribute.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: should we have <literal>final</literal> to specify 
        that a class may not be extended?</para></comment>
        
        <comment><para>TODO: should we make <literal>override</literal> a keyword, 
        to save the effort of redeclaring the attribute type or method return type?</para></comment>
        
        <comment><para>TODO: should it be called <literal>overrides</literal>?</para></comment>
        
        <para>The following annotation is a hint to the compiler that lets 
        the compiler optimize compiled bytecode for non-64 bit architectures:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>small</literal> specifies that a value of type
                <literal>Natural</literal>, <literal>Integer</literal> or
                <literal>Float</literal> contains 32-bit values.</para>
            </listitem>
        </itemizedlist>
        
        <para>By default, <literal>Natural</literal>, <literal>Integer</literal>
        and <literal>Float</literal> are assumed to represent 64-bit values.</para>
        
        <para>The annotation names in this section are treated as keywords by 
        the Ceylon compiler. This is a performance optimization to minimize 
        the need for lookahead in the parser.</para>
        
        <comment><para>TODO: Should we require an <literal>abstract</literal>
        modifier for abstract methods and attributes of abstract classes
        like Java does?</para></comment>
        
    </section>
       
       <!--
       <para>The following annotations are important to the Ceylon SDK.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>id</literal> specifies that an attribute should
                be tested by the <literal>equals()</literal> method, and included
                in the <literal>hash</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>transient</literal> specifies that an attribute 
                is not included in the serialized form of the object.</para>
            </listitem>
            <listitem>
                <para><literal>read</literal> and <literal>write</literal>
                indicate methods or attributes that are protected from multithreaded
                access using a reentrant read/write lock with deadlock detection.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method or
                attribute getter is executed at most once, and the resulting 
                value is cached.</para>
            </listitem>
        </itemizedlist>
        -->
        
    <section id="visibility">
        <title>Visibility and name resolution</title>
        
        <para>Classes, interfaces, aliases, methods, attributes, locals, formal 
        parameters and type parameters have names. Occurrence of a name in code implies 
        a hard dependency from the code in which the name occurs to the schema of the 
        named declaration. We say that a class, interface, alias, method, attribute, 
        formal parameter or type parameter is <emphasis>visible</emphasis> to a certain 
        program element if its name may occur in the code that defines that program 
        element.</para>
        
        <itemizedlist>
            <listitem>
                <para>A formal parameter or type parameter is never visible outside the 
                declaration it belongs to.</para> 
            </listitem>
            <listitem>
                <para>Any declaration that occurs inside a block (the body of a method, 
                attribute getter or attribute setter) is not visible to code outside the 
                block.</para>
            </listitem>
        </itemizedlist>
        
        <para>The visibility of any other declaration depends upon its <emphasis>visibility
        modifier</emphasis>, if any. By default:</para>
        
        <itemizedlist>
            <listitem>
                <para>a declaration that occurs directly inside a class body is not
                visible to code outside the class definition, and</para>
            </listitem>
            <listitem>
                <para>a toplevel declaration is not visible to code outside the package 
                containing its compilation unit.</para>
            </listitem>
        </itemizedlist>
        
        <para>The visibility of a declaration with a visibility modifier annotation
        is determined by the visibility modifier:</para>
        
        <itemizedlist>
            <!--
            <listitem>
                <para><literal>private</literal> specifies that the declaration is 
                visible to all code in the same compilation unit,</para>
            </listitem>
            -->
            <listitem>
                <para><literal>package</literal> specifies that the declaration is 
                visible to all code in any compilation unit in the same package,</para>
            </listitem>
            <listitem>
                <para><literal>module</literal> specifies that the declaration is 
                visible to all code in any package in the same module,</para>
            </listitem>
            <listitem>
                <para><literal>public</literal> specifies that the declaration is 
                visible to all code in any module.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that the <literal>package</literal> modifier is redundant for toplevel 
        declarations.</para>
        
        <comment><para>TODO: Should we call the visibility levels <literal>public</literal>,
        <literal>shared</literal>, <literal>internal</literal> so they are all adjectives 
        rather than nouns?</para></comment>
        
        <para>The visibility of a nested declaration may not be less strict than the 
        visibility of the body (class body, interface body, or block) which contains 
        it. For example, a <literal>package</literal>-visibility class may not contain 
        a <literal>public</literal>-visibility attribute, method, or member class. 
        Likewise, a block may not declare a visibility modifier, so a declaration that 
        occurs inside a block may not declare a visibility modifier. Note, however, 
        that this restriction does not apply to the visibility of nested declarations 
        annotated <literal>override</literal> which inherit their visibility from the 
        declaration they override.</para>
        
        <para>The class <literal>ceylon.language.Visibility</literal> defines the visibility 
        levels:</para>
        
        <programlisting>public class Visibility {
        
    doc "A program element visible to all 
         compilation units."
    case public, 
    
    doc "A program element visible to  
         compilation units in the same
         module."
    case module, 

    doc "A program element visible to  
         compilation units in the same
         package."
    case package, 

    doc "A program element local to the
         block in which it is defined."
    case block; 
    
}</programlisting>

<!--
    doc "A program element visible to  
         the compilation unit in which
         its is declared."
    case private, 
-->
    
        <para>The following declarations define the visibility 
        modifier annotations:</para>
    
        <programlisting>doc "The |public| visibility modifier 
     annotation." 
annotation { of=any; occurs=onceEachElement; } 
public Visibility public() { 
    return public 
}</programlisting>

        <programlisting>doc "The |module| visibility modifier 
     annotation."
annotation { of=any; occurs=onceEachElement; } 
public Visibility module() { 
    return module
}</programlisting>

        <programlisting>doc "The |package| visibility modifier 
     annotation."
annotation { of=any; occurs=onceEachElement; } 
public Visibility package() { 
    return package 
}</programlisting>
        
        <!--
        <programlisting>doc "The |private| visibility modifier 
     annotation."
annotation { of=any; occurs=onceEachElement; } 
public Visibility private() { 
    return private 
}</programlisting>
        -->

        <comment><para>TODO: how are we going to go about compiling these classes which
        <emphasis>define</emphasis> the reserved-word annotations? A special compiler
        switch to turn off these reserved words? (Seems reasonable.)</para></comment>
       
    </section>
    
    <section id="extensions">
        <title>Extensions</title>
        
        <para>An extension allows values of one type to be transparently converted to 
        values of another type. Extensions are declared by annotating a method, attribute 
        or class <literal>extension</literal>. An extension must be:</para>
        
        <itemizedlist>
            <listitem>
                <para>a toplevel method with exactly one formal parameter named
                <literal>this</literal>,</para>
            </listitem>
            <listitem>
                <para>a toplevel class with exactly one initialization parameter named
                <literal>this</literal>,</para>
            </listitem>
            <listitem>
                <para>a member method with no formal parameters,</para>
            </listitem>
            <listitem>
                <para>a member class with no initializer parameters, or</para>
            </listitem>
            <listitem>
                <para>a member attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>An toplevel extension method is called a <emphasis>converter</emphasis>. 
        An toplevel extension class is called a <emphasis>decorator</emphasis>.</para>
                
        
        <programlisting>public extension Log objectToLog(Object this) {
    return this.log;
}</programlisting>
        
        <programlisting>public class Person(User user) {
    ...
    public extension User user = user;
    ...
}</programlisting>

        <programlisting>public extension class SequenceUtils&lt;N&gt;(N[] this) 
        given N extends Number, Comparable&lt;N&gt; {
    
    public N[] positiveElements() {
        return this.elements() where (N n) (n&gt;0)
    }
    
    public N[] elementsLessThan(N limit) {
        return this.elements() where (N n) (n&lt;limit)
    }
    
    ...   
}</programlisting>
        
        <para>Extensions apply to a certain <emphasis>extended type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for toplevel extension methods, the extended type is the 
                declared type of the formal parameter,</para>
            </listitem>
            <listitem>
                <para>for toplevel extension classes, the extended type is the 
                declared type of the initialization parameter,</para>
            </listitem>
            <listitem>
                <para>for member extension methods, the extended type is the type 
                that declares the extension method,</para>
            </listitem>
            <listitem>
                <para>for member extension classes, the extended type is the type 
                that contains the member class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the extended type is the type that 
                declares the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>Extensions define an <emphasis>introduced type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for extension methods, the introduced type is the declared
                return type of the method,</para>
            </listitem>
            <listitem>
                <para>for extension classes, the introduced type is the class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the introduced type is the declared
                type of the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>The introduced type may not be a <literal>mutable</literal> type.</para>

        <!-- 
        <comment><para>Note: I actually much prefer the readability of 
        <literal>User personToUser(extends Person person)</literal> and
        <literal>SequenceUtils&lt;T&gt;(extends T[] collection)</literal>, 
        but this doesn't work for attributes and member methods.</para></comment>
        -->
        
        <para>We say that a converter or decorator is <emphasis>enabled</emphasis> in 
        a compilation unit if the toplevel class or toplevel method is imported by that 
        compilation unit, and the <literal>import</literal> statement is annotated 
        <literal>extension</literal>. If the <literal>import</literal> statement is not 
        annotated <literal>extension</literal>, the declaration is imported normally but 
        the extension is not enabled in the compilation unit.</para>
        
        <programlisting>import extension org.domain.app.extensions.objectToLog;
import extension org.domain.utils.SequenceUtils;</programlisting>

        <para>A wildcard <literal>.*</literal>-style import may not be used to import 
        an extension.</para>
        
        <para>An extension attribute, member class, or member method is enabled in every 
        compilation unit.</para>
        
        <para>A type <literal>X</literal> is <emphasis>extendable</emphasis> to a type
        <literal>Y</literal> in a compilation unit if there exists exactly one possible
        sequence of enabled extensions 
        <literal>E0(T0) satisfies U0, E1(T1) satisfies U1, ... En(tn) satisfies Un</literal>, 
        such that:</para> 
        
        <itemizedlist>
            <listitem>
                <para>the extensions <literal>E0, E1, ... En</literal> are distinct,</para>
            </listitem>
            <listitem>
                <para>the introduced type <literal>Un</literal> of the last extension 
                <literal>En</literal> is a subtype of <literal>Y</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>X</literal> is a subtype of <literal>T0</literal>, the 
                extended type of the first extension <literal>E0</literal>, and is not
                a subtype of <literal>U0</literal>, its introduced type,</para>
            </listitem>
            <listitem>
                <para>for <literal>0&lt;=i&lt;n</literal>, the introduced type 
                <literal>Ui</literal> of the <literal>i</literal>th extension 
                <literal>Ei</literal> is a subtype of <literal>Ti+1</literal>, the 
                extended type of the <literal>i+1</literal>th extension 
                <literal>Ei+1</literal>, and is not a subtype of <literal>Ui+1</literal>, 
                its introduced type.</para>
            </listitem>
        </itemizedlist>
        
        <para>If a type <literal>X</literal> is extendable to a type <literal>Y</literal> 
        in a compilation unit, then <literal>X</literal> is assignable to <literal>Y</literal> 
        in that compilation unit. The compiler automatically introduces a chain of extension 
        invocations where necessary, to produce an instance of <literal>Y</literal> from an
        instance of <literal>X</literal>.</para>
        
        <para>Where an expression of type <literal>X</literal> is assigned to a program 
        element of type <literal>Y</literal> to which <literal>X</literal> is extendable, 
        the extension sequence from <literal>X</literal> to <literal>Y</literal> is 
        automatically introduced by the compiler.</para>
        
        <!-- 
        <itemizedlist>
            <listitem>
                <para>if <literal>X</literal> is a subtype of the type of the program 
                element, the extension sequence is not introduced, but otherwise</para>
            </listitem>
            <listitem>
                <para>if <literal>Y</literal> is a subtype of the type of the program 
                element, but <literal>X</literal> is not, the extension sequence
                <emphasis>is</emphasis> introduced.</para>
            </listitem>
        </itemizedlist>
        -->
        
        <para>Where a member reference is applied to an expression of type <literal>X</literal>, 
        an extension sequence may or may not be introduced:</para>
        
        <itemizedlist>
            <listitem>
                <para>if <literal>X</literal> has a member to which the reference is 
                resolveable, and if for every type <literal>Y</literal> to which <literal>X</literal> 
                is extendable that also has a member to which the reference is resolveable,
                the member of <literal>X</literal> and the member of <literal>Y</literal>
                both <literal>override</literal> a member of a common supertype, then no 
                extension sequence is introduced, but</para>
            </listitem>
            <listitem>
                <para>if <literal>X</literal> does not have a member to which the reference 
                is resolveable, and if there exists exactly one type <literal>Y</literal> 
                to which <literal>X</literal> is extendable that has a member to which the 
                reference is resolveable, the extension sequence from <literal>X</literal> 
                to <literal>Y</literal> <emphasis>is</emphasis> introduced.</para>
            </listitem>
        </itemizedlist>
        
        <para>Otherwise, the member reference is ambiguous and results in a compiler error.</para>
        
        <programlisting>import extension org.mydomain.myproject.extensions.objectToLog;
...
Person person = ...;
User user = person;
info("person is a User and this is a Log!");</programlisting>
        
        <!--
        <para>Is equivalent to the following Java code:</para>
        
        <programlisting>Person person = ...;
User user = personToUser(person);</programlisting>
        -->
        
        <programlisting>import extension org.domain.utils.SequenceUtils;
...
Integer[] zeroToOneHundred = 0..100;
Integer[] oneToNine = zeroToOneHundred.positiveElements().elementsLessThan(10);</programlisting>
        
        <!--
        <para>Is equivalent to this Java code:</para>
    
        <programlisting>Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = new SequenceUtils(collection).nonZeroElements();</programlisting>
        -->
        <!-- 
        <para>An introduced type may result in an ambiguity:</para>
        
        <itemizedlist>
            <listitem>
                <para>the introduced type may have a member type with the same name 
                as a member type of the extended type, or of some other introduced 
                type, and the two member types may have non-distinct erased signatures,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have a method with the same name as a 
                method of the extended type, or of some other introduced type, and 
                the two methods may have non-distinct erased signatures,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have an attribute with the same name 
                as an attribute or method of the extended type, or of some other 
                introduced type,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have a method with the same name as 
                an attribute of the extended type, or of some other introduced type.</para>
            </listitem>
        </itemizedlist>
        
        <para>In this case, the member type, method or attribute may not be called. 
        Any invocation or evaluation of the member results in a compiler error.</para>
        -->
         
        <para>When an introduced extension sequence is executed, for each extension
        in the sequence:</para>
        
        <itemizedlist>
            <listitem>
                <para>First, the instance of the extended type is inspected to determine
                if the runtime type is a subtype of the introduced type. If so, the
                instance is cast to the introduced type.</para>
            </listitem>
            <listitem>
                <para>Otherwise, the extension is invoked to produce an instance of the 
                introduced type that will receive the invocation or evaluation.</para>
            </listitem>
        </itemizedlist>
        
        <para>It's even possible to define an extension to a metatype:</para>
        
        <programlisting>public extension class StringType(Type&lt;String&gt; this) {
    public String concat(String a, String b) { 
        return a + " " + b 
    }
}</programlisting>

        <para>Resulting in a syntax very much like a Java-style "static" invocation.</para>

        <programlisting>log.info(String.concat(a, b));</programlisting>
        
        <!--
        <comment><para>TODO: extensions are nice, and quite powerful, but they aren't enough to
        implement an embedded query language like in JPA. Dynamic languages let you implement a
        method to respond to an unknown member invoked at runtime. Java 6 lets you do a similar
        thing at compile time using a processor (a compiler plugin). I think we can have the best
        of both worlds and let you write an extension method that returns a set of members to be
        introduced to the extended type.</para></comment>
        -->
        
    </section>
    
    <section id="annotationconstraints">
        <title>Annotation constraints</title>
        
        <para>The following meta-annotations provide information to the compiler about the 
        annotations upon which they appear. They are applied to a toplevel method declaration 
        that defines an annotation.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>inherited</literal> specifies that the annotation is automatically 
                inherited by subtypes.</para>
            </listitem>
            <listitem>
                <para><literal>annotation</literal> specifies constraints upon the occurence of 
                an annotation. By default, an annotation may appear multiple times, but may not
                occur on any kind of program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>The meta-annotation <literal>annotation</literal> accepts the following parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>occurs</literal> specifies that the annotation may occur at 
                most once in a certain scope. Its accepts one argument of type
                <literal>Occurrence</literal>: <literal>onceEachElement</literal>, 
                <literal>onceEachType</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>of</literal> specifies the kinds of program element 
                at which the annotation occurs. Its accepts one or more arguments of type
                <literal>Element</literal>: 
                <literal>classes</literal>, <literal>interfaces</literal>,
                <literal>aliases</literal>, <literal>objects</literal>, 
                <literal>methods</literal>, <literal>attributes</literal>, 
                <literal>parameters</literal>, <literal>any</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>withType</literal> specifies that the annotation may only 
                be applied to types that are assignable to the specified type, to
                attributes or parameters of the specified type, or to methods with the
                specified return type.</para>
            </listitem>
            <listitem>
                <para><literal>withParameterTypes</literal> specifies that the annotation 
                may only be applied to methods with the specified formal parameter types.</para>
            </listitem>
            <listitem>
                <para><literal>withAnnotation</literal> specifies that the annotation may 
                only be applied to program elements at which the specified annotation occurs.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>public annotation { 
    of = classes; 
    occurs = onceEachType; 
}
Entity entity(LockMode lockMode) { 
    return Entity(lockMode) 
}</programlisting>

        <programlisting>public annotation { 
    of = { attributes, parameters }; 
    withType = String; 
    occurs = onceEachElement; 
}
PatternValidator pattern(Regex regex) { 
    return PatternValidator(regex)
}</programlisting>
            
        <comment><para>TODO: Should <literal>annotation</literal> be required
        for toplevel methods which can be used as annotations?</para></comment>
        
    </section>
    
    <section id="documentation">
        <title>Documentation</title>
    
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the description of a 
                program element.</para>
            </listitem>
            <listitem>
                <para><literal>by</literal> specifies the authors of a program 
                element.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <literal>String</literal> arguments to the <literal>deprecated</literal>, 
        <literal>doc</literal>, <literal>throws</literal> and <literal>by</literal> 
        annotations are parsed by the documentation compiler as Seam Text, a 
        simple ANTLR-based wiki text format.</para>
        
        <para>These annotations are defined by the package <literal>doc</literal>:</para>
        
        <programlisting>inherited annotation { of=any; occurs = onceEachElement; }
public Description doc(String description) {
    return Description(description.normalize())
}</programlisting>
    
        <programlisting>annotation { of=any; occurs = onceEachElement; }
public Author[] by(String... authors) {
    return from (String author in authors) 
                select Author(author.normalize())
}</programlisting>
    
        <programlisting>annotation { of=any; }
public RelatedElement see(ProgramElement pe) {
    return Related(pe)
}</programlisting>
    
        <programlisting>annotation { of=any; }
public RelatedElement see(ProgramElement pe -> String description) {
    return Related(pe, description.normalize())
}</programlisting>
    
        <programlisting>annotation { of={classes, methods, attributes}; }
public Related throws(Type&lt;Exception&gt; type) {
    return ThrownException(type)
}</programlisting>
        
        <programlisting>public ThrownException throws(Type&lt;Exception&gt; type -> String description) {
    return ThrownException(type, description.normalize())
}</programlisting>

        <comment><para>TODO: Should the documentation annotations be erased by 
        the compiler? Perhaps there should be a compiler switch.</para></comment>
        
     </section>
        
     </section>

</chapter>