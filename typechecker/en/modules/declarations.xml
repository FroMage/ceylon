<chapter id="declarations">
    <title>Declarations</title>
    
    <para>All classes, interfaces, selectors, attributes, methods, constructors, 
    locals, functors, decorators and converters must be declared.</para>
    
    <section>
        <title>General declaration syntax</title>
        
        <para>All declarations follow a general pattern.</para> 
      
    <section>
    <title>Abstract declaration</title>
    
    <para>Declarations conform to the following general schema:</para>
    
    <programlisting>Annotations? 
Type? keyword? Identifier TypeParameters? FormalParameters? 
Supertype?
Interfaces? 
TypeConstraints? 
Declaration?</programlisting>

    </section>
    
    <section>
    <title>Annotation list</title>

    <para>Declarations may be preceded by a list of annotations.</para>
    
    <programlisting>Annotations := Annotation+ COLON</programlisting>
    
    </section>
    
    <section>
    <title>Type declaration</title>

    <para>Method, attribute and converter declarations must declare a type.</para>
    
    <programlisting>Type := Identifier (DOT Identifier)* TypeParameters?</programlisting>

    </section>
    
    <section>
    <title>Type parameter list</title>

    <para>Method, class, interface, decorator and converter declarations may declare 
    generic type parameters.</para>
    
    <programlisting>TypeParameters := LT Identifier (COMMA Identifier)* GT</programlisting>

    </section>

    <section>
    <title>Formal parameter list</title>

    <para>Method and class declarations may declare formal parameters, including
    optional parameters and a varargs parameter.</para>
    
    <programlisting>FormalParameters: = 
OPENPAREN
FormalParameter (COMMA FormalParameter)* (COMMA OptionalParameter)* (COMMA VarargsParameter)? | 
OptionalParameter (COMMA OptionalParameter)* (COMMA VarargsParameter)? | 
VarargsParameter?
CLOSEPAREN</programlisting>

    <programlisting>OptionalParameter = FormalParameter Initializer</programlisting>
    
    <programlisting>VarargsParameter = FormalParameter "..."</programlisting>
    
    <programlisting>FormalParameter := Annotations? Type Identifier</programlisting>
    
    </section>
    
    <section>
    <title>Extended class</title>

    <para>Classes may extend other classes using the <literal>extends</literal> clause.</para>
    
    <programlisting>Supertype := "extends" Instantiation</programlisting>

    </section>
    
    <section>
    <title>Implemented interfaces</title>

    <para>Classes, interfaces and decorators may satisfy implement or extend interfaces, 
    using the <literal>satisfies</literal> clause.</para>
    
    <programlisting>Interfaces = "satisfies" Type (COMMA Type)*</programlisting>

    </section>

    <section>
    <title>Generic type constraint list</title>

    <para>Method, class, interface, decorator and converter declarations which declare 
    generic type parameters may declare constraints upon the type parameters using the
    <literal>where</literal> clause.</para>
    
    <programlisting>TypeConstraints = "where" TypeConstraint (SEMICOLON TypeConstraint)*</programlisting>

    <programlisting>TypeConstraint := Ident (GE|LE) (Type|Ident)</programlisting>

    </section>
    
    <!--
    <section>
        <title>Declaration examples</title>
        
    <para>For example:</para>
    
    <programlisting>Comparable&lt;Person&gt; Person person = Person(name);</programlisting>
    
    <programlisting>public entity: 
class Customer(Name name, optional: Organization org = null) 
    extends Person(name, org) 
{
   ... 
}</programlisting>

    <programlisting>public:
class HashMap&lt;T&gt;(Iterable&lt;Entry&lt;T&gt;&gt; entries = none)
    extends AbstractCollection&lt;Entry&lt;T&gt;&gt;(entries)
    satisfies Map&lt;T&gt; 
    where T >= Comparable 
{ 
    ... 
}</programlisting>
    
    <programlisting>public: interface List&lt;T&gt;
    satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; 
{
    ...
}</programlisting>

    <programlisting>Integer count = 0;</programlisting>
    
    <programlisting>protected: String firstName;</programlisting>
    
    <programlisting>public: String name { return join(firstName, lastName); }
    assign { firstName = first(name); lastName = last(name); }</programlisting>
    
    <programlisting>public: Float total { return calculateTotal(lineItems); }</programlisting>
    
    <programlisting>public: Boolean login() { ... }</programlisting>
    
    <programlisting>public: 
String join(Iterable&lt;String&gt; strings, 
            String delimiter = ", ") 
{ 
   ... 
}</programlisting>
    
    <programlisting>public: Boolean functor Order&lt;T&gt;(T x, T y);</programlisting>

    <programlisting>public: decorator ComparablePerson(Person person) 
    satisfies Comparable&lt;Person&gt; 
{
   ... 
}</programlisting>
               
    <programlisting>public: Float converter IntegerToFloat(Integer int) 
{
   return Float(int);
}</programlisting>
    
    <para>Thus, the syntax of Ceylon declarations is more regular than Java or C#.</para>
    
    </section>
    -->
    
    </section>
    
    <section>
        <title>Classes</title>
        
        <para>A class is a stateful, instantiable type. Class are declared according to 
        the following:</para>
        
        <programlisting>Annotations? 
"class" Identifier TypeParameters? FormalParameters?
Supertype?
Interfaces?
TypeConstraints?
InstanceEnumeraton?
Block</programlisting>

        <section>
             <title>Class inheritance</title>
        
        <para>
        A class may extend another class, and implement any number of interfaces.
        For example:
        </para>
        
        <programlisting>public mutable entity:
class Customer(Name name, optional: Organization org = null) 
    extends Person(name, org) 
{ 
    ... 
}</programlisting>
        <programlisting>class Token() 
    extends Datetime()
    satisfies Comparable&lt;Token&gt;, Identifier
{ 
    ... 
}</programlisting>
        
        <para>
        The types listed after the <literal>satisfies</literal> keyword are the implemented
        interfaces. The type specified after the <literal>extends</literal> keyword is a 
        superclass. The semantics of class inheritance are exactly the same as Java, and the 
        above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>@entity public class Customer 
    extends Person 
{ 
    public Customer(Name name) { this(name, null); }
    public Customer(Name name, Organization org) { super(name, org); }
    ... 
}</programlisting>
        
        <programlisting>class Token 
    extends Datetime 
    implements Comparable&lt;Token&gt;, Identifier 
{ 
    public Token() { super(); }
    ... 
}</programlisting>

        </section>
       
        <section>
            <title>Class instantiation</title>
        
        <para>
        Ceylon classes do not support a Java-like constructor declaration syntax. However, 
        Ceylon supports <emphasis>class initialization parameters</emphasis>. A class 
        initialization parameter may be used anywhere in the class body.
        </para>
        
        <para>This declaration:</para>
        
        <programlisting>public: class Key(Lock lock) 
{
    public: Lock lock = lock;
}</programlisting>
        
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key 
{
    private final ReadAttribute&lt;Lock&gt; lock;
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) 
    { 
        this.lock = new SimpleReadAttribute&lt;Lock&gt;(lock); 
    }
    
}</programlisting>

        <para>This declaration:</para>
        
        <programlisting>public: class Key(Lock lock) 
{
    public: Lock lock { return lock };
}</programlisting>
        
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key 
{
    private Lock _lock;
        
    private final ReadAttribute&lt;Lock&gt; lock = new ReadAttribute&lt;Lock&gt;() {
        @Override public Lock get() { return _lock; }
    }; 
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) 
    { 
        _lock = lock; 
    }
    
}</programlisting>

        <para>Class initialization parameters are optional. The following class:</para>
        
        <programlisting>public mutable: class Point 
{
    public mutable: Exact x;
    public mutable: Exact y;
}</programlisting>
        
        <para>Is equivalent to this Java class with a default constructor:</para>
        
        <programlisting>public class Point 
{
    private final Attribute&lt;Exact&gt; x = new SimpleAttribute&lt;Exact&gt;();
    public SimpleAttribute&lt;Exact&gt; x() { return x; }
    
    private final Attribute&lt;Exact&gt; y = new SimpleAttribute&lt;Exact&gt;();
    public SimpleAttribute&lt;Exact&gt; y() { return y; }
}</programlisting>
        
        <para>A subclass must pass values to each superclass initialization 
        parameter.</para>

        <programlisting>public: 
class SpecialKey1()
    extends Key( SpecialLock() ) 
{
    ...
}</programlisting>

        <programlisting>public: 
class SpecialKey2(Lock lock) 
    extends Key(lock) 
{
    ...
}</programlisting>

        <para>Which are equivalent to the Java:</para>
        
        <programlisting>public class SpecialKey1 
    extends Key 
{
    public SpecialKey1() { 
        super( SpecialLock() );
    }
    ... 
}</programlisting>

        <programlisting>public class SpecialKey2 
    extends Key 
{
    public SpecialKey2(Lock lock) { 
        super(lock);
    }
    ... 
}</programlisting>

        <para>The body of a class may contain arbitrary code, which is
        executed when the class is instantiated.</para>
        
        <programlisting>public mutable: class DiagonalPoint(Exact position) 
    extends Point()
{
    Exact displacement = position**2/2;
    Integer sign = if (position.negative) -1 else 1;
    
    x = sqrt(displacement) * sign;
    y = sqrt(displacement) * sign;
    
    assert (x**2 + y**2 == position**2);
    
}</programlisting>
        
        <para>The compiler is permitted to optimize private attribute 
        declarations. So the above class is equivalent to:</para>
        
        <programlisting>public class DiagonalPoint extends Point
{
    public DiagonalPoint(Exact position) 
    {
        Exact displacement = position.exponentiate(2).divide(2);
        Integer sign = position.negative ? -1 : 1;
        
        x = sqrt(displacement).multiply(sign);
        y = sqrt(displacement).multiply(sign);
        assert x.exponentiate(2) + y.exponentiate(2) 
             == position.exponentiate(2);
    } 
}</programlisting>
        
        </section>

        <!--
        <para>Note that additional initialization may be performed in any
        method annotated <literal>AfterCreate</literal>. Invariants may
        be asserted in any method annotated <literal>AfterInvoke</literal>.</para>
        
        <programlisting>
Public:
class Point(Float x, Float y) 
{
    
    Public: Float x = x;
    Public: Float y = y;
    Public Constant: Date created;
    
    AfterCreate:
    void create()
        created = Date();
        
    AfterInvoke: 
    void check()
        assert sqrt( x**2 + y**2 ) &lt; 100.0;
    
}</programlisting>
        -->

        <section>
        <title>Instance enumeration</title>
        
        <para>A class may specify an enumerated list of instances:</para>
        
        <programlisting>InstanceEnumeraton := 
"instances" 
Identifier ParameterValueSet? 
(COMMA Identifier ParameterValueSet?)* 
"..."?</programlisting>

        <para>The keyword <literal>instances</literal> is used to define a set of predefined
        instances.</para>
        
        <programlisting>public: class DayOfWeek 
    instances mon, tues, wed, thurs, fri, sat, sun {}</programlisting>

        <programlisting>public: class DayOfWeek(String name)
    instances 
       mon("Monday"), 
       tues("Tuesday"),
       wed("Wednesday"),
       thurs("Thursday"),
       fri("Friday"),
       sat("Saturday"),
       sun("Sunday")
{
    public constant: String name = name;
}</programlisting>
        
        <para>
        A class with an <literal>instances</literal> declaration implicitly extends 
        <literal>lang.Selector</literal>, a subclass of <literal>java.lang.Enum</literal>. 
        The above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>public class DayOfWeek 
    extends Selector&lt;DayOfWeek&gt; 
{ 
    public DayOfWeek mon = new DayOfWeek("mon", 0); 
    public DayOfWeek tues = new DayOfWeek("tues", 1);
    public DayOfWeek wed = new DayOfWeek("wed, 2");
    public DayOfWeek thurs = new DayOfWeek("thurs", 3);
    public DayOfWeek fri = new DayOfWeek("fri", 4);
    public DayOfWeek sat = new DayOfWeek("sat", 5);
    public DayOfWeek sun = new DayOfWeek("sun", 6);
    
    private DayOfWeek(String id, int ord)
    {
        super(id, ord);
    }
    
}</programlisting>
        
        <programlisting>public class DayOfWeek 
    extends Selector&lt;DayOfWeek&gt; 
{
    private final ReadAttribute&lt;String&gt; name;
       
    public DayOfWeek mon = new DayOfWeek("Monday", "mon", 0); 
    public DayOfWeek tues = new DayOfWeek("Tuesday", "tues", 1);
    public DayOfWeek wed = new DayOfWeek("Wednesday", "wed, 2");
    public DayOfWeek thurs = new DayOfWeek("Thursday", "thurs", 3);
    public DayOfWeek fri = new DayOfWeek("Friday", "fri", 4);
    public DayOfWeek sat = new DayOfWeek("Saturday", "sat", 5);
    public DayOfWeek sun = new DayOfWeek("Sunday", "sun", 6);
     
    private DayOfWeek(String name, String id, int ord)
    {
        super(id, ord);
        name = new SimpleReadAttribute(name);
    }
    
}</programlisting>

        </section>

        <!--
        <para>A class with an <literal>instances</literal> declaration may not extend
        a class with no <literal>instances</literal> declaration.</para>
        -->
        
    </section>
    
    <section>
        <title>Interfaces</title>
        
        <para>An interface is a non-instantiable type. Interfaces may not be
        directly instantiated. Interfaces are declared according to the 
        following:</para>
        
        <programlisting>Annotations?
"interface" Identifier TypeParameters?
Interfaces?
TypeConstraints? 
OPENBRACE 
( Attribute | Method )* 
CLOSEBRACE</programlisting>

        <para>For example:</para>
        
        <programlisting>interface PaymentStrategy { ... }</programlisting>

        <programlisting>public: interface Comparable&lt;T&gt; { ... }</programlisting>

         <para>Equivalent to the following Java interfaces:</para>

        <programlisting>interface PaymentStrategy { ... }</programlisting>

        <programlisting>public interface Comparable&lt;T&gt; { ... }</programlisting>

        <section>
            <title>Interface inheritance</title>
            
        <para>An interface may extend any number of other interfaces. For example:</para>
        
        <programlisting>public: interface List&lt;T&gt;
    satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; 
{
    ...
}</programlisting>
        
        <para>
        The types listed after the <literal>satisfies</literal> keyword are the supertypes. All 
        supertypes of an interface must be interfaces. The semantics of interface inheritance 
        are exactly the same as Java, and the above declarations are equivalent to the following 
        Java declarations: 
        </para>
        
        <programlisting>public interface List&lt;T&gt; 
    extends Sequence&lt;T&gt;, Collection&lt;T&gt; 
{
    ...
}</programlisting>

        </section>
        
    </section>
    
    <!--  
    <section>
        <title>Constructors</title>
        
        <para>Constructors are declared according to the following:</para>
        
        <programlisting>Annotations? Identifier 
VariableList
( SEMICOLON | ClosedBlock )</programlisting>

        <para>
        For example:
        </para>
        
        <programlisting>Public: User(String username, Person person);</programlisting>
        <programlisting>Public: Integer(String string): value = parse(string);</programlisting>
        <programlisting>Public: User(String u, Person p) { username = u; person = p; }</programlisting>
        
        <para>
        The semantics of constructor declarations are identical to Java.
        </para>
        
        <para>
        A method body may omit the braces if it consists of exactly one statement. If
        there is no constructor body at all, the constructor assigns each parameter to
        the attribute with the same name.
        </para>
        
        <para>
        A Ceylon constructor invocation is equivalent to a Java constructor invocation.
        </para>
                
        <programlisting>@FormalParameterNames({"username", "person"}) 
public User(String username, Person person);</programlisting>

    </section>
    -->
    
    <section>
        <title>Methods</title>
        
        <para>A method is a callable block of code. Methods may have parameters and
        may return a value. Methods are declared according to one of the following:</para>
        
        <programlisting>Annotations? 
(Type | "void") Identifier TypeParameters? FormalParameters
TypeConstraints?
( SEMICOLON | Block )</programlisting>

        <para>For example:</para>
        
        <programlisting>public optional: U get(optional: V key);</programlisting>
        
        <programlisting>protected: 
void init(Integer initialCount=0) 
{
    count=initialCount;
}</programlisting>
    
        <programlisting>public: 
Integer add(Integer x, Integer y) 
{
    return x + y;
}</programlisting>
    
        <programlisting>Identifier createToken() 
{
    return Token();
}</programlisting>
    
        <programlisting>public: 
Boolean login() 
{ 
    ... 
}</programlisting>

        <programlisting>protected: 
void destroy() 
{ 
    ... 
}</programlisting>

        <programlisting>public: 
void print(Object...) 
{ 
    ... 
}</programlisting>
        
        <para>
        <!--A method body may omit the braces if it consists of exactly one statement.--> If
        there is no method body at all, the method throws <literal>UnsupportedMethodException</literal> 
        when invoked.
        </para>
        
        <para>
        The semantics of method declarations are identical to Java, except that Ceylon methods
        may declare optional parameters. Methods with optional parameters may not be overloaded.
        When a method with an optional parameter is called, and a value is not assigned to the
        optional parameter by the caller, the default value specified by the initializer is used.
        </para>
        
        <!--  
        <para>
        The semantics of method declarations are identical to Java, except that Ceylon methods
        may declare multiple types for any formal parameter and multiple return types. This
        indicates that the value passed or returned must implement or extend all the declared
        types.
        </para>
        -->
        
        <para>The Ceylon compiler preserves the names of method parameters.</para>
        
        <programlisting>@FormalParameterNames({"x", "y"}) 
public Integer add(Integer x, Integer y) { ... }</programlisting>

        <para>
        A Ceylon method invocation is equivalent to a Java method invocation.
        </para>
                
    </section>
    
    <section>
        <title>Attributes</title>
        
        <para>An attribute defines state. Attributes are declared according to the 
        following:</para>
        
        <programlisting>Annotations? 
Type Identifier 
( Initializer? SEMICOLON | Block ("assign" Block)? )</programlisting>

        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be overridden by subclasses.</para>
            
        <para>For example:</para>
        
        <programlisting>protected mutable: String firstName;</programlisting>
        
        <programlisting>mutable: Integer count = 0;</programlisting>
        
        <programlisting>public: Float total 
{
    return find (Float sum = 0.0)
        for (LineItem li in lineItems) 
            sum += li.amount;
}</programlisting>
            
        <programlisting>public: 
String name { return renderName(n); }
    assign { n = parseName(name); }</programlisting>
        
        <programlisting>public: String name 
{
    return " ".join(firstName, lastName)
}
assign 
{
    Iterator tokens = name.tokens().iterator(), 
    firstName = tokens.next(), 
    lastName = tokens.next();
}</programlisting>

        <para>
        An attribute declaration is equivalent to a Java method declaration together with 
        a Java field declaration, both of type <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal> both with the same name as the attribute.
        </para>
        
        <para>
        The compiler is permitted to optimize private attributes to a simple Java field
        declaration or a local variable in a Java constructor. Private attributes may not
        be accessed via reflection.
        </para>
        
        <section>
            <title>Attributes with getter/setter code</title>
        
        <para>
        When getter/setter code is specified, the field is initialized to an instance 
        of an anonymous inner subclass of <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal> that overrides the <literal>get()</literal> 
        and <literal>set()</literal> methods with the content of the getter and setter 
        code blocks, if any. For example:
        </para>
        
        <programlisting>public: Float total { return items.totalPrice; }</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Float&gt; total = new ReadAttribute&lt;Float&gt;() {
    @Override public Float get() { return items.get().totalPrice; }
};
public ReadAttribute&lt;Float&gt; total() { return total; }</programlisting>

        <para>While:</para>
        
        <programlisting>public: String name { return renderName(n); }
    assign { n = parseName(name); }</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; name = new Attribute&lt;String&gt;() {
    @Override public String get() { return renderName(n); }
    @Override public void set(String name) { n = parseName(name); }
};
public Attribute&lt;String&gt; name() { return name; }</programlisting>

        </section>
        
        <section>
            <title>Simple attributes</title>
            
        <para>
        If getter code is not specified, the equivalent Java declaration uses a an 
        instance of <literal>lang.SimpleAttribute</literal> or 
        <literal>lang.SimpleReadAttribute</literal>. For example:</para> 
        
        <programlisting>protected mutable: String firstName;</programlisting>

        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; firstName = new SimpleAttribute&lt;String&gt;();
protected Attribute&lt;String&gt; firstName() { return firstName; }</programlisting>

        <para>While:</para>
        
        <programlisting>mutable: Integer count = 0;</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;Integer&gt; count = new SimpleAttribute&lt;Integer&gt;(0);
private Attribute&lt;Integer&gt; count() { return count; }</programlisting>

        <para>And:</para>
        
        <programlisting>public: Integer max = 99;</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Integer&gt; max = new SimpleReadAttribute&lt;Integer&gt;(99);
public ReadAttribute&lt;Integer&gt; max() { return max; }</programlisting>

        <para>TODO: Should we generate getters and setters, just for interop with Java?</para>
        
        </section>
                
    </section>
    
    <!--  
    <section>
        <title>Selectors</title>
        
        <para>Selectors are declared according to the following:</para>
        
        <programlisting>Annotations? Type* 
"selector" Identifier
VariableList?
OPENBRACE 
SelectorValue (COMMA SelectorValue)*
( SEMICOLON ( Attribute | Method )* )? 
CLOSEBRACE</programlisting>
        
        <para>Where:</para>
        
        <programlisting>SelectorValue := Identifier ( OPENPAREN ( Expression (COMMA Expression)* )? CLOSEPAREN )?</programlisting>
        
        <para>
        For example:
        </para>
        
        <programlisting>Public: 
selector DayOfWeek 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>

        <programlisting>Public: 
selector DayOfWeek(String name) 
{ 
    MON("Monday"), TUES("Tuesday"), ...
    
    Public Constant: String name = name;
     
}</programlisting>
        
        <programlisting>Public: 
Comparator&lt;String&gt; 
selector ComparisonOperation { 
    ... 
}</programlisting>
        
        <para>
        The types listed before the <literal>selector</literal> keyword are the supertypes.
        All supertypes of a selector must be interfaces. Any constructors must be private. The 
        semantics of selector declarations and selector interface implementation are exactly the 
        same as for Java <literal>enum</literal>s, except that a Ceylon selector implicitly 
        implements <literal>lang.Selector</literal>, and the above declarations are equivalent to 
        the following Java declarations: 
        </para>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{
         
    MON("Monday"), TUES("Tuesday"), ...
     
    private DayOfWeek(String name) { ... }
    
    ...
    
}</programlisting>
        <programlisting>public enum Comparison 
    implements Comparator&lt;String&gt;, Selector&lt;Comparison&gt; 
{ 
    ... 
}</programlisting>
        
        <para>TODO: let selectors have abstract methods that are overridden by the selector values!</para>
        
    </section>
    -->
    
    <section>
        <title>Functors</title>
        
        <para>A functor represents a typed block of code. Functors are declared according to 
        the following:</para>
        
        <programlisting>Annotations? ( Type | "void" ) 
"functor" Identifier TypeParameters? 
VariableList 
TypeConstraintList? 
SEMICOLON</programlisting>
        
        <para>For example:</para>
        
        <programlisting>public: Comparison functor Order&lt;T&gt;(T x, T y);</programlisting>
        
        <para>
        A functor declaration is equivalent to a Java abstract class declaration that extends
        <literal>lang.Functor</literal> with a single abstract method declaration. For the example
        above, the equivalent Java declaration is:
        </para>
        
        <programlisting>public abstract class Order&lt;T&gt; 
    extends Functor&lt;Comparison&gt; 
{
    public abstract Comparison call(T x, T y);
    
    protected Order(Object... locals) 
    { 
        super(locals); 
    }
}</programlisting>

        <section>
            <title>Functor literals</title>
            
        <para>Consider the following functor literal:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) { x &lt;=&gt; y }</programlisting>
        
        <para>Or:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) x &lt;=&gt; y;</programlisting>
        
        <para>These literals are equivalent to this Java code:</para>

        <programlisting>Order&lt;String&gt; order = new Order&lt;String&gt;() 
{
    public Comparison call(String x, String y) 
    { 
        return Comparison.compare(x,y); 
    }
};</programlisting>
        
        <para>And this functor invocation:</para>
        
        <programlisting>Boolean result = order("Gavin", "Emmanuel");</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Boolean result = order.call("Gavin", "Emmanuel");</programlisting>
        
        </section>
        
    </section>
    
    <section>
        <title>Decorators</title>
        
        <para>A decorator introduces methods and interfaces to a given type. Decorators are 
        declared according to the following:</para>
        
        <programlisting>Annotations?
"decorator" Identifier TypeParameters? OPENPAREN Variable CLOSEPAREN
Interfaces?
TypeConstraintList? 
OPENBRACE Method* CLOSEBRACE</programlisting>

        <para>Decorators may introduce interfaces types and methods.</para>

        <section>
            <title>Introduced methods</title>
            
        <para>Methods declared by a decorator are called <emphasis>introduced methods</emphasis>.</para>
        
        <para>For example, this decorator:</para>
        
        <programlisting>public: decorator CollectionUtils&lt;T&gt;(Collection&lt;T&gt; collection) 
{
    public: Collection&lt;T&gt; nonZeroElements() 
    {
        return collection.exclude(0); 
    }
    
    ...   
}</programlisting>
        
        <para>is equivalent to this Java declaration:</para>
        
        <programlisting>public final class CollectionUtils&lt;T&gt; 
    extends Collection
{
    private final Collection&lt;T&gt; collection
    
    public CollectionUtils(Collection&lt;T&gt; collection) 
    { 
        this.collection = collection; 
    }
    
    public Collection&lt;T&gt; nonZeroElements() 
    { 
        return collection.exclude(0); 
    }
    
    ...
}</programlisting>

        <para>This introduced method call:</para>
        
        <programlisting>Collection&lt;Integer&gt; result = collection.nullElements();</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Collection&lt;Integer&gt; result = new CollectionUtils(collection).nullElements();</programlisting>
        
        <para>A decorator may not override a method defined by the decorated type. Methods defined 
        by the decorated type are delegated to the decorated instance.</para>

        </section>
        
        <section>
            <title>Introduced types</title>
            
        <para>Types appearing after the <literal>satisfies</literal> keyword must be interfaces, and
        are called the <emphasis>introduced types</emphasis>.</para>
        
        <para>This decorator declaration:</para>
        
        <programlisting>public: decorator ComparableUser(User user) 
    satisfies Comparable&lt;User&gt; 
{
    public: Comparison compare(User other) 
    {
        return user.username &lt;=&gt; other.username;
    }
}</programlisting>
        
        <para>is equivalent to this Java declaration:</para>
        
        <programlisting>public final class ComparableUser 
    extends User
    implements Comparable&lt;User&gt; 
{
    private final User user;
    
    public ComparableUser(User user) 
    { 
        this.user = user; 
    }
    
    public Comparison compareTo(User other) 
    { 
        return Comparison.compare(other.username, user.username);
    }
}</programlisting>

        </section>
                
    </section>
    
    <section>
        <title>Converters</title>
        
        <para>A converter allows immutable values of one type to be transparently converted to
        values of another type. Converters are declared according to the following:</para>
        
        <programlisting>Annotations? Type 
"converter" Identifier TypeParameters? 
TypeConstraintList? 
OPENPAREN Variable CLOSEPAREN 
Block</programlisting>

        <para>For example:</para>
        
        <programlisting>User converter PersonUser(Person person) 
{
    return person.user;
}</programlisting>
        
        <para>A converter declaration is equivalent to a Java class declaration. The example 
        above is equivalent to the following Java class:</para>
        
        <programlisting>public final class PersonUser 
    extends Converter&lt;Person, User&gt; 
{
    @Override User convert(Person person) 
    {
        return person.user; 
    }
}</programlisting>

        <para>The Ceylon compiler searches for an appropriate converter whenever a value is
        assigned to a non-assignable type. If a converter for the types is found, the 
        compiler inserts a call to the converter. For example, this Ceylon assignment:</para>
        
        <programlisting>Person person = ...;
User user = person;</programlisting>

        <para>Is equivalent to the following Java code:</para>
        
        <programlisting>Person person = ...;
User user = new PersonUser().convert(person);</programlisting>

    </section>
        
    <section>
        <title>Locals</title>
        
        <para>A local is really just a special case of an attribute declaration, but one that 
        is optimized by the compiler. Locals are declared according to the following:</para>
        
        <programlisting>Annotations? Type Identifier Initializer? SEMICOLON</programlisting>
        
        <para>For example:</para>
        
        <programlisting>optional: String firstName;</programlisting>
        <programlisting>mutable: Integer count = 0;</programlisting>
        
        <para>The semantics of local declarations are identical to Java local variables.</para>
        
        <para>Formal parameters are also considered to be locals.</para>
        
    </section>

</chapter>