<chapter id="declarations">
    <title>Declarations</title>
    
    <para>All classes, interfaces, methods, attributes and locals must be declared.</para>
    
    <section id="generaldeclarations">
        <title>General declaration syntax</title>
        
        <para>All declarations follow a general pattern.</para> 
      
    <section id="abstractdeclaration">
        <title>Abstract declaration</title>
        
        <para>Declarations conform to the following general schema:</para>
        
        <programlisting>Annotation* 
keyword? Type? (TypeName|MemberName) TypeParams? FormalParams*
Supertype?
Interfaces? 
TypeConstraints? 
Body?</programlisting>

        <para>The Ceylon compiler enforces identifier naming conventions. Types must
        be named with an initial uppercase. Members, parameters and locals must be 
        named with an initial lowercase or underscore.</para>
        
        <programlisting>PackageName := LIdentifier</programlisting>
        <programlisting>TypeName := UIdentifier</programlisting>
        <programlisting>MemberName := LIdentifier</programlisting>
        <programlisting>ParameterName := LIdentifier</programlisting>
        
   </section>
      
    <section id="topleveldeclaration">
        <title>Type declarations</title>
        
        <para>A type declaration declares a class, interface or type alias.</para>
        
        <programlisting>TypeDeclaration := Class | Interface | Alias</programlisting>
        
        <comment><para>TODO: Should we support toplevel static method declarations?</para></comment>

        <para>A compilation unit consists of a list of imported types, followed by
        one or more type declarations:</para>
        
        <programlisting>Import* TypeDeclaration+</programlisting>
        
        <programlisting>Import := "import" ImportElement ("." ImportElement)* ('.' '*' | "alias" ImportElement)? ";"</programlisting>
        
        <programlisting>ImportElement := PackageName | TypeName | MemberName</programlisting>
    
     </section>
    
    <section id="annotationlist">
    <title>Annotation list</title>

        <para>Declarations may be preceded by a list of annotations.</para>
    
        <programlisting>Annotation := MemberName ( Arguments | Literal+ )?</programlisting>
        
        <para>Unlike Java, the name of an annotation may not be a qualified name.</para>
        
        <para>An annotation is a static method call. For an annotation with no 
        arguments, or with only literal-valued arguments, the parentheses around, 
        and commas between, the positional arguments may be omitted.</para>
        
        <para>For example:</para>
        
        <programlisting>doc "The user login action"
throws #DatabaseException 
       "if database access fails"
by "Gavin King"
   "Andrew Haley"
see #LogoutAction.logout
scope(session) 
action { description="Log In"; url="/login"; }
public deprecated</programlisting>

        <!--
        <comment>
        <para>TODO: to eliminate backtracking in the parser, we could do one of the
        following things:</para>
        <itemizedlist>
            <listitem>
                <para>require that member declarations with annotations be preceded
                by a <literal>def</literal> keyword,</para>
            </listitem>
            <listitem>
                <para>require that all member declarations be preceded by one of
                <literal>public/module/package/private</literal> or <literal>override</literal>,
                or</para>
            </listitem>
            <listitem>
                <para>surround all the annotations in brackets, like C#.</para>
            </listitem>
        </itemizedlist>
        
        <para>NOTE: we can get much of the value of the <literal>def</literal> keyword with
        a recommendation to developers that they put one of <literal>public/module/package</literal> 
        or <literal>override</literal>, first in the annotation list, and outlaw the use of those 
        identifiers as names of members and local variables. This is enough of a hint to the 
        compiler to eliminate backtracking in almost every case.</para></comment>
        -->
        
    </section>
    
    <section id="formalparameterlist">
        <title>Formal parameter list</title>
    
        <para>Method and class declarations may declare formal parameters, including
        defaulted parameters and a varargs parameter.</para>
        
        <programlisting>FormalParams := 
"("
FormalParam ("," FormalParam)* ("," DefaultParam)* ("," VarargsParam)? | 
DefaultParam ("," DefaultParam)* ("," VarargsParam)? | 
VarargsParam?
")"</programlisting>

        <programlisting>FormalParam := Param | EntryParamPair | RangeParamPair</programlisting>
        
        <para>Each parameter is declared with a type and name and may have annotations and/or
        parameters of its own.</para>
        
        <programlisting>Param := Annotation* Type ParameterName FormalParams*</programlisting>
        
        <para>A parameter with its own parameter list (or lists) is called a 
        <emphasis>functional parameter</emphasis>. Think of it as an abstract local method that 
        must be defined by the caller when the method is invoked or the class is instantiated. 
        For example:</para>
            
        <programlisting>(String label, void onClick())</programlisting>
        
        <programlisting>(Comparison by(X x, X y))</programlisting>
        
        <para>Defaulted parameters specify a default value.</para>
    
        <programlisting>DefaultParam := FormalParam Specifier</programlisting>
        
        <para>The <literal>=</literal> specifier is used throughout the language to indicate a 
        value which cannot be reassigned.</para>
        
        <programlisting>Specifier := "=" Expression</programlisting>
        
        <para>For example:</para>
        
        <programlisting>(Product product, Natural quantity=1)</programlisting>
        
        <para>A varargs parameter accepts a list of arguments or a single argument of type 
        <literal>Iterable</literal>. Inside the method, it is available as a local of type
        <literal>Iterable</literal>.</para>
        
        <programlisting>VarargsParam := Annotation* Type "..." ParameterName</programlisting>
        
        <para>For example:</para>
        
        <programlisting>(Name name, optional Organization org=null, Address... addresses)</programlisting>
        
        <comment><para>TODO: should we just make <literal>X...</literal> a syntactic shorthand
        for <literal>Iterable&lt;X&gt;</literal> everywhere?</para></comment>
        
        <para>Parameters of type <literal>Entry</literal> or <literal>Range</literal> 
        may be specified as a pair of variables.</para>
        
        <programlisting>EntryParamPair := Annotation* Type ParameterName "->" Type ParameterName</programlisting>

        <programlisting>RangeParamPair := Annotation* Type ParameterName ".." ParameterName</programlisting>
        
        <para>A variable pair declaration of form <literal>U u -> V v</literal> results in a single 
        parameter of type <literal>Entry&lt;U,V&gt;</literal>.</para>
        
        <programlisting>(Key key -> Value value)</programlisting>
        
        <para>A variable pair declaration of form <literal>T x .. y</literal> results in a single 
        parameter of type <literal>Range&lt;T&gt;</literal>.</para>
        
        <programlisting>(Float value, Integer min..max)</programlisting>
    
    </section>
    
    <section id="generictypeparameters">
        <title>Generic type parameters</title>
    
         <para>Method, class and interface declarations may declare generic type parameters.</para>
        
        <programlisting>TypeParams := "&lt;" TypeParam ("," TypeParam)* "&gt;"</programlisting>
        
        <programlisting>TypeParam := Variance TypeName</programlisting>
        
        <para>A covariant type parameter is indicated using <literal>out</literal>.
        A contravariant type parameter is indicated using <literal>in</literal>.</para>
        
        <programlisting>Variance :=  ("out" | "in")?</programlisting>
    
        <para>For example:</para>
        
        <programlisting>Map&lt;K, V&gt;</programlisting>
        
        <programlisting>Sender&lt;in M&gt;</programlisting>
        
        <programlisting>Container&lt;out T&gt;</programlisting>
        
        <programlisting>BinaryFunction&lt;in X, in Y, out R&gt;</programlisting>
        
    </section>


    <section id="typedeclaration">
        <title>Type declaration</title>
    
        <para>Method and attribute declarations must declare a type.</para>
        
        <programlisting>Type := RegularType | "subtype"</programlisting>
        
        <para>Most types are classes or interfaces:</para>
        
        <programlisting>RegularType := QualifiedTypeName TypeArguments?</programlisting>
        
        <para>Unlike Java, the name of a type may not be qualified by the package name.</para>
        
        <programlisting>QualifiedTypeName := (TypeName ".")* TypeName</programlisting>
        
        <para>A generic type must specify arguments for the generic type parameters.</para>
        
        <programlisting>TypeArguments := "&lt;" Type ("," Type)* "&gt;"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>Map&lt;Key, List&lt;Item&gt;&gt;</programlisting>
        
        <para>Every Ceylon class and interface has an implicit type parameter that never
        needs to be declared. This special type parameter, referred to using the keyword 
        <literal>subtype</literal>, represents the concrete type of the current instance 
        (the instance that is being invoked).</para>
        
        <para>For example:</para>
        
        <programlisting>public interface Wrapper&lt;out X&gt; {}</programlisting>
        
        <programlisting>public abstract class Wrappable {
   public Wrapper&lt;subtype&gt; wrap() {
       return Wrapper(this);
   }
}</programlisting>
        
        <programlisting>public class Special() extends Wrappable() {}</programlisting>

        <programlisting>Special special = Special();
Wrapper&lt;Special&gt; wrapper = special.wrap();</programlisting>

        <para>For a class declared <literal>final</literal>, any instance of the class
        may be assigned to the type <literal>subtype</literal>. For a class not declared
        <literal>final</literal>, only the <literal>this</literal> reference is
        assignable to <literal>subtype</literal>.</para>
        
        <para>The type <literal>subtype</literal> is considered a covariant type parameter
        of the type, and may not appear in contravariant positions of the type declaration.</para>
        
    </section>
    
    <!--section>
        <title>Functor type declaration</title>
    
        <para>There are also functor types:</para>
        
        <programlisting>FunctorType := FunctorHeader FormalParams</programlisting>
        
        <programlisting>FunctorHeader := "functor" Annotation* (Type | "void")</programlisting>
        
        <para>The parameter names in a functor type declaration do not affect assignability
        of the functor type. They are used when the functor is invoked using named parameters.</para>
        
        <para>For example:</para>
        
        <programlisting>functor Comparison(X x, X y)</programlisting>
        <programlisting>functor Boolean(Payment payment)</programlisting>
        <programlisting>functor void(Y element)</programlisting>
        <programlisting>functor optional Object()</programlisting>
        <programlisting>functor Y(optional Y object, Factory&lt;Y&gt; factory)</programlisting>
        
        <para>Functor types are covariant in the return type, and contravariant in the
        parameter types. So <literal>functor String(Object o)</literal> is assignable to
        <literal>functor Object(String s)</literal>.</para>
        
    </section-->

    <section id="extendedclass">
        <title>Extended class</title>
    
        <para>Classes may extend other classes using the <literal>extends</literal> clause.</para>
        
        <programlisting>Supertype := "extends" RegularType PositionalArguments</programlisting>
    
        <para>For example:</para>
        
        <programlisting>extends Person(name, org)</programlisting>
    
    </section>
    
    <section id="satisfiedinterfaces">
        <title>Satisfied interfaces</title>
    
        <para>Classes and interfaces may satisfy (implement or extend) interfaces, 
        using the <literal>satisfies</literal> clause.</para>
        
        <programlisting>Interfaces = "satisfies" Type ("," Type)*</programlisting>
    
        <para>For example:</para>
        
        <programlisting>satisfies Sequence&lt;T&gt;, Collection&lt;T&gt;</programlisting>
    
    </section>

    <section id="generictypeconstraintlist">
    <title>Generic type constraint list</title>

        <para>Method, class and interface declarations which declare generic type 
        parameters may declare constraints upon the type parameters using the
        <literal>where</literal> clause.</para>
        
        <programlisting>TypeConstraints = "where" TypeConstraint (AMPERSAND TypeConstraint)*</programlisting>
    
        <programlisting>TypeConstraint := TypeName ( ("&gt;="|"&lt;=") Type | '=' 'subtype' | FormalParams ) </programlisting>
        
        <para>There are four kinds of type constraints:</para>
        
        <itemizedlist>
            <listitem>
                <para>upper bounds,</para>
            </listitem>
            <listitem>
                <para>lower bounds</para>
            </listitem>
            <listitem>
                <para>subtype bounds, and</para>
            </listitem>
            <listitem>
                <para>initialization parameter specifications.</para>
            </listitem>
        </itemizedlist>
        
        <para>For example:</para>
        
        <programlisting>where X >= Number&lt;X&gt; &amp; Y = subtype &amp; Y(Natural count)</programlisting>
        
        <para>Subtype bounds are needed since the special type <literal>subtype</literal>
        cannot appear in a contravariant position.</para>
        
        <para>Initialization parameter specifications allow instantiation of the
        generic type.</para>
        
        <comment><para>TODO: Should we use <literal>for</literal> instead of <literal>where</literal>?</para></comment>
        
        <comment><para>TODO: Should we use <literal>satisfies</literal> instead of <literal>>=</literal>? 
        For example <literal>where X satisfies Number&lt;X&gt;</literal>.</para></comment>
    
    </section>
    
    <!--
    <section>
        <title>Declaration examples</title>
        
    <para>For example:</para>
    
    <programlisting>Comparable&lt;Person&gt; Person person = Person(name);</programlisting>
    
    <programlisting>public entity 
class Customer(Name name, optional Organization org = null) 
    extends Person(name, org) 
{
   ... 
}</programlisting>

    <programlisting>public
class HashMap&lt;T&gt;(Iterable&lt;Entry&lt;T&gt;&gt; entries = {})
    extends AbstractCollection&lt;Entry&lt;T&gt;&gt;(entries)
    satisfies Map&lt;T&gt; 
    where T >= Comparable 
{ 
    ... 
}</programlisting>
    
    <programlisting>public interface List&lt;T&gt;
    satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; 
{
    ...
}</programlisting>

    <programlisting>Natural count = 0;</programlisting>
    
    <programlisting>protected String firstName;</programlisting>
    
    <programlisting>public Boolean login() { ... }</programlisting>
    
    <programlisting>public 
String join(Iterable&lt;String&gt; strings, 
            String delimiter = ", ") 
{ 
   ... 
}</programlisting>
    
    <programlisting>public Boolean functor Order&lt;T&gt;(T x, T y);</programlisting>

    <programlisting>public decorator ComparablePerson(Person person) 
    satisfies Comparable&lt;Person&gt; 
{
   ... 
}</programlisting>
               
    <programlisting>public Float converter IntegerToFloat(Integer int) 
{
   return Float(int);
}</programlisting>
    
    <para>Thus, the syntax of Ceylon declarations is more regular than Java or C#.</para>
    
    </section>
    -->
    
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A <emphasis>class</emphasis> is a stateful, instantiable type. Classes 
        are declared according to the following:</para>
        
        <programlisting>Class :=
Annotation*
"class" TypeName TypeParams? FormalParams?
Supertype?
Interfaces?
TypeConstraints?
ClassBody</programlisting>

        <programlisting>ClassBody := "{" Instances? DeclarationOrStatement* "}"</programlisting>

        <section>
             <title>Class inheritance</title>
        
        <para>
        A class may extend another class, and implement any number of interfaces.
        For example:
        </para>
        
        <programlisting>public mutable
class Customer(Name name, optional Organization org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>
        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt;, Identifier {
    ... 
}</programlisting>
        
        <para>
        The types listed after the <literal>satisfies</literal> keyword are the implemented
        interfaces. The type specified after the <literal>extends</literal> keyword is a 
        superclass. The semantics of class inheritance are exactly the same as Java, and the 
        above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>public class Customer 
        extends Person {
    public Customer(Name name) { this(name, null); }
    public Customer(Name name, Organization org) { super(name, org); }
    ... 
}</programlisting>
        
        <programlisting>class Token 
        extends Datetime 
        implements Comparable&lt;Token&gt;, Identifier {
    public Token() { super(); }
    ... 
}</programlisting>

        </section>
       
        <section>
            <title>Class instantiation</title>
        
        <para>
        Ceylon classes do not support a Java-like constructor declaration syntax. However, 
        Ceylon supports <emphasis>class initialization parameters</emphasis>. A class 
        initialization parameter may be used anywhere in the class body. The class body is
        executed every time the class is instantiated.
        </para>
        
        <para>All non-<literal>optional</literal> attributes of the class must be explicitly
        initialized somewhere in the body of the class definition, unless the class is declared
        <literal>abstract</literal>, in which case they must be initialized within the body of
        every subclass definition.</para>
        
        <para>This declaration:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock = lock;
}</programlisting>
        
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private final ReadAttribute&lt;Lock&gt; lock;
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) {
        this.lock = new SimpleReadAttribute&lt;Lock&gt;(lock); 
    }
    
}</programlisting>

        <para>This declaration:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock { return lock };
}</programlisting>
        
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private Lock _lock;
        
    private final ReadAttribute&lt;Lock&gt; lock = new ReadAttribute&lt;Lock&gt;() {
        @Override public Lock get() { return _lock; }
    }; 
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) { 
        _lock = lock; 
    }
    
}</programlisting>

        <para>Class initialization parameters are optional. The following class:</para>
        
        <programlisting>public mutable class Point {
    public mutable Decimal x := 0.0;
    public mutable Decimal y := 0.0;
}</programlisting>
        
        <para>Is equivalent to this Java class with a default constructor:</para>
        
        <programlisting>public class Point {
    private final Attribute&lt;Decimal&gt; x = new SimpleAttribute&lt;Decimal&gt;( new Decimal(0.0) );
    public SimpleAttribute&lt;Decimal&gt; x() { return x; }
    
    private final Attribute&lt;Decimal&gt; y = new SimpleAttribute&lt;Decimal&gt;( new Decimal(0.0) );
    public SimpleAttribute&lt;Decimal&gt; y() { return y; }
}</programlisting>

        <comment><para>TODO: is this the right thing to say? Alternatively, we could say that 
        classes without a parameter list can't have statements or initialized simple attributes
        in the body of the class, and get the constructor automatically generated for the 
        list of attributes.</para></comment>
        
        <para>A subclass must pass values to each superclass initialization 
        parameter.</para>

        <programlisting>public class SpecialKey1()
        extends Key( new SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>public class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>

        <para>Which are equivalent to the Java:</para>
        
        <programlisting>public class SpecialKey1 
        extends Key {
    public SpecialKey1() { 
        super( SpecialLock() );
    }
    ... 
}</programlisting>

        <programlisting>public class SpecialKey2 
        extends Key {
    public SpecialKey2(Lock lock) { 
        super(lock);
    }
    ... 
}</programlisting>

        <para>The body of a class may contain arbitrary code, which is
        executed when the class is instantiated.</para>
        
        <programlisting>public mutable class DiagonalPoint(Decimal position) 
        extends Point() {
    
    x := y := sqrt(position**2/2) * position.sign;
    
    assert "must have distance ${position} from origin" 
        that x**2 + y**2 == position**2;
    
}</programlisting>
        
        <para>The compiler is permitted to optimize private attribute 
        declarations. So the above class is equivalent to:</para>
        
        <programlisting>public class DiagonalPoint extends Point {
        
    public DiagonalPoint(final Decimal position) {
    
        x = y = sqrt( position.power(2).divided(2) ).times(position.sign);
        
        assert_(new F0&lt;String&gt;() {
                   public String call() { 
                       return "must have distance " + position + " from origin";
                   }
                },
                new F0&lt;Boolean&gt;() {
                   public Boolean call() { 
                       return ( x.power(2) + y.power(2) ).equals( position.power(2) );
                   }
                });
    }
    
}</programlisting>

        <comment><para>TODO: should class initialization parameters be allowed to be
        declared <literal>mutable</literal>?</para></comment>
        
        <comment><para>TODO: should class initialization parameters be allowed to be
        declared <literal>public/package/module</literal>, allowing a shortcut
        simple attribute declaration like in Scala?</para></comment>
        
        </section>

       <section>
            <title>Defaulted parameters</title>
            
        <para>
        When a class with a defaulted parameter is instantiated, and a value is not assigned to the
        defaulted parameter by the caller, the default value defined by the specifier is used.
        </para>
        
        <para>This class:</para>
        
        <programlisting>public class Counter(Natural initialCount=0) { ... }</programlisting>
        
        <para>Is equivalent to a class with three Java constructor declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    public Counter() {
        Counter(0);
    }
    
    public Counter(Natural initialCount) {
        ...;
    }
    
    public Counter(CounterParameters namedParameters) {
        Counter( namedParameters.initialCount );
    }

    public static class CounterParameters {
        private Natural initialCount=0;
        CounterParameters initialCount(Natural initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>

        <para>This named parameter call:</para>
        
        <programlisting>Counter { initialCount=10; }</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>new Counter ( new CounterParameters().initialCount(10) );</programlisting>

        </section>
        
        <section>
        <title>Annotations</title>
        
        <para>Every annotation is a static (non-void) method call. This Ceylon class:</para>
        
        <programlisting>doc "Represents a person"
by "Gavin"
public class Person { ... }</programlisting>

        <para>Is equivalent to this Java code:</para>
        
        <programlisting>public class Person { ... 

    static {
        Type&lt;Person&gt; type = Type.get(Person.class);
        type.addAnnotation( doc("Represents a person") );
        type.addAnnotation( by("Gavin") );
        type.addAnnotation( public() );
    }

    ...

}</programlisting>

        
        </section>

    <section id="instanceenumeration">
        <title>Class instance enumeration</title>
        
        <para>The keyword <literal>case</literal> is used to specify an enumerated named 
        instance of a class. All <literal>case</literal>s must appear in a list as the 
        first line of a class definition.</para>
        
        <programlisting>Instances := Instance ("," Instance)* ("..." | ";")</programlisting>

        <programlisting>Instance := Annotation* "case" MemberName Arguments?</programlisting>

        <para>If the <literal>case</literal> list ends in <literal>;</literal> instead of 
        <literal>...</literal>, additional instances of the class may not be instantiated.</para>
        
        <programlisting>public class DayOfWeek {
    case sun,
    case mon, 
    case tues, 
    case wed, 
    case thurs, 
    case fri, 
    case sat; 
}</programlisting>

        <programlisting>public class DayOfWeek(String name) {
    doc "Sunday"
        case sun("Sunday"),
    doc "Monday" 
        case mon("Monday"), 
    doc "Tuesday"
        case tues("Tuesday"),
    doc "Wednesday"
        case wed("Wednesday"),
    doc "Thursday"
        case thurs("Thursday"),
    doc "Friday"
        case fri("Friday"),
    doc "Saturday"
        case sat("Saturday");
       
    public String name = name;
    
}</programlisting>

        <comment><para>TODO: If we decide to support static attributes, then each 
        <literal>case</literal> would be considered a static simple attribute.</para></comment>
        
        <para>A class with declared <literal>case</literal>s implicitly extends 
        <literal>lang.Selector</literal>, a subclass of <literal>java.lang.Enum</literal>. 
        The above declarations are equivalent to the following Java declarations:</para>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; { 
        
    public static DayOfWeek mon = new DayOfWeek("mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("tues", 1);
    public static DayOfWeek wed = new DayOfWeek("wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("fri", 4);
    public static DayOfWeek sat = new DayOfWeek("sat", 5);
    public static DayOfWeek sun = new DayOfWeek("sun", 6);
    
    private DayOfWeek(String id, int ord) {
        super(id, ord);
    }
    
}</programlisting>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; {
        
    private final ReadAttribute&lt;String&gt; name;
       
    public static DayOfWeek mon = new DayOfWeek("Monday", "mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("Tuesday", "tues", 1);
    public static DayOfWeek wed = new DayOfWeek("Wednesday", "wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("Thursday", "thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("Friday", "fri", 4);
    public static DayOfWeek sat = new DayOfWeek("Saturday", "sat", 5);
    public static DayOfWeek sun = new DayOfWeek("Sunday", "sun", 6);
     
    private DayOfWeek(String name, String id, int ord)
    {
        super(id, ord);
        name = new SimpleReadAttribute(name);
    }
    
}</programlisting>

        <comment><para>TODO: let each <literal>case</literal> override methods,
        like in Java.</para></comment>

    </section>
        
    </section>
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An <emphasis>interface</emphasis> is a type which does not specify 
        implementation. Interfaces may not be directly instantiated. Interfaces 
        are declared according to the following:</para>
        
        <programlisting>Interface :=
 Annotation*
"interface" TypeName TypeParams?
Interfaces?
TypeConstraints? 
InterfaceBody</programlisting>

        <programlisting>InterfaceBody := "{" ( AbstractMethod | AbstractAttribute )* "}"</programlisting>

        <para>For example:</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>

         <para>Which is equivalent to the following Java interface:</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>

        <section>
            <title>Interface inheritance</title>
            
            <para>An interface may extend any number of other interfaces. For example:</para>
        
            <programlisting>public interface List&lt;T&gt;
        satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
        
            <para>
            The types listed after the <literal>satisfies</literal> keyword are the supertypes. All 
            supertypes of an interface must be interfaces. The semantics of interface inheritance 
            are exactly the same as Java, and the above declaration is equivalent to the following 
            Java declaration: 
            </para>
        
            <programlisting>public interface List&lt;T&gt; 
        extends Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>

        </section>
        
    </section>
    
    <!--  
    <section>
        <title>Constructors</title>
        
        <para>Constructors are declared according to the following:</para>
        
        <programlisting>Annotation* Identifier 
FormalParams
( ";" | ClosedBlock )</programlisting>

        <para>
        For example:
        </para>
        
        <programlisting>Public: User(String username, Person person);</programlisting>
        <programlisting>Public: Integer(String string): value = parse(string);</programlisting>
        <programlisting>Public: User(String u, Person p) { username = u; person = p; }</programlisting>
        
        <para>
        The semantics of constructor declarations are identical to Java.
        </para>
        
        <para>
        A constructor body may omit the braces if it consists of exactly one statement. 
        If there is no constructor body at all, the constructor assigns each parameter to
        the attribute with the same name.
        </para>
        
        <para>
        A Ceylon constructor invocation is equivalent to a Java constructor invocation.
        </para>
                
        <programlisting>@FormalParameterNames({"username", "person"}) 
public User(String username, Person person);</programlisting>

    </section>
    -->
    
    <section id="methods">
        <title>Methods</title>
        
        <para>A <emphasis>method</emphasis> is a callable block of code. Methods may have 
        parameters and may return a value. Methods are declared according to the following:</para>
        
        <programlisting>Method := MethodHeader ( Block | ("=" MethodReference)? ";" )</programlisting>

        <programlisting>MethodHeader := Annotation* (Type | "void") MemberName TypeParams? FormalParams+ TypeConstraints?</programlisting>

        <para>For example:</para>
        
        <programlisting>public Integer add(Integer x, Integer y) {
    return x + y;
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token();
}</programlisting>

        <programlisting>public optional U get(optional V key);</programlisting>
        
        <programlisting>public void print(Object... objects) {
    for (Object object in objects) { log.info($object); }
}</programlisting>

        <programlisting>public void addEntry(V key -> U value) { ... }</programlisting>
        
        <programlisting>Float say(String words) = person.say;</programlisting>
        
        <para>A method may declare multiple lists of parameters. Methods which declare
        more than one parameter list return references to other methods.</para>
        
        <programlisting>Comparison getOrdering(Natural x, Natural y)() { .... }</programlisting>

        <para>A method may be declared inside the body of another method or attribute, in 
        which case it may refer to any immutable local of the containing scope. It may not 
        refer to mutable locals.</para>
        
        <para>The Ceylon compiler preserves the names of method parameters, using a Java
        annotation.</para>
        
        <programlisting>@FormalParameterNames({"x", "y"}) 
public Integer add(Integer x, Integer y) { ... }</programlisting>

        <para>A Ceylon method invocation is equivalent to a Java method invocation. The 
        semantics of method declarations are identical to Java, except that Ceylon methods 
        may declare defaulted parameters.</para>
        
       <section>
            <title>Defaulted parameters</title>
            
            <para>Methods with defaulted parameters may not be overloaded.</para>
        
            <para>When a method with a defaulted parameter is called, and a value is not 
            assigned to the defaulted parameter by the caller, the default value defined by 
            the specifier is used.</para>
        
            <para>This method:</para>
        
            <programlisting>public class Counter {
        
    package void init(Natural initialCount=0) {
        count:=initialCount;
    }
    
    ...

}</programlisting>
        
            <para>Is equivalent to three Java method declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    void init() {
        init(0);
    }
    
    void init(Natural initialCount) {
        count=initialCount;
    }
    
    void init(CounterInitParameters namedParameters) {
        init( namedParameters.initialCount );
    }

    static class CounterInitParameters {
        private Natural initialCount=0;
        CounterInitParameters initialCount(Natural initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>

            <para>This named parameter call:</para>
        
            <programlisting>counter.init { initialCount=10; }</programlisting>
        
            <para>Is equivalent to this Java code:</para>
        
            <programlisting>counter.init ( new CounterInitParameters().initialCount(10) );</programlisting>

        </section>
        
        <section>
            <title>Interface methods and abstract methods</title>
            
            <para>If there is no method body in a method declaration, the implementation 
            of the method must be specified later in the block, or the class that declares 
            the method must be annotated <literal>abstract</literal>. If no implementation 
            is specified, the method is considered an <emphasis>abstract method</emphasis>.</para>
        
            <para>Methods declared by interfaces may not specify an implementation:</para>
        
            <programlisting>AbstractMethod := MethodHeader ";"</programlisting>

            <para>Interface methods and abstract methods must be implemented by every 
            non-<literal>abstract</literal> class that implements the interface or
            subclasses the abstract class.</para>
                
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to <emphasis>attribute</emphasis> 
        definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a 
                Java field).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived 
                attribute is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived 
                attribute is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be overridden by subclasses. If the attribute is not declared
        <literal>optional</literal>, it may not be overridden or implemented by an
        attribute declared <literal>optional</literal>.</para>
            
        <para>For example:</para>
        
        <programlisting>package mutable String firstName;</programlisting>
        
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <programlisting>public static Decimal pi = calculatePi();</programlisting>
        
        <programlisting>public String name { return join(firstName, lastName); }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
    
        <programlisting>public Float total {
    Float sum = 0.0;
    for (LineItem li in lineItems) {
        sum += li.amount;
    }
    return sum;
}</programlisting>

        <para>An attribute may be declared inside the body of another method or attribute, 
        in which case it may refer to any immutable local of the containing scope. It may 
        not refer to mutable locals.</para>
        
        <para>
        An attribute declaration is equivalent to a Java method declaration together with 
        a Java field declaration, both of type <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal>, both with the same name as the attribute.
        </para>
        
        <para>The compiler is permitted to optimize private attributes to a simple Java field
        declaration or a local variable in a Java constructor. Private attributes may not
        be accessed via reflection.</para>
        
        <comment><para>TODO: Should we generate getters and setters, just for interop with 
        Java?</para></comment>
        
        <comment><para>TODO: I would like to support <literal>def</literal> in place of the type
        for a private attribute or local with an initializer or getter. For example:</para></comment>
        
        <programlisting>def names = List&lt;String&gt;();</programlisting>
        <programlisting>def name { return Name(firstName, initial, lastName); }</programlisting>
        <programlisting>def count:=0;</programlisting>
        
        <section>
            <title>Simple attributes and locals</title>
            
        <para>Simple attribute defines state. Simple attributes are declared according to the 
        following:</para>
        
        <programlisting>SimpleAttribute := AttributeHeader (Specifier | Initializer)? ";"</programlisting>
        
        <programlisting>AttributeHeader := Annotation* Type MemberName</programlisting>
        
        <para>The value of an immutable attribute is specified using <literal>=</literal>. Mutable 
        attributes may be initialized using the assignment operator <literal>:=</literal>.</para>

        <programlisting>Initializer := ":=" Expression</programlisting>

        <para>Formal parameters of classes and methods are also considered to be simple attributes.</para>

        <para>A local is really just a special case of a simple attribute declaration, but one that 
        is optimized by the compiler.</para> 
        
        <itemizedlist>
            <listitem>
                <para>An attribute declared inside the body of a class represents a local if it 
                is not used inside a method, attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>An attribute declared inside the body of a method represents a local.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a class represents a local if it is not used inside a 
                method, attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a method represents a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>The semantics of locals are identical to Java local variables.</para>
        
        <para>For a simple attribute that is not a local, the Java field is initialized to an 
        instance of <literal>lang.SimpleAttribute</literal> or 
        <literal>lang.SimpleReadAttribute</literal>. For example:</para> 
        
        <programlisting>package mutable String firstName;</programlisting>

        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; firstName = new SimpleAttribute&lt;String&gt;();
Attribute&lt;String&gt; firstName() { return firstName; }</programlisting>

        <para>While:</para>
        
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;Natural&gt; count = new SimpleAttribute&lt;Natural&gt;(0);
private Attribute&lt;Natural&gt; count() { return count; }</programlisting>

        <para>And:</para>
        
        <programlisting>public Integer max = 99;</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Integer&gt; max = new SimpleReadAttribute&lt;Integer&gt;(99);
public ReadAttribute&lt;Integer&gt; max() { return max; }</programlisting>

        </section>
        
         <section>
            <title>Attribute getters</title>
            
            <para>An attribute getter is declared as follows:</para>
            
            <programlisting>AttributeGetter := AttributeHeader Block</programlisting>
            
            <para>An attribute getter defines how the value of a derived attribute is
            obtained.</para>

            <para>For an attribute getter, the Java field is initialized to an instance 
            of an anonymous inner subclass of <literal>lang.Attribute</literal> or
            <literal>lang.ReadAttribute</literal> that overrides the <literal>get()</literal> 
            method with the content of the getter block. For example: </para>
        
            <programlisting>public Float total { return items.totalPrice; }</programlisting>
        
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final ReadAttribute&lt;Float&gt; total = new ReadAttribute&lt;Float&gt;() {
    @Override public Float get() { return items.get().totalPrice; }
};
public ReadAttribute&lt;Float&gt; total() { return total; }</programlisting>

        </section>
        
        <section>
            <title>Attribute setters</title>
                    
            <para>An attribute setter is declared as follows:</para>
            
            <programlisting>AttributeSetter := Annotation* "assign" MemberName Block</programlisting>

            <para>An attribute getter defines how the value of a derived attribute is
            assigned. Every attribute setter must have a corresponding getter with the
            same name.</para>

            <comment><para>TODO: should we allow overloaded attribute setters, for example:</para></comment>
        
            <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>

            <para>For an attribute with a setter, the Java field is initialized to an 
            instance of an anonymous inner subclass of <literal>lang.Attribute</literal> 
            that overrides the <literal>set()</literal> method with the content of the 
            setter block. For example:
            </para>
        
            <programlisting>public String name { return join(firstName, lastName); }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
        
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final Attribute&lt;String&gt; name = new Attribute&lt;String&gt;() {
    @Override public String get() { return join(firstName, lastName); }
    @Override public void set(String name) { firstName = first(name); lastName = last(name); }
};
public Attribute&lt;String&gt; name() { return name; }</programlisting>
        
        </section>
        
        <section>
            <title>Interface attributes and abstract attributes</title>
            
            <para>If there is no initializer or getter implementation, and the attribute is not 
            declared <literal>optional</literal>, the value or implementation of the attribute 
            must be specified later in the block, or the class that declares the attribute must 
            be annotated <literal>abstract</literal>. If no value or implementation is specified, 
            and the attribute is not declared <literal>optional</literal>, the attribute is 
            considered an <emphasis>abstract attribute</emphasis>.</para>
        
            <para>Attributes declared by interfaces may not specify an initalizer, getter or setter:</para>
        
            <programlisting>AbstractAttribute := AttributeHeader ";"</programlisting>
        
            <para>Interface attributes and abstract attributes must be implemented by every 
            non-<literal>abstract</literal> class that implements the interface or subclasses the 
            abstract class.</para>
        
            <para>Interface attributes and abstract attributes may be specified <literal>mutable</literal>, 
            in which case every subtype must also define the attribute to be mutable.</para>
        
        </section>
                
    </section>
    
    <!--  
    <section>
        <title>Selectors</title>
        
        <para>Selectors are declared according to the following:</para>
        
        <programlisting>Annotation* Type* 
"selector" Identifier
FormalParams?
"{" 
SelectorValue ("," SelectorValue)*
( ";" ( Attribute | Method )* )? 
"}"</programlisting>
        
        <para>Where:</para>
        
        <programlisting>SelectorValue := Identifier ( "(" ( Expression ("," Expression)* )? ")" )?</programlisting>
        
        <para>
        For example:
        </para>
        
        <programlisting>Public: 
selector DayOfWeek 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>

        <programlisting>Public: 
selector DayOfWeek(String name) 
{ 
    MON("Monday"), TUES("Tuesday"), ...
    
    Public Constant: String name = name;
     
}</programlisting>
        
        <programlisting>Public: 
Comparator&lt;String&gt; 
selector ComparisonOperation { 
    ... 
}</programlisting>
        
        <para>
        The types listed before the <literal>selector</literal> keyword are the supertypes.
        All supertypes of a selector must be interfaces. Any constructors must be private. The 
        semantics of selector declarations and selector interface implementation are exactly the 
        same as for Java <literal>enum</literal>s, except that a Ceylon selector implicitly 
        implements <literal>lang.Selector</literal>, and the above declarations are equivalent to 
        the following Java declarations: 
        </para>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{
         
    MON("Monday"), TUES("Tuesday"), ...
     
    private DayOfWeek(String name) { ... }
    
    ...
    
}</programlisting>
        <programlisting>public enum Comparison 
    implements Comparator&lt;String&gt;, Selector&lt;Comparison&gt; 
{ 
    ... 
}</programlisting>
        
        <para>TODO: let selectors have abstract methods that are overridden by the selector values!</para>
        
    </section>
    -->
    <!--  
    <section id="functors">
        <title>Functors</title>
        
        <para>A functor represents a typed block of code. Functors are declared according to 
        the following:</para>
        
        <programlisting>Annotation* ( Type | "void" ) 
"functor" Identifier TypeParams? 
FormalParams 
TypeConstraintList? 
";"</programlisting>

        <para>TODO: instead of having explicitly declared functor types like <literal>Order&lt;Person&gt;</literal>, 
        we can just provide built-in functor types. If we want more compact type names, we can 
        provide some kind of typedef.</para>

        <para>TODO: let's wait and see what Java 7 does with closures. It will be easier for
        developers to learn something that is aligned with what Java does.</para>
        
        <para>For example:</para>
        
        <programlisting>public Comparison functor Order&lt;T&gt;(T x, T y);</programlisting>
        
        <para>
        A functor declaration is equivalent to a Java abstract class declaration that extends
        <literal>lang.Functor</literal> with a single abstract method declaration. For the example
        above, the equivalent Java declaration is:
        </para>
        
        <programlisting>public abstract class Order&lt;T&gt; 
        extends Functor&lt;Comparison&gt; {
        
    public abstract Comparison call(T x, T y);
    
    protected Order(Object... locals) 
    { 
        super(locals); 
    }
    
}</programlisting>

        <section>
            <title>Functor literals</title>
            
        <para>Consider the following functor literal:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) { x &lt;=&gt; y }</programlisting>
        
        <para>Or:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) x &lt;=&gt; y;</programlisting>
        
        <para>These literals are equivalent to this Java code:</para>

        <programlisting>Order&lt;String&gt; order = new Order&lt;String&gt;() {
    public Comparison call(String x, String y) { 
        return Comparison.compare(x,y); 
    }
};</programlisting>
        
        <para>And this functor invocation:</para>
        
        <programlisting>Boolean result = order("Gavin", "Emmanuel");</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Boolean result = order.call("Gavin", "Emmanuel");</programlisting>
        
        </section>
        
    </section>
    -->
    
    <section id="typealiases">
       <title>Type aliases</title>
    
       <para>A <emphasis>type alias</emphasis> allows a type to be referred to more 
       compactly.</para>
       
       <programlisting>Alias := Annotation* "alias" TypeName TypeParams? Interfaces? TypeConstraints? ";"</programlisting>
       
       <para>A type alias may satisfy any number of interfaces and at most one class.</para>
       
       <!--para>A type alias may satisfy either:</para>
       <itemizedlist>
           <listitem><para>any number of interfaces and at most one class, or</para></listitem>
           <listitem><para>a single functor type.</para></listitem>
       </itemizedlist-->
       
       <para>Any expression which is assignable to all the satisfied types is assignable 
       to the alias type.</para>
       
       <para>For example:</para>
       
       <programlisting>public alias People satisfies List&lt;Person&gt;;</programlisting>
       
       <programlisting>package alias ComparableCollection&lt;X&gt; satisfies Collection&lt;X&gt;, Comparable&lt;X&gt;;</programlisting>
       
       <!--programlisting>alias Compare&lt;T&gt; satisfies functor Comparison(T x, T y);</programlisting-->
       
       <para>A shortcut is provided for definition of private aliases.</para>
       
       <programlisting>import java.util.List alias JavaList;</programlisting>
    
    </section>
    
    <section id="extensions">
        <title>Extensions</title>
        
        <para>An extension allows values of one type to be transparently converted to values 
        of another type. Extensions are declared by annotating a method, attribute or class
        <literal>extension</literal>. An extension method must be a static method with exactly 
        one parameter, or a non-static method with no parameters. An extension class must have 
        exactly one initialization parameter. An extension method or attribute must have a 
        non-<literal>optional</literal> type.</para>
        
        <para>For example:</para>
        
        <programlisting>public class Person {
    ...
    public extension User user;
}</programlisting>
        
        <programlisting>public static extension User personToUser(Person person) { 
    return person.user; 
}</programlisting>
        
        <programlisting>public extension class CollectionUtils&lt;T&gt;(Collection&lt;T&gt; collection) {
    
    public Collection&lt;T&gt; nonZeroElements() {
        return collection.elements() 
            having (T element) element!=0; 
    }
    
    ...   
}</programlisting>
        
        <para>An extension method is called a converter. An extension class is called a 
        decorator.</para>
        
        <comment><para>Note: I actually much prefer the readability of 
        <literal>User personToUser(extends Person person)</literal> and
        <literal>CollectionUtils&lt;T&gt;(extends Collection&lt;T&gt; collection)</literal>, but 
        this doesn't work for attributes and non-static methods.</para></comment>
        
        <para>The Ceylon compiler searches for an appropriate extension whenever a value of one
        type is assigned to a non-assignable type. If exactly one extension for the two types is 
        found, the compiler inserts a call to the extension. For example, this Ceylon assignment:</para>
        
        <programlisting>import org.mydomain.myproject.Converters.personToUser;
...
Person person = ...;
User user = person;</programlisting>

        <para>Is equivalent to the following Java code:</para>
        
        <programlisting>Person person = ...;
User user = personToUser(person);</programlisting>

        <para>The Ceylon compiler also searches for an appropriate extension whenever a member
        is invoked that is not declared by the type. If exactly one extension that declares the
        member is found for the type, the compiler inserts a call to the extension. For example, 
        this Ceylon method call:</para>
        
        <programlisting>import org.mydomain.myframework.CollectionUtils;
...
Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = ints.nonZeroElements();</programlisting>
            
        <para>Is equivalent to this Java code:</para>
    
        <programlisting>Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = new CollectionUtils(collection).nonZeroElements();</programlisting>
            
        <para>An extension is only available in a source file that explicitly 
        <literal>import</literal>s the extension (except for the extensions
        defined in the package <literal>lang</literal>). A wildcard
        <literal>.*</literal>-style import may not be used to import an 
        extension.</para>
        
    </section>
        
    <section id="declaration modifiers">
        <title>Declaration modifiers</title>
        
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>public</literal>, <literal>module</literal>,
                <literal>package</literal> determine the visibility of a 
                declaration (by default, the declaration is visible only
                inside the same compilation unit).</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated.<!--, or that a method or attribute of 
                an abstract class must be implemented by all subclasses.--></para>
            </listitem>
            <listitem>
                <para><literal>static</literal> specifies that a method
                can be called without an instance of the type that defines
                the method.</para>
            </listitem>
            <listitem>
                <para><literal>mutable</literal> specifies that an attribute
                or local may be assigned, or that a class has assignable
                attributes.</para>
            </listitem>
            <listitem>
                <para><literal>optional</literal> specifies that a value may
                be null.</para>
            </listitem>
            <listitem>
                <para><literal>final</literal> indicates that a class may 
                not be extended, or that a method or attribute may not be 
                overridden.</para>
            </listitem>
            <listitem>
                <para><literal>override</literal> indicates that a method
                or attribute overrides a method or attribute defined by a 
                supertype.</para>
            </listitem>
            <listitem>
                <para><literal>extension</literal> specifies that a method
                is a converter, or that a class is a decorator.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method is 
                executed at most once, and the resulting value is cached.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated.</para>
            </listitem>
            <listitem>
                <para><literal>volatile</literal> indicates a volatile
                simple attribute.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: We can minimize backtracking in the parser by 
        making all these "annotations" be keywords. It lets the parser 
        recognize a member declaration a little bit more easily. But on the
        other hand it's a new special kind of thing.</para></comment>
        
        <comment><para>TODO: should there be an <literal>annotation</literal>
        modifier for static methods which can be used as annotations?</para></comment>
            
        <comment><para>TODO: does Ceylon support static attributes?</para></comment>
            
        <para>The following annotation is a hint to the compiler that lets 
        the compiler optimize compiled bytecode for non-64 bit architectures:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>small</literal> specifies that a value of type
                <literal>Natural</literal>, <literal>Integer</literal>  or
                <literal>Float</literal> contains 32-bit values.</para>
            </listitem>
        </itemizedlist>
        
        <para>By default, <literal>Natural</literal>, <literal>Integer</literal>
        and <literal>Float</literal> are assumed to represent 64-bit values.</para>
        
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the documentation for
                a program element.</para>
            </listitem>
            <listitem>
                <para><literal>by</literal> specifies the authors of a 
                program element.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The string values of the <literal>doc</literal>, <literal>throws</literal> 
        and <literal>by</literal> annotations are parsed by the documentation
        compiler as Seam Text, a simple ANTLR-based wiki text format.</para>
        
        <para>The following annotations are important to the Ceylon SDK.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>id</literal> specifies that an attribute should
                be tested by the <literal>equals()</literal> method, and included
                in the <literal>hash</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>transient</literal> specifies that an attribute 
                is not included in the serialized form of the object.</para>
            </listitem>
            <listitem>
                <para><literal>read</literal> and <literal>write </literal>
                indicate methods or attributes that are protected from multithreaded
                access using a reentrant read/write lock with deadlock detection.</para>
            </listitem>
        </itemizedlist>
        
    </section>

</chapter>