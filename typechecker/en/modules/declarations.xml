<chapter id="declarations">
    <title>Declarations</title>
    
    <para>Ceylon is a statically typed language. Classes, interfaces, aliases, methods, 
    attributes and locals must be declared. This allows the compiler to detect many
    errors, including:</para>
    
    <itemizedlist>
        <listitem><para>typing errors in identifier names,</para></listitem>
        <listitem><para>references to types which do not exist or are not visible,</para></listitem>
        <listitem><para>references to type members which do not exist or are not visible,</para></listitem>
        <listitem><para>argument lists which do not match formal parameter lists,</para></listitem>
        <listitem><para>type argument lists which do not match type parameter lists, and</para></listitem>
        <listitem><para>incompatible assignment of an expression of one type to a
        program element of a different type.</para></listitem>
    </itemizedlist>
    
    <para>All declarations follow a general pattern:</para>
        
    <programlisting>Annotation* 
keyword? Type? (TypeName|MemberName) TypeParams? FormalParams*
ExtendedType?
SatisfiedTypes? 
TypeConstraints? 
Body?</programlisting>

    <para>A type parameter does not need an explicit declaration of this form unless it 
    has constraints. In the case that it does have constraints, the constraint declaration 
    does follow the general pattern.</para>
    
    <para>This consistent pattern for declarations, together with the strict block structure
    of the language, makes Ceylon a highly regular language.</para>

    <section id="compilationunitstructure">
        <title>Compilation unit structure</title>
        
        <para>A <emphasis>compilation unit</emphasis> is a text file, with the 
        filename extension <literal>.ceylon</literal>.</para>
        
        <para>A compilation unit consists of a list of imported types and methods, 
        followed by one or more toplevel type or method definitions or by a single 
        toplevel expression:</para>
        
        <programlisting>Import* (ToplevelDeclaration+ | ToplevelExpression)</programlisting>
        
        <section id="topleveldeclarations">
            <title>Toplevel declarations</title>
        
        <para>A <emphasis>toplevel declaration</emphasis> defines a type&mdash;a class, 
        interface or type alias&mdash;or a method.</para>
        
        <programlisting>ToplevelDeclaration := TypeDeclaration | Method</programlisting>
        
        <programlisting>TypeDeclaration := Class | Interface | Alias</programlisting>
        
        <para>All toplevel declarations <!--with a visibility modifier less strict than
        <literal>private</literal>--> must have the same name as the compilation unit 
        filename (after removing the file suffix <literal>.ceylon</literal>). For 
        example, a <!--<literal>public</literal>--> toplevel class named <literal>Person</literal> 
        must be defined in a file named <literal>Person.ceylon</literal>. A 
        <!--<literal>public</literal>--> toplevel method named <literal>hello()</literal> 
        must be defined in a file named <literal>hello.ceylon</literal>. Unlike Java, 
        a compilation unit may contain multiple toplevel class or method declarations 
        with the same name.</para>
        
        <comment><para>TODO: Does Ceylon support toplevel attributes? Perhaps just 
        non-<literal>mutable</literal> toplevel attributes?</para></comment>
            
        </section>
        
        <section id="toplevelexpressions">
            <title>Toplevel expressions</title>
        
        <para>A <emphasis>toplevel expression</emphasis> is a shorthand toplevel 
        method declaration.</para>
        
        <programlisting>ToplevelExpression := (Param ";")* Expression</programlisting>
        
        <para>A toplevel expression is equivalent to a <literal>public</literal> 
        toplevel method declaration with the specified formal parameters, which returns 
        the specified expression. The name of the toplevel method is determined from 
        the name of the compilation unit (by removing the file suffix 
        <literal>.ceylon</literal>).</para>
        
        <para>For example:</para>
            
        <programlisting>String firstName; 
String lastName; 

"Hello" firstName " " lastName "!"</programlisting>

        <para>as a toplevel expression in the file <literal>hello.ceylon</literal> is 
        equivalent to:</para>
            
        <programlisting>public String hello(String firstName, String lastName) { 
    return "Hello " firstName " " lastName "!"
}</programlisting>
        
        <!--
        <comment><para>TODO: should we allow the definition of <literal>private</literal>
        toplevel methods and types in a compilation unit containing a toplevel 
        expression?</para></comment>
        -->
        
        </section>
        
    </section>
    
        <section id="imports">
            <title>Imports</title>
        
        <para>Each compilation unit belongs to exactly one <emphasis>package</emphasis>.
        Code in one compilation unit may refer to a toplevel declaration in another 
        compilation unit in the same package without explicitly importing the declaration. 
        It may refer to a declaration defined in a compilation unit in another package 
        only if it explicitly imports the declaration using the <literal>import</literal> 
        statement.</para>
        
        <programlisting>Import := "import" "extension"? FullPackageName "." ImportSpec ";"</programlisting>
        
        <para>A package is a namespace. A full package name is a period-separated list of 
        all-lowercase identifiers.</para>
        
        <programlisting>FullPackageName := PackageName ("." PackageName)*</programlisting>
        
        <para>An <literal>import</literal> statement may import either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a single (toplevel or member) type,</para>
            </listitem>
            <listitem>
                <para>a single toplevel method,</para>
            </listitem>
            <listitem>
                <para>a single named enumerated instance of a class,</para>
            </listitem>
            <listitem>
                <para>all toplevel declarations of a specified package, or</para>
            </listitem>
            <listitem>
                <para>all named enumerated instances and member types of a specified class
                or interface.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>ImportSpec := TypeSpec | MethodSpec | InstanceSpec | PackageMembersSpec | TypeMembersSpec</programlisting>
        
        <para>Note that toplevel types, toplevel methods, enumerated instances, and extensions 
        in the module <literal>ceylon.lang</literal> do not need to be explicitly imported. 
        They are implicitly imported by every compilation unit.</para>
        
        <para>If the <literal>extension</literal> annotation appears, the imported declaration
        must also be annotated <literal>extension</literal>.</para>
        
        <comment><para>TODO: Would it be better to specify that there is at most a single 
        <literal>import</literal> statement per source file, for example:</para>
        <programlisting>import my.query.Order, ceylon.collection.*, java.util.Map.Entry alias MapEntry;</programlisting></comment>
        
        <comment><para>TODO: Would it be better to enclose that the imported expressions
        in single quotes, as they would need to appear in the body of the source file,
        for example: <literal>'my.query.Order'</literal>, <literal>'ceylon.collection.*'</literal>,
        <literal>'java.util.Map.Entry' alias MapEntry</literal>.</para></comment>
        
        <section id="fullyexplicitimports">
            <title>Fully explicit imports</title>
        
        <para>An import statement that specifies a package name followed by a type
        name imports the type with that name from the given package.</para>
        
        <programlisting>TypeSpec := QualifiedTypeName ("alias" TypeName)?</programlisting>
        
        <para>The name of a member type must be qualified by the names of its containing
        types.</para>
        
        <programlisting>QualifiedTypeName := (TypeName ".")* TypeName</programlisting>
                
        <para>An import statement that specifies a package name followed by a method
        name imports the method with that name from the given package.</para>
        
        <programlisting>MethodSpec := MemberName ("alias" MemberName)?</programlisting>
        
        <para>An import statement that specifies a package name followed by a type
        name and the name of an enumerated instance imports the named enumerated 
        instance.</para>
                
        <programlisting>InstanceSpec := QualifiedTypeName "." MemberName ("alias" MemberName)?</programlisting>
        
        <para>The optional <literal>alias</literal> clause in a fully-explicit import
        allows resolution of cross-namespace declaration name collisions.</para>
        
        <programlisting>import java.util.Map.Entry alias MapEntry;</programlisting>
        
        <programlisting>import my.math.fibonnacciNumber alias fib;</programlisting>
        
        <programlisting>import my.query.Order.descending alias desc;</programlisting>
        
        </section>
        
        <section id="wildcardimports">
            <title>Wildcard imports</title>
        
        <para>The character <literal>*</literal> acts as a wildcard in import statements.</para>
        
        <para>An import statement that specifies a package name followed by a wildcard
        imports all toplevel types of the package.</para>
        
        <programlisting>PackageMembersSpec := "*"</programlisting>
        
        <para>An import statement that specifies a type name followed by a wildcard
        imports all member types of the type.</para>
                
        <programlisting>TypeMembersSpec := QualifiedTypeName "." "*"</programlisting>
        
        <para>Overuse of wildcard imports is discouraged.</para>
        
        <programlisting>import ceylon.collection.*;</programlisting>
        
        <programlisting>import transaction.propagation.TxPropagationType.*;</programlisting>
        
        </section>
        
        </section>
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An <emphasis>interface</emphasis> is a type schema. Interfaces do not 
        specify the implementation of their members and may not be directly instantiated.</para>
        
        <programlisting>Interface :=
Annotation*
"interface" TypeName TypeParams?
SatisfiedTypes?
TypeConstraints? 
InterfaceBody</programlisting>

        <programlisting>InterfaceBody := "{" AbstractDeclaration* "}"</programlisting>

        <para>The body of an interface contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (abstract method, abstract attribute and member class) 
                declarations, and</para>
            </listitem>
            <listitem>
                <para>nested interface declarations.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>AbstractDeclaration := AbstractMethod | AbstractAttribute | TypeDeclaration</programlisting>

        <para>Interface method and attribute declarations may not specify implementation.</para>

        <comment><para>TODO: are member classes of interfaces required to be <literal>abstract</literal>?</para></comment>
        
        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>

        <!-- 
        <para>Which is equivalent to the following Java interface:</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>
        -->
        
        <para>Interface members inherit the visibility modifier of the interface.</para>
        
        <comment><para>TODO: Refine this. Consider block-local interface declarations.</para></comment>
          
        <comment><para>TODO: if methods of interfaces can define defaulted parameters,
        precisely how do we implement that?</para></comment>
        
        <section id="mutableinterfaces">
            <title>Mutable and immutable interfaces</title>
            
        <para>An interface may be annotated <literal>mutable</literal>. If an interface is 
        not annotated <literal>mutable</literal> it is called an <emphasis>immutable type</emphasis>, 
        and it may not:</para>
        
        <itemizedlist>
            <listitem>
                <para>declare or inherit <literal>mutable</literal> attributes, or</para>
            </listitem>
            <listitem>
                <para>extend an interface annotated <literal>mutable</literal>.</para>
            </listitem>
        </itemizedlist>
            
        </section>
            
        <section id="interfaceinheritance">
            <title>Interface inheritance</title>
            
            <para>An interface may extend any number of other interfaces.</para>
        
            <programlisting>public interface List&lt;T&gt;
        satisfies T[], Collection&lt;T&gt; {
    ...
}</programlisting>
        
            <para>The types listed after the <literal>satisfies</literal> keyword are the 
            supertypes. All supertypes of an interface must be interfaces. An interface 
            may not extend the same interface twice (not even with distinct type arguments).</para>
            
            <!--para>
            Since every class that implements an interface is a subclass of <literal>lang.Object</literal>,
            the interface type itself is considered assignable to <literal>lang.Object</literal>.
            </para-->
        
            <para>The semantics of interface inheritance are exactly the same as Java. An 
            interface inherits all members (methods, attributes and member types) of every 
            supertype.</para>
        
            <para>The schema of the inherited members is formed by substituting type arguments
            specified in the <literal>satisfies</literal> clause.</para>
        
            <!--
            <para>and the above declaration is equivalent to the following 
            Java declaration: 
            </para>
        
            <programlisting>public interface List&lt;T&gt; 
        extends Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
            -->
            
        </section>
        
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A <emphasis>class</emphasis> is a stateful, instantiable type. It is a 
        type schema, together with implementation details of the members of the type.</para>
        
        <programlisting>Class :=
Annotation*
"class" TypeName TypeParams? FormalParams
ExtendedType?
SatisfiedTypes?
TypeConstraints?
ClassBody</programlisting>

        <programlisting>ClassBody := "{" Instances? (Declaration | Statement)* "}"</programlisting>
        
        <para>The body of a class contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute and member class) declarations,</para>
            </listitem>
            <listitem>
                <para>nested interface declarations,</para>
            </listitem>
            <listitem>
                <para>instance initialization code, and,</para>
            </listitem>
            <listitem>
                <para>optionally, a list of enumerated named instances of the class.</para>
            </listitem>
        </itemizedlist>

        <programlisting>Declaration := Method | SimpleAttribute | AttributeGetter | AttributeSetter | TypeDeclaration</programlisting>
        
        <para>Ordinarily, a declaration that occurs in a block of code is a block local
        declaration&mdash;it is visible only to statements and declarations that occur
        later in the same block. This rule is relaxed for certain declarations that occur 
        directly inside a class body:</para>
            
        <itemizedlist>
            <listitem>
                <para>declarations with explicit visibility modifiers&mdash;whose visibility
                is determined by the modifier, and</para>
            </listitem>
            <listitem>
                <para>declarations that occur in the second part of the body of the class, 
                after the last statement of the initializer&mdash;which are visible to all
                other declarations in the second part of the body of the class.</para>
            </listitem>
        </itemizedlist>
        
    <section id="mutableclasses">
        <title>Mutable and immutable classes</title>
        
        <para>A class may be annotated <literal>mutable</literal>. If a class is 
        annotated <literal>mutable</literal> it must (directly or indirectly) extend 
        <literal>ceylon.lang.IdentifiableObject</literal>.</para>
        
        <para>If a class is not annotated <literal>mutable</literal> it is called an 
        <emphasis>immutable type</emphasis>, and it may not:</para>
        
        <itemizedlist>
            <listitem>
                <para>declare or inherit <literal>mutable</literal> attributes,</para>
            </listitem>
            <listitem>
                <para>extend a <literal>mutable</literal> superclass, or</para>
            </listitem>
            <listitem>
                <para>implement an interface annotated <literal>mutable</literal>.</para>
            </listitem>
        </itemizedlist>
    
    </section>
    
    <section id="classinitializer">
        <title>Class initializer</title>
        
        <para>Ceylon classes do not support a Java-like constructor declaration syntax. 
        Instead:</para>
        
        <itemizedlist>
           <listitem>
              <para>The body of the class declares <emphasis>initializer parameters</emphasis>. 
              An initializer parameter may be used anywhere in the class body, including in 
              method and attribute definitions.</para>
           </listitem>
           <listitem>
              <para>The initial part of the body of the class is called the 
              <emphasis>initializer</emphasis> and contains a mix of declarations, statements 
              and control structures. The initializer is executed every time the class is 
              instantiated.</para>
           </listitem>
        </itemizedlist>
        
        <para>An initialization parameter may be used to specify or initialize the value of an 
        attrbute:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock = lock;
}</programlisting>
        
        <programlisting>public class Counter(Natural start=0) {
    public mutable Natural count := start;
    public void inc() { count++; }
}</programlisting>
        
        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private final ReadAttribute&lt;Lock&gt; lock;
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) {
        this.lock = new SimpleReadAttribute&lt;Lock&gt;(lock); 
    }
    
}</programlisting>
         -->
        <para>An initialization parameter may even be used within the body of a method,
        attribute getter, or attribute setter:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock { return lock }
}</programlisting>

        <programlisting>public class Key(Lock lock) {
    public void lock() { lock.engage(this); }
    public void unlock() { lock.disengage(this); }
}</programlisting>

        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private Lock _lock;
        
    private final ReadAttribute&lt;Lock&gt; lock = new ReadAttribute&lt;Lock&gt;() {
        @Override public Lock get() { return _lock; }
    };
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) { 
        _lock = lock; 
    }
    
}</programlisting>
        -->
        
        <para>A subclass must pass values to each superclass initialization 
        parameter in the <literal>extends</literal> clause.</para>

        <programlisting>public class SpecialKey1()
        extends Key( SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>public class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>

        <!--
        <para>Which are equivalent to the Java:</para>
        
        <programlisting>public class SpecialKey1 
        extends Key {
    public SpecialKey1() { 
        super( SpecialLock() );
    }
    ... 
}</programlisting>

        <programlisting>public class SpecialKey2 
        extends Key {
    public SpecialKey2(Lock lock) { 
        super(lock);
    }
    ... 
}</programlisting>
        -->
        
        <para>The class initializer is responsible for initializing the state of 
        a new instance of the class, before a reference to the new instance is 
        available to clients.</para>
        
        <programlisting>public abstract class Point() {
    public Decimal x;
    public Decimal y;
}</programlisting>
        
        <programlisting>public class DiagonalPoint(Decimal distance) 
        extends Point() {
    
    Decimal pos = distance / 2**0.5;
    x = pos;
    y = pos;
    
    assert ("must have distance " distance " from origin") 
        that ( x**2 + y**2 &equals; distance**2 );
    
}</programlisting>
        
        <!--
        <para>So the above class is equivalent to:</para>
        
        <programlisting>public class DiagonalPoint extends Point {
        
    public DiagonalPoint(final Decimal position) {
    
        x = y = sqrt( position.power(2).divided(2) ).times(position.sign);
        
        assert_(new F0&lt;String&gt;() {
                   public String call() { 
                       return "must have distance " + position + " from origin";
                   }
                },
                new F0&lt;Boolean&gt;() {
                   public Boolean call() { 
                       return ( x.power(2) + y.power(2) ).equals( position.power(2) );
                   }
                });
    }
    
}</programlisting>
        -->
        
        <para>An initializer may invoke, evaluate or assign members of the current instance 
        of the class (the instance being initialized) without explicitly specifying the 
        receiver.</para>
        
        <para>An initializer of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class or interface (the receiving instance of the 
        instantiation expression) without explicitly specifying the receiver.</para>
        
        <para>A class may be declared inside the body of a method or attribute, in which case 
        the initializer may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        
        <para>The following restrictions apply to statements and declarations that appear within
        the initializer of the class:</para>
        
        <itemizedlist>
           <listitem>
              <para>They may not evaluate attributes or invoke methods that are declared later
              in the body of the class upon the current object or <literal>this</literal>.</para>
           </listitem>
           <listitem>
              <para>They may not pass <literal>this</literal> as an argument of a method invocation
              or the value of an attribute assignment.</para>
           </listitem>
           <listitem>
              <para>They may not declare an abstract method or attribute.</para>
           </listitem>
           <listitem>
              <para>They may not declare a <literal>default</literal> method or attribute.</para>
           </listitem>
        </itemizedlist>
        
        <para>The remainder of the body of the class consists purely of declarations, including
        abstract and <literal>default</literal> methods and attributes. It may not directly contain 
        statements or control structures, but may freely use <literal>this</literal>, and may 
        invoke any method or evaluate any attribute of the class. The usual restriction that a 
        declaration may only be used by code that appears later in the block containing the 
        declaration is relaxed. The declarations in this section may not contain specifiers
        or initializers (<literal>=</literal> or <literal>:=</literal>).</para>
        
        <para>Superclass members may be invoked, evaluated or assigned anywhere inside the body of
        the class. The superclass initializer is executed before the subclass initializer.</para>
        
        <comment><para>TODO: should class initializer parameters be allowed to be declared 
        <literal>public/package/module</literal>, allowing a shortcut simple attribute declaration 
        like in Scala?</para></comment>
                
        <!--
        <section>
        <title>Annotations</title>
        
        <para>Every annotation is a toplevel (non-void) method call. This Ceylon class:</para>
        
        <programlisting>doc "Represents a person"
by "Gavin"
public class Person { ... }</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>public class Person { ... 

    static {
        Type&lt;Person&gt; type = Type.get(Person.class);
        type.addAnnotation( doc("Represents a person") );
        type.addAnnotation( by("Gavin") );
        type.addAnnotation( public() );
    }

    ...

}</programlisting>
        
        </section>
        -->

    </section>

    <section id="callabletypeofclass">
        <title>Callable type of a class</title>
        
        <para>The <emphasis>callable type</emphasis> of a class captures the type and formal parameter 
        types of the class. The callable type is <literal>Callable&lt;T,P...&gt;</literal>, where
        <literal>T</literal> is the class and <literal>P...</literal> are the formal parameter types 
        of the class. A sequenced parameter is considered of type <literal>T[]</literal>
        where <literal>T...</literal> is the declared sequenced type.</para>
    
    </section>
    
        <section id="classinheritance">
             <title>Class inheritance</title>
        
        <para>
        A class may extend another class, and implement any number of interfaces.
        </para>
        
        <programlisting>public mutable
class Customer(Name name, Organization? org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>
        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt;, Identifier {
    ... 
}</programlisting>
        
        <para>
        The types listed after the <literal>satisfies</literal> keyword are the implemented
        interfaces. The type specified after the <literal>extends</literal> keyword is a 
        superclass. A class may not implement the same interface twice (not even with distinct
        type arguments).
        </para>
        
        <para>
        The semantics of class inheritance are exactly the same as Java. A class:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>inherits all members (methods, attributes, and member types) of 
                its superclass, except for members that it <emphasis>overrides</emphasis>,</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which its superclass is assignable,</para>
            </listitem-->
            <listitem>
                <para>must declare or inherit a member that overrides each member of 
                every interface it implements directly or indirectly, unless the class 
                is declared <literal>abstract</literal>, and</para>
            </listitem>
             <listitem>
                <para>must declare or inherit a member that overrides each abstract 
                member of its superclass, unless the class is declared 
                <literal>abstract</literal>.</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which any interface it implements is 
                assignable.</para>
            </listitem-->
        </itemizedlist>
        
        <para>The schema of the inherited members is formed by substituting type arguments
        specified in the <literal>extends</literal> clause.</para>
        
        <para>
        Furthermore, the initializer of the superclass is always executed before the
        initializer of the subclass whenever the subclass is instantiated.
        </para>
        
        <!-- 
        <para>and the 
        above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>public class Customer 
        extends Person {
    public Customer(Name name) { this(name, null); }
    public Customer(Name name, Organization org) { super(name, org); }
    ... 
}</programlisting>
        
        <programlisting>class Token 
        extends Datetime 
        implements Comparable&lt;Token&gt;, Identifier {
    public Token() { super(); }
    ... 
}</programlisting>
         -->
        </section>
       
    <section id="instanceenumeration">
        <title>Class instance enumeration</title>
        
        <para>The keyword <literal>case</literal> is used to specify an enumerated named 
        instance of a class. All <literal>case</literal>s must appear in a list as the 
        first line of a class definition.</para>
        
        <programlisting>Instances := Instance ("," Instance)* ("..." | ";")</programlisting>

        <programlisting>Instance := Annotation* "case" MemberName Arguments?</programlisting>

        <para>If the <literal>case</literal> list ends in <literal>;</literal>, the instance
        list is called <emphasis>closed</emphasis>. If the <literal>case</literal> list ends 
        in <literal>...</literal>, the instance list is called <emphasis>open</emphasis>.</para>
        
        <para>If a class has a closed instance list, the class may not:</para>
        
        <itemizedlist>
            <listitem>
                <para>be instantiated</para>
            </listitem>
            <listitem>
                <para>have subclasses, or</para>
            </listitem>
            <listitem>
                <para>have members annotated <literal>default</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>A class may not specify enumerated named instances if it:</para>
        
        <itemizedlist>
            <listitem>
                <para>is annotated <literal>abstract</literal>,</para>
            </listitem>
            <listitem>
                <para>has generic type parameters, or</para>
            </listitem>
            <listitem>
                <para>is nested directly or indirectly inside another class or inside a 
                block.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>public class DayOfWeek() {
    case sun,
    case mon, 
    case tues, 
    case wed, 
    case thurs, 
    case fri, 
    case sat; 
}</programlisting>

        <comment><para>TODO: Should we make the parens on the class declaration optional 
        in this case: a closed instance list with no parameters?</para></comment>

        <programlisting>public class DayOfWeek(String name) {
        
    doc "Sunday"
    case sun("Sunday"),
    
    doc "Monday" 
    case mon("Monday"),
    
    doc "Tuesday"
    case tues("Tuesday"),
    
    doc "Wednesday"
    case wed("Wednesday"),
    
    doc "Thursday"
    case thurs("Thursday"),
    
    doc "Friday"
    case fri("Friday"),
    
    doc "Saturday"
    case sat("Saturday");
       
    public String name = name;
    
}</programlisting>

        <programlisting>public class TransactionPropagation(void inProgress(), void notInProgress()) {
    
    case required { 
        void inProgress() {}
        void notInProgress() {
            tx.begin();
        }
    },
    
    case supports {
        void inProgress() {}
        void notInProgress() {}
    },
    
    case mandatory { 
        void inProgress() {}
        void notInProgress() {
            throw TransactionMandatory()
        }
    },
    
    case notSupported { 
        void inProgress() {
            throw TransactionNotSupported()
        }
        void notInProgress() {}
    },
    
    case requiresNew { 
        void inProgress() {
            throw TransactionRequiresNew()
        }
        void notInProgress() {
            tx.begin();
        }
    };
    
    public void propagate(Transaction tx) {
        if (tx.inProgress) {
            inProgress();
        }
        else {
            notInProgress();
        }
    }
    
}</programlisting>

        <para>A class with declared <literal>case</literal>s implicitly implements 
        <literal>ceylon.lang.Selector</literal>.</para>
        
        <para>Enumerated instances of a class are instantiated when the class is
        loaded by the virtual machine, with the specified arguments.</para>
        
        <!--
        <para>The above declarations are equivalent to the following Java declarations:</para>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; { 
        
    public static DayOfWeek mon = new DayOfWeek("mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("tues", 1);
    public static DayOfWeek wed = new DayOfWeek("wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("fri", 4);
    public static DayOfWeek sat = new DayOfWeek("sat", 5);
    public static DayOfWeek sun = new DayOfWeek("sun", 6);
    
    private DayOfWeek(String id, int ord) {
        super(id, ord);
    }
    
}</programlisting>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; {
        
    private final ReadAttribute&lt;String&gt; name;
       
    public static DayOfWeek mon = new DayOfWeek("Monday", "mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("Tuesday", "tues", 1);
    public static DayOfWeek wed = new DayOfWeek("Wednesday", "wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("Thursday", "thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("Friday", "fri", 4);
    public static DayOfWeek sat = new DayOfWeek("Saturday", "sat", 5);
    public static DayOfWeek sun = new DayOfWeek("Sunday", "sun", 6);
     
    private DayOfWeek(String name, String id, int ord)
    {
        super(id, ord);
        name = new SimpleReadAttribute(name);
    }
    
}</programlisting>
        -->
        
        <comment><para>TODO: should we have the ability to declare a restricted
        list of member subclasses using <literal>case class</literal>, for example:</para>
        <programlisting>public abstract class Node(String name) {
        
    case root("root"), 
    case class Branch(String name, Node parent) extends Node(name) { ... },
    case class Leaf(String name, Node parent) extends Node(name) { ... };
    
    ...
    
}</programlisting>
        <programlisting>Node root = Node.root;
Node branch = Node.Branch("Furry", root);
Node leaf = Node.Leaf("Kittens", branch);</programlisting>
        </comment>
        
    </section>
    
        <section id="overloadedclasses">
            <title>Overloaded classes</title>
            
            <para>Multiple toplevel classes belonging to the same package, or multiple 
            member classes of the same containing class may declare the same name. The 
            classes are called <emphasis>overloaded</emphasis>. Overloaded classes:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must extend and overload a common <emphasis>root</emphasis>
                    type,</para>
                </listitem>
                <listitem>
                    <para>must have distinct erased signatures,</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters, and</para>
                </listitem>
                <listitem>
                    <para>except for the root type, may not declare any member with a 
                    visibility modifier.</para>
                </listitem>
            </itemizedlist>
            
            <para>Then the class name always refers to the root type, except in 
            instantiation expressions. An instantiation expression is resolved to a 
            particular overloaded class declaration at compile time, using the argument 
            expression types.</para>
            
        </section>
        
    <section id="overridingmemberclasses">
        <title>Overriding member classes</title>
        
        <para>Member class overriding is a unique feature of Ceylon, akin to the
        "factory method" pattern of many other languages.</para>
        
        <itemizedlist>
            <listitem>
                <para>A member class annotated <literal>default</literal> may be 
                overridden by any subtype of the class or interface which declares 
                the member class.</para>
            </listitem>
            <listitem>
                <para>A member class annotated <literal>abstract</literal> may be 
                overridden by any subtype of the class or interface which declares 
                the member class.</para>
            </listitem>
            <listitem>
                <para>A member class annotated <literal>abstract</literal> 
                <emphasis>must</emphasis> be overridden by every non-<literal>abstract</literal> class which is a subtype
                of the class or interface that declares the member class, unless the 
                class inherits a non-<literal>abstract</literal> member class from a 
                superclass that overrides the <literal>abstract</literal> member class.</para>
            </listitem>
        </itemizedlist>
        
        <para>To override a member class, the subtype must declare a member class:</para>
        
        <itemizedlist>
            <listitem>
                <para>annotated <literal>override</literal>,</para>
            </listitem>
            <listitem>
                <para>with the same name as the member class it overrides,</para>
            </listitem>
            <listitem>
                <para>that extends the member class it overrides, and</para>
            </listitem>
            <listitem>
                <para>with a formal parameter list with the same signature as the 
                member class it overrides, after substitution of type arguments
                specified in the <literal>extends</literal> or <literal>satisfies</literal>
                clause.</para>
            </listitem>
        </itemizedlist>
        
        <para>Finally, the overridden member class must be visible to the member
        class annotated <literal>override</literal>.</para>
        
        <para>Then instantiation of the member class is polymorphic, and the actual
        subtype instantiated depends upon the concrete type of the containing class
        instance.</para>
        
        <para>By default, the member class annotated <literal>override</literal> 
        has the same visibility modifier as the member class it overrides. The
        member class may not declare a stricter visibility modifier than the member 
        class it overrides.</para>
    
    </section>
        
    </section>
    
    <!--  
    <section>
        <title>Constructors</title>
        
        <para>Constructors are declared according to the following:</para>
        
        <programlisting>Annotation* Identifier 
FormalParams
( ";" | ClosedBlock )</programlisting>

        <para>
        For example:
        </para>
        
        <programlisting>Public: User(String username, Person person);</programlisting>
        <programlisting>Public: Integer(String string): value = parse(string);</programlisting>
        <programlisting>Public: User(String u, Person p) { username = u; person = p; }</programlisting>
        
        <para>
        The semantics of constructor declarations are identical to Java.
        </para>
        
        <para>
        A constructor body may omit the braces if it consists of exactly one statement. 
        If there is no constructor body at all, the constructor assigns each parameter to
        the attribute with the same name.
        </para>
        
        <para>
        A Ceylon constructor invocation is equivalent to a Java constructor invocation.
        </para>
                
        <programlisting>@FormalParameterNames({"username", "person"}) 
public User(String username, Person person);</programlisting>

    </section>
    -->
    
    <section id="methods">
        <title>Methods</title>
        
        <para>A <emphasis>method</emphasis> is a callable block of code. Methods may have 
        parameters and may return a value.</para>
        
        <programlisting>Method := MethodHeader ( Block | Specifier? ";" )</programlisting>
        
        <para>All method declarations specify the method name and one or more formal 
        parameter lists. A method declaration may specify a type, called the 
        <emphasis>return type</emphasis>, to which the values the method returns is 
        assignable, or it may specify that the method is a <literal>void</literal>
        method&mdash;a method which does not return a value. The return type of a
        <literal>void</literal> method is considered to be <literal>Void</literal>.</para>
        
        <programlisting>MethodHeader := Annotation* (InferableType | "void") MemberName TypeParams? FormalParams+ TypeConstraints?</programlisting>
        
        <para>A method implementation may be specified using either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a block of code, or</para>
            </listitem>
            <listitem>
                <para>a reference to another method.</para>
            </listitem>
        </itemizedlist>
        
        <para>A member method body may invoke, evaluate or assign members of the current 
        instance of the class which defines the method (the instance upon which the method 
        was invoked) without explicitly specifying the receiver.</para>
        
        <para>A member method body of a member class may invoke, evaluate or assign members 
        of the current instance of the containing class or interface (the containing instance 
        of the instance upon which the method was invoked) without explicitly specifying the 
        receiver.</para>
        
        <para>A toplevel method body may not refer to <literal>this</literal> or 
        <literal>super</literal>, since there is no current instance.</para>
        
        <para>A method may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        
        <para>The Ceylon compiler preserves the names of method parameters.</para>
        
        <section id="callabletype">
            <title>Callable type of a method</title>
            
        <para>The <emphasis>callable type</emphasis> of a method captures the return
        type and formal parameter types of the method.</para>
        
        <itemizedlist>
        <listitem>
            <para>The callable type of a method with a single parameter list is 
            <literal>Callable&lt;T,P...&gt;</literal> where <literal>T</literal> is the 
            declared type of the method, or <literal>Void</literal> if the method is 
            <literal>void</literal>, and <literal>P...</literal> are the formal 
            parameter types of the method.</para>
        </listitem>
        <listitem>
            <para>The callable type of a method with multiple parameter lists is 
            <literal>Callable&lt;O,P...&gt;</literal>, where <literal>O</literal> is the
            callable type of a method produced by eliminating the first formal parameter
            list, and <literal>P...</literal> are the formal parameter types of the first 
            formal parameter list of the method.</para>
        </listitem>
        </itemizedlist>
        
        <para>A sequenced parameter is considered of type <literal>T[]</literal> where 
        <literal>T...</literal> is the declared sequenced type.</para>
        
        </section>
        
        <section id="methodswithbodies">
            <title>Methods with bodies</title>
            
        <para>A method implementation may be a block. If the method is a <literal>void</literal> 
        method, the block may not contain a <literal>return</literal> directive that 
        specifies an expression. Otherwise, every conditional execution path of the block 
        must end in a <literal>return</literal> directive that specifies an expression
        assignable to the return type of the method.</para>
        
        <programlisting>public Integer add(Integer x, Integer y) {
    return x + y
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token()
}</programlisting>

        <programlisting>public void print(Object... objects) {
    for (Object object in objects) {
        log.info($object);
    }
}</programlisting>

        <programlisting>public void addEntry(V key -> U value) {
    map.define(key,value);
}</programlisting>

        <programlisting>public Set&lt;T&gt; singleton&lt;T&gt;(T element) 
        given T satisfies Comparable&lt;T&gt; {
    return TreeSet(element)
}</programlisting>

        <programlisting>public Float[n] float&lt;#n&gt;(Decimal[n] decimals) {
    return Vector&lt;Float,#n&gt;() containing (Bounded&lt;#n&gt; i) (decimals[i].float)
}</programlisting>

        <para>Note that a method which declares the return type <literal>Void</literal>
        is not a <literal>void</literal> method. A method with declared type 
        <literal>Void</literal> must return a value of type <literal>Void</literal> 
        (any value will do).</para>
        
        <programlisting>void say(String) { ... }

void hello() {
    say("hello");
}
        
Void goodbye() {
    return say("goodbye")
}</programlisting>
        
        <para>A block local method with a single <literal>return</literal> directive may 
        be declared using the keyword <literal>local</literal> in place of the explicit 
        return type declaration. The type of the method is inferred to be the type of the 
        returned expression.</para>
        
        <programlisting>local add(Integer x, Integer y) {
    return x + y
}</programlisting>
        
        </section>
        
        <section id="methodswithspecifiers">
            <title>Methods with specifiers</title>
            
        <para>Alternatively, a method implementation may be an expression that evaluates 
        to a callable object, specified using <literal>=</literal>. The type of the 
        callable object must be assignable to the callable type of the method.</para>
        
        <programlisting>Float say(String words) = person.say;</programlisting>
        
        <programlisting>Float sqrt(Float x) = 2.root;</programlisting>
        
        <programlisting>Comparison order(String x, String y) = getOrder();</programlisting>
        
        <para>The callable object expression may not refer to formal parameters of the
        method.</para>
        
        <para>A block local method which specifies a callable object expression may be 
        declared using the keyword <literal>local</literal> in place of the explicit 
        return type declaration. The return type of the method is inferred to be the
        type of the type argument to the first type parameter of the expression type
        <literal>Callable</literal> (the return type).</para>
        
        <programlisting>local sqrt(Float x) = 2.root;</programlisting>
        
        </section>
                
        <section id="multipleparameterlists">
            <title>Methods with multiple parameter lists</title>
            
        <para>A method may declare multiple lists of formal parameters. A method which 
        declares more than one formal parameter list returns instances of 
        <literal>Callable</literal>, usually method references.</para>
        
        <para>The type of the expression specified by the <literal>return</literal> 
        directive may be be assignable to either:</para>
        
        <itemizedlist>
            <listitem><para>the callable type of a method produced by taking the 
            method with multiple parameter lists and eliminating the first formal 
            parameter list, or</para></listitem>
            <listitem><para>the declared return type of the method.</para></listitem>
        </itemizedlist>
        
        <para>If the <literal>return</literal> expression type is assignable to the 
        callable type of the method produced by eliminating the first formal parameter 
        list of the method, the method body may <emphasis>only</emphasis> refer to 
        parameters in the first parameter list. It may not refer to parameters of 
        other parameter lists. Parameters declared by parameter lists other than the 
        first parameter list are not considered visible inside the body of the 
        method.</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    Comparison order(Natural x, Natural y) { return x&lt;=&gt;y }
    return order
}</programlisting>

        <para>Otherwise, if the <literal>return</literal> expression type is assignable 
        to the declared return type of the method, the method body may refer to any
        formal parameter in any one of the formal parameter lists of the method. The 
        compiler automatically infers a series of nested methods, one for each parameter 
        list of the method. The declarations and statements in the method body form the 
        body of the most nested inferred method.</para>
        
        <para>This method declaration:</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    return x&lt;=&gt;y
}</programlisting>

        <para>is equivalent to the previous example. The compiler infers a method with
        the same signature and implementation as <literal>order()</literal> above.</para>

        <para>For a method with <literal>n</literal> parameter lists, there are 
        <literal>n</literal> inferred methods. The <literal>i</literal>th inferred 
        method:</para>
        
        <itemizedlist>
            <listitem>
                <para>has the same return type as the original declared method,</para>
            </listitem>
            <listitem>
                <para>has the same formal parameter lists as the declared method, after 
                eliminating the first <literal>i-1</literal> formal parameter lists, 
                and</para>
            </listitem>
            <listitem>
                <para>if <literal>i&lt;n</literal>, has a body which contains the
                definition of the <literal>i+1</literal>th inferred method and 
                simply returns a reference to that method, or</para>
            </listitem>
            <listitem>
                <para>otherwise, if <literal>i=n</literal>, has the body of the original
                declared method.</para>
            </listitem>
        </itemizedlist>
        
        <para>The first inferred method replaces the original declared method in the 
        definition of the class.</para>
        
        <para>This method declaration:</para>
        
        <programlisting>public String fullName(String firstName)(String middleName)(String lastName) {
    return firstName + " " + middleName + " " lastName
}</programlisting>
        
        <para>Is equivalent to:</para>
        
        <programlisting>public String fullName(String firstName)(String middleName)(String lastName) {
    String fullName2(String middleName)(String lastName) {
        String fullName3(String lastName) {
            return firstName + " " + middleName + " " + lastName
        }
        return fullName3
    }
    return fullName2
}</programlisting>
        
        <!--
        <programlisting>@FormalParameterNames({"x", "y"}) 
public Integer add(Integer x, Integer y) { ... }</programlisting>
        -->
                
        </section>
        
        <section id="overloadedmethods">
            <title>Overloaded methods</title>
            
            <para>A class may declare or inherit multiple methods with the same name. 
            The methods are called <emphasis>overloaded</emphasis>. Overloaded methods:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must have distinct erased signatures, and</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters.</para>
                </listitem>
            </itemizedlist>
            
            <para>A class may not not declare of inherit a method with the same name as
            an attribute it declares or inherits.</para>
            
            <para>An invocation expression is resolved to a particular overloaded method 
            declaration at compile time, using the argument expression types.</para>
        
        </section>
        
       <section id="abstractmethods">
            <title>Interface methods and abstract methods</title>
            
            <para>If there is no method body in a method declaration, the implementation 
            of the method must be specified later in the block, or the class that declares 
            the method must be annotated <literal>abstract</literal>. If no implementation 
            is specified, the method is considered an <emphasis>abstract method</emphasis>.</para>
        
            <programlisting>public U? get(V key);</programlisting>
        
            <para>Methods declared by interfaces never specify an implementation:</para>
        
            <programlisting>AbstractMethod := MethodHeader ";"</programlisting>

        </section>
        
        <section id="overridingmethods">
            <title>Overriding methods</title>
            
            <para>Method overriding is the foundation of polymorphism in Ceylon.</para>
            
            <itemizedlist>
            <listitem>
                <para>A method annotated <literal>default</literal> may be overridden by 
                any subtype of the class which declares the method.</para>
            </listitem>
            <listitem>
                <para>A method annotated <literal>fixed</literal> <emphasis>must</emphasis> 
                be overridden by every subtype of the class or interface which declares the
                method.</para>
            </listitem>
            <listitem>
                <para>An interface method or abstract method may be overridden by any subtype 
                of the class or interface which declares the method.</para>
            </listitem>
            <listitem>
                <para>An interface method or abstract method <emphasis>must</emphasis> be 
                overridden by every non-<literal>abstract</literal> class that is a subtype 
                of the interface or abstract class, unless the class inherits a non-abstract 
                method from a superclass which overrides the interface method or abstract 
                method.</para>
            </listitem>
            </itemizedlist>           
            
            <para>To override a method, the subtype must declare a method:</para>
            
            <itemizedlist>
                <listitem>
                    <para>annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>with the same name as the method it overrides,</para>
                </listitem>
                <listitem>
                    <para>the same number of formal parameter lists, with the same
                    signatures, as the method it overrides, after substitution of 
                    type arguments specified in the <literal>extends</literal> or 
                    <literal>satisfies</literal> clause of the class, and</para>
                </listitem>
                 <listitem>
                    <para>with a return type that is assignable to the return type 
                    of the method it overrides in the compilation unit containing
                    the method annotated <literal>override</literal>, after 
                    substitution of type arguments specified in the 
                    <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the overridden method must be visible to the method
            annotated <literal>override</literal>.</para>
            
            <para>A method may not, directly or indirectly, override two different
            methods not themselves annotated <literal>override</literal>.</para>
        
            <para>Then invocation of the method is polymorphic, and the actual
            method invoked depends upon the concrete type of the class instance.</para>
            
            <para>By default, the method annotated <literal>override</literal> has 
            the same visibility modifier as the method it overrides. The method may 
            not declare a stricter visibility modifier than the method it 
            overrides.</para>
            
            <programlisting>abstract public class AbstractSquareRooter() {
    public Float squareRoot(Float x);
}</programlisting>

            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    override Float squareRoot(Float x) { ... }
}</programlisting>
            
            <para>For abstract methods, a special shortcut form of overriding is
            permitted. A subclass initializer may simply specify an instance of
            <literal>Callable</literal> as the implementation of the abstract
            method declared by the superclass. No formal parameter list, return 
            type declaration, or <literal>override</literal> annotation is 
            necessary.</para>
            
            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    Float sqrt(Float x) { ... }
    squareRoot = sqrt;
}</programlisting>
            
            <para>Toplevel methods cannot be overridden, and so toplevel method 
            invocation is never polymorphic.</para>
            
            <comment><para>TODO: are you allowed to override the default value of
            a defaulted parameter?</para></comment>
            
            <comment><para>TODO: are you required to have the same formal parameter
            names in the two methods? I don't see that this would be necessary. In
            a named parameter invocation, you just use the names declared by the
            member of the compile-time type, and they are mapped positionally to the
            parameters of the overriding method.</para></comment>
        
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to <emphasis>attribute</emphasis> 
        definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a 
                Java field or local variable).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived 
                attribute is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived 
                attribute is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be overridden by subclasses.</para>
        
        <para>All attributes have a type and name. The type of the attribute is specified
        by the simple attribute declaration or attribute getter declaration. An attribute 
        may be <literal>mutable</literal>, in which case its value can be assigned using 
        the <literal>:=</literal> and compound assignment operators. This is the case for
        simple attributes explicitly annotated <literal>mutable</literal>, or for 
        attributes with a setter declaration.</para>
            
        <programlisting>AttributeHeader := Annotation* InferableType MemberName</programlisting>
        
        <para>An attribute body may invoke, evaluate or assign members of the current 
        instance of the class which defines the method (the instance upon which the 
        attribute was invoked) without explicitly specifying the receiver.</para>
        
        <para>An attribute body of a member class may invoke, evaluate or assign members 
        of the current instance of the containing class or interface (the containing instance 
        of the instance upon which the attribute was invoked) without explicitly specifying 
        the receiver.</para>
        
        <para>An attribute may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier withing the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        
        
        <!--
        <para>
        An attribute declaration is equivalent to a Java method declaration together with 
        a Java field declaration, both of type <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal>, both with the same name as the attribute.
        </para>
        -->
        
        <section id="simpleattributesandlocals">
            <title>Simple attributes and locals</title>
            
        <para>A simple attribute defines state.</para>
        
        <programlisting>SimpleAttribute := AttributeHeader (Specifier | Initializer)? ";"</programlisting>
        
        <para>A simple attribute or local annotated <literal>mutable</literal> represents a
        value that can be assigned multiple times. A simple attribute or local not annotated
        <literal>mutable</literal> represents a value that can be specified exactly once.</para>
        
        <para>The value of a non-<literal>mutable</literal> attribute is specified using 
        <literal>=</literal>. A <literal>mutable</literal> attribute may be initialized using 
        the assignment operator <literal>:=</literal>.</para>

        <programlisting>Initializer := ":=" Expression</programlisting>

        <para>Formal parameters of classes and methods are also considered to be simple attributes.</para>
        
        <!--
        <para>For a simple attribute that is not a local, the Java field is initialized to an 
        instance of <literal>lang.SimpleAttribute</literal> or 
        <literal>lang.SimpleReadAttribute</literal>. For example:</para> 
         -->
        
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; firstName = new SimpleAttribute&lt;String&gt;();
Attribute&lt;String&gt; firstName() { return firstName; }</programlisting>

        <para>While:</para>
         -->
         
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;Natural&gt; count = new SimpleAttribute&lt;Natural&gt;(0);
private Attribute&lt;Natural&gt; count() { return count; }</programlisting>

        <para>And:</para>
        -->
        
        <programlisting>public Integer max = 99;</programlisting>
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Integer&gt; max = new SimpleReadAttribute&lt;Integer&gt;(99);
public ReadAttribute&lt;Integer&gt; max() { return max; }</programlisting>
        -->

        <programlisting>public Decimal pi = calculatePi();</programlisting>
        
        <programlisting>public Natural[5] evenDigits = {0,2,4,6,8};</programlisting>

        <para>A simple attribute declared directly inside the body of a class represents state 
        associated with the instance of the class. Repeated evaluation of the attribute of a 
        particular instance of the class returns the same result until the attribute of the 
        instance is assigned a new value.</para>
        
        <para>A <emphasis>local</emphasis> represents state associated with execution of a
        particular block of code. A local is really just a special case of a simple attribute 
        declaration, but one whose state is not held across multiple executions of the block
        of code in which the local is defined.</para> 
        
        <itemizedlist>
            <listitem>
                <para>A simple attribute declared inside a block (the body of a method, attribute 
                getter or attribute setter) is a local.</para>
            </listitem>
             <listitem>
                <para>A block local simple attribute declared inside the body of a class is a 
                local if it is not used inside a method, attribute setter or attribute getter 
                declaration.</para>
            </listitem>
           <listitem>
                <para>A formal parameter of a class is a local if it is not used inside a method, 
                attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a method is a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>A local is a block local declaration&mdash;it is visible only to statements and 
        declarations that occur later in the same block or class body, and therefore it may not 
        declare a visibility modifier.</para>
        
        <para>The semantics of locals are identical to Java local variables.</para>
        
        <para>The compiler is permitted to optimize block local simple attributes to a simple 
        Java field declaration or local variable. Block local attributes may not be accessed 
        via reflection.</para>
        
        <para>A block local simple attribute with a specifier or initializer may be declared 
        using the keyword <literal>local</literal> in place of the explicit type declaration. 
        The type of the local or attribute is inferred to be the type of the specifier or
        initializer expression.</para>
        
        <programlisting>local names = List&lt;String&gt;();</programlisting>
        <programlisting>mutable local count:=0;</programlisting>
                
        </section>
        
         <section id="attributegetters">
            <title>Attribute getters</title>
            
            <para>An attribute getter is a callable block of code with no parameters,
            that returns a value.</para>
            
            <programlisting>AttributeGetter := AttributeHeader Block</programlisting>
            
            <para>An attribute getter defines how the value of a derived attribute is
            obtained.</para>
            
            <!--
            <para>For an attribute getter, the Java field is initialized to an instance 
            of an anonymous inner subclass of <literal>lang.Attribute</literal> or
            <literal>lang.ReadAttribute</literal> that overrides the <literal>get()</literal> 
            method with the content of the getter block. For example: </para>
            -->
                    
        <programlisting>public Float total {
    Float sum := 0.0;
    for (LineItem li in lineItems) {
        sum += li.amount;
    }
    return sum
}</programlisting>
        
            <para>If an attribute getter has a matching attribute setter, we say that 
            the attribute is <literal>mutable</literal>. Otherwise we say it is 
            non-<literal>mutable</literal>.</para>
            
            <!--
            <programlisting>public Float total { return items.totalPrice }</programlisting>
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final ReadAttribute&lt;Float&gt; total = new ReadAttribute&lt;Float&gt;() {
    @Override public Float get() { return items.get().totalPrice; }
};
public ReadAttribute&lt;Float&gt; total() { return total; }</programlisting>
            -->
            
        <para>A block local attribute getter with a single <literal>return</literal>
        directive may be declared using the keyword <literal>local</literal> in place of 
        the explicit type declaration. The type of the local or attribute is inferred to 
        be the type of the returned expression.</para>
        
        <programlisting>local name { 
    return Name(firstName, initial, lastName) 
}</programlisting>
                
        </section>
        
        <section id="attributesetters">
            <title>Attribute setters</title>
                    
            <para>An attribute setter is a callable block of code that accepts a
            single value and does not return a value.</para>
            
            <programlisting>AttributeSetter := Annotation* "assign" MemberName Block</programlisting>

            <para>An attribute setter defines how the value of a derived attribute is
            assigned. Every attribute setter must have a corresponding getter with the
            same name.</para>

            <programlisting>public String name { return join(firstName, lastName) }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
            
            <!--
            <para>For an attribute with a setter, the Java field is initialized to an 
            instance of an anonymous inner subclass of <literal>lang.Attribute</literal> 
            that overrides the <literal>set()</literal> method with the content of the 
            setter block. For example:
            </para>
            -->
            
            <comment><para>TODO: should we require that the corresponding getter be 
            annotated <literal>mutable</literal>?</para></comment>
            
            <comment><para>TODO: should we allow overloaded attribute setters, for example:</para>
            <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>
            </comment>
            
            <!--
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final Attribute&lt;String&gt; name = new Attribute&lt;String&gt;() {
    @Override public String get() { return join(firstName, lastName); }
    @Override public void set(String name) { firstName = first(name); lastName = last(name); }
};
public Attribute&lt;String&gt; name() { return name; }</programlisting>
            -->
        </section>
        
        <section id="abstractattributes">
            <title>Interface attributes and abstract attributes</title>
            
            <para>If there is no specifier, initializer or getter implementation, the value 
            or implementation of the attribute must be specified later in the block, or 
            the class that declares the attribute must be annotated <literal>abstract</literal>. 
            If no value or implementation is specified, the attribute is considered an 
            <emphasis>abstract attribute</emphasis>.</para>
        
            <programlisting>package mutable String firstName;</programlisting>

            <para>Attributes declared by interfaces never specify an initalizer, getter 
            or setter:</para>
        
            <programlisting>AbstractAttribute := AttributeHeader ";"</programlisting>
                        
        </section>
        
        <section id="overridingattributes">
            <title>Overriding attributes</title>
            
            <para>Ceylon allows attributes to be overridden, just like methods. This helps
            eliminate the need for Java-style getter and setter methods.</para>
            
            <itemizedlist>
            <listitem>
                <para>An attribute annotated <literal>default</literal> may be overridden by 
                any subtype of the class or interface which declares the method.</para>
            </listitem>
            <listitem>
                <para>A method annotated <literal>fixed</literal> <emphasis>must</emphasis> 
                be overridden by every subtype of the class or interface which declares the
                method.</para>
            </listitem>
            <listitem>
                <para>An interface attribute or abstract attribute may be overridden by any 
                subtype of the class or interface which declares the method.</para>
            </listitem>
            <listitem>
                <para>An interface attribute or abstract attribute <emphasis>must</emphasis> 
                be overridden by every non-<literal>abstract</literal> class that is a subtype 
                of the interface or abstract class, unless the class inherits a non-abstract 
                attribute from a superclass which overrides the interface attribute or abstract 
                attribute.</para>
            </listitem>
            </itemizedlist>
            
            <para>A non-<literal>mutable</literal> attribute may be overridden by a simple 
            attribute or attribute getter. A <literal>mutable</literal> attribute may be 
            overridden by a <literal>mutable</literal> simple attribute or by an attribute 
            getter and setter pair.</para>
            
            <para>To override an attribute, the subtype must declare an attribute:</para>
            
            <itemizedlist>
                <listitem>
                    <para>annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>with the same name as the attribute it overrides,</para>
                </listitem>
                 <listitem>
                    <para>with a type that is assignable to the type of the attribute it 
                    overrides in the compilation unit containing the attribute annotated 
                    <literal>override</literal>, after substitution of type arguments 
                    specified in the <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class,</para>
                </listitem>
                 <listitem>
                    <para>or with <emphasis>exactly the same type</emphasis> as the 
                    attribute it overrides, after substitution of type arguments specified 
                    in the <literal>extends</literal> or <literal>satisfies</literal> clause
                    of the class, if the attribute it overrides is <literal>mutable</literal>, 
                    and</para>
                </listitem>
                <listitem>
                    <para>that is <literal>mutable</literal>, if the attribute it overrides 
                    is <literal>mutable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the overridden attribute must be visible to the attribute
            annotated <literal>override</literal>.</para>
        
            <para>A method may not, directly or indirectly, override two different
            methods not themselves annotated <literal>override</literal>.</para>
        
            <para>A non-<literal>mutable</literal> attribute may be overridden by a 
            <literal>mutable</literal> attribute.</para>
            
            <comment><para>TODO: is that really allowed? It could break the superclass.
            Should we say that you are allowed to do it when you implement an interface
            attribute, but not when you override a superclass attribute?</para></comment>
            
            <para>Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance.</para>
            
            <para>By default, the attribute annotated <literal>override</literal>
            has the same visibility modifier as the attribute it overrides. The
            attribute may not declare a stricter visibility modifier than the 
            attribute it overrides.</para>
            
            <programlisting>abstract module class AbstractPi() {
    module Float pi;
}</programlisting>

            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    override Float pi { ... }
}</programlisting>
            
            <para>For abstract attributes, a special shortcut form of overriding is
            permitted. A subclass initializer may simply specify or assign a value to 
            the attribute declared by the superclass. No type declaration or 
            <literal>override</literal> annotation is necessary.</para>
            
            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    Float calculatePi() { ... }
    pi = calculatePi();
}</programlisting>
            
        </section>
        
        <!--section id="getterandsettermethods">
            <title>Getter and setter methods</title>
            
            <para>For each attribute, one or two methods exist implicitly:</para>
            
            <itemizedlist>
                <listitem>
                    <para>a <emphasis>getter method</emphasis> with no parameters 
                    which returns the attribute type, and</para>
                </listitem>
                <listitem>
                    <para>a <literal>void</literal> <emphasis>setter method</emphasis> 
                    with a single parameter of the attribute type, if the attribute is 
                    <literal>mutable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>These methods may be referred to using the <literal>get</literal> and 
            <literal>set</literal> keywords, for example:</para>
            
            <programlisting>String name = get person.name();</programlisting>
            <programlisting>set person.name(newName);</programlisting>
            
        
        </section-->
                
    </section>
        
    <section id="typealiases">
       <title>Type aliases</title>
    
       <para>A <emphasis>type alias</emphasis> allows a type to be referred to more 
       compactly.</para>
       
       <programlisting>Alias := Annotation* "alias" TypeName TypeParams? SatisfiedTypes? TypeConstraints? ";"</programlisting>
       
       <para>A type alias may satisfy either a single interface or a single class.</para>
       
       <para>The alias type is assignable to the satisfied type, and the satisfied type 
       is assignable to the alias type.</para>
       
       <programlisting>public alias People satisfies List&lt;Person&gt;;</programlisting>
       
       
       <!--programlisting>alias Compare&lt;T&gt; satisfies functor Comparison(T x, T y);</programlisting-->
       
       <para>A shortcut is provided for definition of compilation unit local aliases.</para>
       
       <programlisting>import java.util.List alias JavaList;</programlisting>
       
       <para>Type aliases are not reified types. The metamodel reference for a type
       alias&mdash;for example, <literal>People</literal>&mdash; returns the metamodel 
       object for the aliased type&mdash;in this case, <literal>List&lt;Person&gt;</literal>.</para>
       
       <comment><para>TODO: could we reify them? This would let us define type aliases
       that satisfy multiple interfaces. For example:</para>
       <programlisting>package alias ComparableCollection&lt;X&gt; satisfies Collection&lt;X&gt;, Comparable&lt;X&gt;;</programlisting>
       </comment>
    
    </section>
    
   <section id="declaration modifiers">
        <title>Declaration modifiers</title>
        
        <para>In Ceylon, all declaration modifiers are annotations.</para>
        
    <section id="compilerinstructions">
        <title>Summary of compiler instructions</title>
        
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>public</literal>, <literal>module</literal>
                and <literal>package</literal> <!-- <literal>private</literal> -->
                determine the visibility of a declaration (by default, the 
                declaration is visible only to statements and declarations 
                that appear later inside the same block).</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated<!--, or that a method or attribute of 
                an abstract class must be implemented by all 
                non-<literal>abstract</literal> subclasses-->.</para>
            </listitem>
            <listitem>
                <para><literal>default</literal> specifies that a method, 
                attribute, or member class may be overridden by subclasses.</para>
            </listitem>
            <listitem>
                <para><literal>override</literal> indicates that a method,
                attribute, or member type overrides a method, attribute, 
                or member type defined by a supertype.</para>
            </listitem>
            <listitem>
                <para><literal>mutable</literal> specifies that an attribute
                or local may be assigned, or that a class has assignable
                attributes.</para>
            </listitem>
            <listitem>
                <para><literal>fixed</literal> specifies that a method or
                attribute must be overridden by every subclass.</para>
            </listitem>
            <!--listitem>
                <para><literal>final</literal> indicates that a class may not 
                be extended, or that a method or attribute may not be 
                overridden.</para>
            </listitem-->
            <listitem>
                <para><literal>extension</literal> specifies that a method or
                attribute getter is a converter, or that a class is a decorator.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated. It accepts an optional
                <literal>String</literal> argument.</para>
            </listitem>
            <listitem>
                <para><literal>volatile</literal> indicates a volatile simple 
                attribute.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: should it be called <literal>overrides</literal>?</para></comment>
        
        <para>The following annotation is a hint to the compiler that lets 
        the compiler optimize compiled bytecode for non-64 bit architectures:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>small</literal> specifies that a value of type
                <literal>Natural</literal>, <literal>Integer</literal> or
                <literal>Float</literal> contains 32-bit values.</para>
            </listitem>
        </itemizedlist>
        
        <para>By default, <literal>Natural</literal>, <literal>Integer</literal>
        and <literal>Float</literal> are assumed to represent 64-bit values.</para>
        
        <para>The annotation names in this section are treated as keywords by 
        the Ceylon compiler. This is a performance optimization to minimize 
        the need for lookahead in the parser.</para>
        
        <comment><para>TODO: Should we require an <literal>abstract</literal>
        modifier for abstract methods and attributes of abstract classes
        like Java does?</para></comment>
        
    </section>
       
       <!--
       <para>The following annotations are important to the Ceylon SDK.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>id</literal> specifies that an attribute should
                be tested by the <literal>equals()</literal> method, and included
                in the <literal>hash</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>transient</literal> specifies that an attribute 
                is not included in the serialized form of the object.</para>
            </listitem>
            <listitem>
                <para><literal>read</literal> and <literal>write</literal>
                indicate methods or attributes that are protected from multithreaded
                access using a reentrant read/write lock with deadlock detection.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method or
                attribute getter is executed at most once, and the resulting 
                value is cached.</para>
            </listitem>
        </itemizedlist>
        -->
        
    <section id="visibility">
        <title>Visibility and name resolution</title>
        
        <para>Classes, interfaces, aliases, methods, attributes, locals, formal parameters 
        and type parameters have names. Occurrence of a name in code implies a hard 
        dependency from the code in which the name occurs to the schema of the named 
        declaration. We say that a class, interface, alias, method, attribute, formal 
        parameter or type parameter is <emphasis>visible</emphasis> to a certain program 
        element if its name may occur in the code that defines that program element.</para>
        
        <itemizedlist>
            <listitem>
                <para>A formal parameter or type parameter is never visible outside the 
                declaration it belongs to.</para> 
            </listitem>
            <listitem>
                <para>Any declaration that occurs inside a block (the body of a method, 
                attribute getter or attribute setter) is not visible to code outside the 
                block.</para>
            </listitem>
        </itemizedlist>
        
        <para>The visibility of any other declaration depends upon its <emphasis>visibility
        modifier</emphasis>, if any. By default:</para>
        
        <itemizedlist>
            <listitem>
                <para>a declaration that occurs directly inside a class body is not
                visible to code outside the class definition, and</para>
            </listitem>
            <listitem>
                <para>a toplevel declaration is not visible to code outside the 
                package containing its compilation unit.</para>
            </listitem>
        </itemizedlist>
        
        <para>The visibility of a declaration with a visibility modifier annotation
        is determined by the visibility modifier:</para>
        
        <itemizedlist>
            <!--
            <listitem>
                <para><literal>private</literal> specifies that the declaration is 
                visible to all code in the same compilation unit,</para>
            </listitem>
            -->
            <listitem>
                <para><literal>package</literal> specifies that the declaration is 
                visible to all code in any compilation unit in the same package,</para>
            </listitem>
            <listitem>
                <para><literal>module</literal> specifies that the declaration is 
                visible to all code in any package in the same module,</para>
            </listitem>
            <listitem>
                <para><literal>public</literal> specifies that the declaration is 
                visible to all code in any module.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that the <literal>package</literal> modifier is redundant for toplevel 
        declarations.</para>
        
        <comment><para>TODO: Should we call the visibility levels <literal>public</literal>,
        <literal>shared</literal>, <literal>internal</literal> so they are all adjectives 
        rather than nouns?</para></comment>
        
        <para>The visibility of a nested declaration may not be less strict than the 
        visibility of the body (class body, interface body, or block) which contains 
        it. For example, a <literal>package</literal>-visibility class may not contain 
        a <literal>public</literal>-visibility attribute, method, or member class. 
        Likewise, a block may not declare a visibility modifier, so a declaration that 
        occurs inside a block may not declare a visibility modifier. Note, however, 
        that this restriction does not apply to the visibility of nested declarations 
        annotated <literal>override</literal> which inherit their visibility from the 
        declaration they override.</para>
        
        <para>The class <literal>ceylon.lang.Visibility</literal> defines the visibility 
        levels:</para>
        
        <programlisting>public class Visibility {
        
    doc "A program element visible to all 
         compilation units."
    case public, 
    
    doc "A program element visible to  
         compilation units in the same
         module."
    case module, 

    doc "A program element visible to  
         compilation units in the same
         package."
    case package, 

    doc "A program element local to the
         block in which it is defined."
    case block; 
    
}</programlisting>

<!--
    doc "A program element visible to  
         the compilation unit in which
         its is declared."
    case private, 
-->
    
        <para>The following declarations define the visibility 
        modifier annotations:</para>
    
        <programlisting>doc "The |public| visibility modifier 
     annotation." 
annotation { occurs=onceEachElement; } 
public Visibility public() { 
    return public 
}</programlisting>

        <programlisting>doc "The |module| visibility modifier 
     annotation."
annotation { occurs=onceEachElement; } 
public Visibility module() { 
    return module
}</programlisting>

        <programlisting>doc "The |package| visibility modifier 
     annotation."
annotation { occurs=onceEachElement; } 
public Visibility package() { 
    return package 
}</programlisting>
        
        <!--
        <programlisting>doc "The |private| visibility modifier 
     annotation."
annotation { occurs=onceEachElement; } 
public Visibility private() { 
    return private 
}</programlisting>
        -->

        <comment><para>TODO: how are we going to go about compiling these classes which
        <emphasis>define</emphasis> the reserved-word annotations? A special compiler
        switch to turn off these reserved words? (Seems reasonable.)</para></comment>
       
    </section>
    
    <section id="extensions">
        <title>Extensions</title>
        
        <para>An extension allows values of one type to be transparently converted to 
        values of another type. Extensions are declared by annotating a method, attribute 
        or class <literal>extension</literal>. An extension must be:</para>
        
        <itemizedlist>
            <listitem>
                <para>a toplevel method with exactly one formal parameter named
                <literal>this</literal>,</para>
            </listitem>
            <listitem>
                <para>a member method with no formal parameters,</para>
            </listitem>
            <listitem>
                <para>a toplevel class with exactly one initialization parameter named
                <literal>this</literal>,</para>
            </listitem>
            <listitem>
                <para>a member class with no initializer parameters, or</para>
            </listitem>
            <listitem>
                <para>an attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>An toplevel extension method is called a <emphasis>converter</emphasis>. 
        An toplevel extension class is called a <emphasis>decorator</emphasis>.</para>
                
        <para>Extensions apply to a certain <emphasis>extended type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for toplevel extension methods, the extended type is the declared
                type of the formal parameter,</para>
            </listitem>
            <listitem>
                <para>for member extension methods, the extended 
                type is the type that declares the extension method,</para>
            </listitem>
            <listitem>
                <para>for toplevel extension classes, the extended type is the declared 
                type of the initialization parameter,</para>
            </listitem>
            <listitem>
                <para>for member extension classes, the extended type is the type that 
                contains the member class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the extended type is the type that 
                declares the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>Extensions define an <emphasis>introduced type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for extension methods, the introduced type is the declared
                return type of the method,</para>
            </listitem>
            <listitem>
                <para>for extension classes, the introduced type is the class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the introduced type is the declared
                type of the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>The introduced type may not be a <literal>mutable</literal> type.</para>
        
        <programlisting>public extension Log objectToLog(Object this) {
    return this.log;
}</programlisting>
        
        <programlisting>public class Person(User user) {
    ...
    public extension User user = user;
    ...
}</programlisting>

        <programlisting>public extension class SequenceUtils&lt;N&gt;(N[] this) 
        given N extends Number, Comparable&lt;N&gt; {
    
    public N[] positiveElements() {
        return this.elements() where (N n) (n&gt;0)
    }
    
    public N[] elementsLessThan(N limit) {
        return this.elements() where (N n) (n&lt;limit)
    }
    
    ...   
}</programlisting>
        
        <!-- 
        <comment><para>Note: I actually much prefer the readability of 
        <literal>User personToUser(extends Person person)</literal> and
        <literal>SequenceUtils&lt;T&gt;(extends T[] collection)</literal>, 
        but this doesn't work for attributes and member methods.</para></comment>
         -->
        
        <para>We say that an extension class or toplevel method is <emphasis>enabled</emphasis> 
        in a compilation unit if the class or toplevel method is imported by that 
        compilation unit, and the <literal>import</literal> statement is annotated 
        <literal>extension</literal>. If the <literal>import</literal> statement is 
        not annotated extension, the declaration is imported normally and is not
        be treated as an extension in that compilation unit.</para>
        
        <programlisting>import extension org.domain.app.extensions.objectToLog;
import extension org.domain.utils.SequenceUtils;</programlisting>

        <para>A wildcard <literal>.*</literal>-style import may not be used to import 
        an extension.</para>
        
        <para>An extension attribute, member class or member method is enabled in every 
        compilation unit.</para>
        
        <para>If an extension is enabled in a compilation unit, the extended type is 
        assignable to the introduced type in that compilation unit.</para>
        
        <programlisting>import extension org.mydomain.myproject.extensions.objectToLog;
...
Person person = ...;
User user = person;
info("person is a User and this is a Log!");</programlisting>
        
        <!--
        <para>Is equivalent to the following Java code:</para>
        
        <programlisting>Person person = ...;
User user = personToUser(person);</programlisting>
        -->
        
        <programlisting>import extension org.domain.utils.SequenceUtils;
...
Integer[] zeroToOneHundred = 0..100;
Integer[] oneToNine = zeroToOneHundred.positiveElements().elementsLessThan(10);</programlisting>
        
        <!--
        <para>Is equivalent to this Java code:</para>
    
        <programlisting>Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = new SequenceUtils(collection).nonZeroElements();</programlisting>
        -->
        
        <para>An introduced type may result in an ambiguity:</para>
        
        <itemizedlist>
            <listitem>
                <para>the introduced type may have a member type with the same name 
                as a member type of the extended type, or of some other introduced 
                type, and the two member types may have non-distinct erased signatures,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have a method with the same name as a 
                method of the extended type, or of some other introduced type, and 
                the two methods may have non-distinct erased signatures,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have an attribute with the same name 
                as an attribute or method of the extended type, or of some other 
                introduced type,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have a method with the same name as 
                an attribute of the extended type, or of some other introduced type.</para>
            </listitem>
        </itemizedlist>
        
        <para>In this case, the member type, method or attribute may not be called. 
        Any invocation or evaluation of the member results in a compiler error.</para>
        
        <para>When an invocation of an introduced method or evaluation of an introduced 
        attribute is executed, or when an instance of the extended type is assigned to 
        a program element of the introduced type:</para>
        
        <itemizedlist>
            <listitem>
                <para>First, the instance of the extended type is inspected to determine
                if the runtime type is a subtype of the introduced type. If so, the
                instance is cast to the introduced type.</para>
            </listitem>
            <listitem>
                <para>Otherwise, the extension is invoked to produce an instance of the 
                introduced type that will receive the invocation or evaluation.</para>
            </listitem>
        </itemizedlist>
        
        <para>It's even possible to define an extension to a metatype:</para>
        
        <programlisting>public extension class StringType(Type&lt;String&gt; this) {
    public String concat(String a, String b) { return a + " " + b }
}</programlisting>

        <para>Resulting in a syntax very much like a Java-style "static" invocation.</para>

        <programlisting>log.info(String.concat(a, b));</programlisting>
        
        <!--
        <comment><para>TODO: extensions are nice, and quite powerful, but they aren't enough to
        implement an embedded query language like in JPA. Dynamic languages let you implement a
        method to respond to an unknown member invoked at runtime. Java 6 lets you do a similar
        thing at compile time using a processor (a compiler plugin). I think we can have the best
        of both worlds and let you write an extension method that returns a set of members to be
        introduced to the extended type.</para></comment>
        -->
        
    </section>
    
    <section id="annotationconstraints">
        <title>Annotation constraints</title>
        
        <para>The following meta-annotations provide information to the compiler about the 
        annotations upon which they appear. They are applied to a toplevel method declaration 
        that defines an annotation.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>inherited</literal> specifies that the annotation is automatically 
                inherited by subtypes.</para>
            </listitem>
            <listitem>
                <para><literal>annotation</literal> specifies constraints upon the occurence of 
                an annotation. By default, an annotation may appear multiple times on any program 
                element.</para>
            </listitem>
        </itemizedlist>
        
        <para>The meta-annotation <literal>annotation</literal> accepts the following parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>occurs</literal> specifies that the annotation may occur at 
                most once in a certain scope. Its accepts one argument of type
                <literal>Occurrence</literal>: <literal>onceEachElement</literal>, 
                <literal>onceEachType</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>of</literal> specifies the kinds of program element 
                at which the annotation occurs. Its accepts one or more arguments of type
                <literal>Element</literal>: <literal>classes</literal>, <literal>interfaces</literal>,
                <literal>methods</literal>, <literal>attributes</literal>, <literal>aliases</literal>,
                <literal>parameters</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>withType</literal> specifies that the annotation may only 
                be applied to types that are assignable to the specified type, to
                attributes or parameters of the specified type, or to methods with the
                specified return type.</para>
            </listitem>
            <listitem>
                <para><literal>withParameterTypes</literal> specifies that the annotation 
                may only be applied to methods with the specified formal parameter types.</para>
            </listitem>
            <listitem>
                <para><literal>withAnnotation</literal> specifies that the annotation may 
                only be applied to program elements at which the specified annotation occurs.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>public 
annotation { 
    of = classes; 
    occurs = onceEachType; 
}
Entity entity(LockMode lockMode) { 
    return Entity(lockMode) 
}</programlisting>

        <programlisting>public 
annotation { 
    of = { attributes, parameters }; 
    withType = String; 
    occurs = onceEachElement; 
}
PatternValidator pattern(Regex regex) { 
    return PatternValidator(regex)
}</programlisting>
            
        <comment><para>TODO: Should <literal>annotation</literal> be required
        for toplevel methods which can be used as annotations?</para></comment>
        
    </section>
    
    <section id="documentation">
        <title>Documentation</title>
    
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the description of a 
                program element.</para>
            </listitem>
            <listitem>
                <para><literal>by</literal> specifies the authors of a program 
                element.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <literal>String</literal> arguments to the <literal>deprecated</literal>, 
        <literal>doc</literal>, <literal>throws</literal> and <literal>by</literal> 
        annotations are parsed by the documentation compiler as Seam Text, a 
        simple ANTLR-based wiki text format.</para>
        
        <para>These annotations are defined by the package <literal>doc</literal>:</para>
        
        <programlisting>inherited annotation { occurs = onceEachElement; }
public Description doc(String description) {
    return Description(description.normalize())
}</programlisting>
    
        <programlisting>annotation { occurs = onceEachElement; }
public Author[] by(String... authors) {
    return from (String author in authors) 
                select Author(author.normalize())
}</programlisting>
    
        <programlisting>public RelatedElement see(ProgramElement pe) {
    return Related(pe)
}</programlisting>
    
        <programlisting>public RelatedElement see(ProgramElement pe -> String description) {
    return Related(pe, description.normalize())
}</programlisting>
    
        <programlisting>public Related throws(Type&lt;Exception&gt; type) {
    return ThrownException(type)
}</programlisting>
        
        <programlisting>public ThrownException throws(Type&lt;Exception&gt; type -> String description) {
    return ThrownException(type, description.normalize())
}</programlisting>
        
     </section>
        
     </section>

</chapter>