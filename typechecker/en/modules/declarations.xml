<chapter id="declarations">
    <title>Declarations</title>
    
    <para>All classes, interfaces, methods, attributes and locals must be declared.</para>
    
    <section id="generaldeclarations">
        <title>General declaration syntax</title>
        
        <para>All declarations follow a general pattern.</para> 
      
    <section id="abstractdeclaration">
        <title>Abstract declaration</title>
        
        <para>Declarations conform to the following general schema:</para>
        
        <programlisting>Annotation* 
keyword? Type? (TypeName|MemberName) TypeParams? FormalParams*
Supertype?
Interfaces? 
TypeConstraints? 
Body?</programlisting>

        <para>The Ceylon compiler enforces identifier naming conventions. Types must
        be named with an initial uppercase. Members, parameters, locals and packages
        must be named with an initial lowercase or underscore.</para>
        
        <programlisting>PackageName := LIdentifier</programlisting>
        <programlisting>TypeName := UIdentifier</programlisting>
        <programlisting>MemberName := LIdentifier</programlisting>
        <programlisting>ParameterName := LIdentifier</programlisting>
        
        <para>Ceylon defines three identifier namespaces:</para>
        
        <itemizedlist>
            <listitem>
                <para>classes, interfaces and aliases share a single namespace,</para>
            </listitem>
            <listitem>
                <para>methods, attributes and locals share a single namespace, and</para>
            </listitem>
            <listitem>
                <para>packages have their own dedicated namespace.</para>
            </listitem>
        </itemizedlist>
        
        <para>The Ceylon parser is able to unambiguously identify which namespace an 
        identifier belongs to.</para>
        
   </section>
      
    <section id="topleveldeclaration">
        <title>Imports and toplevel declarations</title>
        
        <para>A toplevel declaration defines a type&mdash;a class, interface or type 
        alias&mdash;or a method.</para>
        
        <programlisting>ToplevelDeclaration := TypeDeclaration | Method</programlisting>
        
        <programlisting>TypeDeclaration := Class | Interface | Alias</programlisting>
        
        <para>All toplevel declarations with a visibility modifier less strict than
        <literal>private</literal> must have the same name as the compilation unit 
        filename (after removing the file suffix <literal>.ceylon</literal>). For 
        example, a <literal>public</literal> toplevel class named <literal>Person</literal> 
        must be defined in a file named <literal>Person.ceylon</literal>. A 
        <literal>public</literal> toplevel method named <literal>hello()</literal> 
        must be defined in a file named <literal>hello.ceylon</literal>. Unlike 
        Java, a compilation unit may contain multiple toplevel class or method 
        declarations with the same name.</para>
        
        <para>A compilation unit consists of a list of imported toplevel types and 
        toplevel methods, followed by one or more type or method definitions:</para>
        
        <programlisting>Import* ToplevelDeclaration+</programlisting>
        
        <para>Each compilation unit belongs to exactly one <emphasis>package</emphasis>.
        An <literal>import</literal> statement allows the compilation unit to refer to a 
        toplevel declaration in another package.</para>
        
        <programlisting>Import := "import" FullPackageName "." ImportSpec ";"</programlisting>
        
        <para>A package is a namespace. A full package name is a period-separated
        list of initial lowercase identifiers.</para>
        
        <programlisting>FullPackageName := PackageName ("." PackageName)*</programlisting>
        
        <para>An <literal>import</literal> statement may import either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a single (toplevel or member) type,</para>
            </listitem>
            <listitem>
                <para>a single toplevel method,</para>
            </listitem>
            <listitem>
                <para>a single named enumerated instance of a class,</para>
            </listitem>
            <listitem>
                <para>all toplevel declarations of a specified package, or</para>
            </listitem>
            <listitem>
                <para>all named enumerated instances and member types of a specified class
                or interface.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>ImportSpec := TypeSpec | MethodSpec | InstanceSpec | PackageMembersSpec | TypeMembersSpec</programlisting>
        
        <programlisting>TypeSpec := QualifiedTypeName ("alias" TypeName)?</programlisting>
        <programlisting>MethodSpec := MemberName ("alias" MemberName)?</programlisting>
        <programlisting>InstanceSpec := QualifiedTypeName "." MemberName ("alias" MemberName)?</programlisting>
        
        <para>The character <literal>*</literal> acts as a wildcard, just like in Java.</para>
        
        <programlisting>PackageMembersSpec := "*"</programlisting>
        <programlisting>TypeMembersSpec := QualifiedTypeName "." "*"</programlisting>
        
        <para>The name of a member type must be qualified by the names of its containing
        types.</para>
        
        <programlisting>QualifiedTypeName := (TypeName ".")* TypeName</programlisting>
        
        <para>The optional <literal>alias</literal> clause allows resolution of 
        cross-namespace declaration name collisions.</para>
        
        <programlisting>import lang.collections.*;</programlisting>
        
        <programlisting>import transaction.propagation.TxPropagationType.*;</programlisting>
        
        <programlisting>import java.util.Map.Entry alias MapEntry;</programlisting>
        
        <programlisting>import my.math.fibonnacciNumber alias fib;</programlisting>
        
        <programlisting>import my.query.Order.descending alias desc;</programlisting>
        
        <para>Code in one compilation unit may refer to a toplevel declaration in another 
        compilation unit in the same package without explicitly importing the declaration. 
        It may refer to a toplevel declaration defined in a compilation unit in another 
        package only if it explicitly imports the declaration.</para>
        
        <comment><para>TODO: Does Ceylon support toplevel attributes? Perhaps just 
        non-<literal>mutable</literal> toplevel attributes?</para></comment>
            
     </section>
    
    <section id="annotationlist">
    <title>Annotation list</title>

        <para>Declarations may be preceded by a list of annotations.</para>
    
        <programlisting>Annotation := MemberName ( Arguments | Literal+ )?</programlisting>
        
        <para>Unlike Java, the name of an annotation may not be a qualified name.</para>
        
        <para>For an annotation with no arguments, or with only literal-valued arguments, 
        the parentheses around, and commas between, the positional arguments may be 
        omitted.</para>
        
        <programlisting>doc "The user login action"
throws #DatabaseException 
       "if database access fails"
by "Gavin King"
   "Andrew Haley"
see #LogoutAction.logout
scope(session) 
action { description="Log In"; url="/login"; }
public deprecated</programlisting>

        <para>An annotation is an invocation of a toplevel method that occurs when the 
        type is loaded by the virtual machine. The return value of the invocation is 
        made available via reflection.</para>
        
        <para>For example, the built-in <literal>doc</literal> annotation is defined as 
        follows:</para>
        
        <programlisting>public multiplicity(onceEachElement) 
Description doc(String description) { 
    return Description(description.normalize())
}</programlisting>
        
        <para>The annotation may be specified at a program element using any one of three 
        forms.</para>
        
        <para>Using a positional parameter invocation of the method:</para>
        
        <programlisting>doc("the name") String name;</programlisting>
        
        <para>Using a named parameter invocation of the method:</para>
        
        <programlisting>doc {description="the name";} String name;</programlisting>
        
        <para>Or using the special abbreviated form for annotations with literal value
        arguments:</para>
        
        <programlisting>doc "the name" String name;</programlisting>
        
        <para>And its value may be obtained like this:</para>
        
        <programlisting>Description description = (#Person).annotations(#Description).first;</programlisting>
        
        <para>Unlike Java, the same annotation may appear multiple times for the same
        program element. Furthermore, different annotations (toplevel methods) may 
        return values of the same type.</para>
        
    </section>
    
    <section id="type">
        <title>Type</title>
    
        <para>Method, attribute and formal parameter declarations must declare a type.</para>
        
        <para>A <emphasis>type</emphasis> or <emphasis>type schema</emphasis> is name 
        (an initial upper case identifier) and an optional list of type parameters, with 
        a set of:</para>
        
        <itemizedlist>
            <listitem>
                <para>attribute schemas,</para>
            </listitem>
            <listitem>
                <para>member method schemas, and</para>
            </listitem>
            <listitem>
                <para>member class schemas.</para>
            </listitem>
        </itemizedlist>
        
        <para>Speaking formally:</para>
        
        <itemizedlist>
            <listitem>
                <para>An <emphasis>attribute schema</emphasis> is a name (an initial lower 
                case identifier) with a type and mutability.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>method schema</emphasis> is a name (an initial lower case 
                identifier) and an optional list of type parameters, with a type (often 
                called the <emphasis>return type</emphasis>) and a list of one or more formal 
                parameter lists.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>class schema</emphasis> is a type with a formal parameter 
                list.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>formal parameter list</emphasis> is a list of names 
                (initial lower case identifiers) with types. The 
                <emphasis>signature</emphasis> of a formal parameter list is formed by 
                discarding the names, leaving the list of types.</para>
            </listitem>
        </itemizedlist>
        
        <para>Speaking slightly less formally, we usually refer to an attribute, method, or 
        member class of a type, meaning an attribute shema, member method schema or member 
        class schema.</para>
        
        <para>The <emphasis>erased signature</emphasis> of a method or class is formed by:</para>
        
        <itemizedlist>
            <listitem>
                <para>taking the signature of the formal parameter list of the member class, 
                or of the first formal parameter list of the method, and</para>
            </listitem>
            <listitem>
                <para>replacing each occurrence of any type alias in the signature with the
                aliased type, and</para>
            </listitem>
            <listitem>
                <para>replacing each occurrence of <literal>Optional&lt;T&gt;</literal> in 
                the signature with <literal>T</literal>, and</para>
            </listitem>
            <listitem>
                <para>replacing each occurrence of any type parameter in the signature with 
                the first declared upper bound of the type parameter, or <literal>lang.Object</literal> 
                if there is no declared upper bound, and</para>
            </listitem>
            <listitem>
                <para>replacing the type of any varargs type parameter in the signature with 
                <literal>lang.Object...</literal>, and then</para>
            </listitem>
            <listitem>
                <para>discarding the type arguments of each element of the list, leaving just 
                the name of a class or interface.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>Note: I really, really hate this stuff. Is there any way we can do 
        better than Java here?</para></comment>
        
        <para>Two erased signatures are considered <emphasis>distinct</emphasis> if they 
        have different lengths, or if at some position within the lists, the two types are 
        non-identical.</para>
        
        <comment><para>TODO: non-identical, or non-assignable?</para></comment>
            
        <para>A type may not have:</para>
        
        <itemizedlist>
            <listitem>
                <para>two attributes with the same name,</para>
            </listitem>
            <listitem>
                <para>a method and an attribute with the same name,</para>
            </listitem>
            <listitem>
                <para>two methods with the same name and non-distinct erased signatures, 
                or</para>
            </listitem>
            <listitem>
                <para>two member classes with the same name and non-distinct erased signatures.</para>
            </listitem>
        </itemizedlist>
        
        <para>A type may be <emphasis>assignable</emphasis> to another type. If <literal>X</literal>
        is assignable to <literal>Y</literal>, then:</para>
        
        <itemizedlist>
            <listitem>
                <para>For each non-<literal>mutable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has an attribute with the same name, whose type is 
                assignable to the type of the attribute of <literal>Y</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>mutable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has a <literal>mutable</literal> attribute with the 
                same name and the same type.</para>
            </listitem>
            <listitem>
                <para>For each method of <literal>Y</literal>, <literal>X</literal>
                has a method with the same name, with the same number of formal parameter 
                lists, with the same signatures, and whose return type is assignable to the 
                return type of the method of <literal>Y</literal>.</para>
            </listitem>
            <listitem>
                <para>For each member class of <literal>Y</literal>, <literal>X</literal>
                has a member class of the same name, with a formal parameter list with 
                the same signature, that is assignable to the member class of 
                <literal>Y</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Assignability obeys the following rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>Identity: <literal>X</literal> is assignable to <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>Transitivity: if <literal>X</literal> is assignable to <literal>Y</literal>
                and <literal>Y</literal> is assignable to <literal>Z</literal> then
                <literal>X</literal> is assignable to <literal>Z</literal>.</para>
            </listitem>
            <listitem>
                <para>Nullsafety: the type <literal>lang.Optional</literal> is 
                not assignable to <literal>lang.Object</literal>. Nor is its subtype
                <literal>lang.Nonexistent</literal>.</para>
            </listitem>
            <listitem>
                <para>Single root: all other types are assignable to <literal>lang.Object</literal>,
                including classes, interfaces, aliases and type parameters.</para>
            </listitem>
        </itemizedlist>
        
        <para>Types are identified by the name of the type (a class, interface, alias or 
        type parameter), together with a list of type arguments if the type definition 
        specifies formal parameters.</para>
        
        <programlisting>Type := ( TypeNameWithArguments ("." TypeNameWithArguments)* | "subtype" ) Abbreviation*</programlisting>
        
        <para>Unlike Java, the name of a type may not be qualified by the package name.</para>

        <para>Certain declarations which usually require an explicit type may omit the type, 
        forcing the compiler to infer it, by specifying the keyword <literal>local</literal>
        where the type usually appears.</para>
        
        <programlisting>InferableType := Type | "local"</programlisting>
        
        <para>Type inference is only allowed for block local declarations. The keyword
        <literal>local</literal> may not be combined with a visibility modifier annotation.</para>
        
        <para>The following type name abbreviations are supported:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>X?</literal> means <literal>Optional&lt;X&gt;</literal> for
                any type <literal>X</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>X[]</literal> means <literal>Sequence&lt;X&gt;</literal> for
                any type <literal>X</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Abbreviation := "?" | "[" "]"</programlisting>
        
        <para>Abbreviations may be combined:</para>
        
        <programlisting>String?[] words = { "hello", "world", null };
String?? firstWord = words[0];</programlisting>
        
        <comment><para>TODO: Should we support <literal>Item...</literal>
        as an abbreviation for <literal>Iterable&lt;Item&gt;</literal>?</para></comment>
        
        <comment><para>TODO: It might be difficult to support <literal>T??</literal>
        since <literal>Optional</literal> is erased.</para></comment>
    
    </section>
        
    <section id="generictypeparameterlist">
        <title>Generic type parameter list</title>
    
        <para>Methods, classes, interfaces and aliases may declare one or more generic type 
        parameters.</para>
        
        <programlisting>TypeParams := "&lt;" TypeParam ("," TypeParam)* VarargsTypeParam "&gt;"</programlisting>
        
        <para>A declaration with type parameters is called <emphasis>generic</emphasis> or
        <emphasis>parameterized</emphasis>.</para>
        
        <itemizedlist>
        <listitem>
          <para>A class or interface declaration with no type parameters defines exactly one 
          type. A parameterized class or interface declaration defines a template for
          producing types: one type for each possible combination of type arguments that 
          satisfy the type constraints specified by the class or interface. The types of 
          members of the this type are determined by replacing every appearance of each type 
          parameter in the schema of the parameterized type definition with its type argument.</para>
        </listitem>
        <listitem>
          <para>A method declaration with no type parameters defines exactly one operation 
          per type. A parameterized method declaration defines a template for producing
          overloaded operations: one operation for each possible combination of type arguments 
          that satisfy the type constraints specified by the method declaration.</para>
        </listitem>
        <listitem>
          <para>A class declaration with no type parameters defines exactly one instantiation 
          operation. A parameterized class declaration defines a template for producing 
          overloaded instantiation operations: one instantiation operation for each possible 
          combination of type arguments that satisfy the type constraints specified by the 
          class declaration. The type of the object produced by an instantiation operation is 
          determined by substituting the same combination of type arguments for the type 
          parameters of the parameterized class.</para>
        </listitem>
        </itemizedlist>
        
        <para>A type parameter is itself a type, visible within the body of the declaration
        it parameterizes. A type parameter is assignable to every upper bound of the type 
        parameter. However, a class, interface, or alias may not extend or implement a type 
        parameter.</para>
        
        <para>Each type parameter has a name and a specified <emphasis>variance</emphasis>.</para>
        
        <programlisting>TypeParam := Variance TypeName</programlisting>
        
        <para>A <emphasis>covariant</emphasis> type parameter is indicated using <literal>out</literal>.
        A <emphasis>contravariant</emphasis> type parameter is indicated using <literal>in</literal>.</para>
        
        <programlisting>Variance :=  ("out" | "in")?</programlisting>
        
        <para>A type parameter declared neither <literal>out</literal> nor <literal>in</literal> 
        is called <emphasis>nonvariant</emphasis>.</para>
        
        <programlisting>Map&lt;K, V&gt;</programlisting>
        
        <programlisting>Sender&lt;in M&gt;</programlisting>
        
        <programlisting>Container&lt;out T&gt;</programlisting>
        
        <programlisting>BinaryFunction&lt;in X, in Y, out R&gt;</programlisting>
        
        <comment><para>TODO: Would <literal>produces</literal> and <literal>consumes</literal> 
        be better?</para></comment>
        
        <para>For a generic type <literal>T&lt;X&gt;</literal>, a type <literal>A</literal>,
        and a subtype <literal>B</literal> of <literal>A</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    If <literal>X</literal> is a covariant type parameter, 
                    <literal>T&lt;B&gt;</literal> is assignable to <literal>T&lt;A&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is a contravariant type parameter, 
                    <literal>T&lt;A&gt;</literal> is assignable to <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is nonvariant (neither covariant nor contravariant), 
                    there is no assignability between <literal>T&lt;A&gt;</literal> and 
                    <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>A covariant type parameter may only appear in covariant positions of the type 
        definition. A contravariant type parameter may only appear in contravariant positions 
        of the type definition. Nonvariant type parameters may appear in any position.</para>
        
        <itemizedlist>
            <listitem>
                <para>The return type of a method is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A formal parameter type of a method is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A type parameter of a method is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A formal parameter type of a member class initializer is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A type parameter of a member class is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>The type of a non-<literal>mutable</literal> attribute is a covariant position.</para>
            </listitem>
            <listitem>
                <para>The type of a <literal>mutable</literal> attribute is a nonvariant position.</para>
            </listitem>
            <listitem>
                <para>An upper bound of a type parameter in a contravariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>An upper bound of a type parameter in a covariant position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A lower bound of a type parameter in a contravariant position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A type parameter in a covariant position cannot have a lower bound. <comment>TODO: is 
                this correct?</comment></para>
            </listitem>
            <listitem>
                <para>A covariant type parameter of a type in a covariant position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A contravariant type parameter of a type in a covariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A covariant type parameter of a type in a contravariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A contravariant type parameter of a type in a contravariant position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A nonvariant type parameter or a type is a nonvariant position.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a functional parameter in a contravariant position is covariant.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a functional parameter in a covariant position is contravariant.</para>
            </listitem>
            <listitem>
                <para>The return type of a functional parameter in a contravariant position is contravariant.</para>
            </listitem>
            <listitem>
                <para>The return type of a functional parameter in a covariant position is covariant.</para>
            </listitem>
        </itemizedlist>
        
        <para>These rules apply to members declared by the type, and to members inherited from supertypes.</para>
        
        <para>Every Ceylon class or interface has an implicit type parameter that never
        needs to be declared. This special type parameter, referred to using the keyword 
        <literal>subtype</literal>, represents the concrete type of the current instance 
        (the instance that is being invoked). It is considered a covariant type parameter
        of the type, and may only appear in covariant positions of the type definition.
        It is upper bounded by the type (and is therefore assignable to the type).</para>
        
        <programlisting>public interface Wrapper&lt;out X&gt; {}</programlisting>
        
        <programlisting>public abstract class Wrappable() {
   public Wrapper&lt;subtype&gt; wrap() {
       return Wrapper(this)
   }
}</programlisting>
        
        <programlisting>public class Special() extends Wrappable() {}</programlisting>

        <programlisting>Special special = Special();
Wrapper&lt;Special&gt; wrapper = special.wrap();</programlisting>

        <para>The only expression assignable to the type <literal>subtype</literal> is
        the special value <literal>this</literal>, except inside the body of a method or
        attribute annotated <literal>fixed</literal>, where the class that declares the
        method or attribute is assignable to <literal>subtype</literal>.</para>
        
        <comment><para>TODO: should we let you declare type constraints on 
        <literal>subtype</literal>?</para></comment>
        
        <para>A <emphasis>varargs type parameter</emphasis>, identified by an elipsis
        <literal>...</literal> accepts a list of zero or more type arguments.</para>
        
        <programlisting>VarargsTypeParam := TypeName "..."</programlisting>
        
        <para>Varargs type parameters are always non-variant.</para>
        
        <para>Inside the declaration of the parameterized type, a varargs type parameter 
        may be used as a type argument to other types which accept a varargs type parameter, 
        or it may be used as the type of the last formal parameter declared by a method.
        It may not appear in any other position. The varargs type parameter acts as a 
        pseudo-type. It is treated by the Ceylon compiler as if it were a type with no 
        members, to which no other type may be assigned, and which can only by assigned to 
        itself.</para>
        
        <programlisting>Method&lt;X, T, P...&gt;</programlisting>
        
    </section>

    <section id="typeargumentlist">
        <title>Type argument list</title>
            
        <para>A list of type arguments produces a new type from a parameterized type, or
        a new method schema from a method schema with type parameters.</para>
        
        <programlisting>TypeNameWithArguments := TypeName TypeArguments?</programlisting>
        
        <programlisting>Entry&lt;String,Person&gt;</programlisting>
        <programlisting>Stack&lt;Frame&gt;.Entry</programlisting>
        
        <para>A type argument must be specified for every type parameter. If the type has
        type parameters, an argument list must be specified. In addition, An arbitrary list 
        of zero or more type parameters may be specified for a varargs type parameter. If 
        the type has no type parameters, and no varargs type parameter, no argument list 
        may be specified.</para>        
        
        <programlisting>TypeArguments := "&lt;" Type ("," Type)* "&gt;"</programlisting>
        
        <para>A type argument is substituted for every appearance of the corresponding
        type parameter in the schema of the parameterized type definition, including:</para>
        
        <itemizedlist>
            <listitem>
                <para>attribute types,</para>
            </listitem>
            <listitem>
                <para>method return types,</para>
            </listitem>
            <listitem>
                <para>method formal parameter types,</para>
            </listitem>
            <listitem>
                <para>initializer formal parameter types, and</para>
            </listitem>
            <listitem>
                <para>type arguments of extended classes and satisfied interfaces.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Map&lt;Key, Value&gt;</programlisting>
        
        <para>In the case of a varargs type parameter:</para>
        
        <itemizedlist>
        <listitem> 
            <para>the type arguments are appended to the list of type arguments in every 
            parameterized type in which the varargs type parameter appears, and</para>
        </listitem>
        <listitem> 
            <para>a list of formal parameters whose types are the type arguments is
            appended to the list of formal parameters of every method declaration in
            which the varargs type parameter appears.</para>
        </listitem>
        </itemizedlist>
        
        <programlisting>Method&lt;Order, Item, Product prod, Natural quantity&gt;</programlisting>
        
        <comment><para>TODO: do we need to let you fill in the formal parameter names?
        If we don't, you won't be able to call this thing using named parameters, and
        we need some special definition in the spec defining how method references
        carry their parameter names with them.
        <programlisting>Method&lt;Order, Item, Product prod, Natural quantity&gt;</programlisting>
        </para></comment>
        
        <para>A type argument may itself be a parameterized type or type parameter.</para>
        
        <programlisting>Map&lt;Key, List&lt;Item&gt;&gt;</programlisting>
        
        <para>Substitution of type arguments may result in an ambiguity:</para>
        
        <itemizedlist>
            <listitem>
                <para>two methods of the parameterized type with the same name may now
                also have non-distinct erased signatures, or</para>
            </listitem>
            <listitem>
                <para>two member classes of the parameterized type with the same name may 
                now also have non-distinct erased signatures.</para>
            </listitem>
        </itemizedlist>
        
        <para>In this case, the member class or method may not be called. Any invocation of the 
        member results in a compiler error.</para>
        
        <para>A type with an ambiguity may never be extended or implemented by another type.
        It may not appear in an <literal>extends</literal>, <literal>satisfies</literal> or
        <literal>abstracts</literal> clause.</para>
        
        <para>Type arguments are <emphasis>reified</emphasis> in Ceylon. An instance of a generic 
        type holds a reference to its type arguments. Therefore, the following are legal in Ceylon:</para>
        
        <itemizedlist>
            <listitem>
                <para>testing the runtime value of a type argument of an instance, for 
                example, <literal>objectList is List&lt;Person&gt;</literal> or 
                <literal>case (is List&lt;Person&gt;)</literal>,</para>
            </listitem>
            <listitem>
                <para>filtering exceptions based on type arguments, for example,
                <literal>catch (NotFoundException&lt;Person&gt; pnfe)</literal>,</para>
            </listitem>
            <listitem>
                <para>testing the runtime value of an instance against a type parameter,
                for example <literal>x is T</literal>, or against a type with a type 
                parameter as an argument, for example, 
                <literal>objectList is List&lt;T&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>obtaining a <literal>Type</literal> object representing a type with 
                type arguments, for example, <literal>#List&lt;Person&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>obtaining a <literal>Type</literal> object representing the runtime 
                value of a type parameter, for example, <literal>#T</literal>, or of a 
                type with a type parameter as an argument, for example, 
                <literal>#List&lt;T&gt;</literal>,</para>
            </listitem>
            <listitem>
                <para>obtaining a <literal>Type</literal> object representing the
                runtime value of a type argument of an instance using reflection, for 
                example, <literal>objectList.type.arguments.first</literal>, and</para>
            </listitem>
            <listitem>
                <para>instantiating a type parameter with an initialization parameter
                specification, for example, <literal>T(parent)</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Varargs type parameters are not reified. None of the above operations can be
        performed with a vararg type parameter.</para>
                
    </section>
    
    <section id="formalparameterlist">
        <title>Formal parameter list</title>
    
        <para>Method and class declarations may declare formal parameters, including
        defaulted parameters and a varargs parameter.</para>
        
        <programlisting>FormalParams := 
"("
FormalParam ("," FormalParam)* ("," DefaultParam)* ("," VarargsParam)? | 
DefaultParam ("," DefaultParam)* ("," VarargsParam)? | 
VarargsParam?
")"</programlisting>

        <programlisting>FormalParam := Param | EntryParamPair | RangeParamPair</programlisting>
        
        <para>Each parameter is declared with a type and name and may have annotations and/or
        parameters of its own.</para>
        
        <programlisting>Param := Annotation* (Type|"void") ParameterName FormalParams*</programlisting>
        
        <para>A parameter with its own parameter list (or lists) is called a 
        <emphasis>functional parameter</emphasis>. Think of it as an abstract local method that 
        must be defined by the caller when the method is invoked or the class is instantiated. 
        </para>
            
        <programlisting>(String label, void onClick())</programlisting>
        
        <programlisting>(Comparison by(X x, X y))</programlisting>
        
        <para>A functional parameter declaration is equivalent to a formal parameter declaration 
        with no parameter lists where the type is the operation type of the method declaration.
        So the above are equivalent to:</para>
        
        <programlisting>(String label, Operation&lt;Object&gt; onClick)</programlisting>
        
        <programlisting>(Operation&lt;Comparison,X,X&gt; by)</programlisting>
        
        <para>Defaulted parameters specify a default argument.</para>
    
        <programlisting>DefaultParam := FormalParam Specifier</programlisting>
        
        <para>The <literal>=</literal> specifier is used throughout the language to indicate a 
        value which cannot be reassigned.</para>
        
        <programlisting>Specifier := "=" Expression</programlisting>
        
        <para>Defaulted parameters must occur after non-defaulted parameters in the formal
        parameter list.</para>
        
        <programlisting>(Product product, Natural quantity=1)</programlisting>
        
        <para>The type of the default argument expression must be assignable to the declared
        type of the formal parameter.</para>
        
        <para>The elipsis <literal>...</literal> indicates that a formal parameter is 
        either:</para>
        
        <itemizedlist>
            <listitem>
                <para>A <emphasis>varargs parameter</emphasis>, which accepts a list of arguments 
                of the specified type <literal>T</literal>, or a single argument of type 
                <literal>Iterable&lt;T&gt;</literal>. Inside the method, the varargs parameter 
                has type <literal>Iterable&lt;T&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>A <emphasis>tuple parameter</emphasis> representing a list of parameters 
                whose types are defined by a varargs type parameter. Inside the method, the 
                argument has the pseudo type of the varargs type parameter and is assignable to 
                any tuple parameter of the same pseudo-type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>VarargsParam := Annotation* Type "..." ParameterName</programlisting>
        
        <para>The varargs parameter or tuple parameter must be the last formal parameter in the 
        list.</para>
        
        <programlisting>(Name name, Organization? org=null, Address... addresses)</programlisting>
        
        <programlisting>(T instance, P... args)</programlisting>
        
        <comment><para>TODO: should we just make <literal>X...</literal> a syntactic shorthand
        for <literal>Iterable&lt;X&gt;</literal> everywhere? Or, alternatively, should we also
        allow <literal>Iterator&lt;X&gt;</literal> to be passed to <literal>X...</literal>?</para></comment>
        
        <para>Parameters of type <literal>Entry</literal> or <literal>Range</literal> 
        may be specified as a pair of variables.</para>
        
        <programlisting>EntryParamPair := Annotation* Type ParameterName "->" Type ParameterName</programlisting>

        <programlisting>RangeParamPair := Annotation* Type ParameterName ".." ParameterName</programlisting>
        
        <para>A variable pair declaration of form <literal>U u -> V v</literal> results in a single 
        parameter of type <literal>Entry&lt;U,V&gt;</literal>.</para>
        
        <programlisting>(Key key -> Value value)</programlisting>
        
        <para>A variable pair declaration of form <literal>T x .. y</literal> results in a single 
        parameter of type <literal>Range&lt;T&gt;</literal>.</para>
        
        <programlisting>(Float value, Integer min..max)</programlisting>
        
        <para>A formal parameter may not be be declared <literal>mutable</literal>, and may not be
        assigned to within the body of the method or class.</para>
        
    </section>
    
    <section id="extendedclass">
        <title>Extended class</title>
    
        <para>A class may extend another class using the <literal>extends</literal> clause.</para>
        
        <programlisting>Supertype := "extends" Type PositionalArguments</programlisting>
    
        <para>A class may extend only one superclass. If the superclass is a parameterized
        type, the <literal>extends</literal> clause must specify type arguments.</para>
        
        <programlisting>extends Person(name, org)</programlisting>
    
        <para>Suppose <literal>X</literal> and <literal>Y</literal> are classes.</para>
    
        <itemizedlist>
        <listitem>
            <para>If <literal>X</literal> extends <literal>Y</literal>, then
            <literal>X</literal> is assignable to <literal>Y</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X</literal> extends <literal>Y&lt;B&gt;</literal>, then
            <literal>X</literal> is assignable to <literal>Y&lt;B&gt;</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> extends <literal>Y&lt;T&gt;</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y&lt;B&gt;</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> extends <literal>Y</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
        <para>A user-defined class may not extend <literal>Optional</literal>,
        <literal>Existent</literal> or <literal>Nonexistent</literal>, since these
        classes are not reified types.</para>
        
    </section>
    
    <section id="satisfiedinterfaces">
        <title>Satisfied interfaces</title>
    
        <para>Classes and interfaces may satisfy (implement or extend) interfaces, 
        using the <literal>satisfies</literal> clause.</para>
        
        <programlisting>Interfaces = "satisfies" Type ("," Type)*</programlisting>
    
        <para>A class or interface may satisfy multiple interfaces. If a satisfied 
        interface is a parameterized type, the <literal>satisfies</literal> clause 
        must specify type arguments.</para>
        
        <programlisting>satisfies T[], Collection&lt;T&gt;</programlisting>
        
        <para>Suppose <literal>Y</literal> is an interface and <literal>X</literal> is
        a class or interface.</para>
    
        <itemizedlist>
        <listitem>
            <para>If <literal>X</literal> satisfies <literal>Y</literal>, then
            <literal>X</literal> is assignable to <literal>Y</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X</literal> satisfies <literal>Y&lt;B&gt;</literal>, then
            <literal>X</literal> is assignable to <literal>Y&lt;B&gt;</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> satisfies <literal>Y&lt;T&gt;</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y&lt;B&gt;</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> satisfies <literal>Y</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
    </section>

    <section id="generictypeconstraintlist">
    <title>Generic type constraint list</title>

        <para>Method, class and interface declarations which declare generic type 
        parameters may declare constraints upon the type parameters using the
        <literal>where</literal> clause.</para>
        
        <programlisting>TypeConstraints = ("where" TypeConstraint)+</programlisting>
    
        <programlisting>TypeConstraint := TypeName FormalParams? Interfaces? Subtypes?</programlisting>
        
        <programlisting>Subtypes := "abstracts" Type ("," Type)*</programlisting>
        
        <para>There are three kinds of type constraint:</para>
        
        <itemizedlist>
            <listitem>
                <para>an upper bound, <literal>X satisfies T</literal>, specifies that 
                the type parameter <literal>X</literal> is assignable to a given
                type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>a lower bound, <literal>X abstracts T</literal>, specifies that 
                a given type <literal>T</literal> is assignable to the type parameter 
                <literal>X</literal>,</para>
            </listitem>
            <!--listitem>
                <para>a subtype bound, <literal>X = subtype</literal>, specifies that 
                the type parameter <literal>X</literal> represents the concrete type
                of the current instance, and</para>
            </listitem-->
            <listitem>
                <para>an initialization parameter specification, <literal>X(...)</literal>
                specifies that the type parameter <literal>X</literal> is a class with
                the given formal parameter types.</para>
            </listitem>
        </itemizedlist>
        
        <para>A constraint may not refer to a varargs type parameter.</para>
        
        <!--
        <para>Subtype bounds are needed since the special type <literal>subtype</literal>
        cannot appear in a contravariant position. A subtype bound cannot be applied to
        a covariant or contravariant type parameter.</para>
        -->
        
        <para>Initialization parameter specifications allow instantiation of the generic 
        type.</para>
        
        <para>A constraints affects the type arguments that can be assigned to a type
        parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type argument to a type parameter with an upper bound must be a type 
                which is assignable to all upper bounds.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with a lower bound must be a type 
                to which all lower bounds are assignable.</para>
            </listitem>
        </itemizedlist>
        
        <para>A constraint affects the assignability of a type parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type parameter is considered assignable to its upper bound.</para>
            </listitem>
            <listitem>
                <para>The lower bound of a type parameter is considered assignable to the
                type parameter.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>where X satisfies Number&lt;X&gt;
where Y(Natural count) satisfies Number&lt;Y&gt;</programlisting>

        <programlisting>where T satisfies Ordinal, Comparable&lt;T&gt; abstracts X</programlisting>
    
        <comment><para>TODO: Should we move <literal>in</literal> and <literal>out</literal>
        down to the <literal>where</literal> clause?</para></comment>
    
    </section>
    
    </section>
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An <emphasis>interface</emphasis> is a type schema. Interfaces do not 
        specify the implementation of their members and may not be directly instantiated.</para>
        
        <programlisting>Interface :=
Annotation*
"interface" TypeName TypeParams?
Interfaces?
TypeConstraints? 
InterfaceBody</programlisting>

        <programlisting>InterfaceBody := "{" AbstractDeclaration* "}"</programlisting>

        <para>The body of an interface contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute and member class) declarations, and</para>
            </listitem>
            <listitem>
                <para>nested interface declarations.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>AbstractDeclaration := AbstractMethod | AbstractAttribute | TypeDeclaration</programlisting>

        <para>Interface method and attribute declarations may not specify implementation.</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>

        <!-- 
        <para>Which is equivalent to the following Java interface:</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>
        -->
        
        <para>Interface members inherit the visibility modifier of the interface.</para>
        
        <comment><para>TODO: Refine this. Consider block-local interface declarations.</para></comment>
          
        <comment><para>TODO: if methods of interfaces can define defaulted parameters,
        precisely how do we implement that?</para></comment>
            
        <section id="interfaceinheritance">
            <title>Interface inheritance</title>
            
            <para>An interface may extend any number of other interfaces.</para>
        
            <programlisting>public interface List&lt;T&gt;
        satisfies T[], Collection&lt;T&gt; {
    ...
}</programlisting>
        
            <para>The types listed after the <literal>satisfies</literal> keyword are the 
            supertypes. All supertypes of an interface must be interfaces.</para>
            
            <!--para>
            Since every class that implements an interface is a subclass of <literal>lang.Object</literal>,
            the interface type itself is considered assignable to <literal>lang.Object</literal>.
            </para-->
        
            <para>The semantics of interface inheritance are exactly the same as Java. An 
            interface inherits all members (methods, attributes and member types) of every 
            supertype.</para>
        
            <para>The schema of the inherited members is formed by substituting type arguments
            specified in the <literal>satisfies</literal> clause.</para>
        
            <!--
            <para>and the above declaration is equivalent to the following 
            Java declaration: 
            </para>
        
            <programlisting>public interface List&lt;T&gt; 
        extends Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
            -->
            
        </section>
        
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A <emphasis>class</emphasis> is a stateful, instantiable type. It is a 
        type schema, together with implementation details of the members of the type.</para>
        
        <programlisting>Class :=
Annotation*
"class" TypeName TypeParams? FormalParams
Supertype?
Interfaces?
TypeConstraints?
ClassBody</programlisting>

        <programlisting>ClassBody := "{" Instances? (Declaration | Statement)* "}"</programlisting>
        
        <para>The body of a class contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute and member class) declarations,</para>
            </listitem>
            <listitem>
                <para>nested interface declarations,</para>
            </listitem>
            <listitem>
                <para>instance initialization code, and,</para>
            </listitem>
            <listitem>
                <para>optionally, a list of enumerated named instances of the class.</para>
            </listitem>
        </itemizedlist>

        <programlisting>Declaration := Method | SimpleAttribute | AttributeGetter | AttributeSetter | TypeDeclaration</programlisting>
        
        <para>A class may be annotated <literal>mutable</literal>. If a class is not 
        annotated <literal>mutable</literal> it is called an <emphasis>immutable type</emphasis>, 
        and it may not:</para> 
        
        <itemizedlist>
            <listitem>
                <para>declare or inherit <literal>mutable</literal> attributes,</para>
            </listitem>
            <listitem>
                <para>extend a <literal>mutable</literal> superclass, or</para>
            </listitem>
            <listitem>
                <para>implement an interface annotated <literal>mutable</literal>.</para>
            </listitem>
        </itemizedlist>
    
        <para>Ordinarily, a declaration that occurs in a block of code is a block local
        declaration&mdash;it is visible only to statements and declarations that occur
        later in the same block. This rule is relaxed for certain declarations that occur 
        directly inside a class body:</para>
            
        <itemizedlist>
            <listitem>
                <para>declarations with explicit visibility modifiers&mdash;whose visibility
                is determined by the modifier, and</para>
            </listitem>
            <listitem>
                <para>declarations that occur in the second part of the body of the class, 
                after the last statement of the initializer&mdash;which are visible to all
                other declarations in the second part of the body of the class.</para>
            </listitem>
        </itemizedlist>
        
    <section id="classinitializer">
        <title>Class initializer</title>
        
        <para>Ceylon classes do not support a Java-like constructor declaration syntax. 
        Instead:</para>
        
        <itemizedlist>
           <listitem>
              <para>The body of the class declares <emphasis>initialization 
              parameters</emphasis>. An initialization parameter may be used anywhere in 
              the class body, including in method and attribute definitions.</para>
           </listitem>
           <listitem>
              <para>The initial part of the body of the class is called the 
              <emphasis>initializer</emphasis> and contains a mix of declarations, statements 
              and control structures. The initializer is executed every time the class is 
              instantiated.</para>
           </listitem>
        </itemizedlist>
        
        <para>An initialization parameter may be used to specify or initialize the value of an 
        attrbute:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock = lock;
}</programlisting>
        
        <programlisting>public class Counter(Natural start=0) {
    public mutable Natural count := start;
    public void inc() { count++; }
}</programlisting>
        
        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private final ReadAttribute&lt;Lock&gt; lock;
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) {
        this.lock = new SimpleReadAttribute&lt;Lock&gt;(lock); 
    }
    
}</programlisting>
         -->
        <para>An initialization parameter may even be used within the body of a method,
        attribute getter, or attribute setter:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock { return lock }
}</programlisting>

        <programlisting>public class Key(Lock lock) {
    public void lock() { lock.engage(this); }
    public void unlock() { lock.disengage(this); }
}</programlisting>

        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private Lock _lock;
        
    private final ReadAttribute&lt;Lock&gt; lock = new ReadAttribute&lt;Lock&gt;() {
        @Override public Lock get() { return _lock; }
    };
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) { 
        _lock = lock; 
    }
    
}</programlisting>
        -->
        
        <para>A subclass must pass values to each superclass initialization 
        parameter in the <literal>extends</literal> clause.</para>

        <programlisting>public class SpecialKey1()
        extends Key( new SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>public class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>

        <!--
        <para>Which are equivalent to the Java:</para>
        
        <programlisting>public class SpecialKey1 
        extends Key {
    public SpecialKey1() { 
        super( SpecialLock() );
    }
    ... 
}</programlisting>

        <programlisting>public class SpecialKey2 
        extends Key {
    public SpecialKey2(Lock lock) { 
        super(lock);
    }
    ... 
}</programlisting>
        -->
        
        <para>The class initializer is responsible for initializing the state of a new instance
        of the class, before a reference to the new instance is available to clients.</para>
        
        <programlisting>public mutable class DiagonalPoint(Decimal position) 
        extends Point() {
    
    x := y := sqrt(position**2/2) * position.sign;
    
    assert ("must have distance " position " from origin") 
        that ( x**2 + y**2 == position**2 );
    
}</programlisting>
        
        <!--
        <para>So the above class is equivalent to:</para>
        
        <programlisting>public class DiagonalPoint extends Point {
        
    public DiagonalPoint(final Decimal position) {
    
        x = y = sqrt( position.power(2).divided(2) ).times(position.sign);
        
        assert_(new F0&lt;String&gt;() {
                   public String call() { 
                       return "must have distance " + position + " from origin";
                   }
                },
                new F0&lt;Boolean&gt;() {
                   public Boolean call() { 
                       return ( x.power(2) + y.power(2) ).equals( position.power(2) );
                   }
                });
    }
    
}</programlisting>
        -->
        
        <para>An initializer may invoke, evaluate or assign members of the current instance 
        of the class (the instance being initialized) without explicitly specifying the 
        receiver.</para>
        
        <para>An initializer of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class (the instance upon which the constructor
        was invoked) without explicitly specifying the receiver.</para>
        
        <para>A class may be declared inside the body of a method or attribute, in which case 
        the initializer may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        
        <para>The following restrictions apply to statements and declarations that appear within
        the initializer of the class:</para>
        
        <itemizedlist>
           <listitem>
              <para>They may not evaluate attributes or invoke methods that are declared later
              in the body of the class upon the current object or <literal>this</literal>.</para>
           </listitem>
           <listitem>
              <para>They may not pass <literal>this</literal> as an argument of a method invocation
              or the value of an attribute assignment.</para>
           </listitem>
           <listitem>
              <para>They may not declare an abstract method or attribute.</para>
           </listitem>
           <listitem>
              <para>They may not declare a <literal>default</literal> method or attribute.</para>
           </listitem>
        </itemizedlist>
        
        <para>The remainder of the body of the class consists purely of declarations, including
        abstract and <literal>default</literal> methods and attributes. It may not directly contain 
        statements or control structures, but may freely use <literal>this</literal>, and may 
        invoke any method or evaluate any attribute of the class. The usual restriction that a 
        declaration may only be used by code that appears later in the block containing the 
        declaration is relaxed. The declarations in this section may not contain specifiers
        or initializers (<literal>=</literal> or <literal>:=</literal>).</para>
        
        <para>Superclass members may be invoked, evaluated or assigned anywhere inside the body of
        the class. The superclass initializer is executed before the subclass initializer.</para>
        
        <comment><para>TODO: should class initialization parameters be allowed to be declared 
        <literal>public/package/module</literal>, allowing a shortcut simple attribute declaration 
        like in Scala?</para></comment>
        
        <para>The <emphasis>operation type</emphasis> of a class captures the type and formal parameter 
        types of the class. The operation type is <literal>Callable&lt;T,P...&gt;</literal>, where
        <literal>T</literal> is the class and <literal>P...</literal> are the formal parameter types 
        of the class.</para>
        
        <!-- comment>
        
        <para>TODO: I would really, really like to believe that one "constructor"
        per class is sufficient, but somehow I'm not quite buying it. We can allow the
        declaration of additional constructors, according to:</para>
        
        <programlisting>Constructor := Annotation* TypeName FormalParams Supertype Block</programlisting>
        
        <para>for example:</para>
        
        <programlisting>public class Person(Name name) {
    public Person(String name) extends Person( Name(name) ) {}
}</programlisting>
        
        </comment-->
                
        <!--
        <section>
        <title>Annotations</title>
        
        <para>Every annotation is a toplevel (non-void) method call. This Ceylon class:</para>
        
        <programlisting>doc "Represents a person"
by "Gavin"
public class Person { ... }</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>public class Person { ... 

    static {
        Type&lt;Person&gt; type = Type.get(Person.class);
        type.addAnnotation( doc("Represents a person") );
        type.addAnnotation( by("Gavin") );
        type.addAnnotation( public() );
    }

    ...

}</programlisting>
        
        </section>
        -->

    </section>

        <section id="classinheritance">
             <title>Class inheritance</title>
        
        <para>
        A class may extend another class, and implement any number of interfaces.
        </para>
        
        <programlisting>public mutable
class Customer(Name name, Organization? org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>
        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt;, Identifier {
    ... 
}</programlisting>
        
        <para>
        The types listed after the <literal>satisfies</literal> keyword are the implemented
        interfaces. The type specified after the <literal>extends</literal> keyword is a 
        superclass.
        </para>
        
        <para>
        If a class does not explicitly specify a superclass using <literal>extends</literal>,
        its superclass is <literal>lang.Object</literal>. There are three exceptions to this
        rule: the built-in classes <literal>lang.Object</literal>, <literal>lang.Optional</literal>,
        and <literal>lang.Referenceable</literal> which do not have superclasses.
        </para>
        
        <para>
        The semantics of class inheritance are exactly the same as Java. A class:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>inherits all members (methods, attributes, and member types) of 
                its superclass, except for members that it <emphasis>overrides</emphasis>,</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which its superclass is assignable,</para>
            </listitem-->
            <listitem>
                <para>must declare or inherit a member that overrides each member of 
                every interface it implements directly or indirectly, unless the class 
                is declared <literal>abstract</literal>, and</para>
            </listitem>
             <listitem>
                <para>must declare or inherit a member that overrides each abstract 
                member of its superclass, unless the class is declared 
                <literal>abstract</literal>.</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which any interface it implements is 
                assignable.</para>
            </listitem-->
        </itemizedlist>
        
        <para>The schema of the inherited members is formed by substituting type arguments
        specified in the <literal>extends</literal> clause.</para>
        
        <para>
        Furthermore, the initializer of the superclass is always executed before the
        initializer of the subclass whenever the subclass is instantiated.
        </para>
        
        <!-- 
        <para>and the 
        above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>public class Customer 
        extends Person {
    public Customer(Name name) { this(name, null); }
    public Customer(Name name, Organization org) { super(name, org); }
    ... 
}</programlisting>
        
        <programlisting>class Token 
        extends Datetime 
        implements Comparable&lt;Token&gt;, Identifier {
    public Token() { super(); }
    ... 
}</programlisting>
         -->
        </section>
       
    <section id="instanceenumeration">
        <title>Class instance enumeration</title>
        
        <para>The keyword <literal>case</literal> is used to specify an enumerated named 
        instance of a class. All <literal>case</literal>s must appear in a list as the 
        first line of a class definition.</para>
        
        <programlisting>Instances := Instance ("," Instance)* ("..." | ";")</programlisting>

        <programlisting>Instance := Annotation* "case" MemberName Arguments?</programlisting>

        <para>If the <literal>case</literal> list ends in <literal>;</literal>, the instance
        list is called <emphasis>closed</emphasis>. If the <literal>case</literal> list ends 
        in <literal>...</literal>, the instance list is called <emphasis>open</emphasis>.</para>
        
        <para>If a class has a closed instance list, the class may not:</para>
        
        <itemizedlist>
            <listitem>
                <para>be instantiated</para>
            </listitem>
            <listitem>
                <para>have subclasses, or</para>
            </listitem>
            <listitem>
                <para>have members annotated <literal>default</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>A class may not specify enumerated named instances if it:</para>
        
        <itemizedlist>
            <listitem>
                <para>is annotated <literal>abstract</literal>,</para>
            </listitem>
            <listitem>
                <para>has generic type parameters, or</para>
            </listitem>
            <listitem>
                <para>is nested directly or indirectly inside another class or inside a 
                block.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>public class DayOfWeek() {
    case sun,
    case mon, 
    case tues, 
    case wed, 
    case thurs, 
    case fri, 
    case sat; 
}</programlisting>

        <comment><para>TODO: Should we make the parens on the class declaration optional 
        in this case: a closed instance list with no parameters?</para></comment>

        <programlisting>public class DayOfWeek(String name) {
        
    doc "Sunday"
    case sun("Sunday"),
    
    doc "Monday" 
    case mon("Monday"),
    
    doc "Tuesday"
    case tues("Tuesday"),
    
    doc "Wednesday"
    case wed("Wednesday"),
    
    doc "Thursday"
    case thurs("Thursday"),
    
    doc "Friday"
    case fri("Friday"),
    
    doc "Saturday"
    case sat("Saturday");
       
    public String name = name;
    
}</programlisting>

        <programlisting>public class TransactionPropagation(void inProgress(), void notInProgress()) {
    
    case required { 
        void inProgress() {}
        void notInProgress() {
            tx.begin();
        }
    },
    
    case supports {
        void inProgress() {}
        void notInProgress() {}
    },
    
    case mandatory { 
        void inProgress() {}
        void notInProgress() {
            throw TransactionMandatory()
        }
    },
    
    case notSupported { 
        void inProgress() {
            throw TransactionNotSupported()
        }
        void notInProgress() {}
    },
    
    case requiresNew { 
        void inProgress() {
            throw TransactionRequiresNew()
        }
        void notInProgress() {
            tx.begin();
        }
    };
    
    public void propagate(Transaction tx) {
        if (tx.inProgress) {
            inProgress();
        }
        else {
            notInProgress();
        }
    }
    
}</programlisting>

        <para>A class with declared <literal>case</literal>s implicitly extends 
        <literal>lang.Selector</literal>, a subclass of 
        <literal>java.lang.Enum</literal>.</para>
        
        <para>Enumerated instances of a class are instantiated when the class is
        loaded by the virtual machine, with the specified arguments.</para>
        
        <!--
        <para>The above declarations are equivalent to the following Java declarations:</para>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; { 
        
    public static DayOfWeek mon = new DayOfWeek("mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("tues", 1);
    public static DayOfWeek wed = new DayOfWeek("wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("fri", 4);
    public static DayOfWeek sat = new DayOfWeek("sat", 5);
    public static DayOfWeek sun = new DayOfWeek("sun", 6);
    
    private DayOfWeek(String id, int ord) {
        super(id, ord);
    }
    
}</programlisting>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; {
        
    private final ReadAttribute&lt;String&gt; name;
       
    public static DayOfWeek mon = new DayOfWeek("Monday", "mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("Tuesday", "tues", 1);
    public static DayOfWeek wed = new DayOfWeek("Wednesday", "wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("Thursday", "thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("Friday", "fri", 4);
    public static DayOfWeek sat = new DayOfWeek("Saturday", "sat", 5);
    public static DayOfWeek sun = new DayOfWeek("Sunday", "sun", 6);
     
    private DayOfWeek(String name, String id, int ord)
    {
        super(id, ord);
        name = new SimpleReadAttribute(name);
    }
    
}</programlisting>
        -->
        
        <comment><para>TODO: should we have the ability to declare a restricted
        list of member subclasses using <literal>case class</literal>, for example:</para>
        <programlisting>abstract class Node(String name) {
        
    case root("root"), 
    case class Branch(String name, Node parent) extends Node(name) { ... },
    case class Leaf(String name, Node parent) extends Node(name) { ... };
    
    ...
    
}</programlisting>
        <programlisting>Node root = Node.root;
Node branch = Node.Branch("Furry", root);
Node leaf = Node.Leaf("Kittens", branch);</programlisting>
        </comment>
        
    </section>
    
        <section id="overloadedclasses">
            <title>Overloaded classes</title>
            
            <para>Multiple toplevel classes belonging to the same package, or
            multiple member classes of the same containing class may declare 
            the same name. The classes are called <emphasis>overloaded</emphasis>.
            Overloaded classes:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must extend and overload a common <emphasis>root</emphasis>
                    type,</para>
                </listitem>
                <listitem>
                    <para>must have distinct erased signatures,</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters, and</para>
                </listitem>
                <listitem>
                    <para>except for the root type, may not declare any member
                    with a visibility modifier.</para>
                </listitem>
            </itemizedlist>
            
            <para>Then the class name always refers to the root type, except in 
            instantiations. In the case of instantiation, the correct overloaded 
            class is resolved at compile time, using the mechanism that Java
            uses to choose between overloaded constructors.</para>
            
        </section>
        
    <section id="overridingmemberclasses">
        <title>Overriding member classes</title>
        
        <para>A member class annotated <literal>abstract</literal> or
        <literal>default</literal> may be overridden by subclasses of the class 
        which contains the member class. The subclass must declare a member class:</para>
        
        <itemizedlist>
            <listitem>
                <para>annotated <literal>override</literal>,</para>
            </listitem>
            <listitem>
                <para>with the same name as the member class it overrides,</para>
            </listitem>
            <listitem>
                <para>that extends the member class it overrides, and</para>
            </listitem>
            <listitem>
                <para>with a formal parameter list with the same signature as the 
                member class it overrides, after substitution of type arguments
                specified in the <literal>extends</literal> or <literal>satisfies</literal>
                clause.</para>
            </listitem>
        </itemizedlist>
        
        <para>Finally, the overridden member class must be visible to the member
        class annotated <literal>override</literal>.</para>
        
        <para>Then instantiation of the member class is polymorphic, and the actual
        subtype instantiated depends upon the concrete type of the containing class
        instance.</para>
        
        <para>By default, the member class annotated <literal>override</literal> 
        has the same visibility modifier as the member class it overrides. The
        member class may not declare a stricter visibility modifier than the member 
        class it overrides.</para>
    
    </section>
        
    </section>
    
    <!--  
    <section>
        <title>Constructors</title>
        
        <para>Constructors are declared according to the following:</para>
        
        <programlisting>Annotation* Identifier 
FormalParams
( ";" | ClosedBlock )</programlisting>

        <para>
        For example:
        </para>
        
        <programlisting>Public: User(String username, Person person);</programlisting>
        <programlisting>Public: Integer(String string): value = parse(string);</programlisting>
        <programlisting>Public: User(String u, Person p) { username = u; person = p; }</programlisting>
        
        <para>
        The semantics of constructor declarations are identical to Java.
        </para>
        
        <para>
        A constructor body may omit the braces if it consists of exactly one statement. 
        If there is no constructor body at all, the constructor assigns each parameter to
        the attribute with the same name.
        </para>
        
        <para>
        A Ceylon constructor invocation is equivalent to a Java constructor invocation.
        </para>
                
        <programlisting>@FormalParameterNames({"username", "person"}) 
public User(String username, Person person);</programlisting>

    </section>
    -->
    
    <section id="methods">
        <title>Methods</title>
        
        <para>A <emphasis>method</emphasis> is a callable block of code. Methods may have 
        parameters and may return a value.</para>
        
        <programlisting>Method := MethodHeader ( Block | Specifier? ";" )</programlisting>

        <programlisting>MethodHeader := Annotation* (InferableType | "void") MemberName TypeParams? FormalParams+ TypeConstraints?</programlisting>
        
        <para>A method implementation may be specified using either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a block of code, or</para>
            </listitem>
            <listitem>
                <para>a reference to another method.</para>
            </listitem>
        </itemizedlist>
        
        <para>A member method body may invoke, evaluate or assign 
        members of the current instance of the class which defines the method (the instance 
        upon which the method was invoked) without explicitly specifying the receiver.</para>
        
        <para>A member method body of a member class may invoke, 
        evaluate or assign members of the current instance of the containing class (the 
        containing instance of the instance upon which the method was invoked) without 
        explicitly specifying the receiver.</para>
        
        <para>A toplevel method body may not refer to <literal>this</literal>
        or <literal>super</literal>, since there is no current instance.</para>
        
        <para>A method may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        
        <programlisting>public Integer add(Integer x, Integer y) {
    return x + y
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token()
}</programlisting>

        <programlisting>public U? get(V? key);</programlisting>
        
        <programlisting>public void print(Object... objects) {
    for (Object object in objects) { log.info($object); }
}</programlisting>

        <programlisting>public void addEntry(V key -> U value) { ... }</programlisting>
        
        <programlisting>Float say(String words) = person.say;</programlisting>
        
        <programlisting>Comparison order(String x, String y) = getOrder();</programlisting>
        
        <para>A method may declare multiple lists of parameters. Methods which declare
        more than one parameter list return method references.</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    Comparison order(Natural x, Natural y) { return x&lt;=&gt;y }
    return order
}</programlisting>

        <para>A method body may <emphasis>only</emphasis> refer to parameters in the 
        first parameter list. It may not refer to parameters of other parameter lists.
        Parameters declared by parameter lists other than the first parameter list are 
        not considered visible inside the body of the method.</para>
        
        <para>A method reference returned by a method with multiple parameter lists 
        must conform to the schema of the method with multiple parameter lists, after 
        eliminating the first parameter list.</para>
        
        <para>The <emphasis>operation type</emphasis> of a method captures the return
        types and formal parameter types of the method.</para>
        
        <itemizedlist>
        <listitem>
            <para>The operation type of a method with a single parameter list is 
            <literal>Callable&lt;T,P...&gt;</literal> where <literal>T</literal> is
            the declared type of the method, and <literal>P...</literal> are the formal
            parameter types of the method.</para>
        </listitem>
        <listitem>
            <para>The operation type of a method with multiple parameter lists is 
            <literal>Callable&lt;O,P...&gt;</literal>, where <literal>O</literal> is the
            operation type of a method produced by eliminating the first formal parameter
            list, and <literal>P...</literal> are the formal parameter types of the first 
            formal parameter list of the method.</para>
        </listitem>
        </itemizedlist>
        
        <para>The Ceylon compiler preserves the names of method parameters.</para>
        
        <!--
        <programlisting>@FormalParameterNames({"x", "y"}) 
public Integer add(Integer x, Integer y) { ... }</programlisting>
        -->
                
        <para>A block local method with a single <literal>return</literal> directive may 
        be declared using the keyword <literal>local</literal> in place of the explicit 
        return type declaration. The type of the local or attribute is inferred to be the 
        type of the returned expression.</para>
        
        <programlisting>local add(Integer x, Integer y) {
    return x + y
}</programlisting>
                
        <para>The semantics of Ceylon methods are identical to Java, except that Ceylon 
        methods may declare defaulted parameters and functional parameters.</para>
        
        <section id="overloadedmethods">
            <title>Overloaded methods</title>
            
            <para>A class may declare or inherit multiple methods with the
            same name. The methods are called <emphasis>overloaded</emphasis>.
            Overloaded methods: </para>
            
            <itemizedlist>
                <listitem>
                    <para>must have distinct erased signatures, and</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters.</para>
                </listitem>
            </itemizedlist>
            
            <para>A class may not not declare of inherit a method with the same name as
            an attribute it declares or inherits.</para>
            
            <para>Like Java, Ceylon resolves overloaded methods at compile time.</para>
        
        </section>
        
       <section id="abstractmethods">
            <title>Interface methods and abstract methods</title>
            
            <para>If there is no method body in a method declaration, the implementation 
            of the method must be specified later in the block, or the class that declares 
            the method must be annotated <literal>abstract</literal>. If no implementation 
            is specified, the method is considered an <emphasis>abstract method</emphasis>.</para>
        
            <para>Methods declared by interfaces never specify an implementation:</para>
        
            <programlisting>AbstractMethod := MethodHeader ";"</programlisting>

        </section>
        
        <section id="overridingmethods">
            <title>Overriding methods</title>
            
            <para>Method overriding is the foundation of polymorphism in Ceylon:</para>
            
            <itemizedlist>
            <listitem>
                <para>A method annotated <literal>default</literal> may be overridden by 
                subclasses of the class or interface which declares the method.</para>
            </listitem>
            <listitem>
                <para>A method annotated <literal>fixed</literal> <emphasis>must</emphasis> 
                be overridden by every subclass of the class or interface which declares the
                method.</para>
            </listitem>
            <listitem>
                <para>An interface method or abstract method must be overridden by every 
                non-<literal>abstract</literal> class that is assignable to the interface or 
                abstract class type, unless the class inherits a non-abstract method from a 
                superclass which overrides the interface method or abstract method.</para>
            </listitem>
            </itemizedlist>           
            
            <para>To override a method, a class must declare a method:</para>
            
            <itemizedlist>
                <listitem>
                    <para>annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>with the same name as the method it overrides,</para>
                </listitem>
                <listitem>
                    <para>the same number of formal parameter lists, with the same
                    signatures, as the method it overrides, after substitution of 
                    type arguments specified in the <literal>extends</literal> or 
                    <literal>satisfies</literal> clause, and</para>
                </listitem>
                 <listitem>
                    <para>with a return type that is assignable to the return type of 
                    the method it overrides, after substitution of type arguments 
                    specified in the <literal>extends</literal> or 
                    <literal>satisfies</literal> clause.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the overridden method must be visible to the method
            annotated <literal>override</literal>.</para>
        
            <para>Then invocation of the method is polymorphic, and the actual
            method invoked depends upon the concrete type of the class instance.</para>
            
            <para>By default, the method annotated <literal>override</literal>
            has the same visibility modifier as the method it overrides. The
            method may not declare a stricter visibility modifier than the method 
            it overrides.</para>
            
            <programlisting>abstract class AbstractSquareRooter() {
    Float squareRoot(Float x);
}</programlisting>

            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    override Float squareRoot(Float x) { ... }
}</programlisting>
            
            <para>For abstract methods, a special shortcut form of overriding is
            permitted. A subclass initializer may simply specify a method reference 
            for the method declared by the superclass. No formal parameter list or 
            return type declaration or <literal>override</literal> annotation is 
            necessary.</para>
            
            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    Float sqrt(Float x) { ... }
    squareRoot = sqrt;
}</programlisting>
            
            <para>Toplevel methods cannot be overridden, and so toplevel method 
            invocation is never polymorphic.</para>
            
            <comment><para>TODO: are you allowed to override the default value of
            a defaulted parameter?</para></comment>
            
            <comment><para>TODO: are you required to have the same formal parameter
            names in the two methods? I don't see that this would be necessary. In
            a named parameter invocation, you just use the names declared by the
            member of the compile-time type, and they are mapped positionally to the
            parameters of the overriding method.</para></comment>
        
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to <emphasis>attribute</emphasis> 
        definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a 
                Java field or local variable).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived 
                attribute is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived 
                attribute is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be overridden by subclasses.</para>
            
        <para>An attribute body may invoke, evaluate or assign members of the current 
        instance of the class which defines the method (the instance upon which the 
        attribute was invoked) without explicitly specifying the receiver.</para>
        
        <para>An attribute body of a member class may invoke, evaluate or assign members 
        of the current instance of the containing class (the containing instance of the 
        instance upon which the attribute was invoked) without explicitly specifying the 
        receiver.</para>
        
        <para>An attribute may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier withing the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        
        <programlisting>package mutable String firstName;</programlisting>
        
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <programlisting>public Decimal pi = calculatePi();</programlisting>
        
        <programlisting>public String name { return join(firstName, lastName) }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
    
        <programlisting>public Float total {
    Float sum := 0.0;
    for (LineItem li in lineItems) {
        sum += li.amount;
    }
    return sum
}</programlisting>
        
        <!--
        <para>
        An attribute declaration is equivalent to a Java method declaration together with 
        a Java field declaration, both of type <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal>, both with the same name as the attribute.
        </para>
        -->
        
        <section id="simpleattributesandlocals">
            <title>Simple attributes and locals</title>
            
        <para>A simple attribute defines state.</para>
        
        <programlisting>SimpleAttribute := AttributeHeader (Specifier | Initializer)? ";"</programlisting>
        
        <programlisting>AttributeHeader := Annotation* InferableType MemberName</programlisting>
        
        <para>A simple attribute or local annotated <literal>mutable</literal> represents a
        value that can be assigned multiple times. A simple attribute or local not annotated
        <literal>mutable</literal> represents a value that can be specified exactly once.</para>
        
        <para>The value of a non-<literal>mutable</literal> attribute is specified using 
        <literal>=</literal>. A <literal>mutable</literal> attribute may be initialized using 
        the assignment operator <literal>:=</literal>.</para>

        <programlisting>Initializer := ":=" Expression</programlisting>

        <para>Formal parameters of classes and methods are also considered to be simple attributes.</para>
        
        <para>A simple attribute declared directly inside the body of a class represents state 
        associated with the instance of the class. Repeated evaluation of the attribute of a 
        particular instance of the class returns the same result until the attribute of the 
        instance is assigned a new value.</para>
        
        <para>A <emphasis>local</emphasis> represents state associated with execution of a
        particular block of code. A local is really just a special case of a simple attribute 
        declaration, but one whose state is not held across multiple executions of the block
        of code in which the local is defined.</para> 
        
        <itemizedlist>
            <listitem>
                <para>A simple attribute declared inside a block (the body of a method, attribute 
                getter or attribute setter) is a local.</para>
            </listitem>
             <listitem>
                <para>A block local simple attribute declared inside the body of a class is a 
                local if it is not used inside a method, attribute setter or attribute getter 
                declaration.</para>
            </listitem>
           <listitem>
                <para>A formal parameter of a class is a local if it is not used inside a method, 
                attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a method is a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>A local is a block local declaration&mdash;it is visible only to statements and 
        declarations that occur later in the same block or class body, and therefore it may not 
        declare a visibility modifier.</para>
        
        <para>The semantics of locals are identical to Java local variables.</para>
        
        <!--
        <para>For a simple attribute that is not a local, the Java field is initialized to an 
        instance of <literal>lang.SimpleAttribute</literal> or 
        <literal>lang.SimpleReadAttribute</literal>. For example:</para> 
         -->
        
        <programlisting>package mutable String firstName;</programlisting>

        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; firstName = new SimpleAttribute&lt;String&gt;();
Attribute&lt;String&gt; firstName() { return firstName; }</programlisting>

        <para>While:</para>
         -->
         
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;Natural&gt; count = new SimpleAttribute&lt;Natural&gt;(0);
private Attribute&lt;Natural&gt; count() { return count; }</programlisting>

        <para>And:</para>
        -->
        
        <programlisting>public Integer max = 99;</programlisting>
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Integer&gt; max = new SimpleReadAttribute&lt;Integer&gt;(99);
public ReadAttribute&lt;Integer&gt; max() { return max; }</programlisting>
        -->

        <para>The compiler is permitted to optimize block local simple attributes to a simple 
        Java field declaration or local variable. Block local attributes may not be accessed 
        via reflection.</para>
        
        <para>A block local simple attribute with a specifier or initializer may be declared 
        using the keyword <literal>local</literal> in place of the explicit type declaration. 
        The type of the local or attribute is inferred to be the type of the specifier or
        initializer expression.</para>
        
        <programlisting>local names = List&lt;String&gt;();</programlisting>
        <programlisting>mutable local count:=0;</programlisting>
                
        </section>
        
         <section id="attributegetters">
            <title>Attribute getters</title>
            
            <para>An attribute getter is a callable block of code with no parameters,
            that returns a value.</para>
            
            <programlisting>AttributeGetter := AttributeHeader Block</programlisting>
            
            <para>An attribute getter defines how the value of a derived attribute is
            obtained.</para>
            
            <!--
            <para>For an attribute getter, the Java field is initialized to an instance 
            of an anonymous inner subclass of <literal>lang.Attribute</literal> or
            <literal>lang.ReadAttribute</literal> that overrides the <literal>get()</literal> 
            method with the content of the getter block. For example: </para>
            -->
        
            <programlisting>public Float total { return items.totalPrice }</programlisting>
            
            <para>If an attribute getter has a matching attribute setter, we say that 
            the attribute is <literal>mutable</literal>. Otherwise we say it is 
            non-<literal>mutable</literal>.</para>
            
            <!--
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final ReadAttribute&lt;Float&gt; total = new ReadAttribute&lt;Float&gt;() {
    @Override public Float get() { return items.get().totalPrice; }
};
public ReadAttribute&lt;Float&gt; total() { return total; }</programlisting>
            -->
            
        <para>A block local attribute getter with a single <literal>return</literal>
        directive may be declared using the keyword <literal>local</literal> in place of 
        the explicit type declaration. The type of the local or attribute is inferred to 
        be the type of the returned expression.</para>
        
        <programlisting>local name { 
    return Name(firstName, initial, lastName) 
}</programlisting>
                
        </section>
        
        <section id="attributesetters">
            <title>Attribute setters</title>
                    
            <para>An attribute setter is a callable block of code that accepts a
            single value and does not return a value.</para>
            
            <programlisting>AttributeSetter := Annotation* "assign" MemberName Block</programlisting>

            <para>An attribute setter defines how the value of a derived attribute is
            assigned. Every attribute setter must have a corresponding getter with the
            same name.</para>

            <programlisting>public String name { return join(firstName, lastName) }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
            
            <!--
            <para>For an attribute with a setter, the Java field is initialized to an 
            instance of an anonymous inner subclass of <literal>lang.Attribute</literal> 
            that overrides the <literal>set()</literal> method with the content of the 
            setter block. For example:
            </para>
            -->
            
            <comment><para>TODO: should we require that the corresponding getter be 
            annotated <literal>mutable</literal>?</para></comment>
            
            <comment><para>TODO: should we allow overloaded attribute setters, for example:</para>
            <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>
            </comment>
            
            <!--
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final Attribute&lt;String&gt; name = new Attribute&lt;String&gt;() {
    @Override public String get() { return join(firstName, lastName); }
    @Override public void set(String name) { firstName = first(name); lastName = last(name); }
};
public Attribute&lt;String&gt; name() { return name; }</programlisting>
            -->
        </section>
        
        <section id="abstractattributes">
            <title>Interface attributes and abstract attributes</title>
            
            <para>If there is no specifier, initializer or getter implementation, the value 
            or implementation of the attribute must be specified later in the block, or 
            the class that declares the attribute must be annotated <literal>abstract</literal>. 
            If no value or implementation is specified, the attribute is considered an 
            <emphasis>abstract attribute</emphasis>.</para>
        
            <para>Attributes declared by interfaces never specify an initalizer, getter 
            or setter:</para>
        
            <programlisting>AbstractAttribute := AttributeHeader ";"</programlisting>
                        
        </section>
        
        <section id="overridingattributes">
            <title>Overriding attributes</title>
            
            <para>Ceylon allows attributes to be overridden, just like methods:</para>
            
            <itemizedlist>
            <listitem>
                <para>An attribute annotated <literal>default</literal> may be overridden by 
                subclasses of the class or interface which declares the method.</para>
            </listitem>
            <listitem>
                <para>A method annotated <literal>fixed</literal> <emphasis>must</emphasis> 
                be overridden by every subclass of the class or interface which declares the
                method.</para>
            </listitem>
            <listitem>
                <para>An interface attribute or abstract attribute must be overridden by every 
                non-<literal>abstract</literal> class that is assignable to the interface or 
                abstract class type, unless the class inherits a non-abstract attribute from a 
                superclass which overrides the interface attribute or abstract attribute.</para>
            </listitem>
            </itemizedlist>
            
            <para>A non-<literal>mutable</literal> attribute may be overridden by a simple 
            attribute or attribute getter. A <literal>mutable</literal> attribute may be 
            overridden by a <literal>mutable</literal> simple attribute or by an attribute 
            getter and setter pair.</para>
            
            <para>A class which overrides an attribute must declare an attribute:</para>
            
            <itemizedlist>
                <listitem>
                    <para>annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>with the same name as the attribute it overrides,</para>
                </listitem>
                 <listitem>
                    <para>with a type that is assignable to the type of the attribute it 
                    overrides, after substitution of type arguments specified in the 
                    <literal>extends</literal> or <literal>satisfies</literal> clause,</para>
                </listitem>
                 <listitem>
                    <para>or with <emphasis>exactly the same type</emphasis> as the attribute 
                    it overrides, after substitution of type arguments specified in the 
                    <literal>extends</literal> or <literal>satisfies</literal> clause, if the 
                    attribute it overrides is <literal>mutable</literal>, and</para>
                </listitem>
                <listitem>
                    <para>that is <literal>mutable</literal>, if the attribute it overrides 
                    is <literal>mutable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the overridden attribute must be visible to the attribute
            annotated <literal>override</literal>.</para>
        
            <para>A non-<literal>mutable</literal> attribute may be overridden by a 
            <literal>mutable</literal> attribute.</para>
            
            <comment><para>TODO: is that really allowed? It could break the superclass.
            Should we say that you are allowed to do it when you implement an interface
            attribute, but not when you override a superclass attribute?</para></comment>
            
            <para>Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance.</para>
            
            <para>By default, the attribute annotated <literal>override</literal>
            has the same visibility modifier as the attribute it overrides. The
            method may not declare a stricter visibility modifier than the method 
            it overrides.</para>
            
            <programlisting>abstract class AbstractPi() {
    Float pi;
}</programlisting>

            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    Float pi { ... }
}</programlisting>
            
            <para>For abstract attributes, a special shortcut form of overriding is
            permitted. A subclass initializer may simply specify or assign a value to 
            the attribute declared by the superclass. No type declaration or 
            <literal>override</literal> annotation is necessary.</para>
            
            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    Float calculatePi() { ... }
    pi = calculatePi();
}</programlisting>
            
        </section>
        
        <!--section id="getterandsettermethods">
            <title>Getter and setter methods</title>
            
            <para>For each attribute, one or two methods exist implicitly:</para>
            
            <itemizedlist>
                <listitem>
                    <para>a <emphasis>getter method</emphasis> with no parameters 
                    which returns the attribute type, and</para>
                </listitem>
                <listitem>
                    <para>a <literal>void</literal> <emphasis>setter method</emphasis> 
                    with a single parameter of the attribute type, if the attribute is 
                    <literal>mutable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>These methods may be referred to using the <literal>get</literal> and 
            <literal>set</literal> keywords, for example:</para>
            
            <programlisting>String name = get person.name();</programlisting>
            <programlisting>set person.name(newName);</programlisting>
            
        
        </section-->
                
    </section>
        
    <section id="typealiases">
       <title>Type aliases</title>
    
       <para>A <emphasis>type alias</emphasis> allows a type to be referred to more 
       compactly.</para>
       
       <programlisting>Alias := Annotation* "alias" TypeName TypeParams? Interfaces? TypeConstraints? ";"</programlisting>
       
       <para>A type alias may satisfy either a single interface or a single class.</para>
       
       <para>The alias type is assignable to the satisfied type, and the satisfied type 
       is assignable to the alias type.</para>
       
       <programlisting>public alias People satisfies List&lt;Person&gt;;</programlisting>
       
       
       <!--programlisting>alias Compare&lt;T&gt; satisfies functor Comparison(T x, T y);</programlisting-->
       
       <para>A shortcut is provided for definition of private aliases.</para>
       
       <programlisting>import java.util.List alias JavaList;</programlisting>
       
       <para>Type aliases are not reified types. The metamodel reference for a type
       alias&mdash;for example, <literal>#People</literal>&mdash; returns the metamodel 
       object for the aliased type&mdash;in this case, <literal>List&lt;Person&gt;</literal>.</para>
       
       <comment><para>TODO: could we reify them? This would let us define type aliases
       that satisfy multiple interfaces. For example:</para>
       <programlisting>package alias ComparableCollection&lt;X&gt; satisfies Collection&lt;X&gt;, Comparable&lt;X&gt;;</programlisting>
       </comment>
    
    </section>
    
   <section id="declaration modifiers">
        <title>Declaration modifiers</title>
        
        <para>In Ceylon, all declaration modifiers are annotations.</para>
        
    <section id="compilerinstructions">
        <title>Summary of compiler instructions</title>
        
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>public</literal>, <literal>module</literal>,
                <literal>package</literal> and <literal>private</literal> 
                determine the visibility of a declaration (by default, the 
                declaration is visible only to statements and declarations 
                that appear later inside the same block).</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated<!--, or that a method or attribute of 
                an abstract class must be implemented by all 
                non-<literal>abstract</literal> subclasses-->.</para>
            </listitem>
            <listitem>
                <para><literal>default</literal> specifies that a method, 
                attribute, or member class may be overridden by subclasses.</para>
            </listitem>
            <listitem>
                <para><literal>override</literal> indicates that a method,
                attribute, or member type overrides a method, attribute, 
                or member type defined by a supertype.</para>
            </listitem>
            <listitem>
                <para><literal>mutable</literal> specifies that an attribute
                or local may be assigned, or that a class has assignable
                attributes.</para>
            </listitem>
            <listitem>
                <para><literal>fixed</literal> specifies that a method or
                attribute must be overridden by every subclass.</para>
            </listitem>
            <!--listitem>
                <para><literal>final</literal> indicates that a class may not 
                be extended, or that a method or attribute may not be 
                overridden.</para>
            </listitem-->
            <listitem>
                <para><literal>extension</literal> specifies that a method or
                attribute getter is a converter, or that a class is a decorator.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated. It accepts an optional
                <literal>String</literal> argument.</para>
            </listitem>
            <listitem>
                <para><literal>volatile</literal> indicates a volatile simple 
                attribute.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: should it be called <literal>overrides</literal>?</para></comment>
        
        <para>The following annotation is a hint to the compiler that lets 
        the compiler optimize compiled bytecode for non-64 bit architectures:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>small</literal> specifies that a value of type
                <literal>Natural</literal>, <literal>Integer</literal> or
                <literal>Float</literal> contains 32-bit values.</para>
            </listitem>
        </itemizedlist>
        
        <para>By default, <literal>Natural</literal>, <literal>Integer</literal>
        and <literal>Float</literal> are assumed to represent 64-bit values.</para>
        
        <para>The annotation names in this section are treated as keywords by 
        the Ceylon compiler. This is a performance optimization to minimize 
        the need for lookahead in the parser.</para>
        
        <comment><para>TODO: Should we require an <literal>abstract</literal>
        modifier for abstract methods and attributes of abstract classes
        like Java does?</para></comment>
        
    </section>
       
       <!--
       <para>The following annotations are important to the Ceylon SDK.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>id</literal> specifies that an attribute should
                be tested by the <literal>equals()</literal> method, and included
                in the <literal>hash</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>transient</literal> specifies that an attribute 
                is not included in the serialized form of the object.</para>
            </listitem>
            <listitem>
                <para><literal>read</literal> and <literal>write</literal>
                indicate methods or attributes that are protected from multithreaded
                access using a reentrant read/write lock with deadlock detection.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method or
                attribute getter is executed at most once, and the resulting 
                value is cached.</para>
            </listitem>
        </itemizedlist>
        -->
        
    <section id="visibility">
        <title>Visibility and name resolution</title>
        
        <para>Classes, interfaces, aliases, methods, attributes, locals, formal parameters 
        and type parameters have names. Occurrence of a name in code implies a hard 
        dependency from the code in which the name occurs to the schema of the named 
        declaration. We say that a class, interface, alias, method, attribute, formal 
        parameter or type parameter is <emphasis>visible</emphasis> to a certain program 
        element if its name may occur in the code that defines that program element.</para>
        
        <itemizedlist>
            <listitem>
                <para>A formal parameter or type parameter is never visible outside the 
                declaration it belongs to.</para> 
            </listitem>
            <listitem>
                <para>Any declaration that occurs inside a block (the body of a method, 
                attribute getter or attribute setter) is not visible to code outside the 
                block.</para>
            </listitem>
        </itemizedlist>
        
        <para>The visibility of any other declaration depends upon its <emphasis>visibility
        modifier</emphasis>, if any. By default:</para>
        
        <itemizedlist>
            <listitem>
                <para>a declaration that occurs directly inside a class body is not
                visible to code outside the class definition, and</para>
            </listitem>
            <listitem>
                <para>a toplevel declaration is not visible to code outside the 
                package containing its compilation unit.</para>
            </listitem>
        </itemizedlist>
        
        <para>The visibility of a declaration with a visibility modifier annotation
        is determined by the visibility modifier:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>private</literal> specifies that the declaration is 
                visible to all code in the same compilation unit,</para>
            </listitem>
            <listitem>
                <para><literal>package</literal> specifies that the declaration is 
                visible to all code in any compilation unit in the same package,</para>
            </listitem>
            <listitem>
                <para><literal>module</literal> specifies that the declaration is 
                visible to all code in any package in the same module,</para>
            </listitem>
            <listitem>
                <para><literal>public</literal> specifies that the declaration is 
                visible to all code in any module.</para>
            </listitem>
        </itemizedlist>
        
        <para>The class <literal>lang.Visibility</literal> defines the visibility 
        levels:</para>
        
        <programlisting>public class Visibility {
        
    doc "A program element visible to all 
         compilation units."
    case public, 
    
    doc "A program element visible to  
         compilation units in the same
         module."
    case module, 

    doc "A program element visible to  
         compilation units in the same
         package."
    case package, 

    doc "A program element visible to  
         the compilation unit in which
         its is declared."
    case private, 
    
    doc "A program element local to the
         block in which it is defined."
    case block; 
    
}</programlisting>
    
        <para>The following declarations define the visibility 
        modifier annotations:</para>
    
        <programlisting>doc "The |public| visibility modifier 
     annotation."
public oncePerElement Visibility public() { 
    return public 
}</programlisting>

        <programlisting>doc "The |module| visibility modifier 
     annotation."
public oncePerElement Visibility module() { 
    return module
}</programlisting>

        <programlisting>doc "The |package| visibility modifier 
     annotation."
public oncePerElement Visibility package() { 
    return package 
}</programlisting>

        <programlisting>doc "The |private| visibility modifier 
     annotation."
public oncePerElement Visibility private() { 
    return private 
}</programlisting>

        <comment><para>TODO: how are we going to go about compiling these classes which
        <emphasis>define</emphasis> the reserved-word annotations? A special compiler
        switch to turn off these reserved words? (Seems reasonable.)</para></comment>
       
    </section>
    
    <section id="extensions">
        <title>Extensions</title>
        
        <para>An extension allows values of one type to be transparently converted to 
        values of another type. Extensions are declared by annotating a method, attribute 
        or class <literal>extension</literal>. An extension must be:</para>
        
        <itemizedlist>
            <listitem>
                <para>a toplevel method with exactly one formal parameter,</para>
            </listitem>
            <listitem>
                <para>a member method with no formal parameters,</para>
            </listitem>
            <listitem>
                <para>a toplevel class with exactly one initialization parameter,</para>
            </listitem>
            <listitem>
                <para>a member class with no initialization parameters, or</para>
            </listitem>
            <listitem>
                <para>an attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>An toplevel extension method is called a <emphasis>converter</emphasis>. 
        An toplevel extension class is called a <emphasis>decorator</emphasis>.</para>
        
        <para>Extensions apply to a certain <emphasis>extended type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for toplevel extension methods, the extended type is the declared
                type of the formal parameter,</para>
            </listitem>
            <listitem>
                <para>for member extension methods, the extended 
                type is the type that declares the extension method,</para>
            </listitem>
            <listitem>
                <para>for toplevel extension classes, the extended type is the declared 
                type of the initialization parameter,</para>
            </listitem>
            <listitem>
                <para>for member extension classes, the extended type is the type that 
                contains the member class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the extended type is the type that 
                declares the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>Extensions define an <emphasis>introduced type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for extension methods, the introduced type is the declared
                return type of the method,</para>
            </listitem>
            <listitem>
                <para>for extension classes, the introduced type is the class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the introduced type is the declared
                type of the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>The introduced type may not be a <literal>mutable</literal> type.</para>
        
        <programlisting>public extension Log objectToLog(Object object) {
    return object.log;
}</programlisting>
        
        <programlisting>public class Person(User user) {
    ...
    public extension User user = user;
    ...
}</programlisting>

        <programlisting>public extension class SequenceUtils&lt;N&gt;(N[] seq) 
        where N extends Number, Comparable&lt;N&gt; {
    
    public N[] positiveElements() {
        return seq.elements() having (N n) (n&gt;0); 
    }
    
    public N[] elementsLessThan(N limit) {
        return seq.elements() having (N n) (n&lt;limit);
    }
    
    ...   
}</programlisting>
        
        <comment><para>Note: I actually much prefer the readability of 
        <literal>User personToUser(extends Person person)</literal> and
        <literal>SequenceUtils&lt;T&gt;(extends T[] collection)</literal>, 
        but this doesn't work for attributes and member methods.</para></comment>
        
        <para>We say that an extension class or toplevel method is 
        <emphasis>enabled</emphasis> in a compilation unit if the class or 
        toplevel method is imported by that compilation unit.</para>
        
        <programlisting>import org.domain.app.extensions.objectToLog;
import org.domain.utils.SequenceUtils;</programlisting>

        <para>A wildcard <literal>.*</literal>-style import may not be used to 
        import an extension.</para>
        
        <para>An extension attribute, member class or member method is 
        enabled in every compilation unit.</para>
        
        <para>If an extension is enabled in a compilation unit, the extended type 
        is assignable to the introduced type in that compilation unit.</para>
        
        <programlisting>import org.mydomain.myproject.extensions.objectToLog;
...
Person person = ...;
User user = person;
info("person is a User and this is a Log!")</programlisting>
        
        <!--
        <para>Is equivalent to the following Java code:</para>
        
        <programlisting>Person person = ...;
User user = personToUser(person);</programlisting>
        -->
        
        <programlisting>import org.domain.utils.SequenceUtils;
...
Integer[] zeroToOneHundred = 0..100;
Integer[] oneToNine = zeroToOneHundred.positiveElements().elementsLessThan(10);</programlisting>
        
        <!--
        <para>Is equivalent to this Java code:</para>
    
        <programlisting>Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = new SequenceUtils(collection).nonZeroElements();</programlisting>
        -->
        
        <para>An introduced type may result in an ambiguity:</para>
        
        <itemizedlist>
            <listitem>
                <para>the introduced type may have a member type with the same name 
                as a member type of the extended type, or of some other introduced 
                type, and the two member types may have non-distinct erased signatures,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have a method with the same name as a 
                method of the extended type, or of some other introduced type, and 
                the two methods may have non-distinct erased signatures,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have an attribute with the same name 
                as an attribute or method of the extended type, or of some other 
                introduced type,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have a method with the same name as 
                an attribute of the extended type, or of some other introduced type.</para>
            </listitem>
        </itemizedlist>
        
        <para>In this case, the member type, method or attribute may not be called. Any invocation
        or evaluation of the member results in a compiler error.</para>
        
        <comment><para>TODO: We should allow an introduced type to specify 
        <literal>override #ExtendedType.member</literal> or 
        <literal>override #OtherIntroducedType.member</literal> to resolve an ambiguity like 
        this.</para></comment>
        
        <para>When an invocation of an introduced method or evaluation of an introduced attribute 
        is executed, or when an instance of the extended type is assigned to a program element
        of the introduced type, the extension is invoked to produce an instance of the introduced
        type that will receive the invocation or evaluation.</para>
        
        <comment><para>TODO: extensions are nice, and quite powerful, but they aren't enough to
        implement an embedded query language like in JPA. Dynamic languages let you implement a
        method to respond to an unknown member invoked at runtime. Java 6 lets you do a similar
        thing at compile time using a processor (a compiler plugin). I think we can have the best
        of both worlds and let you write an extension method that returns a set of members to be
        introduced to the extended type.</para></comment>
        
    </section>
    
    <section id="annotationconstraints">
        <title>Annotation constraints</title>
        
        <para>The following meta-annotations provide information to the compiler about the 
        annotations upon which they appear. They are applied to a toplevel method declaration 
        that defines an annotation.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>inherited</literal> specifies that the annotation is automatically 
                inherited by subtypes.</para>
            </listitem>
            <listitem>
                <para><literal>annotation</literal> specifies constraints upon the occurence of 
                an annotation. By default, an annotation may appear multiple times on any program 
                element.</para>
            </listitem>
        </itemizedlist>
        
        <para>The meta-annotation <literal>annotation</literal> accepts the following parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>occurs</literal> specifies that the annotation may occur at 
                most once in a certain scope. Its accepts one argument of type
                <literal>Occurrence</literal>: <literal>onceEachElement</literal>, 
                <literal>onceEachType</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>of</literal> specifies the kinds of program element 
                at which the annotation occurs. Its accepts one or more arguments of type
                <literal>Element</literal>: <literal>classes</literal>, <literal>interfaces</literal>,
                <literal>methods</literal>, <literal>attributes</literal>, <literal>aliases</literal>,
                <literal>parameters</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>withType</literal> specifies that the annotation may only 
                be applied to types that are assignable to the specified type, to
                attributes or parameters of the specified type, or to methods with the
                specified return type.</para>
            </listitem>
            <listitem>
                <para><literal>withParameterTypes</literal> specifies that the annotation 
                may only be applied to methods with the specified formal parameter types.</para>
            </listitem>
            <listitem>
                <para><literal>withAnnotation</literal> specifies that the annotation may 
                only be applied to program elements at which the specified annotation occurs.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>public 
annotation { 
    of = classes; 
    occurs = onceEachType; 
}
Entity entity(LockMode lockMode) { 
    return Entity(lockMode) 
}</programlisting>

        <programlisting>public 
annotation { 
    of = { attributes, parameters }; 
    withType = #String; 
    occurs = onceEachElement; 
}
PatternValidator pattern(Regex regex) { 
    return PatternValidator(regex)
}</programlisting>
            
        <comment><para>TODO: Should <literal>annotation</literal> be required
        for toplevel methods which can be used as annotations?</para></comment>
        
    </section>
    
    <section id="documentationcompiler">
        <title>Documentation compiler</title>
    
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the description of a 
                program element.</para>
            </listitem>
            <listitem>
                <para><literal>by</literal> specifies the authors of a program 
                element.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <literal>String</literal> arguments to the <literal>deprecated</literal>, 
        <literal>doc</literal>, <literal>throws</literal> and <literal>by</literal> 
        annotations are parsed by the documentation compiler as Seam Text, a 
        simple ANTLR-based wiki text format.</para>
        
        <para>These annotations are defined by the package <literal>doc</literal>:</para>
        
        <programlisting>public Description doc(String description) {
    return Description(description.normalize())
}</programlisting>
    
        <programlisting>public Author[] by(String... authors) {
    return from (String author in authors) select Author(author.normalize())
}</programlisting>
    
        <programlisting>public RelatedElement see(ProgramElement pe, String? description=null) {
    return Related(pe, description.normalize())
}</programlisting>
    
        <programlisting>public ThrownException see(Type type&lt;Exception&gt;, String? description=null) {
    return Related(type, description.normalize())
}</programlisting>
        
        <comment><para>TODO: should <literal>see</literal> and <literal>throws</literal>
        accept a list of <literal>Entry</literal> instead? For example:</para>
<programlisting>see #Ruby->"if you are bored with Java" 
    #Ceylon->"if you want to get some real work done"</programlisting></comment>
        
     </section>
        
     </section>

</chapter>