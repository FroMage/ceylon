<chapter id="declarations">
    <title>Declarations</title>
    
    <para>Ceylon is a statically typed language. Classes, interfaces, methods, attributes 
    and locals must be declared. This allows the compiler to detect many errors, including:</para>
    
    <itemizedlist>
        <listitem><para>typing errors in identifier names,</para></listitem>
        <listitem><para>references to types which do not exist or are not visible,</para></listitem>
        <listitem><para>references to type members which do not exist or are not visible,</para></listitem>
        <listitem><para>argument lists which do not match parameter lists,</para></listitem>
        <listitem><para>type argument lists which do not match type parameter lists, and</para></listitem>
        <listitem><para>incompatible assignment of an expression of one type to a
        program element of a different type.</para></listitem>
    </itemizedlist>
    
    <programlisting>Declaration: Method | Attribute | TypeDeclaration</programlisting>
    
    <programlisting>TypeDeclaration: Class | Object | Interface</programlisting>
        
    <para>All declarations follow a general pattern:</para>
        
    <programlisting>Annotation* 
(keyword | InferableType) (TypeName | MemberName) TypeParams? Params*
CaseTypes? Metatypes? ExtendedType? SatisfiedTypes?
TypeConstraints?
(Definition | ";")</programlisting>

    <para>A type parameter does not need an explicit declaration of this form unless it has 
    constraints. In the case that it does have constraints, the constraint declaration does 
    follow the general pattern.</para>
    
    <para>This consistent pattern for declarations, together with the strict block structure
    of the language, makes Ceylon a highly regular language.</para>

    <section id="compilationunitstructure">
        <title>Compilation unit structure</title>
        
        <para>A <emphasis>compilation unit</emphasis> is a text file, with the 
        filename extension <literal>.ceylon</literal>.</para>
        
        <para>A compilation unit consists of a list of imported types, attributes, and 
        methods, followed by one or more toplevel type, attribute, or method definitions.<!--or by a single 
        toplevel expression:--></para>
        
        <programlisting>Import* ToplevelDeclaration+</programlisting>
        
        <section id="topleveldeclarations">
            <title>Toplevel declarations</title>
        
        <para>A <emphasis>toplevel declaration</emphasis> defines a type&mdash;a class or 
        interface&mdash;or a method or non-<literal>variable</literal> attribute.</para>
        
        <programlisting>ToplevelDeclaration: TypeDeclaration | Method | SimpleAttribute | AttributeGetter</programlisting>
        
        <para>All toplevel declarations <!--annotated <literal>shared</literal>--> must 
        have the same name as the compilation unit filename (after removing the file 
        suffix <literal>.ceylon</literal>). For example, a <!--<literal>shared</literal>--> 
        toplevel class named <literal>Person</literal> must be defined in a file named 
        <literal>Person.ceylon</literal>. A <!--<literal>shared</literal>--> toplevel 
        method named <literal>hello()</literal> must be defined in a file named 
        <literal>hello.ceylon</literal>. A toplevel attribute named <literal>pi</literal> 
        must be defined in a file named <literal>pi.ceylon</literal>. <!--Unlike Java, a 
        compilation unit may contain multiple toplevel class or method declarations with 
        the same name.--></para>
        
        <comment><para>TODO: This doesn't work on platforms with case-insensitive filenames. 
        If I have a method named <literal>x</literal>, and a class named <literal>X</literal>,
        the filesystem can't distinguish them. We need a workaround!</para></comment>
        
        <para>A toplevel declaration may not be annotated <literal>formal</literal>,
        <literal>default</literal>, <literal>definite</literal>, or
        <literal>actual</literal>.</para>
        
        <comment><para>TODO: In a future version of the language, we might relax this 
        restriction and support package extension with toplevel member refinement. This
        can be viewed as a regularization of the language. The practical application is
        that it would make toplevel invocations and instantiations polymorphic, obviating
        the need for things like dependency injection.</para></comment>
        
        </section>
        
    </section>
    
        <section id="imports">
            <title>Imports</title>
        
        <para>Each compilation unit belongs to exactly one <emphasis>package</emphasis>.
        Code in one compilation unit may refer to a toplevel declaration in another 
        compilation unit in the same package without explicitly importing the declaration. 
        It may refer to a declaration defined in a compilation unit in another package 
        only if it explicitly <emphasis>imports</emphasis> the declaration using the 
        <literal>import</literal> statement.</para>
        
        <programlisting>Import: "import" FullPackageName "{" ImportElements "}"</programlisting>
        
        <para>A package is a namespace. A full package name is a period-separated list of 
        all-lowercase identifiers.</para>
        
        <programlisting>FullPackageName: PackageName ("." PackageName)*</programlisting>
        
        <para>For a given package, there may be at most one <literal>import</literal>
        statement per compilation unit.</para>
        
        <para>Each <literal>import</literal> statement imports one or more toplevel 
        declarations from the given package, specifying a list of <emphasis>import
        elements</emphasis>.</para>
        
        <programlisting>ImportElements: ImportElement ("," ImportElement)* ("," ImportWildcard)? | ImportWildcard</programlisting>
        
        <programlisting>ImportElement: ImportTypeElement | ImportMethodAttributeElement</programlisting>
        
        <para>An import element is a reference to either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a single toplevel type (a class or interface) of the package,</para>
            </listitem>
            <listitem>
                <para>a single toplevel method or attribute of the package, or</para>
            </listitem>
            <listitem>
                <para>all toplevel declarations of the package.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that toplevel types, toplevel methods, toplevel attributes,
        and extensions in the module <literal>ceylon.language</literal> never need to be 
        explicitly imported. They are implicitly imported by every compilation unit.</para>
                
        <section id="typeimports">
            <title>Type imports</title>
        
        <para>An import element that specifies a type name imports the toplevel type with 
        that name from the given package.</para>
        
        <programlisting>ImportTypeElement: "implicit"? TypeAlias? TypeName</programlisting>
        
        <para>An <literal>import</literal> statement may not contain two import elements
        which refer to the same type.</para>
        
        <para>A compilation unit may not import two types with the same name.</para>
        
        <programlisting>import ceylon.collection { Set, List, Map }</programlisting>
        
        </section>
        
        <section id="methodattributeimports">
            <title>Method and attribute imports</title>
        
        <para>An import element that specifies a method or attribute name imports the 
        toplevel method or attribute with that name from the given package.</para>
        
        <programlisting>ImportMethodAttributeElement: "implicit"? MethodAttributeAlias? MemberName</programlisting>
        
        <para>An <literal>import</literal> statement may not contain two import elements
        which refer to the same method or attribute.</para>
        
        <para>A compilation unit may not import two methods or attributes with the same 
        name.</para>
        
        <programlisting>import math { sqr, sqrt, e, pi }</programlisting>
        
        </section>
                 
        <section id="implicitimports">
            <title>Implicit imports</title>
               
        <para>If the <literal>implicit</literal> modifier appears, the 
        <literal>import</literal> statement must specify a toplevel type or method 
        annotated <literal>extension</literal>.</para>
        
        <programlisting>import com.acme.formats { implicit ReportFormat, implicit InvoiceFormat }</programlisting>
        
        </section>
                
         <section id="aliasimports">
            <title>Alias imports</title>
               
        <para>The optional alias clause in a fully-explicit import allows resolution 
        of cross-namespace declaration name collisions.</para>
        
        <programlisting>TypeAlias: "local" TypeName "="</programlisting>
        
        <comment><para>TODO: Should we use <literal>class</literal> and 
        <literal>interface</literal> for declaring type aliases, instead of
        <literal>local</literal>? Or should we just drop the keyword altogether?</para></comment>

        <programlisting>MethodAttributeAlias: "local" MemberName "="</programlisting>
        
        <para>An alias assigns a different name to the imported declaration.</para>
        
        <programlisting>import java.util { local JavaMap = Map }</programlisting>
        
        <programlisting>import math { local fib = fibonnacciNumber }</programlisting>
        
        <comment><para>TODO: Currently, inheritance of two members with the same name
        from different unrelated types always results in a compile error. A similar 
        problem arises with extensions. We could let you resolve these kinds of problem 
        by renaming a member of a type you're importing. This is a bit similar to what 
        Eiffel does, but it would be a lexical thing, scoped to the compilation unit. 
        For example:</para>
        <programlisting>import org.formats { Format { local formatToString = format }, ... }</programlisting>
        </comment>
        
        </section>
        
        <section id="wildcardimports">
            <title>Wildcard imports</title>
        
        <para>The elipsis <literal>...</literal> acts as a wildcard in 
        <literal>import</literal> statements. An <literal>import</literal> statement 
        that specifies a wildcard imports all toplevel declarations of the package.</para>
        
        <programlisting>ImportWildcard: "..."</programlisting>
        
        <para>An <literal>import</literal> statement may specify a list of alias imports 
        followed by a wildcard. In this case, the alias imports are imported with the 
        specified names, and all other toplevel declarations are imported with their 
        declared names.</para>
        
        <programlisting>import ceylon.collection { ... }</programlisting>
        
        <programlisting>import math { local fib = fibonnacciNumber, ... }</programlisting>
        
        <programlisting>import com.acme.currencies { implicit CurrencyToDecimal, ... }</programlisting>
        
        <para>Overuse of wildcard imports is discouraged.</para>
        
        </section>
        
        </section>
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An <emphasis>interface</emphasis> is a type schema, together with 
        implementation details for some members of the type. Interfaces may not be 
        directly instantiated.</para>
        
        <programlisting>Interface: Annotation* InterfaceHeader (InterfaceBody | TypeSpecifier ";")</programlisting>
        
        <para>An interface declaration may optionally specify a list of type 
        parameters. An interface declaration may have a list of extended interfaces,
        a list of metatypes, an enumerated list of subtypes, and/or a list of type 
        constraints.</para>
        
        <programlisting>InterfaceHeader: "interface" TypeName TypeParams? InterfaceInheritance TypeConstraints?</programlisting>
        
        <programlisting>InterfaceInheritance: CaseTypes? Metatypes? SatisfiedTypes?</programlisting>
        
        <para>To obtain a concrete instance of an interface, it is necessary to define 
        and instantiate a class that implements the interface, or define an object that
        implements the interface.</para>
        
        <!--<section id="interfacebodies">
            <title>Interface bodies</title>-->
            
        <para>Unlike the body of a class, method, or attribute, the body of an interface
        is not executable, and does not directly contain procedural code.</para>

        <para>The body of an interface contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute, and member class) declarations, and</para>
            </listitem>
            <listitem>
                <para>nested interface and <literal>abstract</literal> class declarations.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>InterfaceBody: "{" Declaration* "}"</programlisting>
        
        <para>An interface may declare <literal>formal</literal> methods, attributes,
        and member classes, and concrete methods, attribute getters, attribute setters, 
        and member classes. An interface may not declare a concrete simple attribute.
        An interface may not declare a member <literal>object</literal>.</para>
        
        <para>A member of an interface may not be annotated <literal>definite</literal>.</para>
        
        <programlisting>shared interface Comparable&lt;T&gt; {
    
    shared formal Comparison compare(T other);
    
    shared Boolean greaterThan(T other) {
        return compare(other)==larger
    }
    
    shared Boolean lessThan(T other) {
        return compare(other)==smaller
    }
    
}</programlisting>

        <para>A non-<literal>abstract </literal> nested class declaration is called a
        <emphasis>member class</emphasis> of the interface. A nested interface or 
        <literal>abstract</literal> class declaration is not part of the schema of the 
        interface type, and is therefore not considered a member of the interface.</para>
        
        <!-- 
        <para>Which is equivalent to the following Java interface:</para>

        <programlisting>shared interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>
        -->
        
        <comment><para>TODO: I think, at least for now, we should prohibit interfaces
        nested inside executable bodies: blocks and class bodies.</para></comment>
        
        <section id="interfacemembervisibility">
            <title>Interface member visibility</title>
            
            <para>An interface member is always visible to all other members of the
            interface.</para>
        
        </section>
        
        <!--
        <section id="mutableinterfaces">
            <title>Mutable and immutable interfaces</title>
            
            <para>An interface may be annotated <literal>variable</literal>. If an interface 
            is not annotated <literal>variable</literal> it is called an <emphasis>immutable 
            type</emphasis>, and it may not:</para>
        
            <itemizedlist>
                <listitem>
                    <para>declare or inherit <literal>variable</literal> attributes, or</para>
                </listitem>
                <listitem>
                    <para>extend an interface annotated <literal>variable</literal>.</para>
                </listitem>
            </itemizedlist>
            
        </section>
        -->
        
        <section id="interfaceinheritance">
            <title>Interface inheritance</title>
            
            <para>An interface may extend any number of other interfaces.</para>
        
            <programlisting>shared interface List&lt;T&gt;
        satisfies T[] &amp; Collection&lt;T&gt; {
    ...
}</programlisting>
        
            <para>The types listed after the <literal>satisfies</literal> keyword are the 
            supertypes. All supertypes of an interface must be interfaces. An interface 
            may not extend the same interface twice (not even with distinct type arguments).</para>
            
            <!--para>
            Since every class that implements an interface is a subclass of <literal>lang.Object</literal>,
            the interface type itself is considered assignable to <literal>lang.Object</literal>.
            </para-->
        
            <para>An interface inherits all members (methods, attributes and member types) 
            of every supertype, except for members refined by the interface or by some 
            supertype of the interface.</para>
            
            <para>The schema of the inherited members is formed by substituting type arguments
            specified in the <literal>satisfies</literal> clause.</para>
            
            <!--
            <para>An interface may not inherit two non-<literal>formal</literal> members
            of different supertypes that both refine the same member of a third supertype.
            If two supertypes both declare non-<literal>formal</literal> members that
            refine the same member of a third supertype, the interface must also refine
            the member.</para>
            -->
            
            <!--
            <para>and the above declaration is equivalent to the following 
            Java declaration: 
            </para>
        
            <programlisting>shared interface List&lt;T&gt; 
        extends Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
            -->
            
             <para>An interface that extends a nested interface must be a member of the type 
             that declares the nested interface or of a subtype of the type that declares the 
             nested interface.</para>
         
        </section>
        
    <section id="interfaceswithcases">
        <title>Interfaces with enumerated cases</title>
        
        <para>The <literal>of</literal> clause of an interface declaration specifies the 
        list of cases of the interface.</para>
        
        <programlisting>shared interface Node&lt;T&gt; of Root&lt;T&gt; | Branch&lt;T&gt; | Leaf&lt;T&gt; { ... }</programlisting>
        
        <para>The cases may be interfaces, classes, or anonymous classes. A case may be 
        an <literal>abstract</literal> class. Each case must be a subtype of the
        interface type.</para>
        
        <para>If an anonymous class is a case of an interface type, it must extend
        <literal>ceylon.language.Case</literal>, directly or indirectly.</para>
        
        <para>If an interface has an <literal>of</literal> clause, then every subtype of 
        the interface must be subtype of one of the enumerated cases.</para>
                
    </section>
    
    <section id="interfacealiases">
        <title>Interface aliases</title>
        
        <para>An interface declaration which specifies a reference to another interface
        type defines an <emphasis>interface alias</emphasis> of the specified interface 
        type.</para>
        
        <programlisting>TypeSpecifier: "=" Type</programlisting>

        <para>The specified interface type may be a produced type (it may specify type 
        arguments). An interface alias simply assigns an alternative name to the original 
        interface type or produced type.</para>
        
        <programlisting>shared interface PeopleByName = Map&lt;String,Person&gt;;</programlisting>
        
        <programlisting>interface Compare&lt;T&gt; = Callable&lt;Comparison,T,T&gt;;</programlisting>
                
        <para>Interface aliases are not reified types. The metamodel reference for an 
        interface alias&mdash;for example, <literal>PeopleByName</literal>&mdash;returns 
        the metamodel object for the aliased interface&mdash;in this case, 
        <literal>Map&lt;String,Person&gt;</literal>.</para>
    
    </section>
        
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A <emphasis>class</emphasis> is a stateful, instantiable type. It is a 
        type schema, together with implementation details of the members of the type.</para>

        <programlisting>Class: Annotation* ClassHeader (ClassBody | TypeSpecifier? ";")</programlisting>
        
        <para>An ordinary class declaration specifies a list of parameters required to 
        instantiate the type, and, optionally a list of type parameters.  A class 
        declaration may have a superclass, a list of extended interfaces, a list of 
        metatypes, an enumerated list of subtypes, and/or a list of type constraints.</para>
        
        <programlisting>ClassHeader: "class" TypeName TypeParams? Params ClassInheritance TypeConstraints?</programlisting>
        
        <programlisting>ClassInheritance: CaseTypes? Metatypes? ExtendedType? SatisfiedTypes?</programlisting>
        
        <para>To obtain an instance of a class, it is necessary to instantiate the
        class, or a subclass of the class.</para> 
        
    <!--<section id="classbodies">
        <title>Class bodies</title>-->
        
        <para>The body of a class contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute, and member class) declarations,</para>
            </listitem>
            <listitem>
                <para>nested interface and <literal>abstract</literal> class declarations, 
                and</para>
            </listitem>
            <listitem>
                <para>instance initialization code.</para>
            </listitem>
        </itemizedlist>

        <programlisting>ClassBody: "{" (Declaration | Statement)* "}"</programlisting>
        
        <para>A non-<literal>abstract </literal> nested class declaration is called a
        <emphasis>member class</emphasis> of the class. A nested interface or 
        <literal>abstract</literal> class declaration is not part of the schema of the 
        class type, and is therefore not considered a member of the class.</para>
        
        <!--
        <para>The body of a class may invoke, evaluate or assign members of the instance 
        being initialized&mdash;the current instance of the class&mdash;without explicitly 
        specifying the receiver.</para>
        
        <para>The body of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class or interface&mdash;the receiving instance 
        of the instantiation expression&mdash;without explicitly specifying the receiver.</para>
        
        <para>A class may be declared inside the body of a method, or attribute, in which 
        case the body of the class may refer to any non-<literal>variable</literal> local, 
        block local attribute getter or block local method declared earlier within the 
        containing scope. It may not refer to <literal>variable</literal> locals from the 
        containing scope.</para>
        -->

    <section id="initializerparameters">
        <title>Initializer parameters</title>
        
        <para>Ceylon classes do not support a Java-like constructor declaration syntax. 
        Instead, the body of the class declares <emphasis>initializer parameters</emphasis>. 
        An initializer parameter may be used anywhere in the class body, including in 
        method and attribute definitions.</para>
        
        <para>An initializer parameter may be used to specify or initialize the value 
        of an attribute:</para>
        
        <programlisting>shared class Key(Lock lock) {
    shared Lock lock = lock;
}</programlisting>
        
        <programlisting>shared class Counter(Natural start=0) {
    shared variable Natural count := start;
    shared void inc() { count++; }
}</programlisting>
        
        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private final ReadAttribute&lt;Lock&gt; lock;
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) {
        this.lock = new SimpleReadAttribute&lt;Lock&gt;(lock); 
    }
    
}</programlisting>
         -->
        <para>An initializer parameter may even be used within the body of a method,
        attribute getter, or attribute setter:</para>
        
        <programlisting>shared class Key(Lock lock) {
    shared Lock lock { return lock }
}</programlisting>

        <programlisting>shared class Key(Lock lock) {
    shared void lock() { lock.engage(this); }
    shared void unlock() { lock.disengage(this); }
}</programlisting>

        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private Lock _lock;
        
    private final ReadAttribute&lt;Lock&gt; lock = new ReadAttribute&lt;Lock&gt;() {
        @Override public Lock get() { return _lock; }
    };
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) { 
        _lock = lock; 
    }
    
}</programlisting>
        -->
        

        <comment><para>TODO: should class initializer parameters be allowed to be declared 
        <literal>shared</literal>, allowing a shortcut simple attribute declaration like in 
        Scala?</para></comment>
                
        <!--
        <section>
        <title>Annotations</title>
        
        <para>Every annotation is a toplevel (non-void) method call. This Ceylon class:</para>
        
        <programlisting>doc "Represents a person"
by "Gavin"
shared class Person { ... }</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>public class Person { ... 

    static {
        Type&lt;Person&gt; type = Type.get(Person.class);
        type.addAnnotation( doc("Represents a person") );
        type.addAnnotation( by("Gavin") );
        type.addAnnotation( shared() );
    }

    ...

}</programlisting>
        
        </section>
        -->

    </section>

    <section id="callabletypeofclass">
        <title>Callable type of a class</title>
        
        <para>The <emphasis>callable type</emphasis> of a class captures the type and parameter 
        types of the class. The callable type is <literal>Callable&lt;T,P...&gt;</literal>, where
        <literal>T</literal> is the class and <literal>P...</literal> are the parameter types 
        of the class. A sequenced parameter is considered of type <literal>T[]</literal>
        where <literal>T...</literal> is the declared sequenced type.</para>
        
        <para>An <literal>abstract</literal> class is not callable.</para>
    
    </section>
    
    <section id="initializersection">
        <title>Initializer section</title>
    
        <para>The initial part of the body of a class is called the <emphasis>initializer</emphasis> 
        and contains a mix of declarations, statements and control structures. The initializer 
        is executed every time the class is instantiated.</para>
           
        <para>A class initializer is responsible for initializing the state of the new 
        instance of the class, before a reference to the new instance is available to 
        clients.</para>
        
        <programlisting>shared abstract class Point() {
    shared formal Decimal x;
    shared formal Decimal y;
}</programlisting>
        
        <programlisting>shared class DiagonalPoint(Decimal distance) 
        extends Point() {
    
    Decimal pos = distance / 2**0.5;
    x = pos;
    y = pos;
    
    assert ("must have distance " distance " from origin") 
        that ( x**2 + y**2 &equals; distance**2 );
    
}</programlisting>
        
        <programlisting>shared object origin 
        extends Point() {
    x = 0.0;
    y = 0.0;
}</programlisting>
        
        <!--
        <para>So the above class is equivalent to:</para>
        
        <programlisting>public class DiagonalPoint extends Point {
        
    public DiagonalPoint(final Decimal position) {
    
        x = y = sqrt( position.power(2).divided(2) ).times(position.sign);
        
        assert_(new F0&lt;String&gt;() {
                   public String call() { 
                       return "must have distance " + position + " from origin";
                   }
                },
                new F0&lt;Boolean&gt;() {
                   public Boolean call() { 
                       return ( x.power(2) + y.power(2) ).equals( position.power(2) );
                   }
                });
    }
    
}</programlisting>
        -->
        
        <para>The following restrictions apply to statements and declarations that appear 
        within the initializer of a class:</para>
        
        <itemizedlist>
           <listitem>
              <para>They may not evaluate attributes or invoke methods that are declared 
              later in the body of the class upon the instance that is being initialized 
              (including upon a self reference or outer instance reference).</para>
           </listitem>
           <listitem>
              <para>They may not pass a reference to the instance that is being initialized 
              (including a self reference or outer instance reference) as an argument of an 
              instantiation or method invocation or as the value of an attribute assignment.</para>
           </listitem>
           <!-- 
           <listitem>
              <para>They may not declare an <literal>abstract</literal> member class or an
              abstract method or attribute of the class.</para>
           </listitem>
           <listitem>
              <para>They may not declare a <literal>default</literal> member class, method, 
              or attribute of the class.</para>
           </listitem>
           -->
           <listitem>
              <para>They may not invoke or evaluate a <literal>formal</literal>, 
              <literal>default</literal>, or <literal>definite</literal> member of the instance 
              that is being initialized, except via the special <literal>super</literal> self 
              reference.</para>
           </listitem>
        </itemizedlist>
        
        <para>It is acceptable to invoke or evaluate a <literal>formal</literal> or 
        <literal>default</literal> member of a superclass that is refined by a 
        non-<literal>formal</literal>, non-<literal>default</literal> declaration of a 
        different superclass or that appears earlier in the body of the class.</para>
        
        <para>Non-<literal>formal</literal>, non-<literal>default</literal> superclass 
        members may be invoked, evaluated or assigned anywhere inside the body of the class. 
        The superclass initializer is executed before the subclass initializer.</para>
        
        <para>For example, the following code fragments are not legal:</para>
        
        <programlisting>class Graph() {
    OpenList&lt;Node&gt; nodes = none;
    class Node() {
        nodes.add(this);    //compiler error (this reference in initializer)
    }
}</programlisting>
        
        <programlisting>class Graph() {
    class Node() {}
    Node createNode() {
        Node node = Node();
        nodes.add(node);    //compiler error (forward reference in initializer)
        return node
    }
    OpenList&lt;Node&gt; nodes = none;
}</programlisting>

        <para>But this code fragment is legal:</para>
        
        <programlisting>class Graph() {
    OpenList&lt;Node&gt; nodes = none;
    Node createNode() {
        Node node = Node();
        nodes.add(node);
        return node
    }
    class Node() {}
}</programlisting>

    </section>
    
    <section id="declarationsection">
        <title>Declaration section</title>
        
        <para>The remainder of the body of the class consists purely of declarations, similar 
        to the body of an interface. <!--including <literal>abstract</literal> and 
        <literal>default</literal> methods and attributes. --> It may not contain:</para>
        
        <itemizedlist>
            <listitem>
                <para>a statement or control structure, unless it is nested inside a method,
                attribute, nested class, or nested interface declaration,</para>
            </listitem>
            <listitem>
                <para>a declaration with a specifier or initializer, unless it is nested inside 
                a method, attribute, nested class, or nested interface declaration, or</para>
            </listitem>
            <listitem>
                <para>a specification or initialization statement for a member of the instance 
                being initialized (including a self reference or outer instance reference).</para>
            </listitem>
        </itemizedlist>
        
        <para>However, the declarations in this second section may freely use <literal>this</literal>, 
        and may invoke any method or evaluate any attribute of the class or its superclasses. 
        The usual restriction that a declaration may only be used by code that appears later in 
        the block containing the declaration is relaxed.</para>
        
        <comment><para>TODO: we could perhaps slightly relax the restrictions here. It's probably
        OK to let you have expression statements and control structures in the second part of the 
        class body, just not specification or initialization statements.</para></comment>
        
    </section>
           
    <section id="classmembervisibility">
        <title>Class member visibility</title>
        
        <para>Ordinarily, a declaration that occurs in a block of code is a block local
        declaration&mdash;it is visible only to statements and declarations that occur
        later in the same block. This rule is relaxed for certain declarations that occur 
        directly inside the body of a class:</para>
        
        <itemizedlist>
            <listitem>
                <para>declarations annotated <literal>shared</literal>&mdash;which are 
                visible wherever the class itself is visible, and</para>
            </listitem>
            <listitem>
                <para>declarations that occur in the second part of the body of the 
                class, after the last statement of the initializer&mdash;which are visible 
                to all other declarations in the second part of the body of the class.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <!--
    <section id="mutableclasses">
        <title>Mutable and immutable classes</title>
        
        <para>A class may be annotated <literal>variable</literal>. If a class is 
        annotated <literal>variable</literal> it must (directly or indirectly) extend 
        <literal>ceylon.language.IdentifiableObject</literal>.</para>
        
        <para>If a class is not annotated <literal>variable</literal> it is called an 
        <emphasis>immutable type</emphasis>, and it may not:</para>
        
        <itemizedlist>
            <listitem>
                <para>declare or inherit <literal>variable</literal> attributes,</para>
            </listitem>
            <listitem>
                <para>extend a <literal>variable</literal> superclass, or</para>
            </listitem>
            <listitem>
                <para>implement an interface annotated <literal>variable</literal>.</para>
            </listitem>
        </itemizedlist>
    
    </section>
    -->
        <section id="classinheritance">
             <title>Class inheritance</title>
        
        <para>A class may extend another class, and implement any number of interfaces.</para>
        
        <programlisting>shared class Customer(Name name, Organization? org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>

        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt; &amp; Identifier {
    ... 
}</programlisting>
        
        <para>The types listed after the <literal>satisfies</literal> keyword are the 
        implemented interfaces. The type specified after the <literal>extends</literal> 
        keyword is a superclass. A class may not implement the same interface twice (not 
        even with distinct type arguments).</para>
        
        <para>A class:</para>
        
        <itemizedlist>
            <listitem>
                <para>inherits all members (methods, attributes, and member types) of every 
                supertype, except for members refined by the class or by some supertype 
                of the class,</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which its superclass is assignable,</para>
            </listitem-->
            <listitem>
                <para>must declare or inherit a member that refines each 
                <literal>formal</literal> member of every interface it implements directly 
                or indirectly, unless the class is declared <literal>abstract</literal> or
                <literal>formal</literal>, and</para>
            </listitem>
             <listitem>
                <para>must declare or inherit a member that refines each 
                <literal>formal</literal> member of its superclass, unless the class is 
                declared <literal>abstract</literal> or <literal>formal</literal>.</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which any interface it implements is 
                assignable.</para>
            </listitem-->
        </itemizedlist>
        
        <para>The schema of the inherited members is formed by substituting type arguments
        specified in the <literal>extends</literal> clause.</para>
        
        <!--
        <para>A class may not inherit two non-<literal>formal</literal> members of 
        different supertypes that both refine the same member of a third supertype.
        If two supertypes both declare non-<literal>formal</literal> members that
        refine the same member of a third supertype, the class must also refine
        the member.</para>
        -->
            
        <para>Furthermore, the initializer of the superclass is always executed before the
        initializer of the subclass whenever the subclass is instantiated.</para>
        
        <para>A subclass must pass values to each superclass initialization parameter in 
        the <literal>extends</literal> clause.</para>

        <programlisting>shared class SpecialKey1()
        extends Key( SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>shared class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>

        <!--
        <para>Which are equivalent to the Java:</para>
        
        <programlisting>public class SpecialKey1 
        extends Key {
    public SpecialKey1() { 
        super( SpecialLock() );
    }
    ... 
}</programlisting>

        <programlisting>public class SpecialKey2 
        extends Key {
    public SpecialKey2(Lock lock) { 
        super(lock);
    }
    ... 
}</programlisting>
        -->
        
        <!-- 
        <para>and the 
        above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>public class Customer 
        extends Person {
    public Customer(Name name) { this(name, null); }
    public Customer(Name name, Organization org) { super(name, org); }
    ... 
}</programlisting>
        
        <programlisting>class Token 
        extends Datetime 
        implements Comparable&lt;Token&gt;, Identifier {
    public Token() { super(); }
    ... 
}</programlisting>
         -->
         
         <para>A sublass of a nested class must be a member of the type that declares 
         the nested class or of a subtype of the type that declares the nested class. 
         A class that implements a nested interface must be a member of the type that 
         declares the nested interface or of a subtype of the type that declares the 
         nested interface.</para>
         
        </section>
       
        <!--
        <section id="overloadedclasses">
            <title>Overloaded classes</title>
            
            <para>Multiple toplevel classes belonging to the same package, or multiple 
            nested classes of the same containing body may declare the same name. The 
            classes are called <emphasis>overloaded</emphasis>.</para>
            
            <para>For any class name and package or containing body, there must be a 
            single <emphasis>root class</emphasis> with the given name belonging to 
            the given package or body. Other classes with the same name belonging to the 
            same package or body:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must extend the root class,</para>
                </listitem>
                <listitem>
                    <para>must have distinct erased signatures,</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters, and</para>
                </listitem>
                <listitem>
                    <para>except for the root class, may not declare any member with a 
                    visibility modifier.</para>
                </listitem>
            </itemizedlist>
            
            <para>Then the class name always refers to the root class, except in 
            instantiation expressions. An instantiation expression is resolved to a 
            particular overloaded class declaration at compile time, using the argument 
            expression types.</para>
        
            <para>A package or body may not declare or inherit two classes with the 
            same name unless either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the classes are overloaded,</para>
                </listitem>
                <listitem>
                    <para>one class refines the other class, or</para>
                </listitem>
                <listitem>
                    <para>one class is defined by a supertype, and is not visible
                    to the subtype that defines the other class.</para>
                </listitem>
            </itemizedlist>
        
        </section>
        -->
        
    <section id="abstractandformalclasses">
        <title>Abstract and formal classes</title>
        
        <para>A class may contain members annotated <literal>formal</literal>. Then
        the class must be either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a toplevel or nested class annotated <literal>abstract</literal>,</para>
            </listitem>
            <listitem>
                <para>a member class annotated <literal>formal</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>If the class is annotated <literal>formal</literal>, it is called a 
        <literal>formal</literal> member class, or, sometimes, an
        <emphasis>abstract member class</emphasis>.</para>
        
        <para>If the class is annotated <literal>abstract</literal>, it is called an
        <literal>abstract</literal> class, or an <emphasis>abstract nested class</emphasis>.</para>
                
        <para>Alternatively, a class may omit a class body entirely.</para>
        
        <programlisting>shared formal class Buffer(Character...) satisfies Character[];</programlisting>
        
        <para>Then the class must be either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a member class of an interface, or</para>
            </listitem>
            <listitem>
                <para>a member class annotated <literal>formal</literal> of a class.</para>
            </listitem>
        </itemizedlist>
        
        <para>In this case, also, it is considered a <literal>formal</literal> member 
        class.</para>
        
        <comment><para>TODO: In this case, do we need to limit the class to specifying 
        at most one supertype? Not sure exactly what limitations exist at the bytecode
        level.</para></comment>
        
        <para>A class annotated <literal>abstract</literal> may not be instantiated.</para>
        
        <para>A member class annotated <literal>formal</literal> may be instantiated.</para>
        
        <para>A member of an <literal>abstract</literal> or <literal>formal</literal> class 
        may not be annotated <literal>definite</literal>.</para>
        
        <para>A class which is not annotated <literal>abstract</literal> or 
        <literal>formal</literal> is called a <emphasis>concrete</emphasis> class.</para>
        
    </section>
        
        <section id="defaultclasses">
            <title>Default classes</title>
            
            <para>A concrete member class may be annotated <literal>default</literal>,
            in which case it may be refined by subtypes of the containing type.</para>
            
        </section>
        
    <section id="refiningmemberclasses">
        <title>Member class refinement</title>
        
        <para>Member class refinement is a unique feature of Ceylon, akin to the
        "factory method" pattern of many other languages.</para>
        
        <itemizedlist>
            <listitem>
                <para>A member class annotated <literal>formal</literal> or
                <literal>default</literal> may be refined by any class which 
                is a subtype of the class or interface which declares the member 
                class.</para>
            </listitem>
            <listitem>
                <para>A member class annotated <literal>formal</literal> 
                <emphasis>must</emphasis> be refined by every concrete class 
                which is a subtype of the class or interface that declares the 
                member class, unless the class inherits a concrete member class 
                from a superclass that refines the <literal>formal</literal> 
                member class.</para>
            </listitem>
        </itemizedlist>
        
        <para>An interface may not refine a member class of an interface it
        extends.</para>
        
        <para>A member class of a class <emphasis>refines</emphasis> a member 
        class of a supertype if the first member class:</para>
        
        <itemizedlist>
            <listitem>
                <para>is annotated <literal>actual</literal>,</para>
            </listitem>
            <listitem>
                <para>has the same name as the member class it refines, and</para>
            </listitem>
            <listitem>
                <para>has a parameter list with the same signature as the member 
                class it refines, after substitution of type arguments specified 
                in the <literal>extends</literal> or <literal>satisfies</literal>
                clause, and either</para>
            </listitem>
            <listitem>
                <para>extends the member class it refines, or, alternatively,</para>
            </listitem>
            <listitem>
               <para>extends the superclass of the member class it refines and 
               implements all interfaces implemented by the member class it 
               refines, where the member class it refines is a 
               <literal>formal</literal> member class with no body.</para>
            </listitem>
        </itemizedlist>
        
        <para>Finally, the refined member class must be visible to the member
        class annotated <literal>actual</literal>.</para>
        
        <para>If a member class is annotated <literal>actual</literal>, it must 
        refine some class defined by a supertype, and the class it refines 
        must be either <literal>formal</literal> or <literal>default</literal>.</para>
            
        <para>A member class may not, directly or indirectly, refine two different
        member classes not themselves annotated <literal>actual</literal>.</para>
        
        <para>Then instantiation of the member class is polymorphic, and the actual
        subtype instantiated depends upon the concrete type of the containing class
        instance.</para>
        
        <para>Note that, according to the rules above, the refining class usually
        extends the member class it refines:</para>
        
        <programlisting>shared abstract class Reader() {
    shared formal class Buffer(Character... chars) 
            satisfies Character[] {}
    ...
}</programlisting>

        <programlisting>shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character... chars) 
            extends Reader.Buffer(chars) {
        ...
    }
    ...
}</programlisting>
        
        <para>But in the special case where the member class it refines does not
        specify a body, the refining class is not required to extend the member 
        class it refines:</para>
        
        <programlisting>shared abstract class Reader() {
    shared formal class Buffer(Character... chars) 
            satisfies Character[];
    ...
}</programlisting>

        <programlisting>shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character... chars) 
            satisfies Character[] {
        ...
    }
    ...
}</programlisting>
        
        <para>A class alias may refine a member class.</para>
        
        <programlisting>shared class FileReader(File file) 
        extends Reader() {
    shared actual class Buffer(Character... chars) = String;
    ...
}</programlisting>
        
    </section>
    
    <section id="anonymousclasses">
        <title>Anonymous classes</title>
        
        <para>An <literal>object</literal> declaration makes it possible to define
        a class, instantiate an instance of the class, and declare an attribute 
        referring to the class instance in a single declaration.</para>
        
        <programlisting>Object: Annotation* ObjectHeader ClassBody</programlisting>
        
        <para>An <literal>object</literal> has an initial lowercase identifier.
        An <literal>object</literal> declaration does not specify parameters or
        type parameters.</para>
        
         <programlisting>ObjectHeader: "object" MemberName ObjectInheritance</programlisting>
         
         <programlisting>ObjectInheritance: ExtendedType? SatisfiedTypes?</programlisting>
         
         <para>An <literal>object</literal> declaration specifies the name of the
         attribute and the schema, supertypes, and implementation of the class. It
         does not specify a type name. Instead, the type has a name assigned 
         internally by the compiler that is not available at compilation time.</para>
         
         <para>An <literal>object</literal> class:</para>
         
         <itemizedlist>
             <!-- 
             <listitem>
                 <para>is implicitly <literal>final</literal>,</para>
             </listitem>
             -->
             <listitem>
                 <para>may not be extended by another class,</para>
             </listitem>
             <listitem>
                 <para>may not be <literal>abstract</literal> or <literal>formal</literal>, 
                 and</para>
             </listitem>
             <listitem>
                 <para>may not declare <literal>default</literal> members.</para>
             </listitem>
         </itemizedlist>
         
         <para>If the <literal>object</literal> is annotated <literal>shared</literal>, 
         the class is <literal>shared</literal>.<!-- If the <literal>object</literal> 
         is annotated <literal>variable</literal>, the class is a <literal>variable</literal> 
         class.--></para>
         
         <para>An <literal>object</literal> attribute:</para>
         
         <itemizedlist>
             <listitem>
                 <para>is non-<literal>variable</literal>, and</para>
             </listitem>
             <listitem>
                 <para>may not be refined or declared <literal>default</literal>.</para>
             </listitem>
         </itemizedlist>
         
         <para>If the <literal>object</literal> is annotated <literal>shared</literal>, 
         the attribute is <literal>shared</literal>. If the <literal>object</literal>
         is annotated <literal>actual</literal>, it refines an attribute of a supertype. 
         If the <literal>object</literal> is annotated <literal>extension</literal>, it 
         is an extension attribute.</para>
         
         <para>The following declaration:</para>
         
         <programlisting>shared object red extends Color('FF0000') {
     shared actual String string = "Red";
}</programlisting>

         <para>Is exactly equivalent to:</para>
         
         <programlisting>class Color_red extends Color('FF0000') {
     shared actual String string = "Red";
}

shared Color_red red = Color_red();</programlisting>
         
         <para>Where <literal>Color_red</literal> is a name generated by the compiler.
         The algorithm for generating this name is not specified here.</para>
         
         <para>Note that a member of an anonymous class that is not annotated 
         <literal>actual</literal> may only be accessed from within the body of 
         the anonymous class or by directly invoking the <literal>object</literal> 
         attribute.</para>
         
         <programlisting>shared object sql {
    shared String escape(String string) { ... }
}

...

String escapedSearchString = sql.escape(searchString);</programlisting>

        <comment><para>TODO: I'm increasingly inclined to think that this is backwards:
        a class should be an <literal>object</literal> with parameters. We could rewrite
        this stuff so that a <literal>class</literal> is equivalent to an interface with
        a typeclass that implements <literal>Callable</literal> and returns a nested 
        <literal>object</literal>. We might have to make an <literal>object</literal> a 
        type, and give it an uppercase name, and/or let you <literal>extend</literal> an
        <literal>object</literal> but that would end up a little more regular anyway, 
        since the <literal>of</literal> clause would now always contain a list of types. 
        The only oddity would be that some common values would getter uppercase names: 
        <literal>True</literal>, <literal>False</literal>, <literal>Null</literal>, 
        etc.</para></comment>
        
    </section>
    
    <section id="classeswithcases">
        <title>Classes with enumerated cases</title>
        
        <para>The <literal>of</literal> clause of a class declaration specifies the 
        list of cases of the class.</para>
        
        <programlisting>shared abstract class Boolean() 
        of true | false 
        extends Case() {}
        
shared object true extends Boolean() {}
shared object false extends Boolean() {}</programlisting>

        <programlisting>shared abstract class Node&lt;T&gt;(String name) 
        of Branch&lt;T&gt; | Leaf&lt;T&gt; { ... }
        
shared class Leaf&lt;T&gt;(String name, T value) 
        extends Node&lt;T&gt;(name) { ... }
        
shared class Branch&lt;T&gt;(String name, Node&lt;T&gt; left, Node&lt;T&gt; right) 
        extends Node&lt;T&gt;(name) { ... }</programlisting>
                
        <para>The cases may be classes, or anonymous classes. A case may be an 
        <literal>abstract</literal> class. Each case must be a subclass of the
        class.</para>
        
        <para>If an anonymous class is a case of a class, the class must extend
        <literal>ceylon.language.Case</literal>, directly or indirectly.</para>
        
        <para>If a class has an <literal>of</literal> clause, then every subtype 
        of the class must be a subtype of one of the enumerated cases.</para>
        
        <para>A non-<literal>abstract</literal> class may not have an <literal>of</literal> 
        clause.<!--A <literal>final</literal> class may not have an <literal>of</literal> 
        clause. --></para>
        
        <comment><para>TODO: We could default the <literal>extends Case()</literal>
        for classes with an <literal>of</literal> clause.</para></comment>
        
        <!--
        <comment><para>TODO: We could let a non-<literal>abstract</literal> class
        limit its subtypes. In which case we could use the syntax <literal>of none</literal> 
        to mean <literal>final</literal>.</para></comment>
        -->
        
        <comment><para>TODO: Should we introduce an abbreviated syntax like:</para>
        <programlisting>shared abstract class Boolean() of case true | case false {}</programlisting>
        <para>Note that it must be <literal>case</literal> instead of <literal>object</literal>
        to resolve an ambiguity between an annotation and the class body followed by 
        a declaration.</para>
        </comment>
        
    </section>
        
    <section id="classaliases">
        <title>Class aliases</title>
        
        <para>A class declaration which specifies a reference to another class type 
        defines a <emphasis>class alias</emphasis> of the specified class type.</para>
        
        <para>The specified class type may be a produced type (it may specify type 
        arguments). A class alias simply assigns an alternative name to the original 
        class type or produced type.</para>
        
        <programlisting>shared class People(Person... people) = ArrayList&lt;Person&gt;;</programlisting>
        
        <para>The callable type of the specified type must be assignable to the 
        callable type of the class alias.</para>
        
        <para>Class aliases are not reified types. The metamodel reference for a class 
        alias&mdash;for example, <literal>People</literal>&mdash;returns the metamodel 
        object for the aliased class&mdash;in this case, 
        <literal>ArrayList&lt;Person&gt;</literal>.</para>
    
    </section>
        
    </section>
    
    <!--  
    <section id="unions">
        <title>Unions</title>
        
        <comment><para>NOTE: Unions are a proposed feature for a future version 
        of the language.</para></comment>
        
        <para>A <emphasis>union</emphasis> is a type with an enumerated list of
        subtypes, called the <emphasis>cases</emphasis> of the union. An instance 
        of any of these cases is an instance of union type. A union may also 
        <literal>satisfy</literal> one or more interfaces, in which case each case 
        type of the union must also satisfy these interfaces. A union itself 
        does not define members.</para>
        
        <programlisting>Union: 
Annotation* 
"choice" TypeName TypeParams?
CaseTypes Metatypes? SatisfiedTypes? 
TypeConstraints?
";"</programlisting>

        <para>The <literal>of</literal> clause of a union declaration specifies the 
        list of cases of the union type.</para>
        
        <programlisting>shared choice Node of root, Branch, Leaf;</programlisting>
        
        <programlisting>choice Container&lt;T&gt; of T[], Set&lt;T&gt;;</programlisting>
        
        <para>The cases may be interfaces, classes, or anonymous classes. A case may 
        be an <literal>abstract</literal> class.</para>
        

        <para>If an anonymous class is a case of a union type, it must extend
        <literal>ceylon.language.Case</literal>, directly or indirectly.</para>
        
        <programlisting>shared object true extends Case() {}
shared object false extends Case() {}
shared choice Boolean of true, false;</programlisting>
        
        <section id="mutableunions">
            <title>Mutable and immutable unions</title>
            
            <para>A union may be annotated <literal>variable</literal>. If a union is not 
            annotated <literal>variable</literal> it is called an <emphasis>immutable 
            type</emphasis>, and it may not:</para>
        
            <itemizedlist>
                <listitem>
                    <para>declare a <literal>variable</literal> case, or</para>
                </listitem>
                <listitem>
                    <para>satisfy an interface annotated <literal>variable</literal>.</para>
                </listitem>
            </itemizedlist>
            
        </section>
            
        <section id="unioninheritance">
            <title>Union inheritance</title>
            
            <para>A union may satisfy any number of other interfaces.</para>
        
        <programlisting>shared choice Node of root, Branch, Leaf satisfies Observable;</programlisting>
        
            <para>The types listed after the <literal>satisfies</literal> keyword are 
            the supertypes. All supertypes of a union must be interfaces. A union may 
            not extend the same interface twice (not even with distinct type arguments).</para>
            
            <para>Every case of the union must be a subtype of every interface satisfied 
            by the union type.</para>
            
        
            <para>A union inherits all members (methods, attributes and member types) 
            of every supertype.</para>
        
            <para>The schema of the inherited members is formed by substituting type 
            arguments specified in the <literal>satisfies</literal> clause.</para>
            
            <para>A union may not inherit two non-<literal>abstract</literal> members of 
            different supertypes that both refine the same member of a third supertype.</para>
        
        </section>
        
    </section>
            
        -->
        <!-- <programlisting>shared interface TransactionPropagation {
    void propagate(Transaction tx);
}

shared choice TransactionPropagationStyle 
        satisfies TransactionPropagation {
        
    abstract class BaseTransactionPropagation()
            satisfies TransactionPropagation {
        
        shared actual void propagate(Transaction tx) {
            if (tx.inProgress) {
                inProgress(tx);
            }
            else {
                notInProgress(tx);
            }
        }
        
        shared void inProgress(Transaction tx);
        
        shared void notInProgress(Transaction tx);
        
    }
    
    shared object required 
            extends BaseTransactionPropagation() { 
        shared actual void inProgress(Transaction tx) {}
        shared actual void notInProgress(Transaction tx) {
            tx.begin();
        }
    }
    
    shared object supports 
            extends BaseTransactionPropagation() {
        shared actual void inProgress(Transaction tx) {}
        shared actual void notInProgress(Transaction tx) {}
    }
    
    shared object mandatory 
            extends BaseTransactionPropagation() { 
        shared actual void inProgress(Transaction tx) {}
        shared actual void notInProgress(Transaction tx) {
            throw TransactionMandatory()
        }
    }
    
    shared object notSupported 
            extends BaseTransactionPropagation() { 
        shared actual void inProgress(Transaction tx) {
            throw TransactionNotSupported()
        }
        shared actual void notInProgress(Transaction tx) {}
    }
    
    shared object requiresNew 
            extends BaseTransactionPropagation() { 
        shared actual void inProgress(Transaction tx) {
            throw TransactionRequiresNew()
        }
        shared actual void notInProgress(Transaction tx) {
            tx.begin();
        }
    }
    
}</programlisting>-->
        
    <section id="methods">
        <title>Methods</title>
        
        <para>A <emphasis>method</emphasis> is a callable block of code. Methods may 
        have parameters and may return a value.</para>
        
        <programlisting>Method: Annotation* MethodHeader (Block | NamedArguments | Specifier? ";")</programlisting>
        
        <para>All method declarations specify the method name, one or more parameter 
        lists, and, optionally, a list of type parameters. A method declaration may 
        specify a type, called the <emphasis>return type</emphasis>, to which the 
        values the method returns are assignable, or it may specify that the method 
        is a <literal>void</literal> method&mdash;a method which does not return a 
        value. The return type of a <literal>void</literal> method is considered to 
        be <literal>Void</literal>. A method declaration may have a list of type 
        constraints.</para>
        
        <programlisting>MethodHeader: (InferableType | "void") MemberName TypeParams? Params+ Metatypes? TypeConstraints?</programlisting>
        
        <para>The Ceylon compiler preserves the names of method parameters.</para>
        
        <!--<section id="methodbodies">
            <title>Method bodies</title>-->
        
        <para>A method implementation may be specified using either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a block of code, or</para>
            </listitem>
            <listitem>
                <para>a reference to another method, or</para>
            </listitem>
            <listitem>
                <para>a named argument list.</para>
            </listitem>
        </itemizedlist>
        
        <!--
        <para>A member method body may invoke, evaluate or assign members of the instance
        being invoked&mdash;the current instance of the class which defines the 
        method&mdash;without explicitly specifying the receiver.</para>
        
        <para>A member method body of a member class may invoke, evaluate or assign members 
        of the current instance of the containing class or interface (the containing instance 
        of the instance upon which the method was invoked) without explicitly specifying the 
        receiver.</para>
        
        <para>A toplevel method body may not refer to <literal>this</literal> or 
        <literal>super</literal>, since there is no current instance.</para>
        
        <para>A method may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>variable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>variable</literal> locals from the containing scope.</para>
        -->
        
        <section id="callabletype">
            <title>Callable type of a method</title>
            
        <para>The <emphasis>callable type</emphasis> of a method captures the return
        type and parameter types of the method.</para>
        
        <itemizedlist>
        <listitem>
            <para>The callable type of a method with a single parameter list is 
            <literal>Callable&lt;R,P...&gt;</literal> where <literal>R</literal> is the 
            return type of the method, or <literal>Void</literal> if the method is 
            <literal>void</literal>, and <literal>P...</literal> are the parameter types 
            of the method.</para>
        </listitem>
        <listitem>
            <para>The callable type of a method with multiple parameter lists is 
            <literal>Callable&lt;O,P...&gt;</literal>, where <literal>O</literal> is the
            callable type of a method produced by eliminating the first parameter list, 
            and <literal>P...</literal> are the parameter types of the first parameter 
            list of the method.</para>
        </listitem>
        </itemizedlist>
        
        <para>A sequenced parameter is considered of type <literal>T[]</literal> where 
        <literal>T...</literal> is the declared sequenced type.</para>
        
        </section>
        
        <section id="methodswithdeclaredcallabletype">
            <title>Methods with declared callable type</title>
            
            <comment><para>NOTE: Declared callable type is a proposed feature for a future
            version of the language.</para></comment>
            
            <para>A method declaration may explicitly specify the callable type of the method
            using the <literal>is</literal> clause.</para>
            
            <para>For example, given the following interface alias:</para>
            
            <programlisting>shared interface Page = Callable&lt;Html,HttpRequest&gt;;</programlisting>
            
            <para>We can explicitly specify the callable type of the following method:</para>
            
            <programlisting>Html login(HttpRequest request) is Page { ... }</programlisting>
            
            <para>This style of declaration is useful when the method is going to be discovered 
            and invoked reflectively, without a direct dependency from the calling code. The
            compiler validates the full signature of the method against the declared 
            callable type.</para>
            
        </section>
        
        <section id="methodswithblocks">
            <title>Methods with blocks</title>
            
        <para>A method implementation may be a block. If the method is a <literal>void</literal> 
        method, the block may not contain a <literal>return</literal> directive that 
        specifies an expression. Otherwise, every conditional execution path of the block 
        must end in a <literal>return</literal> directive that specifies an expression
        assignable to the return type of the method.</para>
        
        <programlisting>shared Integer add(Integer x, Integer y) {
    return x + y
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token()
}</programlisting>

        <programlisting>shared void print(Object... objects) {
    for (Object obj in objects) {
        log.info($obj);
    }
}</programlisting>

        <programlisting>shared void addEntry(V key -> U value) {
    map.define(key,value);
}</programlisting>

        <programlisting>shared Set&lt;T&gt; singleton&lt;T&gt;(T element) 
        given T satisfies Comparable&lt;T&gt; {
    return TreeSet(element)
}</programlisting>

        <programlisting>shared Float[n] float&lt;#n&gt;(Decimal[n] decimals) {
    return Vector&lt;Float,#n&gt;() 
                containing (Bounded&lt;#n&gt; i) (decimals[i].float)
}</programlisting>

        <para>Note that a method which declares the return type <literal>Void</literal>
        is not a <literal>void</literal> method. A method with declared type 
        <literal>Void</literal> must return a value of type <literal>Void</literal> 
        (any value will do).</para>
        
        <programlisting>void say(String) { ... }

void hello() {
    say("hello");
}
        
Void goodbye() {
    return say("goodbye")
}</programlisting>
        
        <para>A block local method with a single <literal>return</literal> directive may 
        be declared using the keyword <literal>local</literal> in place of the explicit 
        return type declaration. The type of the method is inferred to be the type of the 
        returned expression.</para>
        
        <programlisting>local add(Integer x, Integer y) {
    return x + y
}</programlisting>
        
        </section>
        
        <section id="methodswithspecifiers">
            <title>Methods with specifiers</title>
            
        <para>Alternatively, a method implementation may be an expression that evaluates 
        to a callable object, specified using <literal>=</literal>. The type of the 
        callable object must be assignable to the callable type of the method.</para>
        
        <programlisting>Float say(String words) = person.say;</programlisting>
        
        <programlisting>Float sqrt(Float x) = 2.root;</programlisting>
        
        <programlisting>Comparison order(String x, String y) = getOrder();</programlisting>
        
        <para>The callable object expression may not refer to parameters of the
        method.</para>
        
        <para>A block local method which specifies a callable object expression may be 
        declared using the keyword <literal>local</literal> in place of the explicit 
        return type declaration. The return type of the method is inferred to be the
        type of the type argument to the first type parameter of the expression type
        <literal>Callable</literal> (the return type).</para>
        
        <programlisting>local sqrt(Float x) = 2.root;</programlisting>
        
        </section>
        
        <section id="methodswithnamedarguments">
            <title>Methods with named argument lists</title>
            
            <para>The final possibility is that a method implementation may be a named
            argument list. A method with a named argument list must explicitly declare 
            an invocable type (a non-<literal>abstract</literal> class, or any other
            type with a callable metatype) as the return type. The method simply 
            invokes the return type with the specified named arguments and returns the 
            resulting value.</para>
            
            <para>The following declarations are equivalent:</para>
            
            <programlisting>Html login(HttpRequest request) {
    head = Head { title="Hello" };
    body = Body { 
        Div { "Hello World" } 
    };
}</programlisting>
            
            <programlisting>Html login(HttpRequest request) {
    return Html {
        head = Head { title="Hello" };
        body = Body { 
            Div { "Hello World" } 
        };
    }
}</programlisting>
            
            <comment><para>TODO: we could add a keyword or punctuation to help disambiguate 
            the two forms of method implementation, for example:</para>
            <programlisting>Html login(HttpRequest request) with {
    Head head with { ... }
    Body body with { ... }
}</programlisting>
            <programlisting>Html login(HttpRequest request): {
    Head head: { ... }
    Body body: { ... }
}</programlisting></comment>
            
        </section>
                
        <section id="multipleparameterlists">
            <title>Methods with multiple parameter lists</title>
            
        <para>A method may declare multiple lists of parameters. A method which 
        declares more than one parameter list returns instances of 
        <literal>Callable</literal>, usually method references.</para>
        
        <para>The type of the expression specified by the <literal>return</literal> 
        directive may be be assignable to either:</para>
        
        <itemizedlist>
            <listitem><para>the callable type of a method produced by taking the 
            method with multiple parameter lists and eliminating the first parameter 
            list, or</para></listitem>
            <listitem><para>the declared return type of the method.</para></listitem>
        </itemizedlist>
        
        <para>If the <literal>return</literal> expression type is assignable to the 
        callable type of the method produced by eliminating the first parameter 
        list of the method, the method body may <emphasis>only</emphasis> refer to 
        parameters in the first parameter list. It may not refer to parameters of 
        other parameter lists. Parameters declared by parameter lists other than the 
        first parameter list are not considered visible inside the body of the 
        method.</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    Comparison order(Natural x, Natural y) { return x&lt;=&gt;y }
    return order
}</programlisting>

        <para>Otherwise, if the <literal>return</literal> expression type is assignable 
        to the declared return type of the method, the method body may refer to any
        parameter in any one of the parameter lists of the method. The compiler 
        automatically infers a series of nested methods, one for each parameter list of 
        the method. The declarations and statements in the method body form the body of 
        the most nested inferred method.</para>
        
        <para>This method declaration:</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    return x&lt;=&gt;y
}</programlisting>

        <para>is equivalent to the previous example. The compiler infers a method with
        the same signature and implementation as <literal>order()</literal> above.</para>

        <para>For a method with <literal>n</literal> parameter lists, there are 
        <literal>n</literal> inferred methods. The <literal>i</literal>th inferred 
        method:</para>
        
        <itemizedlist>
            <listitem>
                <para>has the same return type as the original declared method,</para>
            </listitem>
            <listitem>
                <para>has the same parameter lists as the declared method, after 
                eliminating the first <literal>i-1</literal> parameter lists, 
                and</para>
            </listitem>
            <listitem>
                <para>if <literal>i&lt;n</literal>, has a body which contains the
                definition of the <literal>i+1</literal>th inferred method and 
                simply returns a reference to that method, or</para>
            </listitem>
            <listitem>
                <para>otherwise, if <literal>i=n</literal>, has the body of the original
                declared method.</para>
            </listitem>
        </itemizedlist>
        
        <para>The first inferred method replaces the original declared method in the 
        definition of the class.</para>
        
        <para>This method declaration:</para>
        
        <programlisting>shared String fullName(String firstName)(String middleName)(String lastName) {
    return firstName + " " + middleName + " " lastName
}</programlisting>
        
        <para>Is equivalent to:</para>
        
        <programlisting>shared String fullName(String firstName)(String middleName)(String lastName) {
    String fullName2(String middleName)(String lastName) {
        String fullName3(String lastName) {
            return firstName + " " + middleName + " " + lastName
        }
        return fullName3
    }
    return fullName2
}</programlisting>
        
        <!--
        <programlisting>@FormalParameterNames({"x", "y"}) 
public Integer add(Integer x, Integer y) { ... }</programlisting>
        -->
        
        <comment><para>TODO: To be totally complete and regular with attribute getters,
        I suppose we should let any method body return a method reference with the same 
        signature as the method. But I'm not really sure how practically useful this
        would be.</para></comment>
                
        </section>
        
        <!--
        <section id="overloadedmethods">
            <title>Overloaded methods</title>
            
            <para>Multiple toplevel methods belonging to the same package, or multiple 
            methods of the same containing body may may declare the same name. A class or
            interface may declare or inherit multiple methods with the same name. The 
            methods are called <emphasis>overloaded</emphasis>. Overloaded methods:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must have distinct erased signatures, and</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters.</para>
                </listitem>
            </itemizedlist>
            
            <para>A class may not not declare or inherit a method with the same name as
            an attribute it declares or inherits.</para>
            
            <para>An invocation expression is resolved to a particular overloaded method 
            declaration at compile time, using the argument expression types.</para>
            
            <para>A package or body may not declare or inherit two methods with the 
            same name unless either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the methods are overloaded,</para>
                </listitem>
                <listitem>
                    <para>one method refines the other method, or</para>
                </listitem>
                <listitem>
                    <para>one method is defined by a supertype, and is not visible
                    to the subtype that defines the other method.</para>
                </listitem>
            </itemizedlist>
        
        </section>
        -->
        
       <section id="formalmethods">
            <title>Formal methods</title>
            
            <para>If there is no method implementation in a method declaration, then
            either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the implementation of the method must be specified later in 
                    the body containing the method declaration,</para>
                </listitem>
                <listitem>
                    <para>the method must be a member of an interface, and the method
                    must be annotated <literal>formal</literal>, or</para>
                </listitem>
                <listitem>
                    <para>the method must be a member of a class, the method must be 
                    annotated <literal>formal</literal>, and the class that declares 
                    the method must be annotated <literal>formal</literal> or
                    <literal>abstract</literal>.</para>
                </listitem>
            </itemizedlist> 
            
            <para>If the method is a member of an interface or is annotated 
            <literal>formal</literal>, it is called a <literal>formal</literal> 
            method, or, sometimes, an <emphasis>abstract method</emphasis>.</para>
            
            <para>A method annotated <literal>formal</literal> may not specify an
            implementation (a block, specifier, or named argument list).</para>
        
            <programlisting>shared formal U? get(V key);</programlisting>
            
            <para>A toplevel method may not be annotated <literal>formal</literal> and 
            must have a method implementation (a block of code, or a reference to another 
            method).</para>
            
            <para>A block local method may not be annotated <literal>formal</literal> 
            and must have a method implementation.</para>

            <para>A method which is not annotated <literal>formal</literal> is called a 
            <emphasis>concrete</emphasis> method.</para>
        
        </section>
        
        <section id="defaultmethods">
            <title>Default and definite methods</title>
            
            <para>A concrete member method may be annotated <literal>default</literal>
            or <literal>definite</literal>, in which case it may be refined by subtypes 
            of the containing type.</para>
            
        </section>
        
        <section id="refiningmethods">
            <title>Method refinement</title>
            
            <para>Method refinement is the foundation of polymorphism in Ceylon.</para>
            
            <itemizedlist>
            <listitem>
                <para>A class or interface may refine any <literal>formal</literal> 
                method or <literal>default</literal> method it inherits, unless it inherits 
                a non-<literal>formal</literal> non-<literal>default</literal> method that 
                refines the method.</para>
            </listitem>
            <listitem>
                <para>A concrete class must refine every <literal>formal</literal> method 
                or <literal>definite</literal> method it inherits, unless it inherits a 
                non-<literal>formal</literal> non-<literal>definite</literal> method that 
                refines the method.</para>
            </listitem>
            </itemizedlist>           
            
            <para>A method of a subtype <emphasis>refines</emphasis> a method of
            a supertype if the first method:</para>
            
            <itemizedlist>
                <listitem>
                    <para>is annotated <literal>actual</literal>,</para>
                </listitem>
                <listitem>
                    <para>has the same name as the method it refines,</para>
                </listitem>
                <listitem>
                    <para>has the same number of parameter lists, with the same
                    signatures, as the method it refines, after substitution of 
                    type arguments specified in the <literal>extends</literal> or 
                    <literal>satisfies</literal> clause of the class, and</para>
                </listitem>
                 <listitem>
                    <para>has a return type that is assignable to the return type 
                    of the method it refines in the compilation unit containing
                    the method annotated <literal>actual</literal>, after 
                    substitution of type arguments specified in the 
                    <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the refined method must be visible to the method
            annotated <literal>actual</literal>.</para>
            
            <para>If a method is annotated <literal>actual</literal>, it must 
            refine some method defined by a supertype, and the method it refines 
            must be either <literal>formal</literal>, <literal>default</literal>, 
            or <literal>definite</literal>.</para>
            
            <para>A method may not, directly or indirectly, refine two different
            methods not themselves annotated <literal>actual</literal>.</para>
        
            <para>Then invocation of the method is polymorphic, and the actual
            method invoked depends upon the concrete type of the class instance.</para>
            
            <programlisting>shared abstract class AbstractSquareRooter() {
    shared formal Float squareRoot(Float x);
}</programlisting>

            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    shared actual Float squareRoot(Float x) { ... }
}</programlisting>
            
            <para>For <literal>formal</literal> methods, a special shortcut form of 
            refinement is permitted. A subclass initializer may simply specify an 
            instance of <literal>Callable</literal> as the implementation of the method 
            declared by the supertype. No parameter list, return type declaration, or 
            <literal>actual</literal> annotation is necessary.</para>
            
            <programlisting>class ConcreteSquareRooter()
        extends AbstractSquareRooter() {
    Float sqrt(Float x) { ... }
    squareRoot = sqrt;
}</programlisting>
            
            <para>Toplevel methods cannot be refined, and so toplevel method invocation 
            is never polymorphic.</para>
            
            <comment><para>TODO: are you allowed to refine the default value of a 
            defaulted parameter?</para></comment>
            
            <comment><para>TODO: are you required to have the same parameter names in 
            the two methods? I don't see that this would be necessary. In a named 
            argument invocation, you just use the names declared by the member of the 
            compile-time type, and they are mapped positionally to the parameters of 
            the refining method.</para></comment>
        
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to <emphasis>attribute</emphasis> 
        definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a 
                Java field or local variable).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived 
                attribute is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived 
                attribute is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Attribute: Annotation* (SimpleAttribute | AttributeGetter | AttributeSetter)</programlisting>
    
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be refined by subclasses.</para>
        
        <para>All attributes have a type and name. The type of the attribute is specified
        by the simple attribute declaration or attribute getter declaration. An attribute 
        may be <literal>variable</literal>, in which case its value can be assigned using 
        the <literal>:=</literal> and compound assignment operators. This is the case for
        simple attributes explicitly annotated <literal>variable</literal>, or for 
        attributes with a setter declaration.</para>
            
        <programlisting>AttributeHeader: InferableType MemberName</programlisting>
        
        <para>Note that an attribute declaration is essentially a method declaration with 
        zero parameter lists. Likewise, an attribute evaluation is essentially a method 
        invocation with zero argument lists.</para>
        
        <para>A toplevel attribute may not be <literal>variable</literal>.</para>
        
        <para>If a class declares or inherits a <literal>variable</literal> attribute, it 
        must (directly or indirectly) extend the class 
        <literal>ceylon.language.IdentifiableObject</literal>.</para>
        
        <para>An attribute of type <literal>Gettable</literal> or <literal>Settable</literal> 
        may not be <literal>variable</literal>.</para>
        
        <!--<section id="attributebodies">
            <title>Attribute bodies</title>-->
        <!-- 
        <para>A member attribute body may invoke, evaluate or assign members of the 
        instance being invoked&mdash;the current instance of the class which defines the 
        method&mdash;without explicitly specifying the receiver.</para>
        
        <para>A member attribute body of a member class may invoke, evaluate or assign 
        members of the current instance of the containing class or interface (the containing 
        instance of the instance upon which the attribute was invoked) without explicitly 
        specifying the receiver.</para>
        
        <para>A toplevel attribute body may not refer to <literal>this</literal> or 
        <literal>super</literal>, since there is no current instance.</para>
        
        <para>An attribute may be declared inside the body of another method or attribute, 
        in which case it may refer to any non-<literal>variable</literal> local, block local 
        attribute getter or block local method declared earlier withing the containing scope. 
        It may not refer to <literal>variable</literal> locals from the containing scope.</para>
        -->
        <!--
        <para>
        An attribute declaration is equivalent to a Java method declaration together with 
        a Java field declaration, both of type <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal>, both with the same name as the attribute.
        </para>
        -->
        
        <section id="simpleattributesandlocals">
            <title>Simple attributes and locals</title>
            
        <para>A simple attribute defines state.</para>
        
        <programlisting>SimpleAttribute: AttributeHeader ( (Specifier | Initializer)? ";" | NamedArguments )</programlisting>
        
        <para>A simple attribute or local annotated <literal>variable</literal> represents a
        value that can be assigned multiple times. A simple attribute or local not annotated
        <literal>variable</literal> represents a value that can be specified exactly once.</para>
        
        <para>The value of a non-<literal>variable</literal> attribute is specified using 
        <literal>=</literal>. A <literal>variable</literal> attribute may be initialized using 
        the assignment operator <literal>:=</literal>.</para>

        <programlisting>Initializer: ":=" Expression</programlisting>

        <para>Parameters of classes and methods are also considered to be locals.</para>
        
        <!--
        <para>For a simple attribute that is not a local, the Java field is initialized to an 
        instance of <literal>lang.SimpleAttribute</literal> or 
        <literal>lang.SimpleReadAttribute</literal>. For example:</para> 
         -->
        
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; firstName = new SimpleAttribute&lt;String&gt;();
Attribute&lt;String&gt; firstName() { return firstName; }</programlisting>

        <para>While:</para>
         -->
         
        <programlisting>variable Natural count := 0;</programlisting>
        
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;Natural&gt; count = new SimpleAttribute&lt;Natural&gt;(0);
private Attribute&lt;Natural&gt; count() { return count; }</programlisting>

        <para>And:</para>
        -->
        
        <programlisting>shared Integer max = 99;</programlisting>
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Integer&gt; max = new SimpleReadAttribute&lt;Integer&gt;(99);
public ReadAttribute&lt;Integer&gt; max() { return max; }</programlisting>
        -->

        <programlisting>shared Decimal pi = calculatePi();</programlisting>
        
        <programlisting>shared Natural[] evenDigits = {0,2,4,6,8};</programlisting>

        <para>A simple attribute declared directly inside the body of a class represents state 
        associated with the instance of the class. Repeated evaluation of the attribute of a 
        particular instance of the class returns the same result until the attribute of the 
        instance is assigned a new value.</para>
        
        <para>A <emphasis>local</emphasis> represents state associated with execution of a
        particular block of code. A local is really just a special case of a simple attribute 
        declaration, but one whose state is not held across multiple executions of the block
        of code in which the local is defined.</para> 
        
        <itemizedlist>
            <listitem>
                <para>A simple attribute declared inside a block (the body of a method, attribute 
                getter or attribute setter) is a local.</para>
            </listitem>
             <listitem>
                <para>A block local simple attribute declared inside the body of a class is a 
                local if it is not used inside a method, attribute setter or attribute getter 
                declaration.</para>
            </listitem>
           <listitem>
                <para>A parameter of a class is a local if it is not used inside a method, 
                attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A parameter of a method is a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>A local is a block local declaration&mdash;it is visible only to statements and 
        declarations that occur later in the same block or class body, and therefore it may not 
        be annotated <literal>shared</literal>.</para>
        
        <para>The semantics of locals are identical to Java local variables.</para>
        
        <para>The compiler is permitted to optimize block local simple attributes to a simple 
        Java field declaration or local variable. Block local attributes may not be accessed 
        via reflection.</para>
        
        <para>A block local simple attribute with a specifier or initializer may be declared 
        using the keyword <literal>local</literal> in place of the explicit type declaration. 
        The type of the local or attribute is inferred to be the type of the specifier or
        initializer expression.</para>
        
        <programlisting>local names = List&lt;String&gt;();</programlisting>
        <programlisting>variable local count:=0;</programlisting>
                
        </section>
        
        <section id="attributeswithnamedarguments">
            <title>Attributes with named argument lists</title>
            
            <para>Alternatively, a non-<literal>variable</literal> simple attribute may 
            specify a named argument list. An attribute with a named argument list must 
            explicitly declare an invocable type (a non-<literal>abstract</literal> 
            class, or any other type with a callable metatype) as the attribute type. 
            The attribute value is determined by simply invoking the return type with 
            the specified named arguments.</para>
            
            <para>The following declarations are equivalent:</para>
            
            <programlisting>Module module {
    name = 'org.hibernate';
    version = '3.0.0';
}</programlisting>
            
            <programlisting>Module module = Module {
    name = 'org.hibernate';
    version = '3.0.0';
}</programlisting>
            
        </section>
        
         <section id="attributegetters">
            <title>Attribute getters</title>
            
            <para>An attribute getter is a callable block of code with no parameters,
            that returns a value.</para>
            
            <programlisting>AttributeGetter: AttributeHeader Block</programlisting>
            
            <para>An attribute getter defines how the value of a derived attribute is
            obtained.</para>
            
            <!--
            <para>For an attribute getter, the Java field is initialized to an instance 
            of an anonymous inner subclass of <literal>lang.Attribute</literal> or
            <literal>lang.ReadAttribute</literal> that refines the <literal>get()</literal> 
            method with the content of the getter block. For example: </para>
            -->
                    
            <programlisting>shared Float total {
    Float sum := 0.0;
    for (LineItem li in lineItems) {
        sum += li.amount;
    }
    return sum
}</programlisting>
        
            <para>If an attribute getter has a matching attribute setter, we say that 
            the attribute is <literal>variable</literal>. Otherwise we say it is 
            non-<literal>variable</literal>.</para>
            
            <!--
            <programlisting>shared Float total { return items.totalPrice }</programlisting>
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final ReadAttribute&lt;Float&gt; total = new ReadAttribute&lt;Float&gt;() {
    @Override public Float get() { return items.get().totalPrice; }
};
public ReadAttribute&lt;Float&gt; total() { return total; }</programlisting>
            -->
            
            <para>A block local attribute getter with a single <literal>return</literal>
            directive may be declared using the keyword <literal>local</literal> in place of 
            the explicit type declaration. The type of the local or attribute is inferred to 
            be the type of the returned expression.</para>
        
            <programlisting>local name { 
    return Name(firstName, initial, lastName) 
}</programlisting>
                
        </section>
        
        <!--
        <section id="getterswithnamedarguments">
            <title>Attribute getters with named argument lists</title>
            
            <para>Alternatively, an attribute getter may be a named
            argument list. A getter with a named argument list must explicitly declare a 
            non-<literal>abstract</literal> class as the attribute type. The getter simply 
            instantiates the return type with the specified named arguments and returns 
            the resulting value.</para>
            
            <para>The following declarations are equivalent:</para>
            
            <programlisting>Module module {
    name = 'org.hibernate';
    version = '3.0.0';
}</programlisting>
            
            <programlisting>Module module {
    return Module {
        name = 'org.hibernate';
        version = '3.0.0';
    }
}</programlisting>

            <comment><para>TODO: should this syntax build a new object each time the attribute 
            is evaluated, or should it construct the object once and return the same object
            each time?</para></comment>
        
        </section>
        -->
        
        <section id="attributesetters">
            <title>Attribute setters</title>
                    
            <para>An attribute setter is a callable block of code that accepts a
            single value and does not return a value.</para>
            
            <programlisting>AttributeSetter: "assign" MemberName Block</programlisting>

            <para>An attribute setter defines how the value of a derived attribute is
            assigned. Every attribute setter must have a corresponding getter with the
            same name.</para>

            <programlisting>shared String name { return join(firstName, lastName) }
shared assign name { firstName = first(name); lastName = last(name); }</programlisting>
            
            <!--
            <para>For an attribute with a setter, the Java field is initialized to an 
            instance of an anonymous inner subclass of <literal>lang.Attribute</literal> 
            that refines the <literal>set()</literal> method with the content of the 
            setter block. For example:
            </para>
            -->
            
            <comment><para>TODO: should we require that the corresponding getter be 
            annotated <literal>variable</literal>?</para></comment>
            
            <!--
            <comment><para>TODO: should we allow overloaded attribute setters, for example:</para>
            <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>
            </comment>
            -->
            
            <!--
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final Attribute&lt;String&gt; name = new Attribute&lt;String&gt;() {
    @Override public String get() { return join(firstName, lastName); }
    @Override public void set(String name) { firstName = first(name); lastName = last(name); }
};
public Attribute&lt;String&gt; name() { return name; }</programlisting>
            -->
        </section>
        
        <section id="formalattributes">
            <title>Formal attributes</title>
            
            <para>If there is no specifier, initializer, or getter implementation, then
            either:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the value or implementation of the attribute must be specified 
                    later in the body containing the attribute declaration,</para>
                </listitem>
                <listitem>
                    <para>the attribute must be a member of an interface, and the 
                    attribute must be annotated <literal>formal</literal>, or</para>
                </listitem>
                <listitem>
                    <para>the attribute must be a member of a class, the attribute must 
                    be annotated <literal>formal</literal>, and the class that declares 
                    the attribute must be annotated <literal>formal</literal> or
                    <literal>abstract</literal>.</para>
                </listitem>
            </itemizedlist> 
            
            <para>If the attribute is a member of an interface or is annotated 
            <literal>formal</literal>, it is called a <literal>formal</literal> 
            attribute, or, sometimes, an <emphasis>abstract method</emphasis>.</para>
            
            <para>An attribute annotated <literal>formal</literal> may not specify an
            implementation (a specifier, initializer, or getter implementation).</para>
        
            <programlisting>shared formal variable String firstName;</programlisting>

            <para>A toplevel attribute declaration may not be annotated <literal>formal</literal> 
            and must have a specifier or getter implementation.</para>

            <para>A block local attribute may not be annotated <literal>formal</literal> 
            and must have a specifier or getter implementation.</para>

            <para>An attribute which is not annotated <literal>formal</literal> is called 
            a <emphasis>concrete</emphasis> attribute.</para>
        
        </section>
        
        <section id="defaultattributes">
            <title>Default and definite attributes</title>
            
            <para>A concrete member attribute may be annotated <literal>default</literal>
            or <literal>definite</literal>, in which case it may be refined by subtypes 
            of the containing type.</para>
            
        </section>
        
        <section id="refiningattributes">
            <title>Attribute refinement</title>
            
            <para>Ceylon allows attributes to be refined, just like methods. This helps
            eliminate the need for Java-style getter and setter methods.</para>
            
            <itemizedlist>
            <listitem>
                <para>A class or interface may refine any <literal>formal</literal> 
                attribute or <literal>default</literal> attribute it inherits, unless it 
                inherits a non-<literal>formal</literal> non-<literal>default</literal> 
                attribute that refines the attribute.</para>
            </listitem>
            <listitem>
                <para>A concrete class must refine every <literal>formal</literal> 
                attribute, or <literal>definite</literal> attribute it inherits, unless it 
                inherits a non-<literal>formal</literal> non-<literal>definite</literal>
                attribute that refines the attribute.</para>
            </listitem>
            </itemizedlist>           
            
            <para>A non-<literal>variable</literal> attribute may be refined by a simple 
            attribute or attribute getter. A <literal>variable</literal> attribute may be 
            refined by a <literal>variable</literal> simple attribute or by an attribute 
            getter and setter pair.</para>
            
            <comment><para>TODO: are you allowed to refine a getter or setter without also 
            refining its matching setter or getter?</para></comment>
            
            <para>An attribute of a subtype <emphasis>refines</emphasis> an attribute of
            a supertype if the first attribute:</para>
            
            <itemizedlist>
                <listitem>
                    <para>is annotated <literal>actual</literal>,</para>
                </listitem>
                <listitem>
                    <para>has the same name as the attribute it refines,</para>
                </listitem>
                 <listitem>
                    <para>has a type that is assignable to the type of the attribute it 
                    refines in the compilation unit containing the attribute annotated 
                    <literal>actual</literal>, after substitution of type arguments 
                    specified in the <literal>extends</literal> or <literal>satisfies</literal> 
                    clause of the class,</para>
                </listitem>
                 <listitem>
                    <para>or has <emphasis>exactly the same type</emphasis> as the 
                    attribute it refines, after substitution of type arguments specified 
                    in the <literal>extends</literal> or <literal>satisfies</literal> clause
                    of the class, if the attribute it refines is <literal>variable</literal>, 
                    and</para>
                </listitem>
                <listitem>
                    <para>is <literal>variable</literal>, if the attribute it refines is 
                    <literal>variable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the refined attribute must be visible to the attribute 
            annotated <literal>actual</literal>.</para>
        
            <para>If an attribute is annotated <literal>actual</literal>, it must 
            refine some attribute defined by a supertype, and the attribute it 
            refines must be either <literal>formal</literal>, <literal>default</literal>, 
            or <literal>definite</literal>.</para>
            
            <para>An attribute may not, directly or indirectly, refine two different
            attributes not themselves annotated <literal>actual</literal>.</para>
        
            <para>A non-<literal>variable</literal> attribute may be refined by a 
            <literal>variable</literal> attribute.</para>
            
            <comment><para>TODO: Is that really allowed? It could break the superclass.
            Should we say that you are allowed to do it when you implement an interface
            attribute, but not when you refine a superclass attribute?</para></comment>
            
            <para>Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance.</para>
            
            <programlisting>shared abstract class AbstractPi() {
    shared formal Float pi;
}</programlisting>

            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    shared actual Float pi { ... }
}</programlisting>
            
            <para>For <literal>formal</literal> attributes, a special shortcut form 
            of refinement is permitted. A subclass initializer may simply specify or 
            assign a value to the attribute declared by the superclass. No type 
            declaration or <literal>actual</literal> annotation is necessary.</para>
            
            <programlisting>class ConcretePi() 
        extends AbstractPi() {
    Float calculatePi() { ... }
    pi = calculatePi();
}</programlisting>

            <comment><para>TODO: Why not also allow this for <literal>default</literal>
            attributes and methods??</para></comment>
            
            <para>Toplevel attributes cannot be refined, and so toplevel attribute 
            evaluation and assignment is never polymorphic.</para>
            
        </section>
        
        <!--section id="getterandsettermethods">
            <title>Getter and setter methods</title>
            
            <para>For each attribute, one or two methods exist implicitly:</para>
            
            <itemizedlist>
                <listitem>
                    <para>a <emphasis>getter method</emphasis> with no parameters 
                    which returns the attribute type, and</para>
                </listitem>
                <listitem>
                    <para>a <literal>void</literal> <emphasis>setter method</emphasis> 
                    with a single parameter of the attribute type, if the attribute is 
                    <literal>variable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>These methods may be referred to using the <literal>get</literal> and 
            <literal>set</literal> keywords, for example:</para>
            
            <programlisting>String name = get person.name();</programlisting>
            <programlisting>set person.name(newName);</programlisting>
            
        
        </section-->
                
    </section>
        
    <section id="declarationmodifiers">
        <title>Declaration modifiers</title>
        
        <para>In Ceylon, all declaration modifiers are annotations.</para>
        
    <section id="compilerinstructions">
        <title>Summary of compiler instructions</title>
        
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>shared</literal> specifies that a 
                declaration is visible outside of the package or body in 
                which it occurs.</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated.</para>
            </listitem>
             <listitem>
                <para><literal>formal</literal> specifies that a member 
                does not specify an implementation and must therefore be 
                refined by every concrete subclass.</para>
            </listitem>
            <listitem>
                <para><literal>default</literal> specifies that a method, 
                attribute, or member class may be refined by subtypes.</para>
            </listitem>
            <listitem>
                <para><literal>actual</literal> indicates that a method,
                attribute, or member type refines a method, attribute, 
                or member type defined by a supertype.</para>
            </listitem>
            <listitem>
                <para><literal>variable</literal> specifies that an attribute
                or local may be assigned.<!--, or that an interface or class has 
                assignable attributes.--></para>
            </listitem>
            <listitem>
                <para><literal>extension</literal> specifies that a method or
                attribute getter is a converter, or that a class is a decorator.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated. It accepts an optional
                <literal>String</literal> argument. The compiler produces a
                warning when compiling code that depends upon a deprecated
                program element.</para>
            </listitem>
            <listitem>
                <para><literal>definite</literal> specifies that a method or
                attribute must be refined by every concrete subclass. 
                <emphasis>(Note that <literal>definite</literal> is a proposed 
                feature for a future version of the language.)</emphasis></para>
            </listitem>
            <!-- 
            <listitem>
                <para><literal>final</literal> specifies that a class may not 
                be extended.</para>
            </listitem>
             -->
        </itemizedlist>
        
        <para>The following annotation is a hint to the compiler that lets 
        the compiler optimize compiled bytecode for non-64 bit architectures:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>small</literal> specifies that a value of type
                <literal>Natural</literal>, <literal>Integer</literal> or
                <literal>Float</literal> contains 32-bit values.</para>
            </listitem>
        </itemizedlist>
        
        <para>By default, <literal>Natural</literal>, <literal>Integer</literal>
        and <literal>Float</literal> are assumed to represent 64-bit values.</para>
        
        <!--
        <para>The annotation names in this section are treated as keywords by 
        the Ceylon compiler. This is a performance optimization to minimize 
        the need for lookahead in the parser.</para>
        -->
        
        <comment><para>TODO: should we have <literal>final</literal> to specify 
        that a class may not be extended?</para></comment>
        
        <comment><para>TODO: should we make <literal>actual</literal> a keyword, 
        to save the effort of redeclaring the attribute type or method return type?</para></comment>
        
        <comment><para>TODO: how hard would it be to add a <literal>recursive</literal>
        annotation to force the compiler to optimize a tail-recursive method or
        getter?</para></comment>
        
    </section>
       
       <!--
       <para>The following annotations are important to the Ceylon SDK.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>id</literal> specifies that an attribute should
                be tested by the <literal>equals()</literal> method, and included
                in the <literal>hash</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>transient</literal> specifies that an attribute 
                is not included in the serialized form of the object.</para>
            </listitem>
            <listitem>
                <para><literal>read</literal> and <literal>write</literal>
                indicate methods or attributes that are protected from multithreaded
                access using a reentrant read/write lock with deadlock detection.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method or
                attribute getter is executed at most once, and the resulting 
                value is cached.</para>
            </listitem>
        </itemizedlist>
        -->
    
    <section id="refinement">
        <title>Refinement modifiers</title>
        
        <para>A declaration may not have more than one of the following annotations: 
        <literal>formal</literal>, <literal>default</literal>, 
        <literal>definite</literal>.</para>
        
        <para>If a declaration is annotated <literal>formal</literal>, 
        <literal>default</literal>, <literal>definite</literal>, or <literal>actual</literal>
        then it must also be annotated <literal>shared</literal>.</para>
        
    </section>
    
    <section id="visibility">
        <title>Visibility and name resolution</title>
        
        <para>Classes, interfaces, methods, attributes, locals, parameters and type 
        parameters have names. Occurrence of a name in code implies a hard dependency 
        from the code in which the name occurs to the schema of the named declaration. 
        We say that a class, interface, method, attribute, parameter or type parameter 
        is <emphasis>visible</emphasis> to a certain program element if its name may 
        occur in the code that defines that program element.</para>
                
        <para>The visibility of a declaration depends upon where it occurs, and upon 
        whether it is annotated <literal>shared</literal>. A toplevel or member 
        declaration may be annotated <literal>shared</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>If a toplevel declaration is annotated <literal>shared</literal>, 
                it is visible wherever the package that contains it is visible.
                Otherwise, a toplevel declaration is visible only to code in the 
                package containing its compilation unit.</para>
            </listitem>
            <listitem>
                <para>If a member declaration is annotated <literal>shared</literal>, 
                it is visible wherever the class or interface that contains it is 
                visible. Otherwise, a declaration that occurs directly inside a class 
                or interface body is visible only inside the class or interface 
                declaration.</para>
            </listitem>
        </itemizedlist>
        
        <para>A parameter, type parameter, or declaration that occurs directly inside
        a block (the body of a method, attribute getter or attribute setter) may not 
        be annotated <literal>shared</literal>.</para>
        
        <itemizedlist>
            <listitem>
                <para>A parameter or type parameter is visible only inside the 
                declaration to which it belongs.</para> 
            </listitem>
            <listitem>
                <para>A declaration that occurs directly inside a block is visible 
                only inside the block.</para>
            </listitem>
        </itemizedlist>
        
        <para>A declaration not annotated <literal>shared</literal> is called a 
        <emphasis>block local</emphasis> declaration.</para>
        
        <comment><para>TODO: Should we allow you to limit the effect of the 
        <literal>shared</literal> annotation by specifying a containing program 
        element or package? Program element is easy, since we already have a
        typesafe syntax for referring to a method or type: 
        <literal>shared(ContainingClass)</literal>. Package is a bit tricker.
        Of course we could use a single-quoted literal, 
        <literal>shared('org.example.containing.package')</literal>, but perhaps 
        this would justify introducing a literal package name syntax:
        <literal>shared(@org.example.containing.package)</literal>.</para>
        </comment>
        
    </section>
    
    <section id="extensions">
        <title>Extensions</title>
        
        <para>An extension allows values of one type to be transparently converted to 
        values of another type. Extensions are declared by annotating a method, attribute 
        or class <literal>extension</literal>. An extension must be:</para>
        
        <itemizedlist>
            <listitem>
                <para>a toplevel method with exactly one parameter named
                <literal>this</literal>,</para>
            </listitem>
            <listitem>
                <para>a toplevel class with exactly one initialization parameter named
                <literal>this</literal>,</para>
            </listitem>
            <listitem>
                <para>a member method with no parameters,</para>
            </listitem>
            <listitem>
                <para>a member class with no initializer parameters, or</para>
            </listitem>
            <listitem>
                <para>a member attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>An extension must not be annotated <literal>formal</literal> or 
        <literal>abstract</literal>.</para>
        
        <para>An toplevel extension method is called a <emphasis>converter</emphasis>. 
        An toplevel extension class is called a <emphasis>decorator</emphasis>.</para>
                
        
        <programlisting>shared extension Log objectToLog(Object this) {
    return this.log;
}</programlisting>
        
        <programlisting>shared class Person(User user) {
    ...
    shared extension User user = user;
    ...
}</programlisting>

        <programlisting>shared extension class SequenceUtils&lt;N&gt;(N[] this) 
        given N extends Number, Comparable&lt;N&gt; {
    
    shared N[] positiveElements() {
        return this.elements() where (N n) (n&gt;0)
    }
    
    shared N[] elementsLessThan(N limit) {
        return this.elements() where (N n) (n&lt;limit)
    }
    
    ...   
}</programlisting>
        
        <programlisting>shared extension homogeneous&lt;T&gt;(Type&lt;T[]&gt; this)(Natural size, T value) {
    OpenList&lt;T&gt; result = none;
    for (Natural i in 0..size-1) {
        result.append(value);
    }
    return result
}</programlisting>
        
        <para>Extensions apply to a certain <emphasis>extended type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for toplevel extension methods, the extended type is the 
                declared type of the parameter,</para>
            </listitem>
            <listitem>
                <para>for toplevel extension classes, the extended type is the 
                declared type of the initialization parameter,</para>
            </listitem>
            <listitem>
                <para>for member extension methods, the extended type is the type 
                that declares the extension method,</para>
            </listitem>
            <listitem>
                <para>for member extension classes, the extended type is the type 
                that contains the member class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the extended type is the type that 
                declares the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>Extensions define an <emphasis>introduced type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for extension methods, the introduced type is the declared
                return type of the method,</para>
            </listitem>
            <listitem>
                <para>for extension classes, the introduced type is the class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the introduced type is the declared
                type of the attribute.</para>
            </listitem>
        </itemizedlist>
        <!--
        <para>The introduced type may not be a <literal>variable</literal> type.</para>
        -->
        <!-- 
        <comment><para>Note: I actually much prefer the readability of 
        <literal>User personToUser(extends Person person)</literal> and
        <literal>SequenceUtils&lt;T&gt;(extends T[] collection)</literal>, 
        but this doesn't work for attributes and member methods.</para></comment>
        -->
        
        <para>We say that a converter or decorator is <emphasis>enabled</emphasis> in 
        a compilation unit if the toplevel class or toplevel method is imported by that 
        compilation unit, and the <literal>import</literal> statement is annotated 
        <literal>implicit</literal>. If the <literal>import</literal> statement is not 
        annotated <literal>implicit</literal>, the declaration is imported normally but 
        the extension is not enabled in the compilation unit.</para>
        
        <programlisting>import org.domain.app.extensions { implicit objectToLog }
import org.domain.utils { implicit SequenceUtils, implicit homogeneous }</programlisting>

        <para>A wildcard <literal>.*</literal>-style import may not be used to import 
        an extension.</para>
        
        <para>An extension attribute, member class, or member method is enabled in every 
        compilation unit.</para>
        
        <para>A type <literal>X</literal> is <emphasis>extendable</emphasis> to a type
        <literal>Y</literal> in a compilation unit if there exists exactly one possible
        sequence of enabled extensions 
        <literal>E0(T0) satisfies U0, E1(T1) satisfies U1, ... En(tn) satisfies Un</literal>, 
        such that:</para> 
        
        <itemizedlist>
            <listitem>
                <para>the extensions <literal>E0, E1, ... En</literal> are distinct,</para>
            </listitem>
            <listitem>
                <para>the introduced type <literal>Un</literal> of the last extension 
                <literal>En</literal> is a subtype of <literal>Y</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>X</literal> is a subtype of <literal>T0</literal>, the 
                extended type of the first extension <literal>E0</literal>, and is not
                a subtype of <literal>U0</literal>, its introduced type,</para>
            </listitem>
            <listitem>
                <para>for <literal>0&lt;=i&lt;n</literal>, the introduced type 
                <literal>Ui</literal> of the <literal>i</literal>th extension 
                <literal>Ei</literal> is a subtype of <literal>Ti+1</literal>, the 
                extended type of the <literal>i+1</literal>th extension 
                <literal>Ei+1</literal>, and is not a subtype of <literal>Ui+1</literal>, 
                its introduced type.</para>
            </listitem>
        </itemizedlist>
        
        <para>If a type <literal>X</literal> is extendable to a type <literal>Y</literal> 
        in a compilation unit, then <literal>X</literal> is assignable to <literal>Y</literal> 
        in that compilation unit. The compiler automatically introduces a chain of extension 
        invocations where necessary, to produce an instance of <literal>Y</literal> from an
        instance of <literal>X</literal>.</para>
        
        <para>Where an expression of type <literal>X</literal> is assigned to a program 
        element of type <literal>Y</literal> to which <literal>X</literal> is extendable, 
        the extension sequence from <literal>X</literal> to <literal>Y</literal> is 
        automatically introduced by the compiler.</para>
        
        <!-- 
        <itemizedlist>
            <listitem>
                <para>if <literal>X</literal> is a subtype of the type of the program 
                element, the extension sequence is not introduced, but otherwise</para>
            </listitem>
            <listitem>
                <para>if <literal>Y</literal> is a subtype of the type of the program 
                element, but <literal>X</literal> is not, the extension sequence
                <emphasis>is</emphasis> introduced.</para>
            </listitem>
        </itemizedlist>
        -->
        
        <para>Where a member reference is applied to an expression of type <literal>X</literal>, 
        an extension sequence may or may not be introduced:</para>
        
        <itemizedlist>
            <listitem>
                <para>if <literal>X</literal> has a member to which the reference is 
                resolveable, and if for every type <literal>Y</literal> to which <literal>X</literal> 
                is extendable that also has a member to which the reference is resolveable,
                the member of <literal>X</literal> and the member of <literal>Y</literal>
                both refine a member of a common supertype, then no extension sequence is 
                introduced, but</para>
            </listitem>
            <listitem>
                <para>if <literal>X</literal> does not have a member to which the reference 
                is resolveable, and if there exists exactly one type <literal>Y</literal> 
                to which <literal>X</literal> is extendable that has a member to which the 
                reference is resolveable, the extension sequence from <literal>X</literal> 
                to <literal>Y</literal> <emphasis>is</emphasis> introduced.</para>
            </listitem>
        </itemizedlist>
        
        <para>Otherwise, the member reference is ambiguous and results in a compiler error.</para>
        
        <programlisting>import org.mydomain.myproject.extensions { implicit objectToLog }
...
Person person = ...;
User user = person;
info("person is a User and this is a Log!");</programlisting>
        
        <!--
        <para>Is equivalent to the following Java code:</para>
        
        <programlisting>Person person = ...;
User user = personToUser(person);</programlisting>
        -->
        
        <programlisting>import org.domain.utils { implicit SequenceUtils }
...
Integer[] zeroToOneHundred = 0..100;
Integer[] oneToNine = zeroToOneHundred.positiveElements().elementsLessThan(10);</programlisting>
        
        <!--
        <para>Is equivalent to this Java code:</para>
    
        <programlisting>Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = new SequenceUtils(collection).nonZeroElements();</programlisting>
        -->
        
        <comment><para>TODO: You can also introduce <literal>Callable</literal> to a type,
        in which case there is no member reference, just an argument list.</para></comment>
        
        <programlisting>import org.domain.utils { implicit homogeneous }
...
Float[] tenZeroes = Sequence(10,0.0);</programlisting>
        
        <!-- 
        <para>An introduced type may result in an ambiguity:</para>
        
        <itemizedlist>
            <listitem>
                <para>the introduced type may have a member type with the same name 
                as a member type of the extended type, or of some other introduced 
                type, and the two member types may have non-distinct erased signatures,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have a method with the same name as a 
                method of the extended type, or of some other introduced type, and 
                the two methods may have non-distinct erased signatures,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have an attribute with the same name 
                as an attribute or method of the extended type, or of some other 
                introduced type,</para>
            </listitem>
            <listitem>
                <para>the introduced type may have a method with the same name as 
                an attribute of the extended type, or of some other introduced type.</para>
            </listitem>
        </itemizedlist>
        
        <para>In this case, the member type, method or attribute may not be called. 
        Any invocation or evaluation of the member results in a compiler error.</para>
        -->
         
        <para>When an introduced extension sequence is executed, for each extension
        in the sequence:</para>
        
        <itemizedlist>
            <listitem>
                <para>First, the instance of the extended type is inspected to determine
                if the runtime type is a subtype of the introduced type. If so, the
                instance is cast to the introduced type.</para>
            </listitem>
            <listitem>
                <para>Otherwise, the extension is invoked to produce an instance of the 
                introduced type that will receive the invocation or evaluation.</para>
            </listitem>
        </itemizedlist>
        
        <para>It's even possible to define an extension to a metatype:</para>
        
        <programlisting>shared extension class StringType(Type&lt;String&gt; this) {
    shared String concat(String a, String b) { 
        return a + " " + b 
    }
}</programlisting>

        <para>Resulting in a syntax very much like a Java-style "static" invocation.</para>

        <programlisting>log.info(String.concat(a, b));</programlisting>
        
        <!--
        <comment><para>TODO: extensions are nice, and quite powerful, but they aren't enough to
        implement an embedded query language like in JPA. Dynamic languages let you implement a
        method to respond to an unknown member invoked at runtime. Java 6 lets you do a similar
        thing at compile time using a processor (a compiler plugin). I think we can have the best
        of both worlds and let you write an extension method that returns a set of members to be
        introduced to the extended type.</para></comment>
        -->
        
    </section>
    
    <section id="annotationconstraints">
        <title>Annotation constraints</title>
        
        <para>The following meta-annotations provide information to the compiler about the 
        annotations upon which they appear. They are applied to a toplevel method declaration 
        that defines an annotation.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>inherited</literal> specifies that the annotation is automatically 
                inherited by subtypes.</para>
            </listitem>
            <listitem>
                <para><literal>annotation</literal> specifies constraints upon the occurence of 
                an annotation. By default, an annotation may appear multiple times, but may not
                occur on any kind of program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>The meta-annotation <literal>annotation</literal> accepts the following parameters.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>occurs</literal> specifies that the annotation may occur at 
                most once in a certain scope. Its accepts one argument of type
                <literal>Occurrence</literal>: <literal>onceEachElement</literal>, 
                <literal>onceEachType</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>of</literal> specifies the kinds of program element 
                at which the annotation occurs. Its accepts one or more arguments of type
                <literal>Element</literal>: 
                <literal>classes</literal>, <literal>interfaces</literal>,
                <literal>aliases</literal>, <literal>objects</literal>, 
                <literal>methods</literal>, <literal>attributes</literal>, 
                <literal>parameters</literal>, <literal>any</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>withType</literal> specifies that the annotation may only 
                be applied to types that are assignable to the specified type, to
                attributes or parameters of the specified type, or to methods with the
                specified return type.</para>
            </listitem>
            <listitem>
                <para><literal>withParameterTypes</literal> specifies that the annotation 
                may only be applied to methods with the specified parameter types.</para>
            </listitem>
            <listitem>
                <para><literal>withAnnotation</literal> specifies that the annotation may 
                only be applied to program elements at which the specified annotation occurs.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>shared annotation { 
    of = classes; 
    occurs = onceEachType; 
}
Entity entity(LockMode lockMode) { 
    return Entity(lockMode) 
}</programlisting>

        <programlisting>shared annotation { 
    of = { attributes, parameters }; 
    withType = String; 
    occurs = onceEachElement; 
}
PatternValidator pattern(Regex regex) { 
    return PatternValidator(regex)
}</programlisting>
            
    </section>
    
    <section id="documentation">
        <title>Documentation</title>
    
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the description of a 
                program element.</para>
            </listitem>
            <listitem>
                <para><literal>by</literal> specifies the authors of a program 
                element.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <literal>String</literal> arguments to the <literal>deprecated</literal>, 
        <literal>doc</literal>, <literal>throws</literal> and <literal>by</literal> 
        annotations are parsed by the documentation compiler as Seam Text, a 
        simple ANTLR-based wiki text format.</para>
        
        <para>These annotations are defined by the package <literal>doc</literal>:</para>
        
        <programlisting>inherited annotation { of=any; occurs = onceEachElement; }
shared Description doc(String description) {
    return Description(description.normalize())
}</programlisting>
    
        <programlisting>annotation { of=any; occurs = onceEachElement; }
shared Author[] by(String... authors) {
    return from (String author in authors) 
                select Author(author.normalize())
}</programlisting>
    
        <programlisting>annotation { of=any; }
shared RelatedElement see(ProgramElement pe) {
    return Related(pe)
}</programlisting>
    
        <programlisting>annotation { of=any; }
shared RelatedElement see(ProgramElement pe -> String description) {
    return Related(pe, description.normalize())
}</programlisting>
    
        <programlisting>annotation { of={classes, methods, attributes}; }
shared Related throws(Type&lt;Exception&gt; type) {
    return ThrownException(type)
}</programlisting>
        
        <programlisting>shared ThrownException throws(Type&lt;Exception&gt; type -> String description) {
    return ThrownException(type, description.normalize())
}</programlisting>

        <comment><para>TODO: Should the documentation annotations be erased by 
        the compiler? Perhaps there should be a compiler switch.</para></comment>
        
     </section>
        
     </section>

</chapter>