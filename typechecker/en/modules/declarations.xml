<chapter id="declarations">
    <title>Declarations</title>
    
    <para>All classes, interfaces, methods, attributes, locals, decorators and 
    converters must be declared.</para>
    
    <section id="generaldeclarations">
        <title>General declaration syntax</title>
        
        <para>All declarations follow a general pattern.</para> 
      
    <section>
	    <title>Abstract declaration</title>
	    
	    <para>Declarations conform to the following general schema:</para>
	    
	    <programlisting>Annotation* 
keyword? Type? Identifier TypeParams? FormalParams? 
Supertype?
Interfaces? 
TypeConstraints? 
Declaration?</programlisting>

    </section>
    
    <section>
    <title>Annotation list</title>

        <para>Declarations may be preceded by a list of annotations. An annotation is just
        an instantiation of a class.</para>
    
	    <programlisting>Annotation := "@" Instantiation | TypeName Literal?</programlisting>
	    
	    <para>For an annotation with no constructor parameters, or with just one string, 
	    type, member, integer, float or regex literal constructor parameter, the 
	    <literal>@</literal> and parentheses may be omitted.</para>
	    
	    <para>For example:</para>
	    
	    <programlisting>doc "The user login action"
author "Gavin King"
@scope(session) @action { description="Log In"; url="/login" }
public deprecated</programlisting>
    
    </section>
    
    <section>
	    <title>Formal parameter list</title>
	
	    <para>Method and class declarations may declare formal parameters, including
	    optional parameters and a varargs parameter.</para>
	    
	    <programlisting>FormalParams := 
"("
FormalParam ("," FormalParam)* ("," OptionalParam)* ("," VarargsParam)? | 
OptionalParam ("," OptionalParam)* ("," VarargsParam)? | 
VarargsParam?
")"</programlisting>

	    <programlisting>FormalParam := Variable | EntryVariablePair | RangeVariablePair</programlisting>
	    
	    <para>Each parameter is declared using with a type and name and may have annotations.</para>
	    
	    <programlisting>Variable := Annotation* Type Identifier</programlisting>
	        
        <para>Optional parameters specify a default value.</para>
	
	    <programlisting>OptionalParam := FormalParam Initializer</programlisting>
	    
	    <programlisting>Initializer := "=" Expression</programlisting>
	    
	    <para>Varargs parameters accept multiple values or values of type <literal>List</literal>.</para>
	    
	    <programlisting>VarargsParam := Annotation* Type "..." Identifier</programlisting>
	    
	    <para>Parameters of type <literal>Entry</literal> or <literal>Range</literal> 
	    may be specified as a pair of variables.</para>
	    
	    <programlisting>EntryVariablePair := Annotation* Type Identifier "->" Type Identifier</programlisting>

	    <programlisting>RangeVariablePair := Annotation* Type Identifier ".." Identifier</programlisting>
	    
	    <para>For example:</para>
	    
	    <programlisting>(Product product, Integer quantity=1)</programlisting>
	    
	    <programlisting>(Name name, optional Organization org=null, Address... addresses)</programlisting>
	    
	    <programlisting>(Key key -> Value value)</programlisting>
	    
	    <para>A variable pair declaration of form <literal>U u -> V v</literal> results in a single 
	    parameter of type <literal>Entry&lt;U,V&gt;</literal>.</para>
	    
	    <programlisting>(Float value, Integer min...max)</programlisting>
    
	    <para>A variable pair declaration of form <literal>T x .. y</literal> results in a single 
	    parameter of type <literal>Range&lt;T&gt;</literal>.</para>
	    
    </section>
    
    <section>
	    <title>Type declaration</title>
	
	    <para>Method, attribute and converter declarations must declare a type.</para>
	    
	    <programlisting>Type := RegularType | FunctorType</programlisting>
	    
	    <para>Most types are classes or interfaces:</para>
	    
	    <programlisting>RegularType := TypeName TypeParams?</programlisting>
	    
	    <programlisting>TypeName := Identifier (DOT Identifier)*</programlisting>
	    
	    <para>Method, class, interface, decorator and converter declarations may declare 
	    generic type parameters.</para>
	    
	    <programlisting>TypeParams := "&lt;" Type ("," Type)* "&gt;"</programlisting>
	
	    <para>For example:</para>
	    
	    <programlisting>lang.collections.Map&lt;Key, List&lt;Item&gt;&gt;</programlisting>
	</section>
	
    <section>
	    <title>Functor type declaration</title>
	
	    <para>There are also functor types:</para>
	    
	    <programlisting>FunctorType := FunctorParams ("produces" Annotation* Type | "void")</programlisting>
	    
        <programlisting>FunctorParams := "(" ( FormalParam ("," FormalParam)* )? ")"</programlisting>
        
	    <para>For example:</para>
	    
	    <programlisting>(X x,X y) produces Comparison</programlisting>
	    <programlisting>(Payment payment) produces Boolean</programlisting>
	    <programlisting>(Y element) void</programlisting>
	    <programlisting>() produces optional Object</programlisting>
	    <programlisting>(optional Y object, Factory&lt;Y&gt; factory) produces Y</programlisting>
	    
	    <para>The parameter names in a functor type declaration do not affect assignability
	    of the functor type. They are used when the functor is invoked using named parameters.</para>
	    
	    <para>TODO: is <literal>F&lt;(X x,X y),Comparison&gt;</literal> a better syntax? Or
	    how about <literal>Comparison functor(X x,X y)</literal>?</para>
    
    </section>

    <section>
	    <title>Extended class</title>
	
	    <para>Classes may extend other classes using the <literal>extends</literal> clause.</para>
	    
	    <programlisting>Supertype := "extends" Instantiation</programlisting>
	
	    <para>For example:</para>
	    
	    <programlisting>extends Person(name, org)</programlisting>
    
    </section>
    
    <section>
	    <title>Implemented interfaces</title>
	
	    <para>Classes, interfaces and decorators may satisfy implement or extend interfaces, 
	    using the <literal>satisfies</literal> clause.</para>
	    
	    <programlisting>Interfaces = "satisfies" Type ("," Type)*</programlisting>
	
	    <para>For example:</para>
	    
	    <programlisting>satisfies Sequence&lt;T&gt;, Collection&lt;T&gt;</programlisting>
    
    </section>

    <section>
    <title>Generic type constraint list</title>

	    <para>Method, class, interface, decorator and converter declarations which declare 
	    generic type parameters may declare constraints upon the type parameters using the
	    <literal>where</literal> clause.</para>
	    
	    <programlisting>TypeConstraints = "where" TypeConstraint (AMPERSAND TypeConstraint)*</programlisting>
	
	    <programlisting>TypeConstraint := Ident ( ("&gt;="|"&lt;=") (Type|Ident) | FormalParams ) </programlisting>
	    
	    <para>There are three kinds of type constraints:</para>
	    
	    <itemizedlist>
	        <listitem>
	            <para>upper bounds,</para>
	        </listitem>
	        <listitem>
	            <para>lower bounds, and</para>
	        </listitem>
	        <listitem>
	            <para>initialization parameter specifications.</para>
	        </listitem>
	    </itemizedlist>
	    
	    <para>For example:</para>
	    
	    <programlisting>where X >= Number&lt;X&gt; &amp; Y >= Comparable&lt;Y&gt; &amp; Y(Integer count)</programlisting>
    
    </section>
    
    <!--
    <section>
        <title>Declaration examples</title>
        
    <para>For example:</para>
    
    <programlisting>Comparable&lt;Person&gt; Person person = Person(name);</programlisting>
    
    <programlisting>public entity 
class Customer(Name name, optional Organization org = null) 
    extends Person(name, org) 
{
   ... 
}</programlisting>

    <programlisting>public
class HashMap&lt;T&gt;(Iterable&lt;Entry&lt;T&gt;&gt; entries = none)
    extends AbstractCollection&lt;Entry&lt;T&gt;&gt;(entries)
    satisfies Map&lt;T&gt; 
    where T >= Comparable 
{ 
    ... 
}</programlisting>
    
    <programlisting>public interface List&lt;T&gt;
    satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; 
{
    ...
}</programlisting>

    <programlisting>Integer count = 0;</programlisting>
    
    <programlisting>protected String firstName;</programlisting>
    
    <programlisting>public Boolean login() { ... }</programlisting>
    
    <programlisting>public 
String join(Iterable&lt;String&gt; strings, 
            String delimiter = ", ") 
{ 
   ... 
}</programlisting>
    
    <programlisting>public Boolean functor Order&lt;T&gt;(T x, T y);</programlisting>

    <programlisting>public decorator ComparablePerson(Person person) 
    satisfies Comparable&lt;Person&gt; 
{
   ... 
}</programlisting>
               
    <programlisting>public Float converter IntegerToFloat(Integer int) 
{
   return Float(int);
}</programlisting>
    
    <para>Thus, the syntax of Ceylon declarations is more regular than Java or C#.</para>
    
    </section>
    -->
    
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A class is a stateful, instantiable type. Class are declared according to 
        the following:</para>
        
        <programlisting>Annotation*
"class" Identifier TypeParams? FormalParams?
Supertype?
Interfaces?
TypeConstraints?
"{" InstanceEnumeration? Statement* "}"</programlisting>

        <section>
             <title>Class inheritance</title>
        
        <para>
        A class may extend another class, and implement any number of interfaces.
        For example:
        </para>
        
        <programlisting>public mutable entity
class Customer(Name name, optional Organization org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>
        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt;, Identifier {
    ... 
}</programlisting>
        
        <para>
        The types listed after the <literal>satisfies</literal> keyword are the implemented
        interfaces. The type specified after the <literal>extends</literal> keyword is a 
        superclass. The semantics of class inheritance are exactly the same as Java, and the 
        above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>@entity public class Customer 
        extends Person {
    public Customer(Name name) { this(name, null); }
    public Customer(Name name, Organization org) { super(name, org); }
    ... 
}</programlisting>
        
        <programlisting>class Token 
        extends Datetime 
        implements Comparable&lt;Token&gt;, Identifier {
    public Token() { super(); }
    ... 
}</programlisting>

        </section>
       
        <section>
            <title>Class instantiation</title>
        
        <para>
        Ceylon classes do not support a Java-like constructor declaration syntax. However, 
        Ceylon supports <emphasis>class initialization parameters</emphasis>. A class 
        initialization parameter may be used anywhere in the class body.
        </para>
        
        <para>This declaration:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock = lock;
}</programlisting>
        
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private final ReadAttribute&lt;Lock&gt; lock;
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) {
        this.lock = new SimpleReadAttribute&lt;Lock&gt;(lock); 
    }
    
}</programlisting>

        <para>This declaration:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock { return lock };
}</programlisting>
        
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private Lock _lock;
        
    private final ReadAttribute&lt;Lock&gt; lock = new ReadAttribute&lt;Lock&gt;() {
        @Override public Lock get() { return _lock; }
    }; 
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) { 
        _lock = lock; 
    }
    
}</programlisting>

        <para>Class initialization parameters are optional. The following class:</para>
        
        <programlisting>public mutable class Point {
    public mutable Exact x;
    public mutable Exact y;
}</programlisting>
        
        <para>Is equivalent to this Java class with a default constructor:</para>
        
        <programlisting>public class Point {
    private final Attribute&lt;Exact&gt; x = new SimpleAttribute&lt;Exact&gt;();
    public SimpleAttribute&lt;Exact&gt; x() { return x; }
    
    private final Attribute&lt;Exact&gt; y = new SimpleAttribute&lt;Exact&gt;();
    public SimpleAttribute&lt;Exact&gt; y() { return y; }
}</programlisting>
        
        <para>A subclass must pass values to each superclass initialization 
        parameter.</para>

        <programlisting>public class SpecialKey1()
        extends Key( new SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>public class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>

        <para>Which are equivalent to the Java:</para>
        
        <programlisting>public class SpecialKey1 
        extends Key {
    public SpecialKey1() { 
        super( SpecialLock() );
    }
    ... 
}</programlisting>

        <programlisting>public class SpecialKey2 
        extends Key {
    public SpecialKey2(Lock lock) { 
        super(lock);
    }
    ... 
}</programlisting>

        <para>The body of a class may contain arbitrary code, which is
        executed when the class is instantiated.</para>
        
        <programlisting>public mutable class DiagonalPoint(Exact position) 
        extends Point() {
        
    Exact displacement = position**2/2;
    Integer sign = if (position.negative) -1 else 1;
    
    x = sqrt(displacement) * sign;
    y = sqrt(displacement) * sign;
    
    assert "must have distance ${position} from origin": 
        x**2 + y**2 == position**2;
    
}</programlisting>
        
        <para>The compiler is permitted to optimize private attribute 
        declarations. So the above class is equivalent to:</para>
        
        <programlisting>public class DiagonalPoint extends Point {
        
    public DiagonalPoint(Exact position) {
        Exact displacement = position.exponentiate(2).divide(2);
        Integer sign = position.negative ? -1 : 1;
        
        x = sqrt(displacement).multiply(sign);
        y = sqrt(displacement).multiply(sign);
        assert x.exponentiate(2) + y.exponentiate(2) 
             == position.exponentiate(2) :
        "must have distance " + position + " from origin";
    }
    
}</programlisting>

        <para>TODO: should class initialization parameters be allowed to be
        declared <literal>mutable</literal>?</para>
        
        </section>

       <section>
            <title>Optional parameters</title>
            
        <para>
        When a class with an optional parameter is instantiated, and a value is not assigned to the
        optional parameter by the caller, the default value specified by the initializer is used.
        </para>
        
        <para>This class:</para>
        
        <programlisting>public class Counter(Integer initialCount=0) { ... }</programlisting>
        
        <para>Is equivalent to a class with three Java constructor declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    public Counter() {
        Counter(0);
    }
    
    public Counter(Integer initialCount) {
        ...;
    }
    
    public Counter(CounterParameters namedParameters) {
        Counter( namedParameters.initialCount );
    }

    public static class CounterParameters {
        private Integer initialCount=0;
        CounterParameters initialCount(Integer initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>

        <para>This named parameter call:</para>
        
        <programlisting>Counter { initialCount=10; }</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>new Counter ( new CounterParameters().initialCount(10) );</programlisting>

        </section>

        <section>
        <title>Instance enumeration</title>
        
        <para>A class may specify an enumerated list of instances:</para>
        
        <programlisting>InstanceEnumeration := "instances" Identifier ParamValues? ("," Identifier ParamValues?)* ("..." | ";")</programlisting>

        <para>The keyword <literal>instances</literal> is used to define a set of predefined
        instances.</para>
        
        <programlisting>public class DayOfWeek { instances mon, tues, wed, thurs, fri, sat, sun; }</programlisting>

        <programlisting>public class DayOfWeek(String name) {
    instances
        mon("Monday"), 
        tues("Tuesday"),
        wed("Wednesday"),
        thurs("Thursday"),
        fri("Friday"),
        sat("Saturday"),
        sun("Sunday");
       
    public String name = name;
    
}</programlisting>
        
        <para>
        A class with an <literal>instances</literal> declaration implicitly extends 
        <literal>lang.Selector</literal>, a subclass of <literal>java.lang.Enum</literal>. 
        The above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; { 
        
    public DayOfWeek mon = new DayOfWeek("mon", 0); 
    public DayOfWeek tues = new DayOfWeek("tues", 1);
    public DayOfWeek wed = new DayOfWeek("wed, 2");
    public DayOfWeek thurs = new DayOfWeek("thurs", 3);
    public DayOfWeek fri = new DayOfWeek("fri", 4);
    public DayOfWeek sat = new DayOfWeek("sat", 5);
    public DayOfWeek sun = new DayOfWeek("sun", 6);
    
    private DayOfWeek(String id, int ord) {
        super(id, ord);
    }
    
}</programlisting>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; {
        
    private final ReadAttribute&lt;String&gt; name;
       
    public DayOfWeek mon = new DayOfWeek("Monday", "mon", 0); 
    public DayOfWeek tues = new DayOfWeek("Tuesday", "tues", 1);
    public DayOfWeek wed = new DayOfWeek("Wednesday", "wed, 2");
    public DayOfWeek thurs = new DayOfWeek("Thursday", "thurs", 3);
    public DayOfWeek fri = new DayOfWeek("Friday", "fri", 4);
    public DayOfWeek sat = new DayOfWeek("Saturday", "sat", 5);
    public DayOfWeek sun = new DayOfWeek("Sunday", "sun", 6);
     
    private DayOfWeek(String name, String id, int ord)
    {
        super(id, ord);
        name = new SimpleReadAttribute(name);
    }
    
}</programlisting>

        </section>

        <!--
        <para>A class with an <literal>instances</literal> declaration may not extend
        a class with no <literal>instances</literal> declaration.</para>
        -->
        
    </section>
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An interface is a type which does not specify implementation. Interfaces may 
        not be directly instantiated. Interfaces are declared according to the following:</para>
        
        <programlisting>Annotation*
"interface" Identifier TypeParams?
Interfaces?
TypeConstraints? 
"{" ( MethodStub | AttributeStub )* "}"</programlisting>

        <para>For example:</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>

         <para>Which is equivalent to the following Java interface:</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>

        <para>TODO: Fantom and Scala let interfaces declare methods with implementation. This 
        is less needed in Ceylon because we have decorators. But it seems pretty harmless
        and useful.</para>
        
        <section>
            <title>Interface inheritance</title>
            
            <para>An interface may extend any number of other interfaces. For example:</para>
        
            <programlisting>public interface List&lt;T&gt;
        satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
        
            <para>
            The types listed after the <literal>satisfies</literal> keyword are the supertypes. All 
            supertypes of an interface must be interfaces. The semantics of interface inheritance 
            are exactly the same as Java, and the above declaration is equivalent to the following 
            Java declaration: 
            </para>
        
            <programlisting>public interface List&lt;T&gt; 
        extends Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>

        </section>
        
    </section>
    
    <!--  
    <section>
        <title>Constructors</title>
        
        <para>Constructors are declared according to the following:</para>
        
        <programlisting>Annotation* Identifier 
FormalParams
( ";" | ClosedBlock )</programlisting>

        <para>
        For example:
        </para>
        
        <programlisting>Public: User(String username, Person person);</programlisting>
        <programlisting>Public: Integer(String string): value = parse(string);</programlisting>
        <programlisting>Public: User(String u, Person p) { username = u; person = p; }</programlisting>
        
        <para>
        The semantics of constructor declarations are identical to Java.
        </para>
        
        <para>
        A constructor body may omit the braces if it consists of exactly one statement. 
        If there is no constructor body at all, the constructor assigns each parameter to
        the attribute with the same name.
        </para>
        
        <para>
        A Ceylon constructor invocation is equivalent to a Java constructor invocation.
        </para>
                
        <programlisting>@FormalParameterNames({"username", "person"}) 
public User(String username, Person person);</programlisting>

    </section>
    -->
    
    <section id="methods">
        <title>Methods</title>
        
        <para>A method is a callable block of code. Methods may have parameters and
        may return a value. Methods are declared according to the following:</para>
        
        <programlisting>Method :=
Annotation*
(Type | "void") Identifier TypeParams? FormalParams
TypeConstraints?
( ";" | Block )</programlisting>

        <para>For example:</para>
        
        <programlisting>public Integer add(Integer x, Integer y) {
    return x + y;
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token();
}</programlisting>

        <programlisting>public optional U get(optional V key);</programlisting>
        
        <programlisting>public void print(Object... objects) {
    for (Object object in objects) log.info($object);
}</programlisting>

        <programlisting>public void addEntry(V key -> U value) { ... }</programlisting>
        
        <!--A method body may omit the braces if it consists of exactly one statement.-->
        
        <para>
        If there is no method body, and the method is not declared <literal>abstract</literal>, 
        the method throws <literal>UnsupportedMethodException</literal> when invoked.
        </para>
        
         <!--  
        <para>
        Ceylon methods
        may declare multiple types for any formal parameter and multiple return types. This
        indicates that the value passed or returned must implement or extend all the declared
        types.
        </para>
        -->
        
        <para>The Ceylon compiler preserves the names of method parameters.</para>
        
        <programlisting>@FormalParameterNames({"x", "y"}) 
public Integer add(Integer x, Integer y) { ... }</programlisting>

        <para>TODO: should we allow a method or attribute getter/setter to omit the braces
        if it consists of exactly one statement. (What about converters?)</para>

        <para>
        A Ceylon method invocation is equivalent to a Java method invocation. The semantics of 
        method declarations are identical to Java, except that Ceylon methods may declare optional 
        parameters. 
        </para>
        
       <section>
            <title>Optional parameters</title>
            
        <para>
        Methods with optional parameters may not be overloaded.
        </para>
        
        <para>
        When a method with an optional parameter is called, and a value is not assigned to the
        optional parameter by the caller, the default value specified by the initializer is used.
        </para>
        
        <para>This method:</para>
        
        <programlisting>public class Counter {
        
    package void init(Integer initialCount=0) {
        count=initialCount;
    }
    
    ...

}</programlisting>
        
        <para>Is equivalent to three Java method declarations and an inner class:</para>
        
        <programlisting>public class Counter {
        
    void init() {
        init(0);
    }
    
    void init(Integer initialCount) {
        count=initialCount;
    }
    
    void init(CounterInitParameters namedParameters) {
        init( namedParameters.initialCount );
    }

    static class CounterInitParameters {
        private Integer initialCount=0;
        CounterInitParameters initialCount(Integer initialCount) { 
            this.initialCount = initialCount;
            return this;
        }
    }
    
}</programlisting>

        <para>This named parameter call:</para>
        
        <programlisting>counter.init { initialCount=10; }</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>counter.init ( new CounterInitParameters().initialCount(10) );</programlisting>

        </section>
        
        <section>
            <title>Interface methods and abstract methods</title>
            
        <para>Methods declared by interfaces and methods marked <literal>abstract</literal> may 
        not specify a body:</para>
        
        <programlisting>MethodStub :=
Annotation*
(Type | "void") Identifier TypeParams? FormalParams
TypeConstraints? 
";"</programlisting>

        <para>Interface methods and abstract methods must be implemented by every 
        non-<literal>abstract</literal> class that implements the interface or
        subclasses the abstract class.</para>
        
        <para>Classes which declare methods marked <literal>abstract</literal> must also be
        declared <literal>abstract</literal>, and may not be instantiated.</para>
        
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to attribute definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a Java field).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived attribute
                is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived attribute
                is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be overridden by subclasses. If the attribute is not declared
        <literal>optional</literal>, it may not be overridden or implemented by an
        attribute declared <literal>optional</literal>.</para>
            
        <para>For example:</para>
        
        <programlisting>package mutable String firstName;</programlisting>
        
        <programlisting>mutable Integer count = 0;</programlisting>
        
        <programlisting>public String name { return join(firstName, lastName); }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
    
        <programlisting>public Float total {
    Float sum = 0.0;
    for (LineItem li in lineItems) 
        sum += li.amount;
    return sum;
}</programlisting>

        <para>
        An attribute declaration is equivalent to a Java method declaration together with 
        a Java field declaration, both of type <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal>, both with the same name as the attribute.
        </para>
        
        <para>
        The compiler is permitted to optimize private attributes to a simple Java field
        declaration or a local variable in a Java constructor. Private attributes may not
        be accessed via reflection.
        </para>
        
        <section>
            <title>Attributes with getter/setter code</title>
            
            <para>An attribute getter is declared as follows:</para>
            
            <programlisting>AttributeGetter := Annotation* Type Identifier Block</programlisting>

        <para>
        When getter code is specified, the Java field is initialized to an instance 
        of an anonymous inner subclass of <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal> that overrides the <literal>get()</literal> 
        method with the content of the getter block. For example:
        </para>
        
        <programlisting>public Float total { return items.totalPrice; }</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Float&gt; total = new ReadAttribute&lt;Float&gt;() {
    @Override public Float get() { return items.get().totalPrice; }
};
public ReadAttribute&lt;Float&gt; total() { return total; }</programlisting>

            <para>An attribute setter is declared as follows:</para>
            
            <programlisting>AttributeSetter := Annotation* "assign" Identifier Block</programlisting>

        <para>
        When setter code is specified, the Java field is initialized to an instance 
        of an anonymous inner subclass of <literal>lang.Attribute</literal> that 
        overrides the <literal>set()</literal> method with the content of the 
        setter block. For example:
        </para>
        
        <programlisting>public String name { return join(firstName, lastName); }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; name = new Attribute&lt;String&gt;() {
    @Override public String get() { return join(firstName, lastName); }
    @Override public void set(String name) { firstName = first(name); lastName = last(name); }
};
public Attribute&lt;String&gt; name() { return name; }</programlisting>

        <para>The attribute name specified by the setter must correspond to a 
        matching attribute getter.</para>
        
        <para>TODO: should we allow overloaded attribute setters, for example:</para>
        
        <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>

        </section>
        
        <section>
            <title>Simple attributes and locals</title>
            
        <para>Simple attribute defines state. Simple attributes are declared according to the 
        following:</para>
        
        <programlisting>SimpleAttribute := Annotation* Type Identifier Initializer? ";"</programlisting>

        <para>Formal parameters of classes, methods, decorators and converters are also considered
        to be simple attributes.</para>

        <para>A local is really just a special case of a simple attribute declaration, but one that 
        is optimized by the compiler.</para> 
        
        <itemizedlist>
            <listitem>
                <para>An attribute declared inside the body of a class represents a local if it 
                is not used inside a method, attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>An attribute declared inside the body of a method represents a local.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a class or decorator represents a local if it is not 
                used inside a method, attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a method or converter represents a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>The semantics of locals are identical to Java local variables.</para>
        
        <para>For a simple attribute that is not a local, the Java field is initialized to an 
        instance of <literal>lang.SimpleAttribute</literal> or 
        <literal>lang.SimpleReadAttribute</literal>. For example:</para> 
        
        <programlisting>package mutable String firstName;</programlisting>

        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; firstName = new SimpleAttribute&lt;String&gt;();
Attribute&lt;String&gt; firstName() { return firstName; }</programlisting>

        <para>While:</para>
        
        <programlisting>mutable Integer count = 0;</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;Integer&gt; count = new SimpleAttribute&lt;Integer&gt;(0);
private Attribute&lt;Integer&gt; count() { return count; }</programlisting>

        <para>And:</para>
        
        <programlisting>public Integer max = 99;</programlisting>
        
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Integer&gt; max = new SimpleReadAttribute&lt;Integer&gt;(99);
public ReadAttribute&lt;Integer&gt; max() { return max; }</programlisting>

        <para>TODO: Should we generate getters and setters, just for interop with Java?</para>
        
        </section>
        
        <section>
            <title>Interface attributes and abstract attributes</title>
            
        <para>Attributes declared by interfaces and attributes marked <literal>abstract</literal> 
        may not specify an initalizer, getter or setter:</para>
        
        <programlisting>AttributeStub := Annotation* Type Identifier ";"</programlisting>
        
        <para>Interface attributes and abstract attributes must be implemented by every 
        non-<literal>abstract</literal> class that implements the interface or subclasses the 
        abstract class.</para>
        
        <para>Interface attributes and abstract attributes may be specified <literal>mutable</literal>, 
        in which case every subtype must also define the attribute to be mutable.</para>
        
        <para>Classes which declare methods marked <literal>abstract</literal> must also be declared 
        <literal>abstract</literal>, and may not be instantiated.</para>
        
        </section>
                
    </section>
    
    <!--  
    <section>
        <title>Selectors</title>
        
        <para>Selectors are declared according to the following:</para>
        
        <programlisting>Annotation* Type* 
"selector" Identifier
FormalParams?
"{" 
SelectorValue ("," SelectorValue)*
( ";" ( Attribute | Method )* )? 
"}"</programlisting>
        
        <para>Where:</para>
        
        <programlisting>SelectorValue := Identifier ( "(" ( Expression ("," Expression)* )? ")" )?</programlisting>
        
        <para>
        For example:
        </para>
        
        <programlisting>Public: 
selector DayOfWeek 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>

        <programlisting>Public: 
selector DayOfWeek(String name) 
{ 
    MON("Monday"), TUES("Tuesday"), ...
    
    Public Constant: String name = name;
     
}</programlisting>
        
        <programlisting>Public: 
Comparator&lt;String&gt; 
selector ComparisonOperation { 
    ... 
}</programlisting>
        
        <para>
        The types listed before the <literal>selector</literal> keyword are the supertypes.
        All supertypes of a selector must be interfaces. Any constructors must be private. The 
        semantics of selector declarations and selector interface implementation are exactly the 
        same as for Java <literal>enum</literal>s, except that a Ceylon selector implicitly 
        implements <literal>lang.Selector</literal>, and the above declarations are equivalent to 
        the following Java declarations: 
        </para>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{
         
    MON("Monday"), TUES("Tuesday"), ...
     
    private DayOfWeek(String name) { ... }
    
    ...
    
}</programlisting>
        <programlisting>public enum Comparison 
    implements Comparator&lt;String&gt;, Selector&lt;Comparison&gt; 
{ 
    ... 
}</programlisting>
        
        <para>TODO: let selectors have abstract methods that are overridden by the selector values!</para>
        
    </section>
    -->
    <!--  
    <section id="functors">
        <title>Functors</title>
        
        <para>A functor represents a typed block of code. Functors are declared according to 
        the following:</para>
        
        <programlisting>Annotation* ( Type | "void" ) 
"functor" Identifier TypeParams? 
FormalParams 
TypeConstraintList? 
";"</programlisting>

        <para>TODO: instead of having explicitly declared functor types like <literal>Order&lt;Person&gt;</literal>, 
        we can just provide built-in functor types. If we want more compact type names, we can 
        provide some kind of typedef.</para>

        <para>TODO: let's wait and see what Java 7 does with closures. It will be easier for
        developers to learn something that is aligned with what Java does.</para>
        
        <para>For example:</para>
        
        <programlisting>public Comparison functor Order&lt;T&gt;(T x, T y);</programlisting>
        
        <para>
        A functor declaration is equivalent to a Java abstract class declaration that extends
        <literal>lang.Functor</literal> with a single abstract method declaration. For the example
        above, the equivalent Java declaration is:
        </para>
        
        <programlisting>public abstract class Order&lt;T&gt; 
        extends Functor&lt;Comparison&gt; {
        
    public abstract Comparison call(T x, T y);
    
    protected Order(Object... locals) 
    { 
        super(locals); 
    }
    
}</programlisting>

        <section>
            <title>Functor literals</title>
            
        <para>Consider the following functor literal:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) { x &lt;=&gt; y }</programlisting>
        
        <para>Or:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) x &lt;=&gt; y;</programlisting>
        
        <para>These literals are equivalent to this Java code:</para>

        <programlisting>Order&lt;String&gt; order = new Order&lt;String&gt;() {
    public Comparison call(String x, String y) { 
        return Comparison.compare(x,y); 
    }
};</programlisting>
        
        <para>And this functor invocation:</para>
        
        <programlisting>Boolean result = order("Gavin", "Emmanuel");</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Boolean result = order.call("Gavin", "Emmanuel");</programlisting>
        
        </section>
        
    </section>
    -->
    
    <section id="decorators">
        <title>Decorators</title>
        
        <para>A decorator introduces methods and interfaces to a given type. Decorators are 
        declared according to the following:</para>
        
        <programlisting>Annotation*
"decorator" Identifier TypeParams? "(" FormalParam ")"
Interfaces?
TypeConstraintList? 
"{" ( Method | AttributeGetter | AttributeSetter )* "}"</programlisting>

        <para>Decorators may introduce interfaces and methods.</para>

        <section>
            <title>Introduced methods</title>
            
        <para>Methods declared by a decorator are called <emphasis>introduced methods</emphasis>.</para>
        
        <para>For example, this decorator:</para>
        
        <programlisting>public decorator CollectionUtils&lt;T&gt;(Collection&lt;T&gt; collection) {
    
    public Collection&lt;T&gt; nonZeroElements() {
        return collection.exclude(0); 
    }
    
    ...   
}</programlisting>
        
        <para>is equivalent to this Java declaration:</para>
        
        <programlisting>public final class CollectionUtils&lt;T&gt; 
        extends Collection {
        
    private final Collection&lt;T&gt; collection
    
    public CollectionUtils(Collection&lt;T&gt; collection) { 
        this.collection = collection; 
    }
    
    public Collection&lt;T&gt; nonZeroElements() { 
        return collection.exclude(0); 
    }
    
    ...
}</programlisting>

        <para>This introduced method call:</para>
        
        <programlisting>Collection&lt;Integer&gt; result = collection.nullElements();</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Collection&lt;Integer&gt; result = new CollectionUtils(collection).nullElements();</programlisting>
        
        <para>Introduced methods are only available in a source file that expicitly 
        <literal>import</literal>s the decorator.</para>
        
        <para>A decorator may not override a method defined by the decorated type. Methods defined 
        by the decorated type are delegated to the decorated instance. TODO: is this the right thing
        to say??</para>

        </section>
        
        <section>
            <title>Introduced types</title>
            
            <para>TODO: there are holes in the semantics of this stuff!</para>
            
        <para>Types appearing after the <literal>satisfies</literal> keyword must be interfaces, and
        are called the <emphasis>introduced types</emphasis>.</para>
        
        <para>This decorator declaration:</para>
        
        <programlisting>public decorator ComparableUser(User user) 
        satisfies Comparable&lt;User&gt; {
        
    public Comparison compare(User other) 
    {
        return user.username &lt;=&gt; other.username;
    }
    
}</programlisting>
        
        <para>is equivalent to this Java declaration:</para>
        
        <programlisting>public final class ComparableUser 
        extends User
        implements Comparable&lt;User&gt; {
        
    private final User user;
    
    public ComparableUser(User user) { 
        this.user = user; 
    }
    
    public Comparison compareTo(User other) { 
        return Comparison.compare(other.username, user.username);
    }
}</programlisting>

        </section>
                
    </section>
    
    <section id="typealiases">
       <title>Type aliases</title>
    
       <para>A type alias allows a type to be referred  to more compactly.</para>
       
       <programlisting>Annotation* "alias" Identifier TypeParams? Interfaces? TypeConstraints? ";"</programlisting>
       
       <para>A type alias may satisfy either:</para>
       
       <itemizedlist>
           <listitem><para>any number of interfaces and at most one class, or</para></listitem>
           <listitem><para>a single functor type.</para></listitem>
       </itemizedlist>
       
       <para>Any expression which is assignable to all the satisfied types is assignable 
       to the alias type.</para>
       
       <para>For example:</para>
       
       <programlisting>public alias People satisfies List&lt;Person&gt;;</programlisting>
       
       <programlisting>package alias ComparableCollection&lt;X&gt; satisfies Collection&lt;X&gt;, Comparable&lt;X&gt;;</programlisting>
       
       <programlisting>alias Compare&lt;T&gt; satisfies (T x,T y) produces Comparison;</programlisting>
    
    </section>
    
    <section id="converters">
        <title>Converters</title>
        
        <para>A converter allows immutable values of one type to be transparently converted to
        values of another type. Converters are declared according to the following:</para>
        
        <programlisting>Annotation*  
"converter" Type Identifier TypeParams? 
TypeConstraintList? 
"(" FormalParam ")" 
Block</programlisting>

        <para>TODO: would it be better to just let you annotate a static method <literal>converter:</literal>,
        instead of having a whole special declaration?</para>
            
        <para>For example:</para>
        
        <programlisting>public converter User PersonUser(Person person) { return person.user; }</programlisting>
        
        <para>The parameter type must be immutable.</para>

        <para>A converter declaration is equivalent to a Java class declaration. The example 
        above is equivalent to the following Java class:</para>
        
        <programlisting>public final class PersonUser 
        extends Converter&lt;Person, User&gt; {
    @Override User convert(Person person) 
    {
        return person.user; 
    }
}</programlisting>

        <para>The Ceylon compiler searches for an appropriate converter whenever a value is
        assigned to a non-assignable type. If exactly one converter for the types is found, 
        the compiler inserts a call to the converter. For example, this Ceylon assignment:</para>
        
        <programlisting>Person person = ...;
User user = person;</programlisting>

        <para>Is equivalent to the following Java code:</para>
        
        <programlisting>Person person = ...;
User user = new PersonUser().convert(person);</programlisting>

        <para>A conversion is only available in a source file that expicitly 
        <literal>import</literal>s the converter.</para>
        
    </section>
    
    <section id="declaration modifiers">
        <title>Declaration modifiers</title>
        
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>public</literal>, <literal>module</literal>,
                <literal>package</literal> determine the visibility of a 
                declaration (by default, the declaration is visible only
                inside the same compilation unit).</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated, or that a method or attribute of 
                an abstract class must be implemented by all subclasses.</para>
            </listitem>
            <listitem>
                <para><literal>static</literal> specifies that a method
                can be called without an instance of the type that defines
                the method.</para>
            </listitem>
            <listitem>
                <para><literal>mutable</literal> specifies that an attribute
                or local may be assigned, or that a class has assignable
                attributes.</para>
            </listitem>
            <listitem>
                <para><literal>optional</literal> specifies that a value may
                be null.</para>
            </listitem>
            <listitem>
                <para><literal>final</literal> indicates that a class may 
                not be extended, or that a method or attribute may not be 
                overridden.</para>
            </listitem>
            <listitem>
                <para><literal>override</literal> indicates that a method
                or attribute overrides a method or attribute defined by a 
                supertype.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method is 
                executed at most once, and the resulting value is cached.</para>
            </listitem>
            <listitem>
                <para><literal>assert</literal> indicates that a statement
                must evaluate to true when assertions are enabled, and is 
                not executed when assertions are disabled.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated.</para>
            </listitem>
            <listitem>
                <para><literal>volatile</literal> indicates a volatile
                simple attribute.</para>
            </listitem>
        </itemizedlist>
            
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the documentation for
                a program element.</para>
            </listitem>
            <listitem>
                <para><literal>author</literal> specifies the author of a 
                program element.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The string value of the <literal>doc</literal> and 
        <literal>author</literal> annotations is parsed by the documentation
        compiler as Seam Text, a simple ANTLR-based wiki text format.</para>
        
    </section>

</chapter>