<chapter id="declarations">
    <title>Declarations</title>
    
    <para>All classes, interfaces, methods, attributes and locals must be declared.</para>
    
    <section id="generaldeclarations">
        <title>General declaration syntax</title>
        
        <para>All declarations follow a general pattern.</para> 
      
    <section id="abstractdeclaration">
        <title>Abstract declaration</title>
        
        <para>Declarations conform to the following general schema:</para>
        
        <programlisting>Annotation* 
keyword? Type? (TypeName|MemberName) TypeParams? FormalParams*
Supertype?
Interfaces? 
TypeConstraints? 
Body?</programlisting>

        <para>The Ceylon compiler enforces identifier naming conventions. Types must
        be named with an initial uppercase. Members, parameters and locals must be 
        named with an initial lowercase or underscore.</para>
        
        <programlisting>PackageName := LIdentifier</programlisting>
        <programlisting>TypeName := UIdentifier</programlisting>
        <programlisting>MemberName := LIdentifier</programlisting>
        <programlisting>ParameterName := LIdentifier</programlisting>
        
   </section>
      
    <section id="topleveldeclaration">
        <title>Type declaration</title>
        
        <para>A type declaration declares a class, interface or type alias.</para>
        
        <programlisting>TypeDeclaration := Class | Interface | Alias</programlisting>
        
        <comment><para>TODO: Should we support toplevel static method declarations?</para></comment>

        <para>A compilation unit consists of a list of imported types, followed by
        one or more type declarations:</para>
        
        <programlisting>Import* TypeDeclaration+</programlisting>
        
        <programlisting>Import := "import" ImportElement ("." ImportElement)* ("." "*" | "alias" ImportElement)? ";"</programlisting>
        
        <programlisting>ImportElement := PackageName | TypeName | MemberName</programlisting>
        
        <para>All toplevel types with a visibility modifier less strict than
        <literal>private</literal> must have the same name as the compilation
        unit filename (after removing the file suffix <literal>.ceylon</literal>).</para>
        
     </section>
    
    <section id="annotationlist">
    <title>Annotation list</title>

        <para>Declarations may be preceded by a list of annotations.</para>
    
        <programlisting>Annotation := MemberName ( Arguments | Literal+ )?</programlisting>
        
        <para>Unlike Java, the name of an annotation may not be a qualified name.</para>
        
        <para>For an annotation with no arguments, or with only literal-valued arguments, 
        the parentheses around, and commas between, the positional arguments may be 
        omitted.</para>
        
        <programlisting>doc "The user login action"
throws #DatabaseException 
       "if database access fails"
by "Gavin King"
   "Andrew Haley"
see #LogoutAction.logout
scope(session) 
action { description="Log In"; url="/login"; }
public deprecated</programlisting>

        <para>An annotation is a static method invocation that occurs when the type
        is loaded by the virtual machine. The return value of the invocation is made 
        available via reflection.</para>
        
        <!--
        <comment>
        <para>TODO: to eliminate backtracking in the parser, we could do one of the
        following things:</para>
        <itemizedlist>
            <listitem>
                <para>require that member declarations with annotations be preceded
                by a <literal>def</literal> keyword,</para>
            </listitem>
            <listitem>
                <para>require that all member declarations be preceded by one of
                <literal>public/module/package/private</literal> or <literal>override</literal>,
                or</para>
            </listitem>
            <listitem>
                <para>surround all the annotations in brackets, like C#.</para>
            </listitem>
        </itemizedlist>
        
        <para>NOTE: we can get much of the value of the <literal>def</literal> keyword with
        a recommendation to developers that they put one of <literal>public/module/package</literal> 
        or <literal>override</literal>, first in the annotation list, and outlaw the use of those 
        identifiers as names of members and local variables. This is enough of a hint to the 
        compiler to eliminate backtracking in almost every case.</para></comment>
        -->
        
    </section>
    
    <section id="type">
        <title>Type</title>
    
        <para>Method, attribute and formal parameter declarations must declare a type.</para>
        
        <programlisting>Type := RegularType | "subtype"</programlisting>
        
        <para>A type may be <emphasis>assignable</emphasis> to another type. If <literal>X</literal>
        is assignable to <literal>Y</literal>, then:</para>
        
        <itemizedlist>
            <listitem>
                <para>For each immutable attribute of <literal>Y</literal>, <literal>X</literal>
                has an attribute with the same name, whose type is assignable to the
                type of the attribute of <literal>Y</literal>. The attribute is not <literal>optional</literal> 
                unless the attribute of <literal>Y</literal> is <literal>optional</literal>.</para>
            </listitem>
            <listitem>
                <para>For each mutable attribute of <literal>Y</literal>, <literal>X</literal>
                has a mutable attribute with the same name and the same type. The
                attribute is <literal>optional</literal> if and only if the attribute of  
                <literal>Y</literal> is <literal>optional</literal>.</para>
            </listitem>
            <listitem>
                <para>For each method of <literal>Y</literal>, <literal>X</literal>
                has a method with the same name, with the same formal parameter types, 
                and whose return type is assignable to the return type of the method of 
                <literal>Y</literal>. The method is not <literal>optional</literal> 
                unless the method of <literal>Y</literal> is <literal>optional</literal>.</para>
            </listitem>
            <listitem>
                <para>For each member type of <literal>Y</literal>, <literal>X</literal>
                has a member type of the same name, with the same formal parameter types,
                that is assignable to the member type of <literal>Y</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Assignability obeys the following rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>identity: <literal>X</literal> is assignable to <literal>X</literal></para>
            </listitem>
            <listitem>
                <para>transitivity: if <literal>X</literal> is assignable to <literal>Y</literal>
                and <literal>Y</literal> is assignable to <literal>Z</literal> then
                <literal>X</literal> is assignable to <literal>Z</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Most types are classes or interfaces:</para>
        
        <programlisting>RegularType := QualifiedTypeName TypeArguments?</programlisting>
        
        <para>Unlike Java, the name of a type may not be qualified by the package name.</para>
        
        <programlisting>QualifiedTypeName := (TypeName ".")* TypeName</programlisting>
        
        <para>A generic type must specify arguments for the generic type parameters.</para>
        
        <programlisting>TypeArguments := "&lt;" Type ("," Type)* "&gt;"</programlisting>
        
        <para>The arguments may themselves be generic types.</para>
        
        <programlisting>Map&lt;Key, List&lt;Item&gt;&gt;</programlisting>
        
        <para>Every Ceylon class and interface has an implicit type parameter that never
        needs to be declared. This special type parameter, referred to using the keyword 
        <literal>subtype</literal>, represents the concrete type of the current instance 
        (the instance that is being invoked).</para>
        
        <programlisting>public interface Wrapper&lt;out X&gt; {}</programlisting>
        
        <programlisting>public abstract class Wrappable {
   public Wrapper&lt;subtype&gt; wrap() {
       return Wrapper(this);
   }
}</programlisting>
        
        <programlisting>public class Special() extends Wrappable() {}</programlisting>

        <programlisting>Special special = Special();
Wrapper&lt;Special&gt; wrapper = special.wrap();</programlisting>

        <para>For a class declared <literal>final</literal>, any instance of the class
        may be assigned to the type <literal>subtype</literal>. For a class not declared
        <literal>final</literal>, only the <literal>this</literal> reference is
        assignable to <literal>subtype</literal>.</para>
        
        <comment><para>TODO: so this means we really need a <literal>final</literal>
        modifier after all? Is there another solution?</para></comment>
        
        <para>The type <literal>subtype</literal> is considered a covariant type parameter
        of the type, and may not appear in contravariant positions of the type declaration.</para>
        
        <comment><para>Should we support <literal>Item[]</literal> as a shorthand for
        <literal>Sequence&lt;Item&gt;</literal> or perhaps <literal>List&lt;Item&gt;</literal> 
        and <literal>Item[Key]</literal> as a shorthand for 
        <literal>Correspondence&lt;Item,Key&gt;</literal> or perhaps 
        <literal>Map&lt;Item,Key&gt;</literal>? Should we support <literal>Item...</literal>
        as a shorthand for <literal>Iterable&lt;Item&gt;</literal>?</para></comment>
        
        <para>The type of a program element determines what members and operators it has and 
        to which other program elements it is assignable. The type may be modified by the 
        <literal>optional</literal> annotation. An <literal>optional</literal> program element 
        is not usually assignable to a non-<literal>optional</literal> program element.</para>
    
    </section>
    
    <section id="generictypeparameters">
        <title>Generic type parameters</title>
    
        <para>Method, class and interface declarations may declare generic type parameters.</para>
        
        <programlisting>TypeParams := "&lt;" TypeParam ("," TypeParam)* "&gt;"</programlisting>
        
        <programlisting>TypeParam := Variance TypeName</programlisting>
        
        <para>A <emphasis>covariant</emphasis> type parameter is indicated using <literal>out</literal>.
        A <emphasis>contravariant</emphasis> type parameter is indicated using <literal>in</literal>.</para>
        
        <programlisting>Variance :=  ("out" | "in")?</programlisting>
        
        <para>For a generic type <literal>T&lt;X&gt;</literal>, a type <literal>A</literal>,
        and a subtype <literal>B</literal> of <literal>A</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    If <literal>X</literal> is a covariant type parameter, 
                    <literal>T&lt;B&gt;</literal> is assignable to <literal>T&lt;A&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is a contravariant type parameter, 
                    <literal>T&lt;A&gt;</literal> is assignable to <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is neither covariant nor contravariant, there is no
                    assignability between <literal>T&lt;A&gt;</literal> and <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Map&lt;K, V&gt;</programlisting>
        
        <programlisting>Sender&lt;in M&gt;</programlisting>
        
        <programlisting>Container&lt;out T&gt;</programlisting>
        
        <programlisting>BinaryFunction&lt;in X, in Y, out R&gt;</programlisting>
        
    </section>

    <!--section>
        <title>Functor type declaration</title>
    
        <para>There are also functor types:</para>
        
        <programlisting>FunctorType := FunctorHeader FormalParams</programlisting>
        
        <programlisting>FunctorHeader := "functor" Annotation* (Type | "void")</programlisting>
        
        <para>The parameter names in a functor type declaration do not affect assignability
        of the functor type. They are used when the functor is invoked using named parameters.</para>
        
        <para>For example:</para>
        
        <programlisting>functor Comparison(X x, X y)</programlisting>
        <programlisting>functor Boolean(Payment payment)</programlisting>
        <programlisting>functor void(Y element)</programlisting>
        <programlisting>functor optional Object()</programlisting>
        <programlisting>functor Y(optional Y object, Factory&lt;Y&gt; factory)</programlisting>
        
        <para>Functor types are covariant in the return type, and contravariant in the
        parameter types. So <literal>functor String(Object o)</literal> is assignable to
        <literal>functor Object(String s)</literal>.</para>
        
    </section-->

    <section id="formalparameterlist">
        <title>Formal parameter list</title>
    
        <para>Method and class declarations may declare formal parameters, including
        defaulted parameters and a varargs parameter.</para>
        
        <programlisting>FormalParams := 
"("
FormalParam ("," FormalParam)* ("," DefaultParam)* ("," VarargsParam)? | 
DefaultParam ("," DefaultParam)* ("," VarargsParam)? | 
VarargsParam?
")"</programlisting>

        <programlisting>FormalParam := Param | EntryParamPair | RangeParamPair</programlisting>
        
        <para>Each parameter is declared with a type and name and may have annotations and/or
        parameters of its own.</para>
        
        <programlisting>Param := Annotation* Type ParameterName FormalParams*</programlisting>
        
        <para>A parameter with its own parameter list (or lists) is called a 
        <emphasis>functional parameter</emphasis>. Think of it as an abstract local method that 
        must be defined by the caller when the method is invoked or the class is instantiated. 
        </para>
            
        <programlisting>(String label, void onClick())</programlisting>
        
        <programlisting>(Comparison by(X x, X y))</programlisting>
        
        <para>Defaulted parameters specify a default value.</para>
    
        <programlisting>DefaultParam := FormalParam Specifier</programlisting>
        
        <para>The <literal>=</literal> specifier is used throughout the language to indicate a 
        value which cannot be reassigned.</para>
        
        <programlisting>Specifier := "=" Expression</programlisting>
        
        <para>Defaulted parameters must occur after non-defaulted parameters in the formal
        parameter list.</para>
        
        <programlisting>(Product product, Natural quantity=1)</programlisting>
        
        <para>A varargs parameter accepts a list of arguments or a single argument of type 
        <literal>Iterable</literal>. Inside the method, it is available as a local of type
        <literal>Iterable</literal>.</para>
        
        <programlisting>VarargsParam := Annotation* Type "..." ParameterName</programlisting>
        
        <para>The varargs parameter must be the last formal parameter in the list.</para>
        
        <programlisting>(Name name, optional Organization org=null, Address... addresses)</programlisting>
        
        <comment><para>TODO: should we just make <literal>X...</literal> a syntactic shorthand
        for <literal>Iterable&lt;X&gt;</literal> everywhere? Or, alternatively, should we also
        allow <literal>Iterator&lt;X&gt;</literal> to be passed to <literal>X...</literal>?</para></comment>
        
        <para>Parameters of type <literal>Entry</literal> or <literal>Range</literal> 
        may be specified as a pair of variables.</para>
        
        <programlisting>EntryParamPair := Annotation* Type ParameterName "->" Type ParameterName</programlisting>

        <programlisting>RangeParamPair := Annotation* Type ParameterName ".." ParameterName</programlisting>
        
        <para>A variable pair declaration of form <literal>U u -> V v</literal> results in a single 
        parameter of type <literal>Entry&lt;U,V&gt;</literal>.</para>
        
        <programlisting>(Key key -> Value value)</programlisting>
        
        <para>A variable pair declaration of form <literal>T x .. y</literal> results in a single 
        parameter of type <literal>Range&lt;T&gt;</literal>.</para>
        
        <programlisting>(Float value, Integer min..max)</programlisting>
    
    </section>
    
    <section id="extendedclass">
        <title>Extended class</title>
    
        <para>Classes may extend other classes using the <literal>extends</literal> clause.</para>
        
        <programlisting>Supertype := "extends" RegularType PositionalArguments</programlisting>
    
        <para>A class may extend only one superclass.</para>
        
        <programlisting>extends Person(name, org)</programlisting>
    
        <para>Suppose <literal>X</literal> and <literal>Y</literal> are classes.</para>
    
        <itemizedlist>
        <listitem>
            <para>If <literal>X</literal> extends <literal>Y</literal>, then
            <literal>X</literal> is assignable to <literal>Y</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X</literal> extends <literal>Y&lt;B&gt;</literal>, then
            <literal>X</literal> is assignable to <literal>Y&lt;B&gt;</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> extends <literal>Y&lt;T&gt;</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y&lt;B&gt;</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> extends <literal>Y</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="satisfiedinterfaces">
        <title>Satisfied interfaces</title>
    
        <para>Classes and interfaces may satisfy (implement or extend) interfaces, 
        using the <literal>satisfies</literal> clause.</para>
        
        <programlisting>Interfaces = "satisfies" Type ("," Type)*</programlisting>
    
        <para>A class or interface may satisfy multiple interfaces.</para>
        
        <programlisting>satisfies Sequence&lt;T&gt;, Collection&lt;T&gt;</programlisting>
        
        <para>Suppose <literal>Y</literal> is an interface and <literal>X</literal> is
        a class or interface.</para>
    
        <itemizedlist>
        <listitem>
            <para>If <literal>X</literal> satisfies <literal>Y</literal>, then
            <literal>X</literal> is assignable to <literal>Y</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X</literal> satisfies <literal>Y&lt;B&gt;</literal>, then
            <literal>X</literal> is assignable to <literal>Y&lt;B&gt;</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> satisfies <literal>Y&lt;T&gt;</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y&lt;B&gt;</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> satisfies <literal>Y</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
    </section>

    <section id="generictypeconstraintlist">
    <title>Generic type constraint list</title>

        <para>Method, class and interface declarations which declare generic type 
        parameters may declare constraints upon the type parameters using the
        <literal>where</literal> clause.</para>
        
        <programlisting>TypeConstraints = "where" TypeConstraint (AMPERSAND TypeConstraint)*</programlisting>
    
        <programlisting>TypeConstraint := TypeName ( ("&gt;="|"&lt;=") Type | "=" "subtype" | FormalParams ) </programlisting>
        
        <para>There are four kinds of type constraints:</para>
        
        <itemizedlist>
            <listitem>
                <para>an upper bound, <literal>X &gt;= T</literal>, specifies that 
                the type parameter <literal>X</literal> is assignable to a given
                type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>a lower bound, <literal>X &lt;= T</literal>, specifies that 
                a given type <literal>T</literal> is assignable to the type parameter 
                <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para>a subtype bound, <literal>X = subtype</literal>, specifies that 
                the type parameter <literal>X</literal> represents the concrete type
                of the current instance, and</para>
            </listitem>
            <listitem>
                <para>an initialization parameter specification, <literal>X(...)</literal>
                specifies that the type parameter <literal>X</literal> is a class with
                with the given formal parameter types.</para>
            </listitem>
        </itemizedlist>
        
        <para>Subtype bounds are needed since the special type <literal>subtype</literal>
        cannot appear in a contravariant position. A subtype bound cannot be applied to
        a covariant or contravariant type parameter.</para>
        
        <para>Initialization parameter specifications allow instantiation of the
        generic type.</para>
        
        <para>Mutiple type constraints are seperated by <literal>&amp;</literal>.</para>
        
        <programlisting>where X &gt;= Number&lt;X&gt; &amp; Y = subtype &amp; Y(Natural count)</programlisting>
        
        <comment><para>TODO: Should we use <literal>for</literal> instead of <literal>where</literal>?</para></comment>
        
        <comment><para>TODO: Should we use <literal>satisfies</literal> instead of <literal>>=</literal>? 
        For example <literal>where X satisfies Number&lt;X&gt;</literal>.</para></comment>
    
    </section>
    
    <!--
    <section>
        <title>Declaration examples</title>
        
    <para>For example:</para>
    
    <programlisting>Comparable&lt;Person&gt; Person person = Person(name);</programlisting>
    
    <programlisting>public entity 
class Customer(Name name, optional Organization org = null) 
    extends Person(name, org) 
{
   ... 
}</programlisting>

    <programlisting>public
class HashMap&lt;T&gt;(Iterable&lt;Entry&lt;T&gt;&gt; entries = {})
    extends AbstractCollection&lt;Entry&lt;T&gt;&gt;(entries)
    satisfies Map&lt;T&gt; 
    where T >= Comparable 
{ 
    ... 
}</programlisting>
    
    <programlisting>public interface List&lt;T&gt;
    satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; 
{
    ...
}</programlisting>

    <programlisting>Natural count = 0;</programlisting>
    
    <programlisting>protected String firstName;</programlisting>
    
    <programlisting>public Boolean login() { ... }</programlisting>
    
    <programlisting>public 
String join(Iterable&lt;String&gt; strings, 
            String delimiter = ", ") 
{ 
   ... 
}</programlisting>
    
    <programlisting>public Boolean functor Order&lt;T&gt;(T x, T y);</programlisting>

    <programlisting>public decorator ComparablePerson(Person person) 
    satisfies Comparable&lt;Person&gt; 
{
   ... 
}</programlisting>
               
    <programlisting>public Float converter IntegerToFloat(Integer int) 
{
   return Float(int);
}</programlisting>
    
    <para>Thus, the syntax of Ceylon declarations is more regular than Java or C#.</para>
    
    </section>
    -->
    
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A <emphasis>class</emphasis> is a stateful, instantiable type. Classes 
        are declared according to the following:</para>
        
        <programlisting>Class :=
Annotation*
"class" TypeName TypeParams? FormalParams?
Supertype?
Interfaces?
TypeConstraints?
ClassBody</programlisting>

        <programlisting>ClassBody := "{" Instances? DeclarationOrStatement* "}"</programlisting>
        
        <para>The body of a class contains member (method, attribute and nested type) 
        declarations, instance initialization code, and, optionally, a list of enumerated 
        named instances of the class.</para>

        <para>Ordinarily, a declaration that occurs in a block of code is a block local
        declaration&mdash;it is visible only to statements and declarations that occur
        later in the same block. This rule is relaxed for certain declarations that occur 
        directly inside a class body:</para>
            
        <itemizedlist>
            <listitem>
                <para>declarations with explicit visibility modifiers&mdash;whose visibility
                is determined by the modifier, and</para>
            </listitem>
            <listitem>
                <para>declarations that occur in the second part of the body of the class, 
                after the last statement of the initializer&mdash;which are visible to all
                other declarations in the second part of the body of the class.</para>
            </listitem>
        </itemizedlist>

    <section id="classinitializer">
        <title>Class initializer</title>
        
        <para>Ceylon classes do not support a Java-like constructor declaration syntax. 
        Instead:</para>
        
        <itemizedlist>
           <listitem>
              <para>The body of the class may declare <emphasis>initialization parameters</emphasis>.
              An initialization parameter may be used anywhere in the class body, including in 
              method and attribute definitions.</para>
           </listitem>
           <listitem>
              <para>The initial part of the body of the class is called the <emphasis>initializer</emphasis> 
              and contains a mix of declarations, statements and control structures. The initializer 
              is executed every time the class is instantiated.</para>
           </listitem>
        </itemizedlist>
        
        <para>An initialization parameter may be used to specify or initialize the value of an 
        attrbute:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock = lock;
}</programlisting>
        
        <programlisting>public class Counter(Natural start=0) {
    public mutable Natural count := start;
    public void inc() { count++; }
}</programlisting>
        
        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private final ReadAttribute&lt;Lock&gt; lock;
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) {
        this.lock = new SimpleReadAttribute&lt;Lock&gt;(lock); 
    }
    
}</programlisting>
         -->
        <para>An initialization parameter may even be used within the body of a method,
        attribute getter, or attribute setter:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock { return lock }
}</programlisting>

        <programlisting>public class Key(Lock lock) {
    public void lock() { lock.engage(this); }
    public void unlock() { lock.disengage(this); }
}</programlisting>

        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private Lock _lock;
        
    private final ReadAttribute&lt;Lock&gt; lock = new ReadAttribute&lt;Lock&gt;() {
        @Override public Lock get() { return _lock; }
    };
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) { 
        _lock = lock; 
    }
    
}</programlisting>
        -->
        
        <para>Class initialization parameters are optional. The following class:</para>
        
        <programlisting>public mutable class Point {
    public mutable Decimal x := 0.0;
    public mutable Decimal y := 0.0;
}</programlisting>

        <para>Is assumed to have zero initialization parameters.</para>
        
        <!--
        <para>Is equivalent to this Java class with a default constructor:</para>
        
        <programlisting>public class Point {
    private final Attribute&lt;Decimal&gt; x = new SimpleAttribute&lt;Decimal&gt;( new Decimal(0.0) );
    public SimpleAttribute&lt;Decimal&gt; x() { return x; }
    
    private final Attribute&lt;Decimal&gt; y = new SimpleAttribute&lt;Decimal&gt;( new Decimal(0.0) );
    public SimpleAttribute&lt;Decimal&gt; y() { return y; }
}</programlisting>
        -->
        
        <comment><para>TODO: is this the right thing to say? Alternatively, we could say that 
        classes without a parameter list can't have statements or initialized simple attributes
        in the body of the class, and get the constructor automatically generated for the 
        list of attributes.</para></comment>
        
        <para>A subclass must pass values to each superclass initialization 
        parameter in the <literal>extends</literal> clause.</para>

        <programlisting>public class SpecialKey1()
        extends Key( new SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>public class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>

        <!--
        <para>Which are equivalent to the Java:</para>
        
        <programlisting>public class SpecialKey1 
        extends Key {
    public SpecialKey1() { 
        super( SpecialLock() );
    }
    ... 
}</programlisting>

        <programlisting>public class SpecialKey2 
        extends Key {
    public SpecialKey2(Lock lock) { 
        super(lock);
    }
    ... 
}</programlisting>
        -->
        
        <para>The class initializer is responsible for initializing the state of a new instance
        of the class, before a reference to the new instance is available to clients.</para>
        
        <programlisting>public mutable class DiagonalPoint(Decimal position) 
        extends Point() {
    
    x := y := sqrt(position**2/2) * position.sign;
    
    assert ("must have distance ${position} from origin") 
        that ( x**2 + y**2 == position**2 );
    
}</programlisting>
        
        <!--
        <para>So the above class is equivalent to:</para>
        
        <programlisting>public class DiagonalPoint extends Point {
        
    public DiagonalPoint(final Decimal position) {
    
        x = y = sqrt( position.power(2).divided(2) ).times(position.sign);
        
        assert_(new F0&lt;String&gt;() {
                   public String call() { 
                       return "must have distance " + position + " from origin";
                   }
                },
                new F0&lt;Boolean&gt;() {
                   public Boolean call() { 
                       return ( x.power(2) + y.power(2) ).equals( position.power(2) );
                   }
                });
    }
    
}</programlisting>
        -->
        
        <para>An initializer may invoke, evaluate or assign members of the current instance 
        of the class (the instance being initialized) without explicitly specifying the 
        receiver.</para>
        
        <para>An initializer of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class (the instance upon which the constructor
        was invoked) without explicitly specifying the receiver.</para>
        
        <para>A class may be declared inside the body of a method or attribute, in which case 
        the initializer may refer to any immutable local, block local attribute getter or block 
        local method declared earlier within the containing scope. It may not refer to mutable 
        locals from the containing scope.</para>
        
        <para>The following restrictions apply to statements and declarations that appear within
        the initializer of the class:</para>
        
        <itemizedlist>
           <listitem>
              <para>They may not evaluate attributes or invoke methods that are declared later
              in the body of the class upon the current object or <literal>this</literal>.</para>
           </listitem>
           <listitem>
              <para>They may not pass <literal>this</literal> as an argument of a method invocation
              or the value of an attribute assignment.</para>
           </listitem>
           <listitem>
              <para>They may not declare an abstract method or attribute.</para>
           </listitem>
           <listitem>
              <para>They may not declare a <literal>default</literal> method or attribute.</para>
           </listitem>
        </itemizedlist>
        
        <para>The remainder of the body of the class consists purely of declarations, including
        abstract and <literal>default</literal> methods and attributes. It may not directly contain 
        statements or control structures, but may freely use <literal>this</literal>, and may 
        invoke any method or evaluate any attribute of the class. The usual restriction that a 
        declaration may only be used by code that appears later in the block containing the 
        declaration is relaxed.</para>
        
        <comment><para>TODO: should class initialization parameters be allowed to be
        declared <literal>mutable</literal>?</para></comment>
        
        <comment><para>TODO: should class initialization parameters be allowed to be
        declared <literal>public/package/module</literal>, allowing a shortcut
        simple attribute declaration like in Scala?</para></comment>
        
        <!-- comment>
        
        <para>TODO: I would really, really like to believe that one "constructor"
        per class is sufficient, but somehow I'm not quite buying it. We can allow the
        declaration of additional constructors, according to:</para>
        
        <programlisting>Constructor := Annotation* TypeName FormalParams Supertype Block</programlisting>
        
        <para>for example:</para>
        
        <programlisting>public class Person(Name name) {
    public Person(String name) extends Person( Name(name) ) {}
}</programlisting>
        
        </comment-->
                
        <!--
        <section>
        <title>Annotations</title>
        
        <para>Every annotation is a static (non-void) method call. This Ceylon class:</para>
        
        <programlisting>doc "Represents a person"
by "Gavin"
public class Person { ... }</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>public class Person { ... 

    static {
        Type&lt;Person&gt; type = Type.get(Person.class);
        type.addAnnotation( doc("Represents a person") );
        type.addAnnotation( by("Gavin") );
        type.addAnnotation( public() );
    }

    ...

}</programlisting>
        
        </section>
        -->

    </section>

        <section>
             <title>Class inheritance</title>
        
        <para>
        A class may extend another class, and implement any number of interfaces.
        </para>
        
        <programlisting>public mutable
class Customer(Name name, optional Organization org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>
        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt;, Identifier {
    ... 
}</programlisting>
        
        <para>
        The types listed after the <literal>satisfies</literal> keyword are the implemented
        interfaces. The type specified after the <literal>extends</literal> keyword is a 
        superclass.
        </para>
        
        <para>
        If a class does not explicitly specify a superclass using <literal>extends</literal>,
        its superclass is <literal>lang.Object</literal>.
        </para>
        
        <para>
        The semantics of class inheritance are exactly the same as Java. A class:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>inherits all members of its superclass,</para>
            </listitem>
            <listitem>
                <para>is assignable to any type to which its superclass is assignable,</para>
            </listitem>
            <listitem>
                <para> must override all members of every interface it implements (unless
                the class is declared <literal>abstract</literal>), and</para>
            </listitem>
            <listitem>
                <para>is assignable to any type to which any interface it implements is 
                assignable.</para>
            </listitem>
        </itemizedlist>
        
        <para>
        Furthermore, the initializer of the superclass is always executed before the
        initializer of the subclass whenever the subclass is instantiated.
        </para>
        
        <!-- 
        <para>and the 
        above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>public class Customer 
        extends Person {
    public Customer(Name name) { this(name, null); }
    public Customer(Name name, Organization org) { super(name, org); }
    ... 
}</programlisting>
        
        <programlisting>class Token 
        extends Datetime 
        implements Comparable&lt;Token&gt;, Identifier {
    public Token() { super(); }
    ... 
}</programlisting>
         -->
        </section>
       
    <section id="instanceenumeration">
        <title>Class instance enumeration</title>
        
        <para>The keyword <literal>case</literal> is used to specify an enumerated named 
        instance of a class. All <literal>case</literal>s must appear in a list as the 
        first line of a class definition.</para>
        
        <programlisting>Instances := Instance ("," Instance)* ("..." | ";")</programlisting>

        <programlisting>Instance := Annotation* "case" MemberName Arguments?</programlisting>

        <para>If the <literal>case</literal> list ends in <literal>;</literal> instead of 
        <literal>...</literal>, additional instances of the class may not be instantiated.</para>
        
        <para>A class annotated <literal>abstract</literal> may not specify enumerated named
        instances.</para>
        
        <programlisting>public class DayOfWeek {
    case sun,
    case mon, 
    case tues, 
    case wed, 
    case thurs, 
    case fri, 
    case sat; 
}</programlisting>

        <programlisting>public class DayOfWeek(String name) {
    doc "Sunday"
        case sun("Sunday"),
    doc "Monday" 
        case mon("Monday"), 
    doc "Tuesday"
        case tues("Tuesday"),
    doc "Wednesday"
        case wed("Wednesday"),
    doc "Thursday"
        case thurs("Thursday"),
    doc "Friday"
        case fri("Friday"),
    doc "Saturday"
        case sat("Saturday");
       
    public String name = name;
    
}</programlisting>

        <comment><para>TODO: If we decide to support static attributes, then each 
        <literal>case</literal> would be considered a static simple attribute.</para></comment>
        
        <para>A class with declared <literal>case</literal>s implicitly extends 
        <literal>lang.Selector</literal>, a subclass of 
        <literal>java.lang.Enum</literal>.</para>
        
        <para>Enumerated instances of a class are instantiated when the class is
        loaded by the virtual machine, with the specified arguments.</para>
        
        <!--
        <para>The above declarations are equivalent to the following Java declarations:</para>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; { 
        
    public static DayOfWeek mon = new DayOfWeek("mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("tues", 1);
    public static DayOfWeek wed = new DayOfWeek("wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("fri", 4);
    public static DayOfWeek sat = new DayOfWeek("sat", 5);
    public static DayOfWeek sun = new DayOfWeek("sun", 6);
    
    private DayOfWeek(String id, int ord) {
        super(id, ord);
    }
    
}</programlisting>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; {
        
    private final ReadAttribute&lt;String&gt; name;
       
    public static DayOfWeek mon = new DayOfWeek("Monday", "mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("Tuesday", "tues", 1);
    public static DayOfWeek wed = new DayOfWeek("Wednesday", "wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("Thursday", "thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("Friday", "fri", 4);
    public static DayOfWeek sat = new DayOfWeek("Saturday", "sat", 5);
    public static DayOfWeek sun = new DayOfWeek("Sunday", "sun", 6);
     
    private DayOfWeek(String name, String id, int ord)
    {
        super(id, ord);
        name = new SimpleReadAttribute(name);
    }
    
}</programlisting>
        -->
    </section>
    
        <section>
            <title>Overloaded classes</title>
            
            <para>Multiple toplevel classes belonging to the same package, or
            multiple member classes of the same containing class may declare 
            the same name. The classes are called <emphasis>overloaded</emphasis>.
            Overloaded classes:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must extend and overload a common <emphasis>root</emphasis>
                    type,</para>
                </listitem>
                <listitem>
                    <para>must have different formal parameter types,</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters, and</para>
                </listitem>
                <listitem>
                    <para>except for the root type, may not declare any member
                    with a visibility modifier.</para>
                </listitem>
            </itemizedlist>
            
            <para>Then the class name always refers to the root type, except in 
            instantiations. In the case of instantiation, the correct overloaded 
            class is resolved at compile time, using the mechanism that Java
            uses to choose between overloaded constructors.</para>
            
        </section>
        
    <section>
        <title>Overriding member classes</title>
        
        <para>A member class annotated <literal>abstract</literal> or
        <literal>default</literal> may be overridden by subclasses of the class 
        which contains the member class. The subclass must declare a member class:</para>
        
        <itemizedlist>
            <listitem>
                <para>annotated <literal>override</literal>,</para>
            </listitem>
            <listitem>
                <para>with the same name as the member class it overrides,</para>
            </listitem>
            <listitem>
                <para>that extends the member class it overrides, and</para>
            </listitem>
            <listitem>
                <para>with the same formal parameter types as the member class it
                overrides.</para>
            </listitem>
        </itemizedlist>
        
        <para>Then instantiation of the member class is polymorphic, and the actual
        subtype instantiated depends upon the concrete type of the containing class
        instance.</para>
        
        <para>By default, the member class annotated <literal>override</literal> 
        has the same visibility modifier as the member class it overrides. The
        member class may not declare a stricter visibility modifier than the member 
        class it overrides.</para>
            
        <comment><para>TODO: If we decide to support <literal>static</literal> member
        classes, they cannot be overridden.</para></comment>
    
    </section>
        
    </section>
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An <emphasis>interface</emphasis> is a type which does not specify 
        the implementation of its members. Interfaces may not be directly instantiated. 
        Interfaces are declared according to the following:</para>
        
        <programlisting>Interface :=
Annotation*
"interface" TypeName TypeParams?
Interfaces?
TypeConstraints? 
InterfaceBody</programlisting>

        <programlisting>InterfaceBody := "{" ( AbstractMethod | AbstractAttribute )* "}"</programlisting>

        <para>The body of an interface contains member (method, attribute and nested type) 
        declarations, but the method and attribute declarations may not specify 
        implementation.</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>

        <!-- 
        <para>Which is equivalent to the following Java interface:</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>
        -->
        
        <para>Interface members inherit the visbility modifier of the interface.</para>
        
        <comment><para>TODO: refine this. Consider block-local interface declarations.</para></comment>
          
        <section>
            <title>Interface inheritance</title>
            
            <para>An interface may extend any number of other interfaces.</para>
        
            <programlisting>public interface List&lt;T&gt;
        satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
        
            <para>
            The types listed after the <literal>satisfies</literal> keyword are the supertypes. All 
            supertypes of an interface must be interfaces.
            </para>
            
            <para>
            Since every class that implements an interface is a subclass of <literal>lang.Object</literal>,
            the interface type itself is considered assignable to <literal>lang.Object</literal>.
            </para>
        
        <para>
        The semantics of interface inheritance are exactly the same as Java. An interface:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>inherits all members of every supertype, and</para>
            </listitem>
            <listitem>
                <para>is assignable to any type to which any supertype is assignable.</para>
            </listitem>
        </itemizedlist>
        
            <!--
            <para>and the above declaration is equivalent to the following 
            Java declaration: 
            </para>
        
            <programlisting>public interface List&lt;T&gt; 
        extends Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
            -->
            
        </section>
        
    </section>
    
    <!--  
    <section>
        <title>Constructors</title>
        
        <para>Constructors are declared according to the following:</para>
        
        <programlisting>Annotation* Identifier 
FormalParams
( ";" | ClosedBlock )</programlisting>

        <para>
        For example:
        </para>
        
        <programlisting>Public: User(String username, Person person);</programlisting>
        <programlisting>Public: Integer(String string): value = parse(string);</programlisting>
        <programlisting>Public: User(String u, Person p) { username = u; person = p; }</programlisting>
        
        <para>
        The semantics of constructor declarations are identical to Java.
        </para>
        
        <para>
        A constructor body may omit the braces if it consists of exactly one statement. 
        If there is no constructor body at all, the constructor assigns each parameter to
        the attribute with the same name.
        </para>
        
        <para>
        A Ceylon constructor invocation is equivalent to a Java constructor invocation.
        </para>
                
        <programlisting>@FormalParameterNames({"username", "person"}) 
public User(String username, Person person);</programlisting>

    </section>
    -->
    
    <section id="methods">
        <title>Methods</title>
        
        <para>A <emphasis>method</emphasis> is a callable block of code. Methods may have 
        parameters and may return a value. Methods are declared according to the following:</para>
        
        <programlisting>Method := MethodHeader ( Block | Specifier? ";" )</programlisting>

        <programlisting>MethodHeader := Annotation* (Type | "void") MemberName TypeParams? FormalParams+ TypeConstraints?</programlisting>
        
        <para>A method implementation may be specified using either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a block of code, or</para>
            </listitem>
            <listitem>
                <para>a reference to another method.</para>
            </listitem>
        </itemizedlist>
        
        <para>A method body may invoke, evaluate or assign members of the current instance 
        of the class which defines the method (the instance upon which the method was 
        invoked) without explicitly specifying the receiver.</para>
        
        <para>A method body of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class (the containing instance of the instance 
        upon which the method was invoked) without explicitly specifying the receiver.</para>
        
        <para>A method may be declared inside the body of another method or attribute, in 
        which case it may refer to any immutable local, block local attribute getter or 
        block local method declared earlier within the containing scope. It may not refer 
        to mutable locals from the containing scope.</para>
        
        <programlisting>public Integer add(Integer x, Integer y) {
    return x + y;
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token();
}</programlisting>

        <programlisting>public optional U get(optional V key);</programlisting>
        
        <programlisting>public void print(Object... objects) {
    for (Object object in objects) { log.info($object); }
}</programlisting>

        <programlisting>public void addEntry(V key -> U value) { ... }</programlisting>
        
        <programlisting>Float say(String words) = person.say;</programlisting>
        
        <programlisting>Comparison order(String x, String y) = getOrder();</programlisting>
        
        <para>A method may declare multiple lists of parameters. Methods which declare
        more than one parameter list return references to other methods.</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    Comparison order(Natural x, Natural y) { return x&lt;=&gt;y; }
    return order;
}</programlisting>

        <para>A method body may <emphasis>only</emphasis> refer to parameters in the 
        first parameter list. It may not refer to parameters of other parameter lists.</para>

        <para>The Ceylon compiler preserves the names of method parameters, using a Java
        annotation.</para>
        
        <!--
        <programlisting>@FormalParameterNames({"x", "y"}) 
public Integer add(Integer x, Integer y) { ... }</programlisting>
        -->

        <para>The semantics of Ceylon methods are identical to Java, except that Ceylon 
        methods may declare defaulted parameters and functional parameters.</para>
        
        <section>
            <title>Overloaded methods</title>
            
            <para>A class may declare or inherit multiple methods with the
            same name. The methods are called <emphasis>overloaded</emphasis>.
            Overloaded methods: </para>
            
            <itemizedlist>
                <listitem>
                    <para>must have different formal parameter types, and</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters.</para>
                </listitem>
            </itemizedlist>
            
            <para>Like Java, Ceylon resolves overloaded methods at compile time.</para>
        
        </section>
        
       <section>
            <title>Interface methods and abstract methods</title>
            
            <para>If there is no method body in a method declaration, the implementation 
            of the method must be specified later in the block, or the class that declares 
            the method must be annotated <literal>abstract</literal>. If no implementation 
            is specified, the method is considered an <emphasis>abstract method</emphasis>.</para>
        
            <para>Methods declared by interfaces never specify an implementation:</para>
        
            <programlisting>AbstractMethod := MethodHeader ";"</programlisting>

            <para>Interface methods and abstract methods must be overridden by every 
            non-<literal>abstract</literal> class that implements the interface or
            subclasses the abstract class.</para>
            
        </section>
        
        <section>
            <title>Overriding methods</title>
            
            <para>An abstract method, interface method, or a method annotated 
            <literal>default</literal> may be overridden by subclasses of the class 
            or interface which declares the method. The subclass must declare a method:</para>
            
            <itemizedlist>
                <listitem>
                    <para>annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>with the same name as the method it overrides,</para>
                </listitem>
                <listitem>
                    <para>the same formal parameter types as the method it overrides,</para>
                </listitem>
                 <listitem>
                    <para>with a return type that is assignable to the return type 
                    of the method it overrides, and</para>
                </listitem>
                <listitem>
                    <para>that is not annotated <literal>optional</literal>, unless the 
                    method it overrides is annotated <literal>optional</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Then invocation of the method is polymorphic, and the actual
            method invoked depends upon the concrete type of the class instance.</para>
            
            <para>By default, the method annotated <literal>override</literal>
            has the same visibility modifier as the method it overrides. The
            method may not declare a stricter visibility modifier than the method 
            it overrides.</para>
            
            <para><literal>static</literal> methods cannot be overridden, and so
            <literal>static</literal> method invocation is never polymorphic.</para>
        
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to <emphasis>attribute</emphasis> 
        definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a 
                Java field or local variable).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived 
                attribute is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived 
                attribute is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be overridden by subclasses.</para>
            
        <para>An attribute body may invoke, evaluate or assign members of the current instance 
        of the class which defines the method (the instance upon which the method was 
        invoked) without explicitly specifying the receiver.</para>
        
        <para>An attribute body of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class (the containing instance of the instance 
        upon which the method was invoked) without explicitly specifying the receiver.</para>
        
        <para>An attribute may be declared inside the body of another method or attribute, in 
        which case it may refer to any immutable local, block local attribute getter or block 
        local method declared earlier withing the containing scope. It may not refer to mutable 
        locals from the containing scope.</para>
        
        <programlisting>package mutable String firstName;</programlisting>
        
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <programlisting>public static Decimal pi = calculatePi();</programlisting>
        
        <programlisting>public String name { return join(firstName, lastName); }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
    
        <programlisting>public Float total {
    Float sum = 0.0;
    for (LineItem li in lineItems) {
        sum += li.amount;
    }
    return sum;
}</programlisting>
        
        <!--
        <para>
        An attribute declaration is equivalent to a Java method declaration together with 
        a Java field declaration, both of type <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal>, both with the same name as the attribute.
        </para>
        -->
        
        <comment><para>TODO: I would like to support <literal>def</literal> in place of the 
        type for a block local attribute or local with an initializer or getter. For 
        example:</para></comment>
        
        <programlisting>def names = List&lt;String&gt;();</programlisting>
        <programlisting>def name { return Name(firstName, initial, lastName); }</programlisting>
        <programlisting>def count:=0;</programlisting>
        
        <section>
            <title>Simple attributes and locals</title>
            
        <para>A simple attribute defines state. Simple attributes are declared according to the 
        following:</para>
        
        <programlisting>SimpleAttribute := AttributeHeader (Specifier | Initializer)? ";"</programlisting>
        
        <programlisting>AttributeHeader := Annotation* Type MemberName</programlisting>
        
        <para>The value of an immutable attribute is specified using <literal>=</literal>. Mutable 
        attributes may be initialized using the assignment operator <literal>:=</literal>.</para>

        <programlisting>Initializer := ":=" Expression</programlisting>

        <para>Formal parameters of classes and methods are also considered to be simple attributes.</para>
        
        <para>A simple attribute declared directly inside the body of a class represents state 
        associated with the instance of the class. Repeated evaluation of the attribute of a 
        particular instance of the class returns the same result until the attribute of the 
        instance is assigned a new value.</para>
        
        <para>A <emphasis>local</emphasis> represents state associated with execution of a
        particular block of code. A local is really just a special case of a simple attribute 
        declaration, but one whose state is not held across multiple executions of the block
        of code in which the local is defined.</para> 
        
        <itemizedlist>
            <listitem>
                <para>A simple attribute declared inside the body of a method, attribute getter
                or attribute setter is a local.</para>
            </listitem>
             <listitem>
                <para>A block local simple attribute declared inside the body of a class is a 
                local if it is not used inside a method, attribute setter or attribute getter 
                declaration.</para>
            </listitem>
           <listitem>
                <para>A formal parameter of a class is a local if it is not used inside a 
                method, attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a method is a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>A local may only be used by statements and declarations that appear later in the
        block of code that contains the local declaration.</para>
        
        <para>The semantics of locals are identical to Java local variables.</para>
        
        <!--
        <para>For a simple attribute that is not a local, the Java field is initialized to an 
        instance of <literal>lang.SimpleAttribute</literal> or 
        <literal>lang.SimpleReadAttribute</literal>. For example:</para> 
         -->
        
        <programlisting>package mutable String firstName;</programlisting>

        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; firstName = new SimpleAttribute&lt;String&gt;();
Attribute&lt;String&gt; firstName() { return firstName; }</programlisting>

        <para>While:</para>
         -->
         
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;Natural&gt; count = new SimpleAttribute&lt;Natural&gt;(0);
private Attribute&lt;Natural&gt; count() { return count; }</programlisting>

        <para>And:</para>
        -->
        
        <programlisting>public Integer max = 99;</programlisting>
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Integer&gt; max = new SimpleReadAttribute&lt;Integer&gt;(99);
public ReadAttribute&lt;Integer&gt; max() { return max; }</programlisting>
        -->

        <para>The compiler is permitted to optimize block local simple attributes to a simple 
        Java field declaration or local variable. Block local attributes may not be accessed 
        via reflection.</para>
        
        </section>
        
         <section>
            <title>Attribute getters</title>
            
            <para>An attribute getter is declared as follows:</para>
            
            <programlisting>AttributeGetter := AttributeHeader Block</programlisting>
            
            <para>An attribute getter defines how the value of a derived attribute is
            obtained.</para>
            
            <!--
            <para>For an attribute getter, the Java field is initialized to an instance 
            of an anonymous inner subclass of <literal>lang.Attribute</literal> or
            <literal>lang.ReadAttribute</literal> that overrides the <literal>get()</literal> 
            method with the content of the getter block. For example: </para>
            -->
        
            <programlisting>public Float total { return items.totalPrice; }</programlisting>
            
            <!--
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final ReadAttribute&lt;Float&gt; total = new ReadAttribute&lt;Float&gt;() {
    @Override public Float get() { return items.get().totalPrice; }
};
public ReadAttribute&lt;Float&gt; total() { return total; }</programlisting>
            -->
            
        </section>
        
        <section>
            <title>Attribute setters</title>
                    
            <para>An attribute setter is declared as follows:</para>
            
            <programlisting>AttributeSetter := Annotation* "assign" MemberName Block</programlisting>

            <para>An attribute setter defines how the value of a derived attribute is
            assigned. Every attribute setter must have a corresponding getter with the
            same name.</para>

            <programlisting>public String name { return join(firstName, lastName); }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
            
            <!--
            <para>For an attribute with a setter, the Java field is initialized to an 
            instance of an anonymous inner subclass of <literal>lang.Attribute</literal> 
            that overrides the <literal>set()</literal> method with the content of the 
            setter block. For example:
            </para>
            -->
            
            <comment><para>TODO: should we allow overloaded attribute setters, for example:</para></comment>
        
            <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>
            
            <!--
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final Attribute&lt;String&gt; name = new Attribute&lt;String&gt;() {
    @Override public String get() { return join(firstName, lastName); }
    @Override public void set(String name) { firstName = first(name); lastName = last(name); }
};
public Attribute&lt;String&gt; name() { return name; }</programlisting>
            -->
        </section>
        
        <section>
            <title>Interface attributes and abstract attributes</title>
            
            <para>If there is no initializer or getter implementation, the value or 
            implementation of the attribute must be specified later in the block, or 
            the class that declares the attribute must be annotated <literal>abstract</literal>. 
            If no value or implementation is specified, and the attribute is not declared 
            <literal>optional</literal>, the attribute is considered an <emphasis>abstract 
            attribute</emphasis>.</para>
        
            <para>Attributes declared by interfaces never specify an initalizer, getter 
            or setter:</para>
        
            <programlisting>AbstractAttribute := AttributeHeader ";"</programlisting>
        
            <para>Interface attributes and abstract attributes must be overidden by every 
            non-<literal>abstract</literal> class that implements the interface or subclasses 
            the abstract class.</para>
                
            <para>Interface attributes and abstract attributes may be annotated 
            <literal>mutable</literal>, in which case every subtype must also define the 
            attribute to be mutable.</para>
        
        </section>
        
        <section>
            <title>Overriding attributes</title>
            
            <para>An abstract attribute, interface attribute, or attribute annotated 
            <literal>default</literal> may be overridden by subclasses of the class or 
            interface which declares the method. An immutable attribute may be overridden 
            by a simple attribute or attribute getter. A mutable attribute may be overridden 
            by a mutable simple attribute or by an attribute getter and setter pair. The 
            subclass must declare an attribute:</para>
            
            <itemizedlist>
                <listitem>
                    <para>annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>with the same name as the attribute it overrides,</para>
                </listitem>
                 <listitem>
                    <para>with a type that is assignable to the type of the attribute 
                    it overrides, if the attribute it overrides is immutable, or with 
                    exactly the same type as the attribute it overrides, if the 
                    attribute it overrides is mutable,</para>
                </listitem>
                <listitem>
                    <para>that is mutable, if the attribute it overrides is mutable,</para>
                </listitem>
                <listitem>
                    <para>that is not <literal>optional</literal>, unless the attribute
                    it overrides is <literal>optional</literal>, and</para>
                </listitem>
                <listitem>
                    <para>that is <literal>optional</literal>, if the attribute it overrides 
                    is both mutable and <literal>optional</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>An immutable attribute may be overridden by a mutable attribute.</para>
            
            <para>Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance.</para>
            
            <para>By default, the attribute annotated <literal>override</literal>
            has the same visibility modifier as the attribute it overrides. The
            method may not declare a stricter visibility modifier than the method 
            it overrides.</para>
            
            <comment><para>TODO: if we decide to support <literal>static</literal> 
            attributes, they can not be overridden.</para></comment>
            
        </section>
        
        <section>
            <title>Getter and setter methods</title>
            
            <para>For each attribute, one or two methods exist implicitly:</para>
            
            <itemizedlist>
                <listitem>
                    <para>a <emphasis>getter method</emphasis> with no parameters 
                    which returns the attribute type, and</para>
                </listitem>
                <listitem>
                    <para>a <literal>void</literal> <emphasis>setter method</emphasis> 
                    with a single parameter of the attribute type, if the attribute is 
                    mutable.</para>
                </listitem>
            </itemizedlist>
            
            <para>These methods may be referred to using the <literal>get</literal> and 
            <literal>set</literal> keywords, for example:</para>
            
            <programlisting>String name = get person.name();</programlisting>
            <programlisting>set person.name(newName);</programlisting>
            
            <!--
            <comment><para>TODO: spec out generated Java-style getters and setters, for interop 
            with Java.</para></comment>
            -->
        
        </section>
                
    </section>
    
    <!--  
    <section>
        <title>Selectors</title>
        
        <para>Selectors are declared according to the following:</para>
        
        <programlisting>Annotation* Type* 
"selector" Identifier
FormalParams?
"{" 
SelectorValue ("," SelectorValue)*
( ";" ( Attribute | Method )* )? 
"}"</programlisting>
        
        <para>Where:</para>
        
        <programlisting>SelectorValue := Identifier ( "(" ( Expression ("," Expression)* )? ")" )?</programlisting>
        
        <para>
        For example:
        </para>
        
        <programlisting>Public: 
selector DayOfWeek 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>

        <programlisting>Public: 
selector DayOfWeek(String name) 
{ 
    MON("Monday"), TUES("Tuesday"), ...
    
    Public Constant: String name = name;
     
}</programlisting>
        
        <programlisting>Public: 
Comparator&lt;String&gt; 
selector ComparisonOperation { 
    ... 
}</programlisting>
        
        <para>
        The types listed before the <literal>selector</literal> keyword are the supertypes.
        All supertypes of a selector must be interfaces. Any constructors must be private. The 
        semantics of selector declarations and selector interface implementation are exactly the 
        same as for Java <literal>enum</literal>s, except that a Ceylon selector implicitly 
        implements <literal>lang.Selector</literal>, and the above declarations are equivalent to 
        the following Java declarations: 
        </para>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{
         
    MON("Monday"), TUES("Tuesday"), ...
     
    private DayOfWeek(String name) { ... }
    
    ...
    
}</programlisting>
        <programlisting>public enum Comparison 
    implements Comparator&lt;String&gt;, Selector&lt;Comparison&gt; 
{ 
    ... 
}</programlisting>
        
        <para>TODO: let selectors have abstract methods that are overridden by the selector values!</para>
        
    </section>
    -->
    <!--  
    <section id="functors">
        <title>Functors</title>
        
        <para>A functor represents a typed block of code. Functors are declared according to 
        the following:</para>
        
        <programlisting>Annotation* ( Type | "void" ) 
"functor" Identifier TypeParams? 
FormalParams 
TypeConstraintList? 
";"</programlisting>

        <para>TODO: instead of having explicitly declared functor types like <literal>Order&lt;Person&gt;</literal>, 
        we can just provide built-in functor types. If we want more compact type names, we can 
        provide some kind of typedef.</para>

        <para>TODO: let's wait and see what Java 7 does with closures. It will be easier for
        developers to learn something that is aligned with what Java does.</para>
        
        <para>For example:</para>
        
        <programlisting>public Comparison functor Order&lt;T&gt;(T x, T y);</programlisting>
        
        <para>
        A functor declaration is equivalent to a Java abstract class declaration that extends
        <literal>lang.Functor</literal> with a single abstract method declaration. For the example
        above, the equivalent Java declaration is:
        </para>
        
        <programlisting>public abstract class Order&lt;T&gt; 
        extends Functor&lt;Comparison&gt; {
        
    public abstract Comparison call(T x, T y);
    
    protected Order(Object... locals) 
    { 
        super(locals); 
    }
    
}</programlisting>

        <section>
            <title>Functor literals</title>
            
        <para>Consider the following functor literal:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) { x &lt;=&gt; y }</programlisting>
        
        <para>Or:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) x &lt;=&gt; y;</programlisting>
        
        <para>These literals are equivalent to this Java code:</para>

        <programlisting>Order&lt;String&gt; order = new Order&lt;String&gt;() {
    public Comparison call(String x, String y) { 
        return Comparison.compare(x,y); 
    }
};</programlisting>
        
        <para>And this functor invocation:</para>
        
        <programlisting>Boolean result = order("Gavin", "Emmanuel");</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Boolean result = order.call("Gavin", "Emmanuel");</programlisting>
        
        </section>
        
    </section>
    -->
    
    <section id="typealiases">
       <title>Type aliases</title>
    
       <para>A <emphasis>type alias</emphasis> allows a type to be referred to more 
       compactly.</para>
       
       <programlisting>Alias := Annotation* "alias" TypeName TypeParams? Interfaces? TypeConstraints? ";"</programlisting>
       
       <para>A type alias may satisfy any number of interfaces and at most one class.</para>
       
       <!--para>A type alias may satisfy either:</para>
       <itemizedlist>
           <listitem><para>any number of interfaces and at most one class, or</para></listitem>
           <listitem><para>a single functor type.</para></listitem>
       </itemizedlist-->
       
       <para>Any expression which is assignable to all the satisfied types is assignable 
       to the alias type.</para>
              
       <programlisting>public alias People satisfies List&lt;Person&gt;;</programlisting>
       
       <programlisting>package alias ComparableCollection&lt;X&gt; satisfies Collection&lt;X&gt;, Comparable&lt;X&gt;;</programlisting>
       
       <!--programlisting>alias Compare&lt;T&gt; satisfies functor Comparison(T x, T y);</programlisting-->
       
       <para>A shortcut is provided for definition of private aliases.</para>
       
       <programlisting>import java.util.List alias JavaList;</programlisting>
    
    </section>
    
    <section id="extensions">
        <title>Extensions</title>
        
        <para>An extension allows values of one type to be transparently converted to values 
        of another type. Extensions are declared by annotating a method, attribute or class
        <literal>extension</literal>. An extension method must be a static method with exactly 
        one parameter, or a non-static method with no parameters. An extension class must have 
        exactly one initialization parameter. An extension method or attribute must have a 
        non-<literal>optional</literal> type.</para>
        
        <programlisting>public class Person {
    ...
    public extension User user;
}</programlisting>
        
        <programlisting>public static extension User personToUser(Person person) { 
    return person.user; 
}</programlisting>
        
        <programlisting>public extension class CollectionUtils&lt;T&gt;(Collection&lt;T&gt; collection) {
    
    public Collection&lt;T&gt; nonZeroElements() {
        return collection.elements() 
            having (T element) element!=0; 
    }
    
    ...   
}</programlisting>
        
        <para>An extension method is called a converter. An extension class is called a 
        decorator.</para>
        
        <comment><para>Note: I actually much prefer the readability of 
        <literal>User personToUser(extends Person person)</literal> and
        <literal>CollectionUtils&lt;T&gt;(extends Collection&lt;T&gt; collection)</literal>, 
        but this doesn't work for attributes and non-static methods.</para></comment>
        
        <para>The Ceylon compiler searches for an appropriate extension whenever a value of one
        type is assigned to a non-assignable type. If exactly one extension for the two types is 
        found, the compiler inserts a call to the extension.</para>
        
        <programlisting>import org.mydomain.myproject.Converters.personToUser;
...
Person person = ...;
User user = person;</programlisting>
        
        <!--
        <para>Is equivalent to the following Java code:</para>
        
        <programlisting>Person person = ...;
User user = personToUser(person);</programlisting>
        -->
        
        <para>The Ceylon compiler also searches for an appropriate extension whenever a member
        is invoked that is not declared by the type. If exactly one extension that declares the
        member is found for the type, the compiler inserts a call to the extension.</para>
        
        <programlisting>import org.mydomain.myframework.CollectionUtils;
...
Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = ints.nonZeroElements();</programlisting>
        
        <!--
        <para>Is equivalent to this Java code:</para>
    
        <programlisting>Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = new CollectionUtils(collection).nonZeroElements();</programlisting>
        -->
        
        <para>An extension is only available in a source file that explicitly 
        <literal>import</literal>s the extension (except for the extensions
        defined in the package <literal>lang</literal>). A wildcard
        <literal>.*</literal>-style import may not be used to import an 
        extension.</para>
        
    </section>
        
    <section id="declaration modifiers">
        <title>Declaration modifiers</title>
        
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>public</literal>, <literal>module</literal>,
                <literal>package</literal> and <literal>private</literal> 
                determine the visibility of a declaration (by default, the 
                declaration is visible only to statements and declarations 
                that appear later inside the same block).</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated<!--, or that a method or attribute of 
                an abstract class must be implemented by all 
                non-<literal>abstract</literal> subclasses-->.</para>
            </listitem>
            <listitem>
                <para><literal>default</literal> specifies that a method, 
                attribute, or member class may be overridden by subclasses.</para>
            </listitem>
            <listitem>
                <para><literal>override</literal> indicates that a method,
                attribute, or member type overrides a method, attribute, 
                or member type defined by a supertype. The method, 
                attribute, or member type being overridden must be abstract 
                or annotated <literal>default</literal>, and must be visible 
                to the element annotated <literal>override</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>static</literal> specifies that a method can 
                be called without an instance of the type that defines the 
                method.</para>
            </listitem>
            <listitem>
                <para><literal>mutable</literal> specifies that an attribute
                or local may be assigned, or that a class has assignable
                attributes.</para>
            </listitem>
            <listitem>
                <para><literal>optional</literal> specifies that a value may
                be null.</para>
            </listitem>
            <!--listitem>
                <para><literal>final</literal> indicates that a class may not 
                be extended, or that a method or attribute may not be 
                overridden.</para>
            </listitem-->
            <listitem>
                <para><literal>extension</literal> specifies that a method or
                attribute getter is a converter, or that a class is a decorator.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method or
                attribute getter is executed at most once, and the resulting 
                value is cached.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated.</para>
            </listitem>
            <listitem>
                <para><literal>volatile</literal> indicates a volatile simple 
                attribute.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: We can minimize backtracking in the parser by 
        making all these "annotations" be keywords. It lets the parser 
        recognize a member declaration a little bit more easily. But on the
        other hand it's a new special kind of thing.</para></comment>
        
        <comment><para>TODO: should we require an <literal>abstract</literal>
        modifier for abstract methods and attributes of abstract classes
        like Java does?</para></comment>
        
        <comment><para>TODO: should there be an <literal>annotation</literal>
        modifier for static methods which can be used as annotations?</para></comment>
        
        <comment><para>TODO: does Ceylon support static attributes?</para></comment>
            
        <comment><para>TODO: should we support toplevel methods instead of
        methods annotated <literal>static</literal>?</para></comment>

        <para>The following annotation is a hint to the compiler that lets 
        the compiler optimize compiled bytecode for non-64 bit architectures:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>small</literal> specifies that a value of type
                <literal>Natural</literal>, <literal>Integer</literal> or
                <literal>Float</literal> contains 32-bit values.</para>
            </listitem>
        </itemizedlist>
        
        <para>By default, <literal>Natural</literal>, <literal>Integer</literal>
        and <literal>Float</literal> are assumed to represent 64-bit values.</para>
        
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the documentation for
                a program element.</para>
            </listitem>
            <listitem>
                <para><literal>by</literal> specifies the authors of a program 
                element.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The string values of the <literal>doc</literal>, <literal>throws</literal> 
        and <literal>by</literal> annotations are parsed by the documentation
        compiler as Seam Text, a simple ANTLR-based wiki text format.</para>
        
        <para>The following annotations are important to the Ceylon SDK.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>id</literal> specifies that an attribute should
                be tested by the <literal>equals()</literal> method, and included
                in the <literal>hash</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>transient</literal> specifies that an attribute 
                is not included in the serialized form of the object.</para>
            </listitem>
            <listitem>
                <para><literal>read</literal> and <literal>write </literal>
                indicate methods or attributes that are protected from multithreaded
                access using a reentrant read/write lock with deadlock detection.</para>
            </listitem>
        </itemizedlist>
        
    </section>

</chapter>