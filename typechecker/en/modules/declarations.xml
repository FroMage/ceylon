<chapter id="declarations">
    <title>Declarations</title>
    
    <para>All classes, interfaces, methods, attributes and locals must be declared.</para>
    
    <section id="generaldeclarations">
        <title>General declaration syntax</title>
        
        <para>All declarations follow a general pattern.</para> 
      
    <section id="abstractdeclaration">
        <title>Abstract declaration</title>
        
        <para>Declarations conform to the following general schema:</para>
        
        <programlisting>Annotation* 
keyword? Type? (TypeName|MemberName) TypeParams? FormalParams*
Supertype?
Interfaces? 
TypeConstraints? 
Body?</programlisting>

        <para>The Ceylon compiler enforces identifier naming conventions. Types must
        be named with an initial uppercase. Members, parameters and locals must be 
        named with an initial lowercase or underscore.</para>
        
        <programlisting>PackageName := LIdentifier</programlisting>
        <programlisting>TypeName := UIdentifier</programlisting>
        <programlisting>MemberName := LIdentifier</programlisting>
        <programlisting>ParameterName := LIdentifier</programlisting>
        
   </section>
      
    <section id="topleveldeclaration">
        <title>Imports and toplevel declarations</title>
        
        <para>A toplevel declaration defines a type: a class, interface or type alias.</para>
        
        <programlisting>TypeDeclaration := Class | Interface | Alias</programlisting>
        
        <comment><para>TODO: Should we support toplevel method declarations?</para></comment>

        <para>All toplevel types with a visibility modifier less strict than
        <literal>private</literal> must have the same name as the compilation
        unit filename (after removing the file suffix <literal>.ceylon</literal>).
        Unlike Java, a compilation unit may contain multiple toplevel class 
        declarations with the same name.</para>
        
        <para>A compilation unit consists of a list of imported types, followed by
        one or more type definitions:</para>
        
        <programlisting>Import* TypeDeclaration+</programlisting>
        
        <programlisting>Import := "import" ImportPath ("." "*" | "alias" ImportElement)? ";"</programlisting>
        
        <programlisting>ImportPath := ImportElement ("." ImportElement)*</programlisting>
        
        <programlisting>ImportElement := PackageName | TypeName | MemberName</programlisting>
        
        <para>Each compilation unit belongs to exactly one <emphasis>package</emphasis>. 
        A package is a namespace. Code in one compilation unit may refer to a toplevel type 
        defined in another compilation unit in the same package without explicitly importing
        the type. It may refer to a toplevel type defined in a compilation in another package
        only if it explicitly imports the type.</para>
        
     </section>
    
    <section id="annotationlist">
    <title>Annotation list</title>

        <para>Declarations may be preceded by a list of annotations.</para>
    
        <programlisting>Annotation := MemberName ( Arguments | Literal+ )?</programlisting>
        
        <para>Unlike Java, the name of an annotation may not be a qualified name.</para>
        
        <para>For an annotation with no arguments, or with only literal-valued arguments, 
        the parentheses around, and commas between, the positional arguments may be 
        omitted.</para>
        
        <programlisting>doc "The user login action"
throws #DatabaseException 
       "if database access fails"
by "Gavin King"
   "Andrew Haley"
see #LogoutAction.logout
scope(session) 
action { description="Log In"; url="/login"; }
public deprecated</programlisting>

        <para>An annotation is a <literal>static</literal> method invocation that occurs 
        when the type is loaded by the virtual machine. The return value of the invocation 
        is made available via reflection.</para>
        
        <para>For example, the built-in <literal>doc</literal> annotation is declared as 
        follows:</para>
        
        <programlisting>public multiplicity(onceEachElement) 
Description doc(String description) { 
    return Description(description) 
}</programlisting>
        
        <para>The annotation may be specified at a program element using any one of three 
        forms.</para>
        
        <para>Using a positional parameter invocation of the <literal>static</literal> 
        method:</para>
        
        <programlisting>doc("the name") String name;</programlisting>
        
        <para>Using a named parameter invocation of the <literal>static</literal> method:</para>
        
        <programlisting>doc {description="the name";} String name;</programlisting>
        
        <para>Or using the special abbreviated form for annotations with literal value
        arguments:</para>
        
        <programlisting>doc "the name" String name;</programlisting>
        
        <para>And its value may be obtained like this:</para>
        
        <programlisting>Description description = (#Person).annotations(#Description).first;</programlisting>
        
        <para>Unlike Java, the same annotation may appear multiple times for the same
        program element. Furthermore, different annotations (<literal>static</literal> 
        methods) may return values of the same type.</para>
        
        <!--
        <comment>
        <para>TODO: to eliminate backtracking in the parser, we could do one of the
        following things:</para>
        <itemizedlist>
            <listitem>
                <para>require that member declarations with annotations be preceded
                by a <literal>def</literal> keyword,</para>
            </listitem>
            <listitem>
                <para>require that all member declarations be preceded by one of
                <literal>public/module/package/private</literal> or <literal>override</literal>,
                or</para>
            </listitem>
            <listitem>
                <para>surround all the annotations in brackets, like C#.</para>
            </listitem>
        </itemizedlist>
        
        <para>NOTE: we can get much of the value of the <literal>def</literal> keyword with
        a recommendation to developers that they put one of <literal>public/module/package</literal> 
        or <literal>override</literal>, first in the annotation list, and outlaw the use of those 
        identifiers as names of members and local variables. This is enough of a hint to the 
        compiler to eliminate backtracking in almost every case.</para></comment>
        -->
        
    </section>
    
    <section id="type">
        <title>Type</title>
    
        <para>Method, attribute and formal parameter declarations must declare a type.</para>
        
        <programlisting>Type := RegularType | "subtype"</programlisting>
        
        <para>A type is a set of:</para>
        
        <itemizedlist>
            <listitem>
                <para>attributes,</para>
            </listitem>
            <listitem>
                <para>non-<literal>static</literal> methods, and</para>
            </listitem>
            <listitem>
                <para>member classes.</para>
            </listitem>
        </itemizedlist>
        
        <para>A type may be <emphasis>assignable</emphasis> to another type. If <literal>X</literal>
        is assignable to <literal>Y</literal>, then:</para>
        
        <itemizedlist>
            <listitem>
                <para>For each non-<literal>mutable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has an attribute with the same name, whose type is 
                assignable to the type of the attribute of <literal>Y</literal>. The 
                attribute is not <literal>optional</literal> unless the attribute of 
                <literal>Y</literal> is <literal>optional</literal>.</para>
            </listitem>
            <listitem>
                <para>For each <literal>mutable</literal> attribute of <literal>Y</literal>, 
                <literal>X</literal> has a <literal>mutable</literal> attribute with the 
                same name and the same type. The attribute is <literal>optional</literal> 
                if and only if the attribute of <literal>Y</literal> is 
                <literal>optional</literal>.</para>
            </listitem>
            <listitem>
                <para>For each method of <literal>Y</literal>, <literal>X</literal>
                has a method with the same name, with the same formal parameter types, 
                and whose return type is assignable to the return type of the method of 
                <literal>Y</literal>. The method is not <literal>optional</literal> 
                unless the method of <literal>Y</literal> is <literal>optional</literal>.</para>
            </listitem>
            <listitem>
                <para>For each member type of <literal>Y</literal>, <literal>X</literal>
                has a member type of the same name, with the same formal parameter types,
                that is assignable to the member type of <literal>Y</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>Assignability obeys the following rules:</para>
        
        <itemizedlist>
            <listitem>
                <para>Identity: <literal>X</literal> is assignable to <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>Transitivity: if <literal>X</literal> is assignable to <literal>Y</literal>
                and <literal>Y</literal> is assignable to <literal>Z</literal> then
                <literal>X</literal> is assignable to <literal>Z</literal>.</para>
            </listitem>
            <listitem>
                <para>Single root: all types are assignable to <literal>lang.Object</literal>,
                including classes, interfaces, aliases and type parameters.</para>
            </listitem>
        </itemizedlist>
        
        <para>Types are identified by the name of the type (a class, interface, alias or 
        type parameter), together with a list of type arguments if the type definition 
        specifies formal parameters.</para>
        
        <programlisting>RegularType := QualifiedTypeName TypeArguments?</programlisting>
        
        <para>Unlike Java, the name of a type may not be qualified by the package name.</para>
        
        <programlisting>QualifiedTypeName := (TypeName ".")* TypeName</programlisting>
        
        <para>A generic type must specify arguments for the generic type parameters.</para>
        
        <programlisting>TypeArguments := "&lt;" Type ("," Type)* "&gt;"</programlisting>
        
        <para>A type argument is substituted for every appearance of the corresponding
        type parameter in the schema of the parameterized type definition, including:</para>
        
        <itemizedlist>
            <listitem>
                <para>attribute types,</para>
            </listitem>
            <listitem>
                <para>method return types,</para>
            </listitem>
            <listitem>
                <para>method formal parameter types,</para>
            </listitem>
            <listitem>
                <para>initializer formal parameter types, and</para>
            </listitem>
            <listitem>
                <para>type arguments of extended classes and satisfied interfaces.</para>
            </listitem>
        </itemizedlist>
        
        <para>A type argument may itself be a parameterized type or type parameter.</para>
        
        <programlisting>Map&lt;Key, List&lt;Item&gt;&gt;</programlisting>
        
        <para>Every Ceylon class and interface has an implicit type parameter that never
        needs to be declared. This special type parameter, referred to using the keyword 
        <literal>subtype</literal>, represents the concrete type of the current instance 
        (the instance that is being invoked).</para>
        
        <programlisting>public interface Wrapper&lt;out X&gt; {}</programlisting>
        
        <programlisting>public abstract class Wrappable {
   public Wrapper&lt;subtype&gt; wrap() {
       return Wrapper(this);
   }
}</programlisting>
        
        <programlisting>public class Special() extends Wrappable() {}</programlisting>

        <programlisting>Special special = Special();
Wrapper&lt;Special&gt; wrapper = special.wrap();</programlisting>

        <para>For a class declared <literal>final</literal>, any instance of the class
        may be assigned to the type <literal>subtype</literal>. For a class not declared
        <literal>final</literal>, only the <literal>this</literal> reference is
        assignable to <literal>subtype</literal>.</para>
        
        <comment><para>TODO: so this means we really need a <literal>final</literal>
        modifier after all? Is there another solution?</para></comment>
        
        <para>The type <literal>subtype</literal> is considered a covariant type parameter
        of the type, and may only appear in covariant positions of the type definition.</para>
        
        <comment><para>Should we support <literal>Item[]</literal> as a shorthand for
        <literal>Sequence&lt;Item&gt;</literal> or perhaps <literal>List&lt;Item&gt;</literal> 
        and <literal>Item[Key]</literal> as a shorthand for 
        <literal>Correspondence&lt;Item,Key&gt;</literal> or perhaps 
        <literal>Map&lt;Item,Key&gt;</literal>? Should we support <literal>Item...</literal>
        as a shorthand for <literal>Iterable&lt;Item&gt;</literal>?</para></comment>
    
    </section>
    
    <section id="generictypeparameters">
        <title>Generic type parameters</title>
    
        <para>Methods, classes, interfaces and aliases may declare one or more generic type 
        parameters. A class, interface or alias that declares type parameters is called a
        <emphasis>parameterized type</emphasis>. A method that declares type parameters is
        called a parameterized method.</para>
        
        <programlisting>TypeParams := "&lt;" TypeParam ("," TypeParam)* "&gt;"</programlisting>
        
        <para>A class or interface declaration with no type parameters defines exactly one 
        type. A class or interface declaration with type parameters defines a template for
        producing types: one type for each possible combination of type arguments that 
        satisfy the type constraints specified by the class or interface. The types of 
        members of the this type are determined by replacing every appearance of each type 
        parameter in the schema of the parameterized type definition with its type argument.</para>
        
        <para>A method declaration with no type parameters defines exactly one operation 
        per type. A method declaration with type parameters defines a template for producing
        overloaded operations: one operation for each possible combination of type arguments 
        that satisfy the type constraints specified by the method declaration.</para>
        
        <para>A class declaration with no type parameters defines exactly one instantiation 
        operation. A class declaration with type parameters defines a template for producing 
        overloaded instantiation operations: one instantiation operation for each possible 
        combination of type arguments that satisfy the type constraints specified by the 
        class declaration. The type of the object produced by an instantiation operation is 
        determined by substituting the same combination of type arguments for the type 
        parameters of the parameterized class.</para>
        
        <para>A type parameter is itself a type, visible within the body of the declaration
        it parameterizes. A type parameter is assignable to every lower bound of the type 
        parameter.</para>
        
        <para>Each type parameter has a name and a specified <emphasis>variance</emphasis>.</para>
        
        <programlisting>TypeParam := Variance TypeName</programlisting>
        
        <para>A <emphasis>covariant</emphasis> type parameter is indicated using <literal>out</literal>.
        A <emphasis>contravariant</emphasis> type parameter is indicated using <literal>in</literal>.</para>
        
        <programlisting>Variance :=  ("out" | "in")?</programlisting>
        
        <para>A type parameter declared neither <literal>out</literal> nor <literal>in</literal> is
        called <emphasis>nonvariant</emphasis>.</para>
        
        <programlisting>Map&lt;K, V&gt;</programlisting>
        
        <programlisting>Sender&lt;in M&gt;</programlisting>
        
        <programlisting>Container&lt;out T&gt;</programlisting>
        
        <programlisting>BinaryFunction&lt;in X, in Y, out R&gt;</programlisting>
        
        <para>For a generic type <literal>T&lt;X&gt;</literal>, a type <literal>A</literal>,
        and a subtype <literal>B</literal> of <literal>A</literal>:</para>
        
        <itemizedlist>
            <listitem>
                <para>
                    If <literal>X</literal> is a covariant type parameter, 
                    <literal>T&lt;B&gt;</literal> is assignable to <literal>T&lt;A&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is a contravariant type parameter, 
                    <literal>T&lt;A&gt;</literal> is assignable to <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
            <listitem>
                <para>
                    If <literal>X</literal> is nonvariant (neither covariant nor contravariant), 
                    there is no assignability between <literal>T&lt;A&gt;</literal> and 
                    <literal>T&lt;B&gt;</literal>.
                </para>
            </listitem>
        </itemizedlist>
        
        <para>A covariant type parameter may only appear in covariant positions of the type 
        definition. A contravariant type parameter may only appear in contravariant positions 
        of the type definition. Nonvariant type parameters may appear in any position.</para>
        
        <itemizedlist>
            <listitem>
                <para>The return type of a method is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A formal parameter type of a method is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A type parameter of a method is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A formal parameter type of a member class initializer is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A type parameter of a member class is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>The type of a non-<literal>mutable</literal> attribute is a covariant position.</para>
            </listitem>
            <listitem>
                <para>The type of a <literal>mutable</literal> attribute is a nonvariant position.</para>
            </listitem>
            <listitem>
                <para>A lower bound of a type parameter in a covariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A lower bound of a type parameter in a contravariant position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A covariant type parameter of a covariant position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A contravariant type parameter of a covariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A covariant type parameter of a contravariant position is a contravariant position.</para>
            </listitem>
            <listitem>
                <para>A contravariant type parameter of a contravariant position is a covariant position.</para>
            </listitem>
            <listitem>
                <para>A nonvariant type parameter is a nonvariant position.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a functional parameter in a contravariant position is covariant.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a functional parameter in a covariant position is contravariant.</para>
            </listitem>
            <listitem>
                <para>The return type of a functional parameter in a contravariant position is contravariant.</para>
            </listitem>
            <listitem>
                <para>The return type of a functional parameter in a covariant position is covariant.</para>
            </listitem>
        </itemizedlist>
        
    </section>

    <!--section>
        <title>Functor type declaration</title>
    
        <para>There are also functor types:</para>
        
        <programlisting>FunctorType := FunctorHeader FormalParams</programlisting>
        
        <programlisting>FunctorHeader := "functor" Annotation* (Type | "void")</programlisting>
        
        <para>The parameter names in a functor type declaration do not affect assignability
        of the functor type. They are used when the functor is invoked using named parameters.</para>
        
        <para>For example:</para>
        
        <programlisting>functor Comparison(X x, X y)</programlisting>
        <programlisting>functor Boolean(Payment payment)</programlisting>
        <programlisting>functor void(Y element)</programlisting>
        <programlisting>functor optional Object()</programlisting>
        <programlisting>functor Y(optional Y object, Factory&lt;Y&gt; factory)</programlisting>
        
        <para>Functor types are covariant in the return type, and contravariant in the
        parameter types. So <literal>functor String(Object o)</literal> is assignable to
        <literal>functor Object(String s)</literal>.</para>
        
    </section-->

    <section id="formalparameterlist">
        <title>Formal parameter list</title>
    
        <para>Method and class declarations may declare formal parameters, including
        defaulted parameters and a varargs parameter.</para>
        
        <programlisting>FormalParams := 
"("
FormalParam ("," FormalParam)* ("," DefaultParam)* ("," VarargsParam)? | 
DefaultParam ("," DefaultParam)* ("," VarargsParam)? | 
VarargsParam?
")"</programlisting>

        <programlisting>FormalParam := Param | EntryParamPair | RangeParamPair</programlisting>
        
        <para>Each parameter is declared with a type and name and may have annotations and/or
        parameters of its own.</para>
        
        <programlisting>Param := Annotation* (Type|"void") ParameterName FormalParams*</programlisting>
        
        <para>A parameter with its own parameter list (or lists) is called a 
        <emphasis>functional parameter</emphasis>. Think of it as an abstract local method that 
        must be defined by the caller when the method is invoked or the class is instantiated. 
        </para>
            
        <programlisting>(String label, void onClick())</programlisting>
        
        <programlisting>(Comparison by(X x, X y))</programlisting>
        
        <para>Defaulted parameters specify a default argument.</para>
    
        <programlisting>DefaultParam := FormalParam Specifier</programlisting>
        
        <para>The <literal>=</literal> specifier is used throughout the language to indicate a 
        value which cannot be reassigned.</para>
        
        <programlisting>Specifier := "=" Expression</programlisting>
        
        <para>Defaulted parameters must occur after non-defaulted parameters in the formal
        parameter list.</para>
        
        <programlisting>(Product product, Natural quantity=1)</programlisting>
        
        <para>The type of the default argument expression must be assignable to the declared
        type of the formal parameter. It must be a non-<literal>optional</literal> expression,
        unless the parameter is annotated <literal>optional</literal>.</para>
        
        <para>A varargs parameter accepts a list of arguments or a single argument of type 
        <literal>Iterable</literal>. Inside the method, it is available as a local of type
        <literal>Iterable</literal>.</para>
        
        <programlisting>VarargsParam := Annotation* Type "..." ParameterName</programlisting>
        
        <para>The varargs parameter must be the last formal parameter in the list.</para>
        
        <programlisting>(Name name, optional Organization org=null, Address... addresses)</programlisting>
        
        <comment><para>TODO: should we just make <literal>X...</literal> a syntactic shorthand
        for <literal>Iterable&lt;X&gt;</literal> everywhere? Or, alternatively, should we also
        allow <literal>Iterator&lt;X&gt;</literal> to be passed to <literal>X...</literal>?</para></comment>
        
        <para>Parameters of type <literal>Entry</literal> or <literal>Range</literal> 
        may be specified as a pair of variables.</para>
        
        <programlisting>EntryParamPair := Annotation* Type ParameterName "->" Type ParameterName</programlisting>

        <programlisting>RangeParamPair := Annotation* Type ParameterName ".." ParameterName</programlisting>
        
        <para>A variable pair declaration of form <literal>U u -> V v</literal> results in a single 
        parameter of type <literal>Entry&lt;U,V&gt;</literal>.</para>
        
        <programlisting>(Key key -> Value value)</programlisting>
        
        <para>A variable pair declaration of form <literal>T x .. y</literal> results in a single 
        parameter of type <literal>Range&lt;T&gt;</literal>.</para>
        
        <programlisting>(Float value, Integer min..max)</programlisting>
    
        <para>An formal parameter may be annotated <literal>optional</literal>, in which case the 
        parameter accepts a <literal>null</literal> argument.</para>
        
        <para>Otherwise, if the <literal>optional</literal> annotation does not appear, the Ceylon 
        compiler guarantees that the formal parameter never receives a <literal>null</literal> 
        argument. Every argument of the formal parameter must be an expression of 
        non-<literal>optional</literal> type.</para>

        <para>A formal parameter may not be be declared <literal>mutable</literal>, and may not be
        assigned to within the body of the method or class.</para>
        
    </section>
    
    <section id="extendedclass">
        <title>Extended class</title>
    
        <para>A class may extend another class using the <literal>extends</literal> clause.</para>
        
        <programlisting>Supertype := "extends" RegularType PositionalArguments</programlisting>
    
        <para>A class may extend only one superclass. If the superclass is a parameterized
        type, the <literal>extends</literal> clause must specify type arguments.</para>
        
        <programlisting>extends Person(name, org)</programlisting>
    
        <para>Suppose <literal>X</literal> and <literal>Y</literal> are classes.</para>
    
        <itemizedlist>
        <listitem>
            <para>If <literal>X</literal> extends <literal>Y</literal>, then
            <literal>X</literal> is assignable to <literal>Y</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X</literal> extends <literal>Y&lt;B&gt;</literal>, then
            <literal>X</literal> is assignable to <literal>Y&lt;B&gt;</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> extends <literal>Y&lt;T&gt;</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y&lt;B&gt;</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> extends <literal>Y</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
    </section>
    
    <section id="satisfiedinterfaces">
        <title>Satisfied interfaces</title>
    
        <para>Classes and interfaces may satisfy (implement or extend) interfaces, 
        using the <literal>satisfies</literal> clause.</para>
        
        <programlisting>Interfaces = "satisfies" Type ("," Type)*</programlisting>
    
        <para>A class or interface may satisfy multiple interfaces. If a satisfied 
        interface is a parameterized type, the <literal>satisfies</literal> clause 
        must specify type arguments.</para>
        
        <programlisting>satisfies Sequence&lt;T&gt;, Collection&lt;T&gt;</programlisting>
        
        <para>Suppose <literal>Y</literal> is an interface and <literal>X</literal> is
        a class or interface.</para>
    
        <itemizedlist>
        <listitem>
            <para>If <literal>X</literal> satisfies <literal>Y</literal>, then
            <literal>X</literal> is assignable to <literal>Y</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X</literal> satisfies <literal>Y&lt;B&gt;</literal>, then
            <literal>X</literal> is assignable to <literal>Y&lt;B&gt;</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> satisfies <literal>Y&lt;T&gt;</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y&lt;B&gt;</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        <listitem>
            <para>If <literal>X&lt;T&gt;</literal> satisfies <literal>Y</literal>, 
            then <literal>X&lt;B&gt;</literal> is assignable to <literal>Y</literal> 
            for any type <literal>B</literal>.</para>
        </listitem>
        </itemizedlist>
        
    </section>

    <section id="generictypeconstraintlist">
    <title>Generic type constraint list</title>

        <para>Method, class and interface declarations which declare generic type 
        parameters may declare constraints upon the type parameters using the
        <literal>where</literal> clause.</para>
        
        <programlisting>TypeConstraints = "where" TypeConstraint (AMPERSAND TypeConstraint)*</programlisting>
    
        <programlisting>TypeConstraint := TypeName ( ("&gt;="|"&lt;=") Type | "=" "subtype" | FormalParams ) </programlisting>
        
        <para>There are four kinds of type constraints:</para>
        
        <itemizedlist>
            <listitem>
                <para>an upper bound, <literal>X &gt;= T</literal>, specifies that 
                the type parameter <literal>X</literal> is assignable to a given
                type <literal>T</literal>,</para>
            </listitem>
            <listitem>
                <para>a lower bound, <literal>X &lt;= T</literal>, specifies that 
                a given type <literal>T</literal> is assignable to the type parameter 
                <literal>X</literal>,</para>
            </listitem>
            <listitem>
                <para>a subtype bound, <literal>X = subtype</literal>, specifies that 
                the type parameter <literal>X</literal> represents the concrete type
                of the current instance, and</para>
            </listitem>
            <listitem>
                <para>an initialization parameter specification, <literal>X(...)</literal>
                specifies that the type parameter <literal>X</literal> is a class with
                with the given formal parameter types.</para>
            </listitem>
        </itemizedlist>
        
        <para>Subtype bounds are needed since the special type <literal>subtype</literal>
        cannot appear in a contravariant position. A subtype bound cannot be applied to
        a covariant or contravariant type parameter.</para>
        
        <para>Initialization parameter specifications allow instantiation of the generic 
        type.</para>
        
        <para>A constraints affects the type arguments that can be assigned to a type
        parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type argument to a type parameter with a lower bound must be a type 
                which is assignable to the lower bounds.</para>
            </listitem>
            <listitem>
                <para>A type argument to a type parameter with an upper bound must be a type to
                which the upper bound is assignable.</para>
            </listitem>
        </itemizedlist>
        
        <para>A constraint affects the assignability of a type parameter:</para>
        
        <itemizedlist>
            <listitem>
                <para>A type parameter is considered assignable to its lower bound.</para>
            </listitem>
            <listitem>
                <para>The upper bound of a type parameter is considered assignable to the
                type parameter.</para>
            </listitem>
        </itemizedlist>
        
        <para>Mutiple type constraints are seperated by <literal>&amp;</literal>.</para>
        
        <programlisting>where X &gt;= Number&lt;X&gt; &amp; Y = subtype &amp; Y(Natural count)</programlisting>
        
        <comment><para>TODO: Should we use <literal>for</literal> instead of <literal>where</literal>?</para></comment>
        
        <comment><para>TODO: Should we use <literal>satisfies</literal> instead of <literal>>=</literal>? 
        For example <literal>where X satisfies Number&lt;X&gt;</literal>.</para></comment>
    
    </section>
    
    <!--
    <section>
        <title>Declaration examples</title>
        
    <para>For example:</para>
    
    <programlisting>Comparable&lt;Person&gt; Person person = Person(name);</programlisting>
    
    <programlisting>public entity 
class Customer(Name name, optional Organization org = null) 
    extends Person(name, org) 
{
   ... 
}</programlisting>

    <programlisting>public
class HashMap&lt;T&gt;(Iterable&lt;Entry&lt;T&gt;&gt; entries = {})
    extends AbstractCollection&lt;Entry&lt;T&gt;&gt;(entries)
    satisfies Map&lt;T&gt; 
    where T >= Comparable 
{ 
    ... 
}</programlisting>
    
    <programlisting>public interface List&lt;T&gt;
    satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; 
{
    ...
}</programlisting>

    <programlisting>Natural count = 0;</programlisting>
    
    <programlisting>protected String firstName;</programlisting>
    
    <programlisting>public Boolean login() { ... }</programlisting>
    
    <programlisting>public 
String join(Iterable&lt;String&gt; strings, 
            String delimiter = ", ") 
{ 
   ... 
}</programlisting>
    
    <programlisting>public Boolean functor Order&lt;T&gt;(T x, T y);</programlisting>

    <programlisting>public decorator ComparablePerson(Person person) 
    satisfies Comparable&lt;Person&gt; 
{
   ... 
}</programlisting>
               
    <programlisting>public Float converter IntegerToFloat(Integer int) 
{
   return Float(int);
}</programlisting>
    
    <para>Thus, the syntax of Ceylon declarations is more regular than Java or C#.</para>
    
    </section>
    -->
    
    </section>
    
    <section id="classes">
        <title>Classes</title>
        
        <para>A <emphasis>class</emphasis> is a stateful, instantiable type. Classes 
        are declared according to the following:</para>
        
        <programlisting>Class :=
Annotation*
"class" TypeName TypeParams? FormalParams?
Supertype?
Interfaces?
TypeConstraints?
ClassBody</programlisting>

        <programlisting>ClassBody := "{" Instances? (Declaration | Statement)* "}"</programlisting>
        
        <para>The body of a class contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute and member class) declarations,</para>
            </listitem>
            <listitem>
                <para><literal>static</literal> method declarations and nested 
                interface declarations,</para>
            </listitem>
            <listitem>
                <para>instance initialization code, and,</para>
            </listitem>
            <listitem>
                <para>optionally, a list of enumerated named instances of the class.</para>
            </listitem>
        </itemizedlist>

        <programlisting>Declaration := Method | SimpleAttribute | AttributeGetter | AttributeSetter | TypeDeclaration</programlisting>
        
        <para>A class may be annotated <literal>mutable</literal>. If a class is not 
        annotated <literal>mutable</literal> it is called an <emphasis>immutable type</emphasis>, 
        and it may not:</para> 
        
        <itemizedlist>
            <listitem>
                <para>declare or inherit <literal>mutable</literal> attributes,</para>
            </listitem>
            <listitem>
                <para>extend a <literal>mutable</literal> superclass, or</para>
            </listitem>
            <listitem>
                <para>implement an interface annotated <literal>mutable</literal>.</para>
            </listitem>
        </itemizedlist>
    
        <para>Ordinarily, a declaration that occurs in a block of code is a block local
        declaration&mdash;it is visible only to statements and declarations that occur
        later in the same block. This rule is relaxed for certain declarations that occur 
        directly inside a class body:</para>
            
        <itemizedlist>
            <listitem>
                <para>declarations with explicit visibility modifiers&mdash;whose visibility
                is determined by the modifier, and</para>
            </listitem>
            <listitem>
                <para>declarations that occur in the second part of the body of the class, 
                after the last statement of the initializer&mdash;which are visible to all
                other declarations in the second part of the body of the class.</para>
            </listitem>
        </itemizedlist>
        
    <section id="classinitializer">
        <title>Class initializer</title>
        
        <para>Ceylon classes do not support a Java-like constructor declaration syntax. 
        Instead:</para>
        
        <itemizedlist>
           <listitem>
              <para>The body of the class may declare <emphasis>initialization parameters</emphasis>.
              An initialization parameter may be used anywhere in the class body, including in 
              method and attribute definitions.</para>
           </listitem>
           <listitem>
              <para>The initial part of the body of the class is called the <emphasis>initializer</emphasis> 
              and contains a mix of declarations, statements and control structures. The initializer 
              is executed every time the class is instantiated.</para>
           </listitem>
        </itemizedlist>
        
        <para>An initialization parameter may be used to specify or initialize the value of an 
        attrbute:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock = lock;
}</programlisting>
        
        <programlisting>public class Counter(Natural start=0) {
    public mutable Natural count := start;
    public void inc() { count++; }
}</programlisting>
        
        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private final ReadAttribute&lt;Lock&gt; lock;
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) {
        this.lock = new SimpleReadAttribute&lt;Lock&gt;(lock); 
    }
    
}</programlisting>
         -->
        <para>An initialization parameter may even be used within the body of a method,
        attribute getter, or attribute setter:</para>
        
        <programlisting>public class Key(Lock lock) {
    public Lock lock { return lock }
}</programlisting>

        <programlisting>public class Key(Lock lock) {
    public void lock() { lock.engage(this); }
    public void unlock() { lock.disengage(this); }
}</programlisting>

        <!--
        <para>Is equivalent to this Java class:</para>

        <programlisting>public class Key {
    private Lock _lock;
        
    private final ReadAttribute&lt;Lock&gt; lock = new ReadAttribute&lt;Lock&gt;() {
        @Override public Lock get() { return _lock; }
    };
    public ReadAttribute&lt;Lock&gt; lock() { return lock; }
    
    public Key(Lock lock) { 
        _lock = lock; 
    }
    
}</programlisting>
        -->
        
        <para>Class initialization parameters are optional. The following class:</para>
        
        <programlisting>public mutable class Point {
    public mutable Decimal x := 0.0;
    public mutable Decimal y := 0.0;
}</programlisting>

        <para>Is assumed to have zero initialization parameters.</para>
        
        <!--
        <para>Is equivalent to this Java class with a default constructor:</para>
        
        <programlisting>public class Point {
    private final Attribute&lt;Decimal&gt; x = new SimpleAttribute&lt;Decimal&gt;( new Decimal(0.0) );
    public SimpleAttribute&lt;Decimal&gt; x() { return x; }
    
    private final Attribute&lt;Decimal&gt; y = new SimpleAttribute&lt;Decimal&gt;( new Decimal(0.0) );
    public SimpleAttribute&lt;Decimal&gt; y() { return y; }
}</programlisting>
        -->
        
        <comment><para>TODO: is this the right thing to say? Alternatively, we could say that 
        classes without a parameter list can't have statements or initialized simple attributes
        in the body of the class, and get the constructor automatically generated for the 
        list of attributes.</para></comment>
        
        <para>A subclass must pass values to each superclass initialization 
        parameter in the <literal>extends</literal> clause.</para>

        <programlisting>public class SpecialKey1()
        extends Key( new SpecialLock() ) {
    ...
}</programlisting>

        <programlisting>public class SpecialKey2(Lock lock) 
        extends Key(lock) {
    ...
}</programlisting>

        <!--
        <para>Which are equivalent to the Java:</para>
        
        <programlisting>public class SpecialKey1 
        extends Key {
    public SpecialKey1() { 
        super( SpecialLock() );
    }
    ... 
}</programlisting>

        <programlisting>public class SpecialKey2 
        extends Key {
    public SpecialKey2(Lock lock) { 
        super(lock);
    }
    ... 
}</programlisting>
        -->
        
        <para>The class initializer is responsible for initializing the state of a new instance
        of the class, before a reference to the new instance is available to clients.</para>
        
        <programlisting>public mutable class DiagonalPoint(Decimal position) 
        extends Point() {
    
    x := y := sqrt(position**2/2) * position.sign;
    
    assert ("must have distance ${position} from origin") 
        that ( x**2 + y**2 == position**2 );
    
}</programlisting>
        
        <!--
        <para>So the above class is equivalent to:</para>
        
        <programlisting>public class DiagonalPoint extends Point {
        
    public DiagonalPoint(final Decimal position) {
    
        x = y = sqrt( position.power(2).divided(2) ).times(position.sign);
        
        assert_(new F0&lt;String&gt;() {
                   public String call() { 
                       return "must have distance " + position + " from origin";
                   }
                },
                new F0&lt;Boolean&gt;() {
                   public Boolean call() { 
                       return ( x.power(2) + y.power(2) ).equals( position.power(2) );
                   }
                });
    }
    
}</programlisting>
        -->
        
        <para>An initializer may invoke, evaluate or assign members of the current instance 
        of the class (the instance being initialized) without explicitly specifying the 
        receiver.</para>
        
        <para>An initializer of a member class may invoke, evaluate or assign members of the 
        current instance of the containing class (the instance upon which the constructor
        was invoked) without explicitly specifying the receiver.</para>
        
        <comment><para>TODO: Does Ceylon support <literal>static</literal> member classes?</para></comment>
            
        <para>A class may be declared inside the body of a method or attribute, in which case 
        the initializer may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        
        <para>The following restrictions apply to statements and declarations that appear within
        the initializer of the class:</para>
        
        <itemizedlist>
           <listitem>
              <para>They may not evaluate attributes or invoke methods that are declared later
              in the body of the class upon the current object or <literal>this</literal>.</para>
           </listitem>
           <listitem>
              <para>They may not pass <literal>this</literal> as an argument of a method invocation
              or the value of an attribute assignment.</para>
           </listitem>
           <listitem>
              <para>They may not declare an abstract method or attribute.</para>
           </listitem>
           <listitem>
              <para>They may not declare a <literal>default</literal> method or attribute.</para>
           </listitem>
        </itemizedlist>
        
        <para>The remainder of the body of the class consists purely of declarations, including
        abstract and <literal>default</literal> methods and attributes. It may not directly contain 
        statements or control structures, but may freely use <literal>this</literal>, and may 
        invoke any method or evaluate any attribute of the class. The usual restriction that a 
        declaration may only be used by code that appears later in the block containing the 
        declaration is relaxed.</para>
        
        <comment><para>TODO: should class initialization parameters be allowed to be
        declared <literal>public/package/module</literal>, allowing a shortcut
        simple attribute declaration like in Scala?</para></comment>
        
        <!-- comment>
        
        <para>TODO: I would really, really like to believe that one "constructor"
        per class is sufficient, but somehow I'm not quite buying it. We can allow the
        declaration of additional constructors, according to:</para>
        
        <programlisting>Constructor := Annotation* TypeName FormalParams Supertype Block</programlisting>
        
        <para>for example:</para>
        
        <programlisting>public class Person(Name name) {
    public Person(String name) extends Person( Name(name) ) {}
}</programlisting>
        
        </comment-->
                
        <!--
        <section>
        <title>Annotations</title>
        
        <para>Every annotation is a static (non-void) method call. This Ceylon class:</para>
        
        <programlisting>doc "Represents a person"
by "Gavin"
public class Person { ... }</programlisting>
        
        <para>Is equivalent to this Java code:</para>
        
        <programlisting>public class Person { ... 

    static {
        Type&lt;Person&gt; type = Type.get(Person.class);
        type.addAnnotation( doc("Represents a person") );
        type.addAnnotation( by("Gavin") );
        type.addAnnotation( public() );
    }

    ...

}</programlisting>
        
        </section>
        -->

    </section>

        <section id="classinheritance">
             <title>Class inheritance</title>
        
        <para>
        A class may extend another class, and implement any number of interfaces.
        </para>
        
        <programlisting>public mutable
class Customer(Name name, optional Organization org = null) 
        extends Person(name, org) { 
    ... 
}</programlisting>
        <programlisting>class Token() 
        extends Datetime()
        satisfies Comparable&lt;Token&gt;, Identifier {
    ... 
}</programlisting>
        
        <para>
        The types listed after the <literal>satisfies</literal> keyword are the implemented
        interfaces. The type specified after the <literal>extends</literal> keyword is a 
        superclass.
        </para>
        
        <para>
        If a class does not explicitly specify a superclass using <literal>extends</literal>,
        its superclass is <literal>lang.Object</literal>.
        </para>
        
        <para>
        The semantics of class inheritance are exactly the same as Java. A class:
        </para>
        
        <itemizedlist>
            <listitem>
                <para>inherits all members (methods, attributes, and member types) of 
                its superclass, except for members that it <emphasis>overrides</emphasis>,</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which its superclass is assignable,</para>
            </listitem-->
            <listitem>
                <para>must declare or inherit a member that overrides each member of 
                every interface it implements directly or indirectly, unless the class 
                is declared <literal>abstract</literal>, and</para>
            </listitem>
             <listitem>
                <para>must declare or inherit a member that overrides each abstract 
                member of its superclass, unless the class is declared 
                <literal>abstract</literal>.</para>
            </listitem>
            <!--listitem>
                <para>is assignable to any type to which any interface it implements is 
                assignable.</para>
            </listitem-->
        </itemizedlist>
        
        <para>
        Furthermore, the initializer of the superclass is always executed before the
        initializer of the subclass whenever the subclass is instantiated.
        </para>
        
        <!-- 
        <para>and the 
        above declarations are equivalent to the following Java declarations: 
        </para>
        
        <programlisting>public class Customer 
        extends Person {
    public Customer(Name name) { this(name, null); }
    public Customer(Name name, Organization org) { super(name, org); }
    ... 
}</programlisting>
        
        <programlisting>class Token 
        extends Datetime 
        implements Comparable&lt;Token&gt;, Identifier {
    public Token() { super(); }
    ... 
}</programlisting>
         -->
        </section>
       
    <section id="instanceenumeration">
        <title>Class instance enumeration</title>
        
        <para>The keyword <literal>case</literal> is used to specify an enumerated named 
        instance of a class. All <literal>case</literal>s must appear in a list as the 
        first line of a class definition.</para>
        
        <programlisting>Instances := Instance ("," Instance)* ("..." | ";")</programlisting>

        <programlisting>Instance := Annotation* "case" MemberName Arguments?</programlisting>

        <para>If the <literal>case</literal> list ends in <literal>;</literal> instead of 
        <literal>...</literal>, additional instances of the class may not be instantiated.</para>
        
        <para>A class annotated <literal>abstract</literal> may not specify enumerated named
        instances.</para>
        
        <para>A class with type parameters may not specify enumerated named instances.</para>
        
        <programlisting>public class DayOfWeek {
    case sun,
    case mon, 
    case tues, 
    case wed, 
    case thurs, 
    case fri, 
    case sat; 
}</programlisting>

        <programlisting>public class DayOfWeek(String name) {
    doc "Sunday"
        case sun("Sunday"),
    doc "Monday" 
        case mon("Monday"), 
    doc "Tuesday"
        case tues("Tuesday"),
    doc "Wednesday"
        case wed("Wednesday"),
    doc "Thursday"
        case thurs("Thursday"),
    doc "Friday"
        case fri("Friday"),
    doc "Saturday"
        case sat("Saturday");
       
    public String name = name;
    
}</programlisting>

        <comment><para>TODO: If we decide to support static attributes, then each 
        <literal>case</literal> would be considered a static simple attribute.</para></comment>
        
        <para>A class with declared <literal>case</literal>s implicitly extends 
        <literal>lang.Selector</literal>, a subclass of 
        <literal>java.lang.Enum</literal>.</para>
        
        <para>Enumerated instances of a class are instantiated when the class is
        loaded by the virtual machine, with the specified arguments.</para>
        
        <!--
        <para>The above declarations are equivalent to the following Java declarations:</para>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; { 
        
    public static DayOfWeek mon = new DayOfWeek("mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("tues", 1);
    public static DayOfWeek wed = new DayOfWeek("wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("fri", 4);
    public static DayOfWeek sat = new DayOfWeek("sat", 5);
    public static DayOfWeek sun = new DayOfWeek("sun", 6);
    
    private DayOfWeek(String id, int ord) {
        super(id, ord);
    }
    
}</programlisting>
        
        <programlisting>public class DayOfWeek 
        extends Selector&lt;DayOfWeek&gt; {
        
    private final ReadAttribute&lt;String&gt; name;
       
    public static DayOfWeek mon = new DayOfWeek("Monday", "mon", 0); 
    public static DayOfWeek tues = new DayOfWeek("Tuesday", "tues", 1);
    public static DayOfWeek wed = new DayOfWeek("Wednesday", "wed, 2");
    public static DayOfWeek thurs = new DayOfWeek("Thursday", "thurs", 3);
    public static DayOfWeek fri = new DayOfWeek("Friday", "fri", 4);
    public static DayOfWeek sat = new DayOfWeek("Saturday", "sat", 5);
    public static DayOfWeek sun = new DayOfWeek("Sunday", "sun", 6);
     
    private DayOfWeek(String name, String id, int ord)
    {
        super(id, ord);
        name = new SimpleReadAttribute(name);
    }
    
}</programlisting>
        -->
    </section>
    
        <section id="overloadedclasses">
            <title>Overloaded classes</title>
            
            <para>Multiple toplevel classes belonging to the same package, or
            multiple member classes of the same containing class may declare 
            the same name. The classes are called <emphasis>overloaded</emphasis>.
            Overloaded classes:</para>
            
            <itemizedlist>
                <listitem>
                    <para>must extend and overload a common <emphasis>root</emphasis>
                    type,</para>
                </listitem>
                <listitem>
                    <para>must have different formal parameter types,</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters, and</para>
                </listitem>
                <listitem>
                    <para>except for the root type, may not declare any member
                    with a visibility modifier.</para>
                </listitem>
            </itemizedlist>
            
            <para>Then the class name always refers to the root type, except in 
            instantiations. In the case of instantiation, the correct overloaded 
            class is resolved at compile time, using the mechanism that Java
            uses to choose between overloaded constructors.</para>
            
        </section>
        
    <section id="overridingmemberclasses">
        <title>Overriding member classes</title>
        
        <para>A member class annotated <literal>abstract</literal> or
        <literal>default</literal> may be overridden by subclasses of the class 
        which contains the member class. The subclass must declare a member class:</para>
        
        <itemizedlist>
            <listitem>
                <para>annotated <literal>override</literal>,</para>
            </listitem>
            <listitem>
                <para>with the same name as the member class it overrides,</para>
            </listitem>
            <listitem>
                <para>that extends the member class it overrides, and</para>
            </listitem>
            <listitem>
                <para>with the same formal parameter types as the member class it
                overrides.</para>
            </listitem>
        </itemizedlist>
        
        <para>Finally, the overridden member class must be visible to the member
        class annotated <literal>override</literal>.</para>
        
        <para>Then instantiation of the member class is polymorphic, and the actual
        subtype instantiated depends upon the concrete type of the containing class
        instance.</para>
        
        <para>By default, the member class annotated <literal>override</literal> 
        has the same visibility modifier as the member class it overrides. The
        member class may not declare a stricter visibility modifier than the member 
        class it overrides.</para>
            
        <comment><para>TODO: If we decide to support <literal>static</literal> member
        classes, they cannot be overridden.</para></comment>
    
    </section>
        
    </section>
    
    <section id="interfaces">
        <title>Interfaces</title>
        
        <para>An <emphasis>interface</emphasis> is a type which does not specify 
        the implementation of its members. Interfaces may not be directly instantiated. 
        Interfaces are declared according to the following:</para>
        
        <programlisting>Interface :=
Annotation*
"interface" TypeName TypeParams?
Interfaces?
TypeConstraints? 
InterfaceBody</programlisting>

        <programlisting>InterfaceBody := "{" AbstractDeclaration* "}"</programlisting>

        <para>The body of an interface contains:</para>
        
        <itemizedlist>
            <listitem>
                <para>member (method, attribute and member class) declarations, and</para>
            </listitem>
            <listitem>
                <para>nested interface declarations.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>AbstractDeclaration := AbstractMethod | AbstractAttribute | TypeDeclaration</programlisting>

        <para>Interface method and attribute declarations may not specify implementation.</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>

        <!-- 
        <para>Which is equivalent to the following Java interface:</para>

        <programlisting>public interface Comparable&lt;T&gt; {
    Comparison compare(T other);
}</programlisting>
        -->
        
        <para>Interface members inherit the visibility modifier of the interface.</para>
        
        <comment><para>TODO: Refine this. Consider block-local interface declarations.</para></comment>
          
        <section id="interfaceinheritance">
            <title>Interface inheritance</title>
            
            <para>An interface may extend any number of other interfaces.</para>
        
            <programlisting>public interface List&lt;T&gt;
        satisfies Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
        
            <para>
            The types listed after the <literal>satisfies</literal> keyword are the supertypes. All 
            supertypes of an interface must be interfaces.
            </para>
            
            <!--para>
            Since every class that implements an interface is a subclass of <literal>lang.Object</literal>,
            the interface type itself is considered assignable to <literal>lang.Object</literal>.
            </para-->
        
            <para>
            The semantics of interface inheritance are exactly the same as Java. An interface inherits 
            all members (methods, attributes and member types) of every supertype.
        </para>
        
            <!--
            <para>and the above declaration is equivalent to the following 
            Java declaration: 
            </para>
        
            <programlisting>public interface List&lt;T&gt; 
        extends Sequence&lt;T&gt;, Collection&lt;T&gt; {
    ...
}</programlisting>
            -->
            
        </section>
        
    </section>
    
    <!--  
    <section>
        <title>Constructors</title>
        
        <para>Constructors are declared according to the following:</para>
        
        <programlisting>Annotation* Identifier 
FormalParams
( ";" | ClosedBlock )</programlisting>

        <para>
        For example:
        </para>
        
        <programlisting>Public: User(String username, Person person);</programlisting>
        <programlisting>Public: Integer(String string): value = parse(string);</programlisting>
        <programlisting>Public: User(String u, Person p) { username = u; person = p; }</programlisting>
        
        <para>
        The semantics of constructor declarations are identical to Java.
        </para>
        
        <para>
        A constructor body may omit the braces if it consists of exactly one statement. 
        If there is no constructor body at all, the constructor assigns each parameter to
        the attribute with the same name.
        </para>
        
        <para>
        A Ceylon constructor invocation is equivalent to a Java constructor invocation.
        </para>
                
        <programlisting>@FormalParameterNames({"username", "person"}) 
public User(String username, Person person);</programlisting>

    </section>
    -->
    
    <section id="methods">
        <title>Methods</title>
        
        <para>A <emphasis>method</emphasis> is a callable block of code. Methods may have 
        parameters and may return a value. Methods are declared according to the following:</para>
        
        <programlisting>Method := MethodHeader ( Block | Specifier? ";" )</programlisting>

        <programlisting>MethodHeader := Annotation* (Type | "void") MemberName TypeParams? FormalParams+ TypeConstraints?</programlisting>
        
        <para>A method implementation may be specified using either:</para>
        
        <itemizedlist>
            <listitem>
                <para>a block of code, or</para>
            </listitem>
            <listitem>
                <para>a reference to another method.</para>
            </listitem>
        </itemizedlist>
        
        <para>A non-<literal>static</literal> method body may invoke, evaluate or assign 
        members of the current instance of the class which defines the method (the instance 
        upon which the method was invoked) without explicitly specifying the receiver.</para>
        
        <para>A non-<literal>static</literal> method body of a member class may invoke, 
        evaluate or assign members of the current instance of the containing class (the 
        containing instance of the instance upon which the method was invoked) without 
        explicitly specifying the receiver.</para>
        
        <para>A <literal>static</literal> method body may not refer to <literal>this</literal>
        or <literal>super</literal>, since there is no current instance.</para>
        
        <comment><para>TODO: Should we support toplevel methods instead of methods annotated 
        <literal>static</literal>?</para></comment>
        
        <para>A method may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier within the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        
        <programlisting>public Integer add(Integer x, Integer y) {
    return x + y;
}</programlisting>
    
        <programlisting>Identifier createToken() {
    return Token();
}</programlisting>

        <programlisting>public optional U get(optional V key);</programlisting>
        
        <programlisting>public void print(Object... objects) {
    for (Object object in objects) { log.info($object); }
}</programlisting>

        <programlisting>public void addEntry(V key -> U value) { ... }</programlisting>
        
        <programlisting>Float say(String words) = person.say;</programlisting>
        
        <programlisting>Comparison order(String x, String y) = getOrder();</programlisting>
        
        <para>A method may declare multiple lists of parameters. Methods which declare
        more than one parameter list return method references.</para>
        
        <programlisting>Comparison getOrder()(Natural x, Natural y) {
    Comparison order(Natural x, Natural y) { return x&lt;=&gt;y; }
    return order;
}</programlisting>

        <para>A method body may <emphasis>only</emphasis> refer to parameters in the 
        first parameter list. It may not refer to parameters of other parameter lists.
        Parameters declared by parameter lists other than the first parameter list are 
        not considered visible inside the body of the method.</para>
        
        <para>A method reference returned by a method with multiple parameter lists 
        must conform to the signature of the method with multiple parameter lists, 
        after eliminating the first parameter list.</para>

        <para>The Ceylon compiler preserves the names of method parameters, using a Java
        annotation.</para>
        
        <!--
        <programlisting>@FormalParameterNames({"x", "y"}) 
public Integer add(Integer x, Integer y) { ... }</programlisting>
        -->

        <para>A non-<literal>void</literal> method may be annotated <literal>optional</literal>, 
        in which case the method may return a <literal>null</literal> value.</para>
        
        <para>Otherwise, if the <literal>optional</literal> annotation does not appear, the 
        Ceylon compiler guarantees that the method never returns <literal>null</literal>.
        Every <literal>return</literal> directive must specify an expression of 
        non-<literal>optional</literal> type</para>
                
        <para>The semantics of Ceylon methods are identical to Java, except that Ceylon 
        methods may declare defaulted parameters and functional parameters.</para>
        
        <section id="overloadedmethods">
            <title>Overloaded methods</title>
            
            <para>A class may declare or inherit multiple methods with the
            same name. The methods are called <emphasis>overloaded</emphasis>.
            Overloaded methods: </para>
            
            <itemizedlist>
                <listitem>
                    <para>must have different formal parameter types, and</para>
                </listitem>
                <listitem>
                    <para>may not declare default parameters.</para>
                </listitem>
            </itemizedlist>
            
            <para>Like Java, Ceylon resolves overloaded methods at compile time.</para>
        
        </section>
        
       <section id="abstractmethods">
            <title>Interface methods and abstract methods</title>
            
            <para>If there is no method body in a method declaration, the implementation 
            of the method must be specified later in the block, or the class that declares 
            the method must be annotated <literal>abstract</literal>. If no implementation 
            is specified, the method is considered an <emphasis>abstract method</emphasis>.</para>
        
            <para>Methods declared by interfaces never specify an implementation:</para>
        
            <programlisting>AbstractMethod := MethodHeader ";"</programlisting>

            <para>An interface method or abstract method must be overridden by every 
            non-<literal>abstract</literal> class that is assignable to the interface or 
            abstract class type, unless the class inherits a non-abstract method from a 
            superclass which overrides the interface method or abstract method.</para>
            
        </section>
        
        <section id="overridingmethods">
            <title>Overriding methods</title>
            
            <para>An abstract method, interface method, or a method annotated 
            <literal>default</literal> may be overridden by subclasses of the class 
            or interface which declares the method. The subclass must declare a method:</para>
            
            <itemizedlist>
                <listitem>
                    <para>annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>with the same name as the method it overrides,</para>
                </listitem>
                <listitem>
                    <para>the same formal parameter types as the method it overrides,</para>
                </listitem>
                 <listitem>
                    <para>with a return type that is assignable to the return type of 
                    the method it overrides, and</para>
                </listitem>
                <listitem>
                    <para>that is not annotated <literal>optional</literal>, unless the 
                    method it overrides is annotated <literal>optional</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the overridden methos class must be visible to the method
            annotated <literal>override</literal>.</para>
        
            <para>Then invocation of the method is polymorphic, and the actual
            method invoked depends upon the concrete type of the class instance.</para>
            
            <para>By default, the method annotated <literal>override</literal>
            has the same visibility modifier as the method it overrides. The
            method may not declare a stricter visibility modifier than the method 
            it overrides.</para>
            
            <para><literal>static</literal> methods cannot be overridden, and so
            <literal>static</literal> method invocation is never polymorphic.</para>
        
        </section>
        
    </section>
    
    <section id="attributes">
        <title>Attributes</title>
        
        <para>There are three kinds of declarations related to <emphasis>attribute</emphasis> 
        definition:</para>
        
        <itemizedlist>
            <listitem>
                <para>Simple attribute declarations define state (very similar to a 
                Java field or local variable).</para>
            </listitem>
            <listitem>
                <para>Attribute getter declarations define how the value of a derived 
                attribute is obtained.</para>
            </listitem>
            <listitem>
                <para>Attribute setter declarations define how the value of a derived 
                attribute is assigned.</para>
            </listitem>
        </itemizedlist>
        
        <para>Unlike Java fields, Ceylon attribute access is polymorphic and attribute 
        definitions may be overridden by subclasses.</para>
            
        <para>An attribute body may invoke, evaluate or assign members of the current 
        instance of the class which defines the method (the instance upon which the 
        attribute was invoked) without explicitly specifying the receiver.</para>
        
        <para>An attribute body of a member class may invoke, evaluate or assign members 
        of the current instance of the containing class (the containing instance of the 
        instance upon which the attribute was invoked) without explicitly specifying the 
        receiver.</para>
        
        <comment><para>TODO: Does Ceylon support <literal>static</literal> attributes?
        Perhaps just non-<literal>mutable</literal> <literal>static</literal> attributes?</para></comment>
            
        <para>An attribute may be declared inside the body of another method or attribute, in 
        which case it may refer to any non-<literal>mutable</literal> local, block local 
        attribute getter or block local method declared earlier withing the containing scope. 
        It may not refer to <literal>mutable</literal> locals from the containing scope.</para>
        
        <programlisting>package mutable String firstName;</programlisting>
        
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <programlisting>public static Decimal pi = calculatePi();</programlisting>
        
        <programlisting>public String name { return join(firstName, lastName); }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
    
        <programlisting>public Float total {
    Float sum = 0.0;
    for (LineItem li in lineItems) {
        sum += li.amount;
    }
    return sum;
}</programlisting>
        
        <!--
        <para>
        An attribute declaration is equivalent to a Java method declaration together with 
        a Java field declaration, both of type <literal>lang.Attribute</literal> or
        <literal>lang.ReadAttribute</literal>, both with the same name as the attribute.
        </para>
        -->
        
        <para>A simple attribute or attribute getter may be annotated <literal>optional</literal>,
        in which case the attribute may evaluate to <literal>null</literal>, and, if the
        attribute is also <literal>mutable</literal>, may have a null value assigned.</para>
        
        <para>Otherwise, if the <literal>optional</literal> annotation does not appear, the 
        Ceylon compiler guarantees that the attribute cannot evaluate to <literal>null</literal> 
        or have a null value assigned. Every assignment to the attribute must specify an
        expression of non-<literal>optional</literal> type.</para>
        
        <comment><para>TODO: I would like to support <literal>def</literal> in place of the 
        type for a block local attribute or local with an initializer or getter. For 
        example:</para></comment>
        
        <programlisting>def names = List&lt;String&gt;();</programlisting>
        <programlisting>def name { return Name(firstName, initial, lastName); }</programlisting>
        <programlisting>def count:=0;</programlisting>
        
        <section id="simpleattributesandlocals">
            <title>Simple attributes and locals</title>
            
        <para>A simple attribute defines state. Simple attributes are declared according to the 
        following:</para>
        
        <programlisting>SimpleAttribute := AttributeHeader (Specifier | Initializer)? ";"</programlisting>
        
        <programlisting>AttributeHeader := Annotation* Type MemberName</programlisting>
        
        <para>A simple attribute or local annotated <literal>mutable</literal> represents a
        value that can be assigned multiple times. A simple attribute or local not annotated
        <literal>mutable</literal> represents a value that can be specified exactly once.</para>
        
        <para>The value of a non-<literal>mutable</literal> attribute is specified using 
        <literal>=</literal>. A <literal>mutable</literal> attribute may be initialized using 
        the assignment operator <literal>:=</literal>.</para>

        <programlisting>Initializer := ":=" Expression</programlisting>

        <para>Formal parameters of classes and methods are also considered to be simple attributes.</para>
        
        <para>A simple attribute declared directly inside the body of a class represents state 
        associated with the instance of the class. Repeated evaluation of the attribute of a 
        particular instance of the class returns the same result until the attribute of the 
        instance is assigned a new value.</para>
        
        <para>A <emphasis>local</emphasis> represents state associated with execution of a
        particular block of code. A local is really just a special case of a simple attribute 
        declaration, but one whose state is not held across multiple executions of the block
        of code in which the local is defined.</para> 
        
        <itemizedlist>
            <listitem>
                <para>A simple attribute declared inside a block (the body of a method, attribute 
                getter or attribute setter) is a local.</para>
            </listitem>
             <listitem>
                <para>A block local simple attribute declared inside the body of a class is a 
                local if it is not used inside a method, attribute setter or attribute getter 
                declaration.</para>
            </listitem>
           <listitem>
                <para>A formal parameter of a class is a local if it is not used inside a method, 
                attribute setter or attribute getter declaration.</para>
            </listitem>
            <listitem>
                <para>A formal parameter of a method is a local.</para>
            </listitem>
        </itemizedlist>
        
        <para>A local is a block local declaration&mdash;it is visible only to statements and 
        declarations that occur later in the same block or class body, and therefore it may not 
        declare a visibility modifier.</para>
        
        <para>The semantics of locals are identical to Java local variables.</para>
        
        <!--
        <para>For a simple attribute that is not a local, the Java field is initialized to an 
        instance of <literal>lang.SimpleAttribute</literal> or 
        <literal>lang.SimpleReadAttribute</literal>. For example:</para> 
         -->
        
        <programlisting>package mutable String firstName;</programlisting>

        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;String&gt; firstName = new SimpleAttribute&lt;String&gt;();
Attribute&lt;String&gt; firstName() { return firstName; }</programlisting>

        <para>While:</para>
         -->
         
        <programlisting>mutable Natural count := 0;</programlisting>
        
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final Attribute&lt;Natural&gt; count = new SimpleAttribute&lt;Natural&gt;(0);
private Attribute&lt;Natural&gt; count() { return count; }</programlisting>

        <para>And:</para>
        -->
        
        <programlisting>public Integer max = 99;</programlisting>
        <!--
        <para>is equivalent to this Java code:</para>
        
        <programlisting>private final ReadAttribute&lt;Integer&gt; max = new SimpleReadAttribute&lt;Integer&gt;(99);
public ReadAttribute&lt;Integer&gt; max() { return max; }</programlisting>
        -->

        <para>The compiler is permitted to optimize block local simple attributes to a simple 
        Java field declaration or local variable. Block local attributes may not be accessed 
        via reflection.</para>
        
        </section>
        
         <section id="attributegetters">
            <title>Attribute getters</title>
            
            <para>An attribute getter is declared as follows:</para>
            
            <programlisting>AttributeGetter := AttributeHeader Block</programlisting>
            
            <para>An attribute getter defines how the value of a derived attribute is
            obtained.</para>
            
            <!--
            <para>For an attribute getter, the Java field is initialized to an instance 
            of an anonymous inner subclass of <literal>lang.Attribute</literal> or
            <literal>lang.ReadAttribute</literal> that overrides the <literal>get()</literal> 
            method with the content of the getter block. For example: </para>
            -->
        
            <programlisting>public Float total { return items.totalPrice; }</programlisting>
            
            <para>If an attribute getter has a matching attribute setter, we say that 
            the attribute is <literal>mutable</literal>. Otherwise we say it is 
            non-<literal>mutable</literal>.</para>
            
            <!--
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final ReadAttribute&lt;Float&gt; total = new ReadAttribute&lt;Float&gt;() {
    @Override public Float get() { return items.get().totalPrice; }
};
public ReadAttribute&lt;Float&gt; total() { return total; }</programlisting>
            -->
            
        </section>
        
        <section id="attributesetters">
            <title>Attribute setters</title>
                    
            <para>An attribute setter is declared as follows:</para>
            
            <programlisting>AttributeSetter := Annotation* "assign" MemberName Block</programlisting>

            <para>An attribute setter defines how the value of a derived attribute is
            assigned. Every attribute setter must have a corresponding getter with the
            same name.</para>

            <programlisting>public String name { return join(firstName, lastName); }
public assign name { firstName = first(name); lastName = last(name); }</programlisting>
            
            <!--
            <para>For an attribute with a setter, the Java field is initialized to an 
            instance of an anonymous inner subclass of <literal>lang.Attribute</literal> 
            that overrides the <literal>set()</literal> method with the content of the 
            setter block. For example:
            </para>
            -->
            
            <comment><para>TODO: should we allow overloaded attribute setters, for example:</para></comment>
        
            <programlisting>assign Name name { firstName = name.firstName; lastName = name.lastName; }</programlisting>
            
            <!--
            <para>is equivalent to this Java code:</para>
        
            <programlisting>private final Attribute&lt;String&gt; name = new Attribute&lt;String&gt;() {
    @Override public String get() { return join(firstName, lastName); }
    @Override public void set(String name) { firstName = first(name); lastName = last(name); }
};
public Attribute&lt;String&gt; name() { return name; }</programlisting>
            -->
        </section>
        
        <section id="abstractattributes">
            <title>Interface attributes and abstract attributes</title>
            
            <para>If there is no initializer or getter implementation, the value or 
            implementation of the attribute must be specified later in the block, or 
            the class that declares the attribute must be annotated <literal>abstract</literal>. 
            If no value or implementation is specified, and the attribute is not declared 
            <literal>optional</literal>, the attribute is considered an <emphasis>abstract 
            attribute</emphasis>.</para>
        
            <para>Attributes declared by interfaces never specify an initalizer, getter 
            or setter:</para>
        
            <programlisting>AbstractAttribute := AttributeHeader ";"</programlisting>
            
            <para>An interface attribute or abstract attribute must be overridden by every 
            non-<literal>abstract</literal> class that is assignable to the interface or 
            abstract class type, unless the class inherits a non-abstract attribute from a 
            superclass which overrides the interface attribute or abstract attribute.</para>
            
        </section>
        
        <section id="overridingattributes">
            <title>Overriding attributes</title>
            
            <para>An abstract attribute, interface attribute, or attribute annotated 
            <literal>default</literal> may be overridden by subclasses of the class or 
            interface which declares the method. A non-<literal>mutable</literal> 
            attribute may be overridden by a simple attribute or attribute getter. A 
            <literal>mutable</literal> attribute may be overridden by a 
            <literal>mutable</literal> simple attribute or by an attribute getter and 
            setter pair. The subclass must declare an attribute:</para>
            
            <itemizedlist>
                <listitem>
                    <para>annotated <literal>override</literal>,</para>
                </listitem>
                <listitem>
                    <para>with the same name as the attribute it overrides,</para>
                </listitem>
                 <listitem>
                    <para>with a type that is assignable to the type of the attribute it 
                    overrides, if the attribute it overrides is non-<literal>mutable</literal>, 
                    or with exactly the same type as the attribute it overrides, if the 
                    attribute it overrides is <literal>mutable</literal>,</para>
                </listitem>
                <listitem>
                    <para>that is <literal>mutable</literal>, if the attribute it overrides 
                    is <literal>mutable</literal>,</para>
                </listitem>
                <listitem>
                    <para>that is not <literal>optional</literal>, unless the attribute
                    it overrides is <literal>optional</literal>, and</para>
                </listitem>
                <listitem>
                    <para>that is <literal>optional</literal>, if the attribute it overrides 
                    is both <literal>mutable</literal> and <literal>optional</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Finally, the overridden attribute must be visible to the attribute
            annotated <literal>override</literal>.</para>
        
            <para>A non-<literal>mutable</literal> attribute may be overridden by a 
            <literal>mutable</literal> attribute.</para>
            
            <para>Then evaluation and assignment of the attribute is polymorphic, and 
            the actual attribute evaluated or assigned depends upon the concrete type 
            of the class instance.</para>
            
            <para>By default, the attribute annotated <literal>override</literal>
            has the same visibility modifier as the attribute it overrides. The
            method may not declare a stricter visibility modifier than the method 
            it overrides.</para>
            
            <comment><para>TODO: if we decide to support <literal>static</literal> 
            attributes, they can not be overridden.</para></comment>
            
        </section>
        
        <!--section id="getterandsettermethods">
            <title>Getter and setter methods</title>
            
            <para>For each attribute, one or two methods exist implicitly:</para>
            
            <itemizedlist>
                <listitem>
                    <para>a <emphasis>getter method</emphasis> with no parameters 
                    which returns the attribute type, and</para>
                </listitem>
                <listitem>
                    <para>a <literal>void</literal> <emphasis>setter method</emphasis> 
                    with a single parameter of the attribute type, if the attribute is 
                    <literal>mutable</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>These methods may be referred to using the <literal>get</literal> and 
            <literal>set</literal> keywords, for example:</para>
            
            <programlisting>String name = get person.name();</programlisting>
            <programlisting>set person.name(newName);</programlisting>
            
        
        </section-->
                
    </section>
    
    <!--  
    <section>
        <title>Selectors</title>
        
        <para>Selectors are declared according to the following:</para>
        
        <programlisting>Annotation* Type* 
"selector" Identifier
FormalParams?
"{" 
SelectorValue ("," SelectorValue)*
( ";" ( Attribute | Method )* )? 
"}"</programlisting>
        
        <para>Where:</para>
        
        <programlisting>SelectorValue := Identifier ( "(" ( Expression ("," Expression)* )? ")" )?</programlisting>
        
        <para>
        For example:
        </para>
        
        <programlisting>Public: 
selector DayOfWeek 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>

        <programlisting>Public: 
selector DayOfWeek(String name) 
{ 
    MON("Monday"), TUES("Tuesday"), ...
    
    Public Constant: String name = name;
     
}</programlisting>
        
        <programlisting>Public: 
Comparator&lt;String&gt; 
selector ComparisonOperation { 
    ... 
}</programlisting>
        
        <para>
        The types listed before the <literal>selector</literal> keyword are the supertypes.
        All supertypes of a selector must be interfaces. Any constructors must be private. The 
        semantics of selector declarations and selector interface implementation are exactly the 
        same as for Java <literal>enum</literal>s, except that a Ceylon selector implicitly 
        implements <literal>lang.Selector</literal>, and the above declarations are equivalent to 
        the following Java declarations: 
        </para>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{ 
    MON, TUES, WED, THURS, FRI, SAT, SUN 
}</programlisting>
        
        <programlisting>public enum DayOfWeek 
    implements Selector&lt;DayOfWeek&gt; 
{
         
    MON("Monday"), TUES("Tuesday"), ...
     
    private DayOfWeek(String name) { ... }
    
    ...
    
}</programlisting>
        <programlisting>public enum Comparison 
    implements Comparator&lt;String&gt;, Selector&lt;Comparison&gt; 
{ 
    ... 
}</programlisting>
        
        <para>TODO: let selectors have abstract methods that are overridden by the selector values!</para>
        
    </section>
    -->
    <!--  
    <section id="functors">
        <title>Functors</title>
        
        <para>A functor represents a typed block of code. Functors are declared according to 
        the following:</para>
        
        <programlisting>Annotation* ( Type | "void" ) 
"functor" Identifier TypeParams? 
FormalParams 
TypeConstraintList? 
";"</programlisting>

        <para>TODO: instead of having explicitly declared functor types like <literal>Order&lt;Person&gt;</literal>, 
        we can just provide built-in functor types. If we want more compact type names, we can 
        provide some kind of typedef.</para>

        <para>TODO: let's wait and see what Java 7 does with closures. It will be easier for
        developers to learn something that is aligned with what Java does.</para>
        
        <para>For example:</para>
        
        <programlisting>public Comparison functor Order&lt;T&gt;(T x, T y);</programlisting>
        
        <para>
        A functor declaration is equivalent to a Java abstract class declaration that extends
        <literal>lang.Functor</literal> with a single abstract method declaration. For the example
        above, the equivalent Java declaration is:
        </para>
        
        <programlisting>public abstract class Order&lt;T&gt; 
        extends Functor&lt;Comparison&gt; {
        
    public abstract Comparison call(T x, T y);
    
    protected Order(Object... locals) 
    { 
        super(locals); 
    }
    
}</programlisting>

        <section>
            <title>Functor literals</title>
            
        <para>Consider the following functor literal:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) { x &lt;=&gt; y }</programlisting>
        
        <para>Or:</para>
        
        <programlisting>Order&lt;String&gt; order = (String x, String y) x &lt;=&gt; y;</programlisting>
        
        <para>These literals are equivalent to this Java code:</para>

        <programlisting>Order&lt;String&gt; order = new Order&lt;String&gt;() {
    public Comparison call(String x, String y) { 
        return Comparison.compare(x,y); 
    }
};</programlisting>
        
        <para>And this functor invocation:</para>
        
        <programlisting>Boolean result = order("Gavin", "Emmanuel");</programlisting>
        
        <para>Is equivalent to this Java code:</para>

        <programlisting>Boolean result = order.call("Gavin", "Emmanuel");</programlisting>
        
        </section>
        
    </section>
    -->
    
    <section id="typealiases">
       <title>Type aliases</title>
    
       <para>A <emphasis>type alias</emphasis> allows a type to be referred to more 
       compactly.</para>
       
       <programlisting>Alias := Annotation* "alias" TypeName TypeParams? Interfaces? TypeConstraints? ";"</programlisting>
       
       <para>A type alias may satisfy any number of interfaces and at most one class.</para>
       
       <!--para>A type alias may satisfy either:</para>
       <itemizedlist>
           <listitem><para>any number of interfaces and at most one class, or</para></listitem>
           <listitem><para>a single functor type.</para></listitem>
       </itemizedlist-->
       
       <para>The alias type is assignable to all of the satisfied types.</para>
              
       <para>Any expression which is assignable to all the satisfied types is assignable 
       to the alias type.</para>
       
       <programlisting>public alias People satisfies List&lt;Person&gt;;</programlisting>
       
       <programlisting>package alias ComparableCollection&lt;X&gt; satisfies Collection&lt;X&gt;, Comparable&lt;X&gt;;</programlisting>
       
       <!--programlisting>alias Compare&lt;T&gt; satisfies functor Comparison(T x, T y);</programlisting-->
       
       <para>A shortcut is provided for definition of private aliases.</para>
       
       <programlisting>import java.util.List alias JavaList;</programlisting>
    
    </section>
    
   <section id="declaration modifiers">
        <title>Declaration modifiers</title>
        
        <para>In Ceylon, all declaration modifiers are ordinary annotations.</para>
        
    <section id="compilerinstructions">
        <title>Summary of compiler instructions</title>
        
        <para>The following annotations are compiler instructions:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>public</literal>, <literal>module</literal>,
                <literal>package</literal> and <literal>private</literal> 
                determine the visibility of a declaration (by default, the 
                declaration is visible only to statements and declarations 
                that appear later inside the same block).</para>
            </listitem>
            <listitem>
                <para><literal>abstract</literal> specifies that a class
                cannot be instantiated<!--, or that a method or attribute of 
                an abstract class must be implemented by all 
                non-<literal>abstract</literal> subclasses-->.</para>
            </listitem>
            <listitem>
                <para><literal>default</literal> specifies that a method, 
                attribute, or member class may be overridden by subclasses.</para>
            </listitem>
            <listitem>
                <para><literal>override</literal> indicates that a method,
                attribute, or member type overrides a method, attribute, 
                or member type defined by a supertype.</para>
            </listitem>
            <listitem>
                <para><literal>static</literal> specifies that a method can 
                be called without an instance of the type that defines the 
                method.</para>
            </listitem>
            <listitem>
                <para><literal>mutable</literal> specifies that an attribute
                or local may be assigned, or that a class has assignable
                attributes.</para>
            </listitem>
            <listitem>
                <para><literal>optional</literal> specifies that an attribute,
                local, parameter, or method return value may be null.</para>
            </listitem>
            <!--listitem>
                <para><literal>final</literal> indicates that a class may not 
                be extended, or that a method or attribute may not be 
                overridden.</para>
            </listitem-->
            <listitem>
                <para><literal>extension</literal> specifies that a method or
                attribute getter is a converter, or that a class is a decorator.</para>
            </listitem>
            <listitem>
                <para><literal>deprecated</literal> indicates that a method, 
                attribute or type is deprecated. It accepts an optional
                <literal>String</literal> argument.</para>
            </listitem>
            <listitem>
                <para><literal>volatile</literal> indicates a volatile simple 
                attribute.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: We can minimize backtracking in the parser by 
        making all these "annotations" be keywords. It lets the parser 
        recognize a member declaration a little bit more easily. But on the
        other hand it's a new special kind of thing.</para></comment>
        
        <comment><para>TODO: Should we require an <literal>abstract</literal>
        modifier for abstract methods and attributes of abstract classes
        like Java does?</para></comment>
        
        <para>The following annotation is a hint to the compiler that lets 
        the compiler optimize compiled bytecode for non-64 bit architectures:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>small</literal> specifies that a value of type
                <literal>Natural</literal>, <literal>Integer</literal> or
                <literal>Float</literal> contains 32-bit values.</para>
            </listitem>
        </itemizedlist>
        
        <para>By default, <literal>Natural</literal>, <literal>Integer</literal>
        and <literal>Float</literal> are assumed to represent 64-bit values.</para>
        
    </section>
       
       <!--
       <para>The following annotations are important to the Ceylon SDK.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>id</literal> specifies that an attribute should
                be tested by the <literal>equals()</literal> method, and included
                in the <literal>hash</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>transient</literal> specifies that an attribute 
                is not included in the serialized form of the object.</para>
            </listitem>
            <listitem>
                <para><literal>read</literal> and <literal>write</literal>
                indicate methods or attributes that are protected from multithreaded
                access using a reentrant read/write lock with deadlock detection.</para>
            </listitem>
            <listitem>
                <para><literal>once</literal> indicates that a method or
                attribute getter is executed at most once, and the resulting 
                value is cached.</para>
            </listitem>
        </itemizedlist>
        -->
        
    <section id="visibility">
        <title>Visibility and name resolution</title>
        
        <para>Classes, interfaces, aliases, methods, attributes, locals, formal parameters 
        and type parameters have names. Occurrence of a name in code implies a hard 
        dependency from the code in which the name occurs to the schema of the named 
        declaration. We say that a class, interface, alias, method, attribute, formal 
        parameter or type parameter is <emphasis>visible</emphasis> to a certain program 
        element if its name may occur in the code that defines that program element.</para>
        
        <itemizedlist>
            <listitem>
                <para>A formal parameter or type parameter is never visible outside the 
                declaration it belongs to.</para> 
            </listitem>
            <listitem>
                <para>Any declaration that occurs inside a block (the body of a method, 
                attribute getter or attribute setter) is not visible to code outside the 
                block.</para>
            </listitem>
        </itemizedlist>
        
        <para>The visibility of any other declaration depends upon its <emphasis>visibility
        modifier</emphasis>, if any. By default:</para>
        
        <itemizedlist>
            <listitem>
                <para>a declaration that occurs directly inside a class body is not
                visible to code outside the class definition, and</para>
            </listitem>
            <listitem>
                <para>a toplevel declaration is not visible to code outside the 
                package containing its compilation unit.</para>
            </listitem>
        </itemizedlist>
        
        <para>The visibility of a declaration with a visibility modifier annotation
        is determined by the visibility modifier:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>private</literal> specifies that the declaration is 
                visible to all code in the same compilation unit,</para>
            </listitem>
            <listitem>
                <para><literal>package</literal> specifies that the declaration is 
                visible to all code in any compilation unit in the same package,</para>
            </listitem>
            <listitem>
                <para><literal>module</literal> specifies that the declaration is 
                visible to all code in any package in the same module,</para>
            </listitem>
            <listitem>
                <para><literal>public</literal> specifies that the declaration is 
                visible to all code in any module.</para>
            </listitem>
        </itemizedlist>
        
        <para>If two named declarations visible to some program element have the same 
        name, and if they are not overloaded forms of the same class or method, then 
        that name may not be used inside the program element unless:</para>
            
        <itemizedlist>
            <listitem>
                <para>One declaration occurs in a block, class body, or interface body
                that is contained, directly or indirectly, inside the block, class 
                body, or interface body that directly contains the other declaration. 
                In this case, the name resolves to the inner declaration inside the 
                block, class body, or interface body in which it occurs. We say that
                the inner declaration name <emphasis>hides</emphasis> the outer 
                declaration name.</para>
            </listitem>
            <listitem>
                <para>One declaration is a class initialization parameter, and the other 
                declares a member of the class. In this case the name resolves to the 
                class initialization parameter inside the body of the class. We say that
                the initialization parameter name <emphasis>hides</emphasis> the class
                member name.</para>
            </listitem>
        </itemizedlist>
        
        <para>The class <literal>lang.Visibility</literal> defines the visibility 
        levels:</para>
        
        <programlisting>public class Visibility {
        
    doc "A program element visible to all 
         compilation units."
    case public, 
    
    doc "A program element visible to  
         compilation units in the same
         module."
    case module, 

    doc "A program element visible to  
         compilation units in the same
         package."
    case package, 

    doc "A program element visible to  
         the compilation unit in which
         its is declared."
    case private, 
    
    doc "A program element local to the
         block in which it is defined."
    case local; 
    
    doc "The |public| visibility modifier 
         annotation."
    public static oncePerElement Visibility public() { 
        return public 
    }
    
    doc "The |module| visibility modifier 
         annotation."
    public static oncePerElement Visibility module() { 
        return module
    }
    
    doc "The |package| visibility modifier 
         annotation."
    public static oncePerElement Visibility package() { 
        return package 
    }
    
    doc "The |private| visibility modifier 
         annotation."
    public static oncePerElement Visibility private() { 
        return private 
    }
    
}</programlisting>
                
    </section>
    
    <section id="extensions">
        <title>Extensions</title>
        
        <para>An extension allows values of one type to be transparently converted to 
        values of another type. Extensions are declared by annotating a method, attribute 
        or class <literal>extension</literal>. An extension must be:</para>
        
        <itemizedlist>
            <listitem>
                <para>a <literal>static</literal>, non-<literal>optional</literal> method 
                with exactly one formal parameter,</para>
            </listitem>
            <listitem>
                <para>a non-<literal>static</literal>, non-<literal>optional</literal> 
                method with no formal parameters,</para>
            </listitem>
            <listitem>
                <para>a toplevel class with exactly one initialization parameter,</para>
            </listitem>
            <listitem>
                <para>a member class with no initialization parameters, or</para>
            </listitem>
            <listitem>
                <para>a non-<literal>optional</literal> attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>An <literal>static</literal> extension method is called a <emphasis>converter</emphasis>. 
        An toplevel extension class is called a <emphasis>decorator</emphasis>.</para>
        
        <para>Extensions apply to a certain <emphasis>extended type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for static extension methods, the extended type is the declared
                type of the formal parameter,</para>
            </listitem>
            <listitem>
                <para>for non-<literal>static</literal> extension methods, the extended 
                type is the type that declares the extension method,</para>
            </listitem>
            <listitem>
                <para>for toplevel extension classes, the extended type is the declared 
                type of the initialization parameter,</para>
            </listitem>
            <listitem>
                <para>for member extension classes, the extended type is the type that 
                contains the member class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the extended type is the type that 
                declares the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>Extensions define an <emphasis>introduced type</emphasis>:</para>
        
        <itemizedlist>
            <listitem>
                <para>for extension methods, the introduced type is the declared
                return type of the method,</para>
            </listitem>
            <listitem>
                <para>for extension classes, the introduced type is the class, and</para>
            </listitem>
            <listitem>
                <para>for extension attributes, the introduced type is the declared
                type of the attribute.</para>
            </listitem>
        </itemizedlist>
        
        <para>The introduced type may not be a <literal>mutable</literal> type.</para>
        
        <programlisting>public class Person {
    ...
    public extension User user;
}</programlisting>
        
        <programlisting>public static extension User personToUser(Person person) { 
    return person.user; 
}</programlisting>
        
        <programlisting>public extension class CollectionUtils&lt;T&gt;(Collection&lt;T&gt; collection) {
    
    public Collection&lt;T&gt; nonZeroElements() {
        return collection.elements() 
            having (T element) element!=0; 
    }
    
    ...   
}</programlisting>
        
        <comment><para>Note: I actually much prefer the readability of 
        <literal>User personToUser(extends Person person)</literal> and
        <literal>CollectionUtils&lt;T&gt;(extends Collection&lt;T&gt; collection)</literal>, 
        but this doesn't work for attributes and non-<literal>static</literal> methods.</para></comment>
        
        <para>We say that an extension class or <literal>static</literal> method is 
        <emphasis>enabled</emphasis> in a compilation unit if the class or <literal>static</literal> 
        method is imported by that compilation unit.</para>
        
        <programlisting>import org.domain.app.Extensions.personToUser;
import org.domain.utils.CollectionUtils;</programlisting>

        <para>A wildcard <literal>.*</literal>-style import may not be used to import an 
        extension.</para>
        
        <para>An extension attribute, member class or non-<literal>static</literal> method is 
        enabled in every compilation unit.</para>
        
        <para>If an extension is enabled in a compilation unit, the extended type is assignable
        to the introduced type in that compilation unit.</para>
        
        <programlisting>import org.mydomain.myproject.Converters.personToUser;
...
Person person = ...;
User user = person;</programlisting>
        
        <!--
        <para>Is equivalent to the following Java code:</para>
        
        <programlisting>Person person = ...;
User user = personToUser(person);</programlisting>
        -->
        
        <programlisting>import org.mydomain.myframework.CollectionUtils;
...
Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = ints.nonZeroElements();</programlisting>
        
        <!--
        <para>Is equivalent to this Java code:</para>
    
        <programlisting>Collection&lt;Integer&gt; ints = ...;
Collection&lt;Integer&gt; result = new CollectionUtils(collection).nonZeroElements();</programlisting>
        -->
        
        <para>An introduced type may result in an ambiguity:</para>
        
        <itemizedlist>
            <listitem>
                <para>the extended type may have an attribute with the same name as an attribute
                of the introduced type, or</para>
            </listitem>
            <listitem>
                <para>the extended type may have a method with the same name and parameter types 
                as a method of the introduced type.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: What about ambiguities with multiple introduced types?</para></comment>
        
        <para>In this case, the attribute or method of the extended type is considered to override
        the method of the introduced type.</para>
        
        <comment><para>TODO: Or should we say the opposite?! What about using the <literal>override</literal>
        annotation to decide?</para></comment>
        
        <para>When an invocation of an introduced method or evaluation of an introduced attribute 
        is executed, or when an instance of the extended type is assigned to a program element
        of the introduced type, the extension is invoked to produce an instance of the introduced
        type that will receive the invocation or evaluation.</para>
        
    </section>
    
    <section id="annotationconstraints">
        <title>Annotation constraints</title>
        
        <para>The following annotations constrain the occurence of an annotation. By default, 
        an annotation may appear multiple times on any program element.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>inherited</literal> specifies that the annotation is automatically 
                inherited by subtypes.</para>
            </listitem>
            <listitem>
                <para><literal>multiplicity</literal> specifies that the annotation may occur at 
                most once in a certain scope. Its accepts one or more arguments of type
                <literal>Multiplicity</literal>: <literal>onceEachElement</literal>, 
                <literal>onceEachType</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>ofElements</literal> specifies the kinds of program element 
                at which the annotation occurs. Its accepts one or more arguments of type
                <literal>Element</literal>: <literal>class</literal>, <literal>interface</literal>,
                <literal>method</literal>, <literal>attribute</literal>, <literal>alias</literal>,
                <literal>parameter</literal>.</para>
            </listitem>
            <listitem>
                <para><literal>withType</literal> specifies that the annotation may only 
                be applied to types that are assignable to the specified type, to
                attributes or parameters of the specified type, or to methods with the
                specified return type.</para>
            </listitem>
            <listitem>
                <para><literal>withParameterTypes</literal> specifies that the annotation 
                may only be applied to methods with the specified formal parameter types.</para>
            </listitem>
            <listitem>
                <para><literal>withAnnotation</literal> specifies that the may only be 
                applied to program elements at which the specified annotation occurs.</para>
            </listitem>
        </itemizedlist>
        
        <para>These annotations are applied to the static method declaration that defines an
        annotation, and the constraints are checked by the compiler.</para>
        
        <programlisting>public static ofElements(class) multiplicity(onceEachType)
Entity entity(LockMode lockMode) { return Entity(lockMode) }</programlisting>

        <programlisting>public static ofElements(attribute, parameter) withType(String) multiplicity(onceEachElement)
Pattern pattern(Regex regex) { return Pattern(regex) }</programlisting>
            
        <comment><para>TODO: Should there be an <literal>annotation</literal>
        modifier for static methods which can be used as annotations?</para></comment>
        
    </section>
    
    <section id="documentationcompiler">
        <title>Documentation compiler</title>
    
        <para>The following annotations are instructions to the documentation
        compiler:</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>doc</literal> specifies the description of a 
                program element.</para>
            </listitem>
            <listitem>
                <para><literal>by</literal> specifies the authors of a program 
                element.</para>
            </listitem>
            <listitem>
                <para><literal>see</literal> specifies a related member or 
                type.</para>
            </listitem>
            <listitem>
                <para><literal>throws</literal> specifies a thrown exception
                type.</para>
            </listitem>
        </itemizedlist>
        
        <para>The <literal>String</literal> arguments to the <literal>deprecated</literal>, 
        <literal>doc</literal>, <literal>throws</literal> and <literal>by</literal> 
        annotations are parsed by the documentation compiler as Seam Text, a 
        simple ANTLR-based wiki text format.</para>
        
        <para>These annotations are defined by the class 
        <literal>doc.Documentation</literal>:</para>
        
        <programlisting>public class Documentation {
    
    public static Description doc(String description) {
        return Description(description)
    }
    
    public static Sequence&lt;Author&gt; by(String... authors) {
        return from (String author in authors) select Author(author)
    }
    
    public static RelatedElement see(ProgramElement pe, String description=null) {
        return Related(pe, description)
    }
    
    public static ThrownException see(Type type&lt;Exception&gt;, String description=null) {
        return Related(type, description)
    }
    
}</programlisting>
        
        <comment><para>TODO: should <literal>see</literal> and <literal>throws</literal>
        accept a list of <literal>Entry</literal> instead? For example:</para>
<programlisting>see #Ruby->"if you are bored with Java" 
    #Ceylon->"if you want to get some real work done"</programlisting></comment>
        
     </section>
        
     </section>

</chapter>