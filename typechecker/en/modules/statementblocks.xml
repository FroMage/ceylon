<chapter id="statementblocks">
    <title>Blocks and control structures</title>
    
    <para>Method, attribute, and class bodies contain procedural code that is executed 
    when the method or attribute is invoked, or when the class is instantiated. The 
    code contains expressions and control directives and is organized using blocks and 
    control structures.</para>
    
    <para>The Ceylon language has a recursive block structure&mdash;statements and
    declarations that are syntactically valid in the body of a toplevel declaration 
    are, in general, also syntactically valid in the body of a nested declaration or 
    of a control structure, and vice-versa.</para>
    
    <para>There exist two exceptions to this rule:</para>
    
    <itemizedlist>
        <listitem>
            <para>a class body may not end in a control directive,</para>
        </listitem>
        <!--
        <listitem>
            <para>an enumerated named instance list may only appear directly in the body 
            of a toplevel class, and</para> 
        </listitem>
        -->
        <listitem>
            <para>the body of an interface may contain only abstract declarations.</para>
        </listitem>
    </itemizedlist>
        
    <comment><para>TODO: a named argument list looks very much like a block, but is not 
    currently defined that way. The language would be more regular if we decided to just 
    make it a block.</para></comment>
        
    <comment><para>TODO: Note that Java does not let you define an interface inside a 
    method, so we should either add the same restriction, or figure out workaround. Java 
    doesn't let you define a method inside a method either, but we can wrap the nested 
    method in an anonymous class.</para></comment>
    
    <comment><para>TODO: Note that in Java, all nested classes of interfaces are considered 
    static inner classes. This results in a very funny semantic for a class nested inside 
    an interface nested inside another class: the class does not have access to the members 
    of the containing class. In Ceylon, a nested class is allowed to invoke all its 
    containing types. We need to figure out how to implement this. Also consider the related 
    case of a class nested inside an interface nested inside a method.</para></comment>
            
    <section id="declarationvisibilityandblockstructure">
        <title>Declaration visibility and block structure</title>
    
        <para>The scope of a declaration is governed by the block in which it occurs.</para>
    
    <section id="nameresolution">
        <title>Name resolution</title>
        
        <para>An unqualified identifier (an identifier not preceded by <literal>.</literal>,
        <literal>[].</literal> or <literal>?.</literal>) that appears in a program 
        element refers to a declaration elsewhere: a class, interface, alias, method, 
        attribute, or local.</para>
        
        <para>A <emphasis>body</emphasis> is a block, class body or interface body.
        A declaration is <emphasis>in scope</emphasis> at a program element if:</para>
        
        <itemizedlist>
            <listitem>
                <para>it is a formal parameter, type parameter, or control structure 
                variable of a body that contains the program element, or</para>
            </listitem>
            <listitem>
                <para>it directly occurs earlier in a body that contains the program 
                element, or</para>
            </listitem>
            <listitem>
                <para>it directly occurs in an interface body, and the program element 
                also occurs in the interface body, or</para>
            </listitem>
            <listitem>
                <para>it directly occurs in the second part of a class body, after the 
                last statement or declaration of the initializer, and the program element 
                also occurs in the second part of the class body, or</para>
            </listitem>
            <listitem>
                <para>it is a declaration imported by the compilation unit containing 
                the program element and is visible to the program element, or</para>
            </listitem>
            <listitem>
                <para>it is a toplevel declaration in the package containing the program
                element and is visible to the program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>If there is no declaration with the specified name in scope at the program
        element where the specified name occurs, a compilation error occurs.</para>
        
        <para>If multiple declarations with the specified name are in scope at the program
        element where the specified name occurs, the name refers to the declaration which
        is not <emphasis>hidden</emphasis> by another declaration:</para>
        
        <itemizedlist>
            <listitem>
                <para>if an inner body is contained (directly or indirectly) in an outer body, 
                a declaration, formal parameter, type parameter or control structure variable 
                of the inner body hides a declaration, formal parameter, type parameter or 
                control structure variable in the outer body,</para>
            </listitem>
            <listitem>
                <para>a formal parameter of a class body hides an attribute of the class,</para>
            </listitem>
            <listitem>
                <para>a declaration occurring in a body containing the program element 
                hides a declaration imported by the compilation unit, and</para>
            </listitem>
            <listitem>
                <para>a declaration imported by the compilation unit hides a toplevel 
                declaration of the package containing the program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>If there are multiple unhidden declarations with the specified name, and 
        they are not all overloaded declarations of the same method or class, the name 
        is ambiguous, and a compilation error occurs.</para>
        
        <para>A body may not contain two declarations with the same name unless they are 
        overloaded versions of the same method or class, or unless one is a formal parameter 
        of the class body and the other is an attribute of the class. A package may not 
        contain two toplevel declarations with the same name unless they are overloaded 
        versions of the same method or class.</para>
        
        <para>Note that this code is not legal:</para>
        
        <programlisting>String uppercase(String string) {
    String string = string.uppercase;  //compiler error!
    return string;
}</programlisting>

        <para>However, this code <emphasis>is</emphasis> legal, since class initialization 
        parameters and attributes may share a name:</para>
        
        <programlisting>public class Person(String name) {
    public String name = name;
}</programlisting>

        <para>Note that this code is not legal:</para>
        
        <programlisting>Entry&lt;Float,Float&gt; xy() {
    Float x { return y }  //compiler error!
    Float y { return x }
    return x->y
}</programlisting>

        <para>Nor is this code legal, since all three statements occur inside the
        initializer of the class:</para>
        
        <programlisting>class Point() {
    Float x { return y }  //compiler error!
    Float y { return x }
    Entry&lt;Float,Float&gt; xy = x->y;
}</programlisting>

        <para>However, this code <emphasis>is</emphasis> legal, since the statements do not 
        occur in the initializer of the class:</para>
        
        <programlisting>class Point() {
    Float x { return y }
    Float y { return x }
}</programlisting>
    
    </section>
    
        <section id="nesteddeclarationsandclosure">
            <title>Nested declarations and closure</title>
        
            <para>Blocks may contain declarations. A declaration that occurs in a block is a 
            block local declaration&mdash;it is visible only to statements and declarations 
            that occur later in the same block, and therefore it may not declare a visibility 
            modifier.</para>
            
            <para>A block may not contain a method or attribute declaration annotated 
            <literal>abstract</literal>, <literal>default</literal>, <literal>fixed</literal>, 
            or <literal>override</literal>.</para>
            
            <para>Class and interface bodies also contain declarations. Unlike a declaration 
            nested inside a block, a declaration directly contained in the body of a class 
            may declare a visibility modifier, thus making the member accessible outside the 
            body of the class. similarly, a declaration contained in the body of an interface
            inherits the visibility modifier of the interface, making the member accessible 
            outside the body of the interface.</para>
            
            <para>The body of a nested class, method, or attribute declaration may invoke, 
            evaluate, or assign any class, method, or attribute whose declaration is in scope 
            at the nested declaration, except for <literal>mutable</literal> locals of a 
            containing method or attribute.</para>
            
            <para>If the nested declaration is nested directly or indirectly inside a class or 
            interface declaration, then there is always a <emphasis>current instance</emphasis> 
            of the class or interface when the nested declaration body is executed. The current 
            instance is determined as follows:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for the innermost class or interface declaration that contains the 
                    nested declaration, the current instance is the receiving instance of the
                    invocation, evaluation, or assignment, and</para>
                </listitem>
                <listitem>
                    <para>for any other class or interface that contains the nested declaration,
                    the current instance is the same object that was the current instance when
                    the initializer of the current instance of the innermost class or interface 
                    declaration was executed.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>Outer outer = Outer();
Inner inner = outer.Inner();
inner.member();</programlisting>
            
            <para>In this example, <literal>inner</literal> is the current instance of 
            <literal>Inner</literal> when <literal>member()</literal> is executed, and
            <literal>outer</literal> is the current instance of <literal>Outer</literal>.</para>
                        
            <para>If the nested declaration is nested directly or indirectly inside a block,
            then there is always a <emphasis>current frame</emphasis> of the block when the
            nested declaration is executed. The current frame contains the values of all
            non-<literal>mutable</literal> locals declared by the block. The current frame
            is determined as follows:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the nested declaration is nested directly inside the block,
                    the current frame contains the current values at the point of execution
                    of the value reference expression or callable reference expression that
                    refers to the nested declaration, or, otherwise</para>
                </listitem>
                <listitem>
                    <para>if the nested declaration is contained inside the body of another
                    nested declaration, the current frame is the current frame of the 
                    containing declaration at the point of execution of the value reference 
                    expression or callable reference expression that refers to the nested 
                    declaration.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>String outer(String s)()() {
    String middle()() {
        String inner() {
            return s;
        }
        return inner
    }
    return middle
}

String middle()() = outer("hello");
String inner() = middle();
String result = inner();</programlisting>

            <programlisting>Object outer(String s) {
    object middle {
        override String string {
            return s;
        }
    }
    return middle
}

Object middle = outer("hello");
String result = middle.string;</programlisting>

            <para>In both examples, <literal>result</literal> refers to the value 
            <literal>"hello"</literal>.</para>
            
            <para>The set of <!--all declarations which belong directly to a containing body of a 
            nested declaration, together with the --> current instances of containing classes and 
            interfaces and current frames of containing blocks is called the 
            <emphasis>closure</emphasis> of the nested declaration.</para>           
            
        </section>
        
    <section id="containingbodies">
        <title>Access to declarations of containing bodies</title>

        <para>The initializer of a class, or the body of a member of a class may invoke, 
        evaluate or assign members of the current instance of the class which defines the 
        initializer or member&mdash;the instance being instantiated or invoked&mdash;without 
        explicitly specifying the receiver, or by specifying a self reference 
        <literal>this</literal> as the receiver.</para>

        <para>The initializer of a member class, or the body of a member of a member class
        or nested interface may invoke, evaluate or assign members of the current instance 
        of the containing class or interface&mdash;the parent instance of the instance being 
        instantiated or invoked&mdash;without explicitly specifying the receiver, or by 
        specifying an outer instance reference <literal>outer</literal> as the receiver.</para>

        <para>A toplevel method or attribute body may not refer to a self reference or outer 
        instance reference, since there is no current instance.</para>

        <para>The body of a method, class, or attribute nested inside the body of another 
        method or attribute may invoke or evaluate any non-<literal>mutable</literal> local, 
        block local attribute getter or block local method declared earlier within the 
        containing scope. It may not refer to <literal>mutable</literal> locals defined 
        within the containing method or attribute body.</para>
        
        <para>When a member is hidden by a block local declaration, the member may be
        accessed via the self reference <literal>this</literal> or via the outer instance
        reference <literal>outer</literal>. For example:</para>
        
        <programlisting>public class Item(String name) {
    mutable String name := name;
    public void changeName(String name) {
        this.name := name;
    }
}</programlisting>
        
            <programlisting>class Catalog(String name) {
    String name = name;
    class Schema(String name) {
        String name = name;
        String catalogName { return outer.name }
        class Table(String name) {
            String name = name;
            String schemaName { return outer.name }
            String catalogName { return outer.outer.name }
        }
    }
}</programlisting>
    
        </section>
    
    </section>
    
    <section id="blocksandstatements">
        <title>Blocks and statements</title>
            
        <para>A <emphasis>block</emphasis> is list of semicolon-delimited statements, 
        method, attribute and local declarations, and control structures, surrounded by 
        braces. Some blocks end in a control directive. The statements, local specifiers 
        and control structures belonging to a block are executed sequentially in the 
        order that they appear inside the block. Execution of a block begins at the first 
        statement, local specifier, or control structure of the block. Execution of a block 
        terminates when the last statement, local specifier, or control structure of the 
        block finishes executing, when a control directive that terminates the block is 
        executed, or when an exception is thrown.</para>

        <programlisting>Block := "{" (Declaration | Statement)* DirectiveStatement? "}"</programlisting>
        
        <para>A <emphasis>statement</emphasis> is an assignment or specification, an 
        invocation of a method, an instantiation of a class, a control structure or a 
        control directive.</para>

        <programlisting>Statement := ExpressionStatement | Specification | ControlStructure</programlisting>
        
        <para>A simple attribute or local may not be used in an expression until its value 
        has been explicitly specified or initialized. The Ceylon compiler guarantees this
        by evaluating all conditional branches that lead to the first use of an attribute
        of local in an expression. Each conditional branch must specify or assign a value 
        to the simple attribute or local before using it in an expression.</para>
        
        <para>Every simple attribute of a non-<literal>abstract</literal> class must be 
        explicitly specified or initialized by the initializer of the class or by the
        initializer of one of its superclasses. The Ceylon compiler guarantees this by 
        evaluating all conditional branches that lead to termination of the initializer
        without an uncaught exception. Each conditional branch must specify or assign a 
        value to the simple attribute before the initializer terminates without an uncaught 
        exception.</para>
        
        <para>A simple attribute or local may not be the target of a specifier expression 
        if its value has already been specified. The Ceylon compiler guarantees this by 
        evaluating all conditional branches that lead to the use of a simple attribute or 
        local in a specifier expression. No conditional branch may specify a value to the 
        simple attribute or local before using it in a specifier expression.</para>
        
        <para>Every non-<literal>void</literal> method or attribute getter must terminate in
        the execution of a <literal>return</literal> or <literal>throw</literal> directive. 
        The Ceylon compiler guarantees this by evaluating all conditional branches that lead 
        to termination of the method. Each conditional branch must end in a 
        <literal>return</literal> or <literal>throw</literal> directive.</para>
        
        <para>Every block local declaration must be used somewhere inside the block in which
        it is declared.</para>
        
        <comment><para>TODO: chapter 16 of the JLS goes into way more detail about the notion
        of "definite assignment" and "definite unassignment". We eventually need something
        more like this level of detail, I suppose.</para></comment>
        
        <comment><para>TODO: should we allow blocks and control structures to be annotated, 
        for example:</para>
        <programlisting>doc "unsafe assignment" 
suppressWarnings(typesafety)
do { 
    apple = orange;
}</programlisting>
<programlisting>doc "synchronize on the lock"
try (lock) { ... }</programlisting>
</comment>
        
        <section id="expressionstatements">
            <title>Expression statements</title>
            
        <para>Only certain expressions are valid statements:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignment,</para>
            </listitem>
            <listitem>
                <para>prefix or postfix increment or decrement,</para>
            </listitem>
            <listitem>
                <para>invocation of a method,</para>
            </listitem>
            <listitem>
                <para>instantiation of a class.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>ExpressionStatement := ( Assignment | IncrementOrDecrement | Invocation ) ";"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>x := 1;</programlisting>
        <programlisting>x++;</programlisting>
        <programlisting>log.info("Hello");</programlisting>
        <programlisting>Main(p);</programlisting>
        
        <!-- 
        <comment><para>TODO: it would be possible to say that any expression is a valid
        statement, but this seems to just open up more potential programming errors. So
        I think it's better to limit statements to assignments, invocations
        and instantiations.</para></comment>
        <comment><para>TODO: should we let you leave off the <literal>;</literal> on the last
        expression statement in the block, like we do for directives?</para></comment>
        -->
                
        </section>
        
        <section id="controldirectives">
            <title>Control directives</title>
            
        <para>Control directive statements end execution of the current block and force 
        the flow of execution to resume in some outer scope. They may only appear at the 
        end of a block, so the semicolon terminator is optional.</para>

        <programlisting>DirectiveStatement := Directive ";"?</programlisting>
        
        <para>Ceylon provides the following control directives:</para>
        
        <itemizedlist>
            <listitem>the <literal>return</literal> directive&mdash;to return a value from a method 
            or attribute getter,</listitem>
            <listitem>the <literal>break</literal> directive&mdash;to terminate a loop,</listitem>
            <listitem>the <literal>continue</literal> directive&mdash;to jump to the next iteration 
            of a loop,</listitem>
            <listitem>the <literal>throw</literal> directive&mdash;to raise an exception, and</listitem>
            <listitem>the <literal>retry</literal> directive&mdash;to re-execute a <literal>try</literal> 
            block, reinitializing all resources.</listitem>
        </itemizedlist>
                
        <programlisting>Directive := Return | Throw | Break | Continue | Retry</programlisting>

        <para>For example:</para>
        
        <programlisting>throw Exception()</programlisting>
        <programlisting>retry</programlisting>
        <programlisting>return x+y</programlisting>
        <programlisting>return "Hello"</programlisting>
        <programlisting>break true</programlisting>
        <programlisting>continue</programlisting>
        
        <para>The <literal>return</literal> directive may not appear outside the body of 
        a method or attribute getter. In the case of a <literal>void</literal> method, no 
        expression may be specified. In the case of a non-<literal>void</literal> method 
        or attribute getter, an expression must be specified. The expression type must be 
        assignable to the return type of the method. When the directive is executed, the 
        expression is evaluated to determine the return value of the method or attribute 
        getter.</para>
        
        <programlisting>Return := "return" Expression?</programlisting>
        
        <para>The <literal>break</literal> directive may not be appear outside the body 
        of a loop. If the loop has no <literal>fail</literal> block, the <literal>break</literal> 
        directive may not specify an expression. If the loop has a <literal>fail</literal> 
        block, the <literal>break</literal> directive must specify an expression of 
        type <literal>ceylon.language.Boolean</literal>. When the directive is executed, the expression 
        is evaluated and a value of <literal>false</literal> specifies that the 
        <literal>fail</literal> block should be executed.</para>
        
        <programlisting>Break := "break" Expression?</programlisting>
        
        <para>The <literal>continue</literal> directive may not be appear outside the body 
        of a loop.</para>
        
        <programlisting>Continue := "continue"</programlisting>
        
        <para>A <literal>throw</literal> directive may appear anywhere and may specify an 
        expression of type <literal>ceylon.language.Exception</literal>. When the directive is executed, 
        the expression is evaluated and the resulting exception is thrown. If no expression 
        is specified, the directive is equivalent to <literal>throw Exception()</literal>.</para>
        
        <programlisting>Throw := "throw" Expression?</programlisting>
        
        <comment><para>TODO: Crazy idea: let <literal>...</literal> be a shortcut for
        <literal>throw NotYetImplemented()</literal>. Too cute?</para></comment>
        
        <para>A <literal>retry</literal> directive may not appear outside of a
        <literal>catch</literal> block.</para>
        
        <programlisting>Retry := "retry"</programlisting>
        
        <!--comment><para>TODO: We could support <literal>for/fail</literal> loops 
        that return a value by supporting a <literal>found expr</literal> directive. 
        We could support conditionals that return a value by adding a 
        <literal>then expr</literal> directive.</para></comment-->
        
        </section>
        
        <section id="specificationstatements">
            <title>Specification statements</title>
            
        <para>A specification statement may specify the value of a non-<literal>mutable</literal> 
        attribute or local that has already been declared earlier in the block. It may 
        even specify a value of type <literal>Callable</literal> for a method that was 
        declared earlier in the block.</para>
        
        <programlisting>Specification := MemberName Specifier ";"</programlisting>
                
        <para>The Ceylon language distinguishes between assignment to a <literal>mutable</literal> 
        value (the <literal>:=</literal> operator) and specification of the value of a 
        non-<literal>mutable</literal> local or attribute (using <literal>=</literal>). 
        A specification is not an expression.</para>
        
        <para>The specified expression type must be assignable to the type of the 
        attribute or local.</para>
        
        <para>A specification may appear inside an control structure, in which case the
        compiler validates that all paths result in a properly specified method or 
        attribute. For example:</para>
        
        <programlisting>String description;
Comparison order(X x, X y);
if (reverseOrder()) {
    description = "Reverse order";
    order = reverse;
}
else {
    description = "Natural order";
    order = natural;
}</programlisting>

        </section>
        
    </section>
    
    <section id="controlstructures">
        <title>Control structures</title>
        
        <para>Control of execution flow may be achieved using control directives and 
        control structures. Control structures include conditionals, loops, and 
        exception management. <!--For many tasks, the use of these traditional control
        structures is considered bad style, and the use of expressions with functor 
        parameters is preferred. However, control structures support the use of the 
        <literal>return</literal> and <literal>break</literal> directives, whereas 
        functors do not. Therefore, some tasks may be accomplished only with control 
        structures.--></para>

        <para>Ceylon provides the following control structures:</para>
        
        <itemizedlist>
            <listitem>
                <para>the <literal>if/else</literal> conditional&mdash;for controlling execution 
                based upon a boolean value, and dealing with null values,</para>
            </listitem>
            <listitem>
                <para>the <literal>switch/case/else</literal> conditional&mdash;for controlling 
                execution using an enumerated list of values,</para>
            </listitem>
            <listitem>
                <para>the <literal>while</literal> and <literal>do/while</literal> loops&mdash;for 
                loops which terminate based upon the value of a boolean expression,</para>
            </listitem>
            <listitem>
                <para>the <literal>for/fail</literal> loop&mdash;for looping over elements of a 
                collection, and</para>
            </listitem>
            <listitem>
                <para>the <literal>try/catch/finally</literal> exception manager&mdash;for managing 
                exceptions and controlling the lifecycle of objects which require explicit destruction.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>ControlStructure := IfElse | SwitchCaseElse | While | DoWhile | ForFail | TryCatchFinally</programlisting>
       
        <para>Control structures are not considered to be expressions, and therefore do not evaluate
        to a value.</para>
        
        <comment><para>TODO: Should we support, like Java, single-statement control structure bodies 
        without the braces.</para></comment>
        
        <section id="controlstructurevariables">
            <title>Control structure variables</title>
       
        <para>Some control structures allow embedded declaration of a <emphasis>variable</emphasis> 
        that is available inside the control structure body.</para>
        
        <programlisting>Variable := Type MemberName</programlisting>
        
        <para>In certain cases, the explicit type be omitted, forcing the compiler to infer it, by 
        specifying the keyword <literal>local</literal> where the type usually appears. The type of 
        the variable is inferred to be the type of the expression that follows.</para>
        
        <programlisting>InferableVariable := InferableType MemberName FormalParams*</programlisting>
        
        <para>A variable is treated as a formal parameter of the control structure body.</para>
        
        </section>
        
        <section id="controlstructureconditions">
            <title>Control structure conditions</title>
            
        <para>Some control structures expect conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>a <emphasis>boolean condition</emphasis> is satisfied when a boolean expression
                evaluates to <literal>true</literal>,</para>
            </listitem>
            <listitem>
                <para>an <emphasis>existence condition</emphasis> is satisfied when an expression of
                type <literal>Optional&lt;X&gt;</literal> evaluates to a non-null value,</para>
            </listitem>
            <listitem>
                <para>a <emphasis>nonemptiness condition</emphasis> is satisfied when an expression 
                of type <literal>Optional&lt;Container&gt;</literal> evaluates to a non-null, non-empty 
                value, and</para>
            </listitem>
            <listitem>
                <para>an <emphasis>assignabilty condition</emphasis> is satisfied when an expression
                 of type <literal>Object</literal> evaluates to an instance of a type assignable to 
                 the specified type.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: does <literal>is</literal> really test assignability, or should it 
        it test that the value is an instance of a <emphasis>subtype</emphasis> of the given type?</para></comment>
        
        <programlisting>Condition := Expression | ExistsCondition | IsCondition</programlisting>
       
        <programlisting>ExistsCondition := ("exists" | "nonempty") (InferableVariable Specifier | Expression)</programlisting>
       
        <programlisting>IsCondition := "is" (Variable Specifier | Type Expression)</programlisting>
        
        <para>Any condition contains an expression. In the case of existence, nonemptiness and 
        assignability conditions, the expression may be a specifier of a variable declaration.</para>

        <para>The type of a condition expression depend upon whether the <literal>exists</literal>, 
        <literal>nonempty</literal> or <literal>is</literal> modifier appears:</para>

        <itemizedlist>
            <listitem>
                <para>If no <literal>is</literal>, <literal>exists</literal> or <literal>nonempty</literal> 
                modifier appears, the condition must be an expression of type <literal>Boolean</literal>.</para>
            </listitem>
            <listitem>
                <para>If the <literal>is</literal> modifier appears, the condition expression must 
                be of type <literal>Object</literal>.</para>
            </listitem>
            <listitem>
                <para>If the <literal>exists</literal> modifier appears, the condition expression 
                must be of type <literal>Optional&lt;X&gt;</literal> for some type 
                <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>If the <literal>nonempty</literal> modifier appears, the condition must be an 
                expression of type <literal>Optional&lt;Container&gt;</literal>.</para>
            </listitem>
        </itemizedlist>

        <para>For <literal>exists</literal> or <literal>nonempty</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>If the condition declares a variable, the variable must be declared of 
                type <literal>X</literal>, where the specifier expression is of type 
                <literal>Optional&lt;X&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>If the condition expression is a local, the local will be treated by the 
                compiler as non-<literal>mutable</literal> and as having type <literal>X</literal> 
                inside the block that follows immediately, where the conditional expression is of 
                type <literal>Optional&lt;X&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>If you prefer, you can think of the following:</para>
        
        <programlisting>if (exists name) { ... }</programlisting>
        
        <para>As an abbreviation of:</para>
        
        <programlisting>if (exists String name = name) { ... }</programlisting>
        
        <para>Where the <literal>name</literal> declared by the condition hides the outer declaration
        of <literal>name</literal> inside the block that follows.</para>
        
        <comment><para>Note: I suppose we could have a <literal>nonempty</literal> condition on 
        a <literal>Sequence&lt;X&gt;</literal> let you treat <literal>seq.first</literal> and
        <literal>seq.last</literal> as type <literal>X</literal> instead of <literal>X?</literal>,
        but the danger is that the list could change underneath us. And we do already have the idiom 
        <literal>if (exists X first = seq.first) { doSomething(first); }</literal> which is only 
        a little more verbose than <literal>if (nonempty seq) { doSomething(seq.first); }</literal>
        </para></comment>
                        
        <para>For <literal>is</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>If the condition declares a variable, the specifier expression type need 
                not be assignable to the declared type of the variable, or</para>
            </listitem>
            <listitem>
                <para>if the condition is a local, the local will be treated by the compiler 
                as non-<literal>mutable</literal> and as having the specified type inside the block 
                that follows immediately.</para>
            </listitem>
        </itemizedlist>
                        
        <para>If you prefer, you can think of the following:</para>
        
        <programlisting>if (is Usable obj) { ... }</programlisting>
        
        <para>As an abbreviation of:</para>
        
        <programlisting>if (is Usable obj = obj) { ... }</programlisting>
        
        <para>Where the <literal>obj</literal> declared by the condition hides the outer declaration
        of <literal>obj</literal> inside the block that follows.</para>
        
        <para>The semantics of a condition depend upon whether the <literal>exists</literal>, 
        <literal>nonempty</literal> or <literal>is</literal> modifier appears:</para>

        <itemizedlist>
            <listitem>
                <para>If no <literal>is</literal>, <literal>exists</literal> or <literal>nonempty</literal> 
                modifier appears, the condition is satisfied if the expression evaluates to 
                <literal>true</literal> when the control structure is executed.</para>
            </listitem>
            <listitem>
                <para>If the <literal>is</literal> modifier appears, the condition is satisfied 
                if the expression evaluates to an instance of a class that is assignable to the 
                specified type when the control structure is executed.</para>
            </listitem>
            <listitem>
                <para>If the <literal>exists</literal> modifier appears, the condition is satisfied 
                if the expression evaluates to an instance of <literal>Something&lt;X&gt;</literal> 
                when the control structure is executed.</para>
            </listitem>
            <listitem>
                <para>If the <literal>nonempty</literal> modifier appears, the condition is satisfied 
                if the expression evaluates to an instance of <literal>Something&lt;Container&gt;</literal> 
                for which <literal>value.empty</literal> evaluates to <literal>false</literal>
                when the control structure is executed.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that these are formal definitions. In fact, the compiler erases 
        <literal>Optional&lt;T&gt;</literal> to <literal>T</literal> before generating bytecode.
        So <literal>if (exists x)</literal> is actually processed as <literal>if (x!=null)</literal>
        by the virtual machine.</para>
        
        <comment><para>TODO: should we have a new kind of condition which directly compares types,
        allowing you to treat multiple variables as having the tested type inside the block, for 
        example:</para>
        <programlisting>List&lt;X&gt; xs = ...;
X x = ...;
if (X satisfies Comparable&lt;X&gt;) {
    X x0;
    if (exists X first = xs.first) {
        x0 = max(x, first);
    }
    else {
        x0 = x;
    }
    return forAll(X y in xs) every (x&lt;=x0)
}</programlisting>
        <programlisting>String string&lt;P...&gt;(Tuple&lt;P...&gt; tuple) {
    if (T, Q... satisfies P...) {
        return $tuple.head + ", " + string(tuple.tail);
    }
    else {
        return ";"
    }
}</programlisting></comment>

        </section>
        
        <section id="ifelse">
            <title><literal>if/else</literal></title>
            
            <para>The <literal>if/else</literal> conditional has the following form:</para>
            
            <programlisting>IfElse := If Else?</programlisting>

            <programlisting>If := "if" "(" Condition ")" Block</programlisting>
            
            <programlisting>Else := "else" (Block | IfElse)</programlisting>

            <!--programlisting>IfElse := 
"if" "(" Condition ("," Condition)* ")"
( ClosedBlock | OpenBlock "else" ClosedBlock )</programlisting-->

            <para>When the construct is executed, the condition is evaluated. If the condition is 
            satisfied, the <literal>if</literal> block is executed. Otherwise, the <literal>else</literal> 
            block, if any, is executed.</para>

            <!--para>Condition expressions may refer to any local variable defined by a previous
            condition.</para-->
            
            <para>An <literal>if</literal> conditional may ensure initialization of a local variable 
            or attribute or termination of a non-<literal>void</literal> method or attribute getter 
            in a <literal>return</literal> or <literal>throw</literal> directive only if it has an 
            <literal>else</literal> block.</para>
                    
            <para>For example:</para>
            
            <programlisting>if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid := true;
}
else {
    throw NotEnoughMoneyException()
}</programlisting>

            <programlisting>public void welcome(User? user) {
    if (exists user) {
        log.info("Hi " user.name "!");
    }
    else {
        log.info("Hello World!");
    }
}</programlisting>
            
            <programlisting>public Payment payment(Order order) {
    if (exists Payment p = order.payment) {
        return p
    }
    else { 
        return Payment(order)
    }
}</programlisting>

            <programlisting>if (exists Payment p = order.payment) {
    if (p.paid) { 
        log.info("already paid"); 
    }
}</programlisting>
            
            <programlisting>if (is CardPayment p = order.payment) {
    return p.card
}</programlisting>
            
        </section>
        
        <section id="switchcaseelse">
            <title><literal>switch/case/else</literal></title>
            
            <para>The <literal>switch/case/else</literal> conditional has the following form:</para>
            
            <programlisting>SwitchCaseElse := Switch ( Cases | "{" Cases "}" )</programlisting>
            
            <programlisting>Switch := "switch" "(" Expression ")"</programlisting>
            
            <programlisting>Cases := CaseItem+ DefaultCaseItem?</programlisting>

            <programlisting>CaseItem := "case" "(" Case ")" Block</programlisting>
            <programlisting>DefaultCaseItem := "else" Block</programlisting>

            <para>The <literal>switch</literal> expression may be of any type. Each <literal>case</literal> 
            value must be a list of expressions of type assignable to <literal>Matcher&lt;X&gt;</literal>, 
            where <literal>X</literal> is the <literal>switch</literal> expression type. Alternatively, 
            a <literal>case</literal> may be an assignability condition of form <literal>case (is ...)</literal>.</para>

            <programlisting>Case := Expression ("," Expression)* | "is" Type</programlisting>
            
            <!--
            <para>If a <literal>case (null)</literal> occurs, the <literal>switch</literal> expression 
            must be of type <literal>Optional&lt;X&gt;</literal> for some type <literal>X</literal>.</para>

            <para>If the <literal>switch</literal> expression is of type <literal>Optional&lt;X&gt;</literal>, 
            there must be an explicit <literal>case (null)</literal>.</para>
            -->
            
            <para>The <literal>case</literal>s of a <literal>switch</literal> are 
            <emphasis>exhaustive</emphasis> if the switch expression type is <literal>T</literal> 
            or <literal>T?</literal> where <literal>T</literal> is a type with an enumerated list 
            of cases and:</para>
            
            <itemizedlist>
                <listitem>
                    <para>every case of the type which is an anonymous class is explicitly listed 
                    as an ordinary <literal>case</literal> value of the <literal>switch</literal>,</para>
                </listitem>
                <listitem>
                    <para>every other case of the type (every named class or interface) is 
                    explicitly listed as a <literal>case (is ...)</literal> assignability condition, 
                    and</para>
                </listitem>
                <listitem>
                    <para>there is a <literal>case (null)</literal> if the switch expression type 
                    is <literal>T?</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <comment><para>TODO: make this recursive (you can list all cases of a case instead of 
            listing the case).</para></comment>
            
            <para>If no <literal>else</literal> block is specified, the <literal>switch</literal> 
            must have an exhaustive <literal>case</literal> list. Conversely, if the <literal>switch</literal> 
            has an exhaustive <literal>case</literal> list, no <literal>else</literal> block may be 
            specified.</para>
            
            <para>When the construct is executed, the <literal>switch</literal> expression is 
            evaluated, and the resulting value is tested against the <literal>case</literal> values 
            using <literal>Matcher.matches()</literal>. The <literal>case</literal> block for the 
            first <literal>case</literal> value that tests <literal>true</literal> is executed. If 
            no <literal>case</literal> value tests <literal>true</literal>, and an <literal>else</literal> 
            block is defined, the <literal>else</literal> block is executed.</para>
            
            <!-- 
            <para>A <literal>switch</literal> statement may ensure initialization of a local variable 
            or attribute or termination of a non-<literal>void</literal> method or attribute getter 
            in a <literal>return</literal> or <literal>throw</literal> directive only if it has:</para>
            
            <itemizedlist>
                <listitem>
                    <para>an exhaustive <literal>case</literal> list, or</para>
                </listitem>
                <listitem>
                    <para>an <literal>else</literal> block.</para>
                </listitem>
            </itemizedlist>
            -->
             
            <para>For an assignability condition <literal>case</literal>, if the <literal>switch</literal> 
            expression is a local, then the local will be treated by the compiler as having the 
            specified type inside the <literal>case</literal> block.</para>
            
            <para>For example:</para>

            <programlisting>public PaymentProcessor processor {
    switch (payment.type) 
    case (null) { 
        throw NoPaymentTypeException()
    }
    case (credit, debit) { 
        return cardPaymentProcessor
    }
    case (check) { 
        return checkPaymentProcessor
    }
    else { 
        return interactivePaymentProcessor
    }
}</programlisting>
            
            <programlisting>switch (payment.type) {
    case (credit, debit) { 
        log.debug("card payment");
        cardPaymentProcessor.process(payment, user.card);
    } 
    case (check) {
        log.debug("check payment");
        checkPaymentProcessor.process(payment);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

            <programlisting>switch (payment) {
    case (is CardPayment) { 
        pay(payment.amount, payment.card);
    } 
    case (is CheckPayment) {
        pay(payment.amount, payment.check);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

            <programlisting>switch (node) {
    case (root) { 
        handleRootNode();
    } 
    case (is Leaf) {
        handleLeafNode(node);
    }
    case (is Branch) {
        handleBranchNode(node);
    }
}</programlisting>

            <comment><para>TODO: should it be a <literal>catch</literal>-style syntax 
            instead of <literal>case (is ...)</literal>?</para></comment>
            
        </section>
        
        <section id="forfail">
            <title><literal>for/fail</literal></title>
            
             <para>The <literal>for/fail</literal> loop has the following form:</para>
             
            <programlisting>ForFail := For Fail?</programlisting>

            <programlisting>For := "for" "(" ForIterator ")" Block</programlisting>
            
            <programlisting>Fail := "fail" Block</programlisting>

            <!--programlisting>ForFail :=
"for" "(" Iteration (";" Iteration)* ")" 
( ClosedBlock | OpenBlock "fail" ClosedBlock )
</programlisting-->

            <para>An iteration variable declaration must specify one or two iteration
            variables, and an iterated expression that contains the range of values to 
            be iterated. <!--It may optionally specify one or more iteration constraint 
            expressions (conditions).--></para>

            <programlisting>ForIterator := InferableVariable ("->" InferableVariable)? "in" Expression</programlisting>

            <!--programlisting>Iteration := FormalParam "in" Expression (":" Condition ("," Condition)*)? </programlisting-->

            <para>The type of the iterated expression depends upon the iteration variable 
            declarations:</para>
            
            <itemizedlist>
            <listitem>
                <para>The iterated expression must be an expression of type assignable to 
                <literal>Iterable&lt;X&gt;</literal> <!--or <literal>Iterator&lt;X&gt;</literal>-->
                where <literal>X</literal> is the declared type of the iteration variable.</para> 
            </listitem>
            <listitem>
                <para>If two iteration variables are defined, the iterated expression type 
                must be assignable to <literal>Iterable&lt;Entry&lt;U,V&gt;&gt;</literal> <!--or 
                <literal>Iterator&lt;Entry&lt;U,V&gt;&gt;</literal>--> where <literal>U</literal>
                and <literal>V</literal> are the declared types of the iteration variables.</para>
            </listitem>
            </itemizedlist>
            
            <!--para>Iterated and constraint expressions may refer to any local variable 
            defined by a previous iteration.</para-->
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para><!--if the iterated expression is of type <literal>Iterable</literal>,-->
                    the iterator is obtained by calling <literal>iterator()</literal>, and 
                    then</para>
                </listitem>
                <listitem>
                    <para>the <literal>for</literal> block is executed once for each value 
                    of type <literal>X</literal> produced by the iterator, until the iterator 
                    is exhausted.</para>
                </listitem>
            </itemizedlist>
            
            <para>Note that:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the iterated expression is also of type <literal>Sequence&lt;X&gt;</literal>,
                    the compiler is permitted to optimize away the use of <literal>Iterator</literal>, 
                    instead using indexed element access.</para>
                </listitem>
                <listitem>
                    <para>if the iterated expression is a range constructor expression, the compiler 
                    is permitted to optimize away creation of the <literal>Range</literal>, and generate
                    the indices using the <literal>successor</literal> operation.</para>
                </listitem>
            </itemizedlist>
            
            <para>If the loop exits early via execution of one of the control directives 
            <literal>break true</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the <literal>fail</literal> block is not executed. Otherwise, if the loop completes, 
            or if the loop exits early via execution of the control directive <literal>break false</literal>, 
            the <literal>fail</literal> block, if any, is executed.</para>
            
            <para>A <literal>for</literal> loop may ensure initialization of a local variable or 
            attribute or termination of a non-<literal>void</literal> method or attribute getter 
            in a <literal>return</literal> or <literal>throw</literal> directive only if it has 
            a <literal>fail</literal> block.</para>
                    
            <para>For example:</para>

            <programlisting>for (Person p in people) { 
    log.info(p.name);
}</programlisting>

            <programlisting>mutable Float sum := 0.0;
for (Integer i in -10..10) {
    sum += x[i] ? 0.0;
}</programlisting>
            
            <programlisting>for (Natural month -> Float temp in monthlyTempsList) { 
    plot(month,temp); 
}</programlisting>

            <programlisting>for (String word -> Natural freq in wordFrequencyMap) { 
    log.info("The frequency of the " word " is " freq "."); 
}</programlisting>
            
            <programlisting>for (Person p in people) {
    log.debug("Testing person: " p.name ".");
    if (p.age >= 18) {
        log.info("Found an adult: " p.name ".");
        break true
    }
}
fail {
    log.info("no adults");
}
</programlisting>

        </section>
        
        <section id="dowhile">
            <title><literal>while</literal> and <literal>do/while</literal></title>
            
            <para>The <literal>while</literal> loop has the form:</para>
            
            <programlisting>While := LoopCondition Block</programlisting>

            <para>The <literal>do/while</literal> loop has the form:</para>
            
            <programlisting>DoWhile := "do" Block LoopCondition ";"</programlisting>

            <para>The loop condition determines when the loop terminates.</para>
            
            <programlisting>LoopCondition := "while" "(" Condition ")"</programlisting>

            <!--programlisting>DoWhileFail := 
( "do" ("(" Variable Specifier ")")? OpenBlock? )?
"while" "(" Condition ("," Condition)* ")" 
( ";" | ClosedBlock | OpenBlock? "fail" ClosedBlock )</programlisting-->
            
            <para>When the construct is executed, the block is executed repeatedly, 
            until the loop condition first evaluates to <literal>false</literal>, 
            at which point iteration ends. In a <literal>while</literal> loop, the block 
            is executed after the condition is evaluated. In a <literal>do/while</literal> 
            loop, the second block is executed before it is evaluated.</para>
            
            <para>A <literal>while</literal> loop may ensure initialization of a local 
            variable or attribute or termination of a non-<literal>void</literal> method 
            or attribute getter in a <literal>return</literal> or <literal>throw</literal> 
            directive only if it is of form <literal>do/while</literal>.</para>
                    
            <comment><para>TODO: does <literal>do/while</literal> need a fail block? Python 
            has it, but what is the real usecase?</para></comment>
            
            <!--para>If the loop exits early via execution of one of the control directives 
            <literal>found</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the fail block is not executed. Otherwise, if the loop completes, or if the
            loop exits early via execution of the control directive <literal>break</literal>, 
            the fail block is executed, if it is defined.</para-->
            
            <para>For example:</para>
            
            <programlisting>mutable Natural n:=0;
OpenList&lt;Natural&gt; seq = ArrayList&lt;Natural&gt;();
while (n&lt;=max) {
    seq.append(n);
    n+=step(n);
}</programlisting>
            
            <programlisting>Iterator&lt;Person&gt; iter = org.employees.iterator();
while (exists Person p = iter.head) {
    log.info(p.name);
    iter.=tail;
}</programlisting>
                  
            <programlisting>mutable Person person := ....;
do {
    log.info(person.name);
    person.=parent;
} 
while (!person.dead);</programlisting>

        </section>

        <section id="trycatchfinally">
            <title><literal>try/catch/finally</literal></title>
            
            <para>The <literal>try/catch/finally</literal> exception manager has the form:</para>
            
            <programlisting>TryCatchFinally := Try Catch* Finally?</programlisting>

            <programlisting>Try := "try" ("(" Resource ")")? Block</programlisting>
            
            <programlisting>Catch := "catch" "(" Variable ")" Block</programlisting>
            
            <programlisting>Finally := "finally" Block</programlisting>

            <para>The type of each <literal>catch</literal> variable declaration must be 
            assignable to <literal>ceylon.language.Exception</literal>.</para>
            
            <para>The <literal>try</literal> block may declare a <emphasis>resource</emphasis>
            expression. A resource expresson produces a heavyweight object that must be 
            released when execution of the <literal>try</literal> terminates. Each resource 
            expression must be of type assignable to <literal>ceylon.language.Usable</literal>.</para>
            
            <programlisting>Resource := InferableVariable Specifier | Expression</programlisting>
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the resource expression, if any, is evaluated, and then 
                    <literal>begin()</literal> is called upon the resulting
                    resource instance, then</para>
                </listitem>
                <listitem>
                    <para>the <literal>try</literal> block is executed, then</para>
                </listitem>
                <listitem>
                    <para><literal>end()</literal> is called the resource instance, 
                    if any, with the exception that propagated out of the 
                    <literal>try</literal> block, if any, then</para>
                </listitem>
                <listitem>
                    <para>if an exception did propagate out of the <literal>try</literal> 
                    block, the first <literal>catch</literal> block with a variable 
                    to which the exception is assignable, if any, is executed, and 
                    then</para>
                </listitem>
                <listitem>
                    <para>the <literal>finally</literal> block, if any, is 
                    executed.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>try ( File file = File(name) ) {
    file.open(readOnly);
    ...
}
catch (FileNotFoundException fnfe) {
    log.info("file not found: " name "");
}
catch (FileReadException fre) {
    log.info("could not read from file: " name "");
}
finally {
    if (file.open) file.close();
}</programlisting>
            
            <programlisting>try (semaphore) {
    if ( !map.defines(key) ) {
        map[key] := value;
    }
}</programlisting>

            <para>(This example shows a Ceylon-ified version of the Java 
            <literal>synchronized</literal> block.)</para>
            
            <programlisting>try ( Transaction() ) {
    try ( Session s = Session() ) {
        return s.get(Person, id)
    }
    catch (NotFoundException e) {
        return null
    }
}</programlisting>

            <para>The <literal>retry</literal> directive re-evaluates the resource 
            expression, if any, and then re-executes the <literal>try</literal> block, 
            calling <literal>begin()</literal> and <literal>end()</literal> upon the 
            resource instance.</para>

            <programlisting>mutable Natural retries := 0;
try ( Transaction() ) {
    ...
}
catch (TransactionTimeoutException tte) {
    if (retries &lt; 3) {
        retries++;
        retry
    }
    else {
        throw tte
    }
}</programlisting>
            
         </section>
         
    </section>

</chapter>