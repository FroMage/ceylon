<chapter id="statementblocks">
    <title>Blocks and control structures</title>
    
    <para>Method, attribute, and class bodies contain procedural code that is executed 
    when the method or attribute is invoked, or when the class is instantiated. The 
    code contains expressions and control directives and is organized using blocks and 
    control structures.</para>
    
    <para>The Ceylon language has a recursive block structure&mdash;statements and
    declarations that are syntactically valid in the body of a toplevel declaration 
    are, in general, also syntactically valid in the body of a nested declaration or 
    of a control structure, and vice-versa.</para>
    
    <!--
    <para>There exists just one exception to this rule: a class body may not end in a 
    control directive.</para>
    -->
    
    <comment><para>TODO: a named argument list looks very much like a block, but is 
    not currently defined that way. The language would be more regular if we decided to 
    just make it a block.</para></comment>
    
    <section id="blockstructure">
        <title>Block structure</title>
    
        <para>A <emphasis>body</emphasis> is a block, class body or interface body. Every 
        body is list of semicolon-delimited statements, control structures, and declarations, 
        surrounded by braces. Some bodies end in a control directive. Every program element 
        in the list is said to <emphasis>directly occur</emphasis> in the body. A program 
        element <emphasis>directly occurs earlier</emphasis> than a second program element 
        if both program elements directly occur in a body and the first program element 
        occurs earlier in the list than the second program element.</para>
        
        <!--
        <para>As a special case, the <literal>while</literal> condition of a <literal>do/while</literal> 
        loop is considered to directly occur in the <literal>do</literal> block. All other
        statements and declarations of the <literal>do</literal> block are considered to
        directly occur earlier than the <literal>while</literal> condition.</para>
        -->
        
        <para>A program element <emphasis>(indirectly) occurs</emphasis> in a body if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the program element directly occurs in the body, or</para>
            </listitem>
            <listitem>
                <para>the program element indirectly occurs inside the body of a declaration
                or control structure that occurs directly in the body.</para>
            </listitem>
        </itemizedlist>
        
        <para>We sometimes say that the body <emphasis>contains</emphasis> the program 
        element if the program element (indirectly) occurs in the body.</para>
        
        <para>A program element <emphasis>(indirectly) occurs earlier</emphasis> than a 
        second program element if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or</para>
            </listitem>
            <listitem>
                <para>the second program element indirectly occurs inside the body of a 
                declaration or control structure that directly occurs earlier in the same 
                body as the first program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>The set of program elements that (indirectly) occur later than a program 
        element is sometimes called the <emphasis>lexical scope</emphasis> of the program
        element.</para>
        
        <para>A program element <emphasis>sequentially occurs</emphasis> in a body if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the program element directly occurs in the body, or</para>
            </listitem>
            <listitem>
                <para>the program element sequentially occurs inside the body of a control 
                structure that occurs directly in the body.</para>
            </listitem>
        </itemizedlist>
        
        <para>A program element <emphasis>sequentially occurs earlier</emphasis> than a 
        second program element if:</para>
        
        <itemizedlist>
            <listitem>
                <para>the two program elements both directly occur in the same body, and 
                the second program element occurs after the first program element, or</para>
            </listitem>
            <listitem>
                <para>the second program element sequentially occurs inside the body of a 
                control structure that directly occurs earlier in the same body as the 
                first program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>If a program element sequentially occurs earlier than a second program element, 
        the <emphasis>sequence of statements</emphasis> from the first program element to the
        second program element comprises:</para>
        
        <itemizedlist>
            <listitem>
                <para>the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the second program element, if the second program 
                element occurs directly in the same body as the first program element, or</para>
            </listitem>
            <listitem>
                <para>the sequence of statements that occur directly in the body in which
                the first program element directly occurs, beginning from the first program 
                element and ending with the declaration or control structure in whose body 
                the second program element sequentially occurs, followed by the sequence of 
                statements from the first statement of the declaration whose body contains 
                the second program element to the second program element itself, otherwise.</para>
            </listitem>
        </itemizedlist>
        
    <section id="declarationnameuniqueness">
        <title>Declaration name uniqueness</title>
        
        <para>A package may not contain two toplevel declarations (interfaces, 
        classes, methods, or attributes) with the same name.</para>
        
        <para>A program element is contained within the <emphasis>namespace</emphasis> 
        of a declaration if either:</para>
        
        <itemizedlist>
            <listitem>
                <para>it directly occurs in the body in which the declaration 
                directly occurs,</para>
            </listitem>
            <listitem>
                <para>the declaration is a parameter or type parameter, and it 
                directly occurs in the body of the declaration which the 
                declaration parameterizes,</para>
            </listitem>
            <!--
            <listitem>
                <para>it is a type parameter of the declaration,</para>
            </listitem>
            <listitem>
                <para>it indirectly occurs in the body of the declaration, and the 
                declaration is a class or interface,</para>
            </listitem>
            <listitem>
                <para>it is a type parameter of a declaration that indirectly occurs 
                in the body of the declaration, and the declaration is a class or 
                interface,</para>
            </listitem>
            -->
            <listitem>
                <para>it is a control structure variable or iteration variable of a 
                control structure contained in the namespace of the declaration, or</para>
            </listitem>
            <listitem>
                <para>it directly occurs in the body of a control structure contained
                in the namespace of the declaration.</para>
            </listitem>
        </itemizedlist>
        
        <comment><para>TODO: Java prohibits a type name from hiding the name of an outer
        type. Can we easily work around this limitation?</para></comment>
        
        <para>The namespace of a declaration may not contain a second declaration with 
        the same name, unless:</para>
        
        <itemizedlist>
          <listitem>
             <para>the declaration is a class,</para>
          </listitem>
          <listitem>
            <para>one declaration is an initializer parameter of the class and the 
            other is an attribute of the class,</para>
          </listitem>
          <listitem>
            <para>the type of the parameter is the same as the type of the attribute,
            and either</para>
          </listitem>
          <listitem>
            <para>the attribute is a non-<literal>variable</literal> simple 
            attribute with a specifier, and the specifier expression is a value 
            reference to the initializer parameter, or</para>
          </listitem>
          <listitem>
            <para>the attribute is a getter with no matching setter, and the body 
            of the getter has a single <literal>return</literal> statement, and the 
            return expression is a value reference to the initializer parameter.</para>
          </listitem>
        </itemizedlist>
        
        <para>(Where a parameter or type parameter is considered to be a declaration 
        that is directly contained by the body of the declaration it parameterizes.)</para>
        
        <para>Note that this code is not legal:</para>
        
        <programlisting>String uppercase(String string) {
    String string = string.uppercase;  //compiler error!
    return string;
}</programlisting>

        <para>However, this code <emphasis>is</emphasis> legal, since, according to 
        the rules above, an initialization parameter and an attribute may share a 
        name if they have the same value:</para>
        
        <programlisting>class Person(String name) {
    shared String name = name;
}</programlisting>

        <para>But the following is not legal:</para>
        
        <programlisting>class Person(String name) {
    shared String name = name.lowercase;
}</programlisting>

        <para>However, an inner body may <emphasis>hide</emphasis> declarations of 
        a containing body. For example, the following code is legal:</para>
        
        <programlisting>class Person(String name) {
    shared String lowerCaseName {
        String name = name.lowercase;
        return name;
    }
}</programlisting>
        
        <para>A class or interface may not inherit a declaration with the same 
        name as a declaration it contains unless either:</para>
            
        <itemizedlist>
            <listitem>
                <para>the contained declaration directly or indirectly refines 
                the inherited declaration, or</para>
            </listitem>
            <listitem>
                <para>the inherited declaration is a block local declaration.</para>
            </listitem>
        </itemizedlist>
        
        <para>A class or interface may not inherit two declarations with the
        same name unless either:</para>

        <itemizedlist>
            <listitem>
                <para>both of the inherited declarations are <literal>formal</literal>
                and directly or indirectly refine some member of a common 
                supertype,</para>
            </listitem>
            <listitem>
                <para>the class or interface contains a declaration that directly 
                or indirectly refines both the inherited declarations (in which
                case both the inherited declarations directly or indirectly refine 
                some member of a common supertype),</para>
            </listitem>
            <listitem>
                <para>one of the inherited declarations directly or indirectly 
                refines the other inherited declaration, or</para>
            </listitem>
            <listitem>
                <para>at least one of the inherited declarations is a block local 
                declaration.</para>
            </listitem>
        </itemizedlist>
        
    </section>
    
    <!--
    <section id="declarationvisibility">
        <title>Declaration visibility</title>
    
            <para>The scope of a declaration is governed by the body or package in which it 
            occurs.</para>
        
            <para>Packages contain toplevel declarations. A declaration that occurs in a 
            package is visible to any program element that occurs in any compilation unit of 
            the package. The toplevel declaration may be annotated <literal>shared</literal>, 
            in which case it is also visible to compilation units in other packages that 
            <literal>import</literal> it.</para>
        
            <para>Blocks may contain declarations. A declaration that (indirectly) occurs in 
            a block is a block local declaration&mdash;it is visible to a program element only 
            if the program element occurs withing the lexical scope of the declaration. 
            Therefore, a declaration contained in a block may not declare a visibility modifier. 
            Nor may block local declarations be refined. Therefore, a block may not contain a 
            declaration annotated <literal>formal</literal>, <literal>default</literal>, 
            <literal>actual</literal>, or <literal>shared</literal>.</para>
            
            <para>Class and interface bodies also contain declarations. Unlike a declaration 
            nested inside a block, a declaration directly contained in the body of a class or
            interface may be annotated <literal>shared</literal>, making the member accessible 
            outside the body of the class or interface. Furthermore, a declaration occurring 
            in an interface body or in the declaration section of a class body is visible to 
            all other program elements that occur in the same interface body or declaration 
            section (unless it is a <literal>value</literal> or <literal>function</literal>
            declaration with an inferred type).</para>
            
    </section>
   -->
    
    <section id="scopeofdeclaration">
        <title>Scope of a declaration</title>
        
        <para>The scope of a declaration is governed by the body or package in which it 
        occurs. A declaration that occurs directly in a package or in a class or interface 
        body may be annotated <literal>shared</literal>, making it visible outside the 
        package or body in which it occurs. A declaration that directly occurs in a block 
        may not be annotated <literal>shared</literal>.</para> 
        
        <para>A declaration is <emphasis>in scope</emphasis> at a program element if
        and only if either:</para>
        
        <itemizedlist>
            <listitem>
                <para>the declaration is a parameter or type parameter of a declaration 
                whose body contains the program element,</para>
            </listitem>
            <listitem>
                <para>the program element belongs to the declaration itself,</para>
            </listitem>
            <listitem>
                <para>the declaration is a control structure variable or iteration 
                variable belonging to a block of a control structure that contains the 
                program element,</para>
            </listitem>
            <!--listitem>
                <para>the program element is the <literal>while</literal> condition of a 
                <literal>do/while</literal> loop and the <literal>do</literal> block of 
                the loop contains the declaration,</para>
            </listitem-->
            <listitem>
                <para>the program element occurs within the lexical scope of the 
                declaration,</para>
            </listitem>
            <listitem>
                <para>the declaration directly occurs in an interface body, and the program 
                element also (indirectly) occurs in the same interface body,</para>
            </listitem>
            <listitem>
                <para>the declaration directly occurs in the declaration section of a class 
                body, and the program element also (indirectly) occurs in the declaration 
                section of the same class body,</para>
            </listitem>
            <listitem>
                <para>the declaration is imported by the compilation unit containing the 
                program element and is visible to the program element, or</para>
            </listitem>
            <listitem>
                <para>the declaration is a toplevel declaration in the package containing 
                the program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>Where:</para>
        
        <itemizedlist>
        <listitem>
        <para>A control structure variable or iteration variable <emphasis>belongs</emphasis> 
        to a block of a control structure if the block immediately follows the declaration 
        of the variable.</para>
        </listitem>
        <listitem>
        <para>A program element <emphasis>belongs</emphasis> to a declaration if it occurs
        in the <literal>extends</literal>, <literal>satisfies</literal>, <literal>of</literal>,
        <literal>given</literal>, <literal>abstracts</literal>, <literal>adapts</literal> or
        <literal>is</literal> clause of the declaration.</para>
        </listitem>
        </itemizedlist>
        
        <para>A specifier or initializer expression of a declaration or control structure
        variable does not belong to the declaration, and is not contained in the body of 
        the declaration, and therefore the declaration is <emphasis>not</emphasis> in scope 
        at its own specifier or initializer expression. Likewise, an iteration variable 
        declaration is <emphasis>not</emphasis> in scope at its own iterated expression.</para>
        
            <para>The following toplevel method declarations, belonging to the same package, 
            are legal:</para>
        
            <programlisting>Float x { return y; }</programlisting>

            <programlisting>Float y { return x; }</programlisting>
            
            <comment><para>TODO: Actually the compiler would currently require that the two 
            declarations occur in separate compilation units. Who is wrong, spec or 
            compiler?</para></comment>

            <para>This code is not legal, since the body of a method is an ordinary block:</para>
        
            <programlisting>Entry&lt;Float,Float&gt; xy() {
    Float x { return y; }  //compiler error!
    Float y { return x; }
    return x->y;
}</programlisting>

            <para>This code is not legal, since all three statements occur in the initializer 
            section of the class body:</para>
        
            <programlisting>class Point() {
    Float x { return y; }  //compiler error!
    Float y { return x; }
    Entry&lt;Float,Float&gt; xy = x->y;
}</programlisting>

            <para>However, this code <emphasis>is</emphasis> legal, since the statements occur 
            in the declaration section of the class body:</para>
        
            <programlisting>class Point() {
    Float x { return y; }
    Float y { return x; }
}</programlisting>

    </section>
        
    <section id="nameresolution">
        <title>Name resolution</title>
                
        <para>An unqualified identifier (an identifier not preceded by <literal>.</literal>,
        <literal>[].</literal> or <literal>?.</literal>) that appears in a program 
        element refers to a named declaration elsewhere: a class, interface, type 
        parameter, method, attribute, or local.</para>
        
        <para>If a certain identifier name occurs at a program element, there must be at 
        least one declaration with the given name in scope at the program element. If 
        multiple declarations with the given name are in scope at the program element where 
        the given name occurs, then there must be exactly one such declaration which is not 
        <emphasis>hidden</emphasis> by another declaration:</para>
        
        <itemizedlist>
            <listitem>
                <para>if an inner body is contained (directly or indirectly) in an outer 
                body, a declaration, parameter, type parameter or control structure 
                variable of the inner body hides a declaration, parameter, type parameter 
                or control structure variable in the outer body,</para>
            </listitem>
            <listitem>
                <para>a declaration inherited by an nested class hides a declaration,
                parameter, type parameter, or control structure variable of the containing
                body, <emphasis>TODO: is this correct?</emphasis></para>
            </listitem>
            <listitem>
                <para>a parameter of a class body hides an attribute of the class,</para>
            </listitem>
            <listitem>
                <para>a declaration occurring in a body containing the program element 
                hides a declaration imported by the compilation unit, and</para>
            </listitem>
            <listitem>
                <para>a declaration imported by the compilation unit hides a toplevel 
                declaration of the package containing the program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>Then the given name refers to this unique unhidden declaration, and either:</para>
        
        <itemizedlist>
            <listitem>
                <para>the program element must occur within the lexical scope of this 
                declaration, or</para>
            </listitem>
            <listitem>
                <para>this declaration must not be declared using the keyword 
                <literal>value</literal> or <literal>function</literal>.</para>
            </listitem>
        </itemizedlist>
                
    </section>
            
        <section id="closure">
            <title>Closure</title>
            
            <para>The principle of <emphasis>closure</emphasis> states a that nested body
            always has access to a set of values for all simple attributes and locals declared 
            by containing bodies.</para>
    
            <para>If a declaration is nested directly or indirectly inside a class or interface 
            declaration, then there is always a <emphasis>current instance</emphasis> of the 
            class or interface when the nested declaration body is executed. The current 
            instance is determined as follows:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for the innermost class or interface declaration that contains the 
                    nested declaration, the current instance is the receiving instance of the
                    invocation, evaluation, or assignment, and</para>
                </listitem>
                <listitem>
                    <para>for any other class or interface that contains the nested declaration,
                    the current instance is the same object that was the current instance when
                    the initializer of the current instance of the innermost class or interface 
                    declaration was executed.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>Outer outerObject = Outer();
Inner innerObject = outerObject.Inner();
innerObject.member();</programlisting>
            
            <para>In this example, <literal>innerObject</literal> is the current instance of 
            <literal>Inner</literal> when <literal>member()</literal> is executed, and
            <literal>outerObject</literal> is the current instance of <literal>Outer</literal>.</para>
                        
            <para>If a declaration is nested directly or indirectly inside a block, then there 
            is always a <emphasis>current frame</emphasis> of the block when the nested 
            declaration is executed. The current frame contains the values of all 
            non-<literal>variable</literal> locals declared by the block. The current frame is 
            determined as follows:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the nested declaration is nested directly inside a block,
                    the current frame contains the current values at the point of execution
                    of the value reference expression or callable reference expression that
                    refers to the nested declaration, or, otherwise</para>
                </listitem>
                <listitem>
                    <para>if the nested declaration is contained inside the body of another
                    nested declaration, the current frame is the current frame of the 
                    containing declaration at the point of execution of the value reference 
                    expression or callable reference expression that refers to the nested 
                    declaration.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>String outerMethod(String s)()() {
    String middleMethod()() {
        String innerMethod() {
            return s;
        }
        return innerMethod;
    }
    return middleMethod;
}

String middleMethod()() = outerMethod("hello");
String innerMethod() = middleMethod();
String result = innerMethod();</programlisting>

            <programlisting>Object outerMethod(String s) {
    object middleObject {
        shared actual String string {
            return s;
        }
    }
    return middleObject;
}

Object middleObject = outerMethod("hello");
String result = middleObject.string;</programlisting>

            <para>In both examples, <literal>result</literal> refers to the value 
            <literal>"hello"</literal>.</para>
            
            <para>The set of <!--all declarations which belong directly to a containing body 
            of a nested declaration, together with the --> current instances of containing 
            classes and interfaces and current frames of containing blocks is called the 
            <emphasis>closure</emphasis> of the nested declaration.</para>           
            
        </section>
        
    <section id="containingbodies">
        <title>References within a closure</title>

        <para>The initializer of a class, or the body of a member of a class may instantiate,
        invoke, evaluate or assign members of the current instance of the class which defines 
        the initializer or member&mdash;the instance being instantiated or invoked&mdash;without 
        explicitly specifying the receiver, or by specifying a self reference 
        <literal>this</literal> as the receiver.</para>

        <para>The initializer of a nested class, or the body of a member of a nested class
        or nested interface may invoke, evaluate or assign members of the current instance 
        of the containing class or interface&mdash;the parent instance of the instance being 
        instantiated or invoked&mdash;without explicitly specifying the receiver, or by 
        specifying an outer instance reference <literal>outer</literal> as the receiver.</para>

        <para>A toplevel method or attribute body may not refer to a self reference, since 
        there is no current instance.</para>

        <para>The body of a method, class, or attribute nested inside the body of another 
        method or attribute may invoke or evaluate any <!--non-<literal>variable</literal>--> 
        local, block local attribute getter or block local method whose declaration indirectly 
        occurs earlier within the containing scope.</para>
        
        <comment><para>TODO: is there a good reason to add the following limitation: It may 
        not refer to <literal>variable</literal> locals defined within the containing method 
        or attribute body.</para></comment> 
        
        <para>When a member of a class is hidden by a block local declaration, the member 
        may be accessed via the self reference <literal>this</literal> or via the outer 
        instance reference <literal>outer</literal>. For example:</para>
        
        <programlisting>shared class Item(String name) {
    variable String name := name;
    shared void changeName(String name) {
        this.name := name;
    }
}</programlisting>
        
            <programlisting>class Catalog(String name) {
    String name = name;
    class Schema(String name) {
        String name = name;
        Catalog catalog { return outer; }
        String catalogName { return outer.name; }
        class Table(String name) {
            String name = name;
            Schema schema { return outer; }
            String schemaName { return outer.name; }
            String catalogName { return catalog.name; }
        }
    }
}</programlisting>
    
        </section>
    
    </section>
    
    <section id="blocksandstatements">
        <title>Blocks and statements</title>
            
        <para>A <emphasis>block</emphasis> is list of semicolon-delimited statements, 
        control structures, and declarations, surrounded by braces.</para>
        
        <programlisting>Block: "{" (Declaration | Statement)* "}"</programlisting>
        
        <para>A <emphasis>statement</emphasis> is an assignment or specification, an 
        invocation of a method, an instantiation of a class, a control structure, or 
        a control directive.</para>

        <programlisting>Statement: ExpressionStatement | Specification | DirectiveStatement | ControlStructure</programlisting>
        
        <para>The statements, local specifiers, and control structures that directly occur
        in a block are executed sequentially in the order that they appear inside the block. 
        Execution of a block begins at the first statement, local specifier, or control 
        structure of the block. Execution of a block terminates when the last statement, 
        local specifier, or control structure of the block finishes executing, when a 
        control directive that terminates the block is executed, or when an exception is 
        thrown.</para>

        <!-- 
        <para>A simple attribute or local may not be used in an expression until its value 
        has been explicitly specified or initialized. The Ceylon compiler guarantees this
        by evaluating all conditional branches that lead to the first use of an attribute
        of local in an expression. Each conditional branch must specify or assign a value 
        to the simple attribute or local before using it in an expression.</para>
        
        <para>Every simple attribute of a concrete class must be explicitly specified or 
        initialized by the initializer of the class or by the initializer of one of its 
        superclasses. The Ceylon compiler guarantees this by evaluating all conditional 
        branches that lead to termination of the initializer without an uncaught exception. 
        Each conditional branch must specify or assign a value to the simple attribute 
        before the initializer terminates without an uncaught exception.</para>
        
        <para>A simple attribute or local may not be the target of a specifier expression 
        if its value has already been specified. The Ceylon compiler guarantees this by 
        evaluating all conditional branches that lead to the use of a simple attribute or 
        local in a specifier expression. No conditional branch may specify a value to the 
        simple attribute or local before using it in a specifier expression.</para>
        
        <para>Every non-<literal>void</literal> method or attribute getter must terminate in
        the execution of a <literal>return</literal> or <literal>throw</literal> directive. 
        The Ceylon compiler guarantees this by evaluating all conditional branches that lead 
        to termination of the method. Each conditional branch must end in a 
        <literal>return</literal> or <literal>throw</literal> directive.</para>
        -->
        
        <para>Every block local declaration must be used somewhere inside the block in which
        it is declared.</para>
        
        <comment><para>TODO: should we allow blocks and control structures to be annotated, 
        for example:</para>
        <programlisting>doc "unsafe assignment" 
suppressWarnings(typesafety)
if (it.walksLikeADuck) { Duck duck = it; }</programlisting>
<programlisting>doc "synchronize on the lock"
try (lock) { ... }</programlisting>
</comment>
        
        <comment><para>TODO: Note that Java does not let you define an interface inside a 
        method, so we should either add the same restriction, or figure out workaround. 
        Java doesn't let you define a method inside a method either, but we can wrap the 
        nested method in an anonymous class.</para></comment>
        
        <comment><para>TODO: Note that in Java, all nested classes of interfaces are 
        considered static inner classes. This results in a very funny semantic for a class 
        nested inside an interface nested inside another class: the class does not have 
        access to the members of the containing class. In Ceylon, a nested class is allowed 
        to invoke all its containing types. We need to figure out how to implement this. 
        Also consider the related case of a class nested inside an interface nested inside 
        a method.</para></comment>
        
        <section id="expressionstatements">
            <title>Expression statements</title>
            
        <para>Only certain expressions are valid statements:</para>
        
        <itemizedlist>
            <listitem>
                <para>assignment,</para>
            </listitem>
            <listitem>
                <para>prefix or postfix increment or decrement,</para>
            </listitem>
            <listitem>
                <para>invocation of a method,</para>
            </listitem>
            <listitem>
                <para>instantiation of a class.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>ExpressionStatement: ( Assignment | IncrementOrDecrement | Invocation ) ";"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>x := 1;</programlisting>
        <programlisting>x++;</programlisting>
        <programlisting>log.info("Hello");</programlisting>
        <programlisting>Main(p);</programlisting>
        
        <!-- 
        <comment><para>TODO: it would be possible to say that any expression is a valid
        statement, but this seems to just open up more potential programming errors. So
        I think it's better to limit statements to assignments, invocations
        and instantiations.</para></comment>
        <comment><para>TODO: should we let you leave off the <literal>;</literal> on the last
        expression statement in the block, like we do for directives?</para></comment>
        -->
                
        </section>
        
        <section id="controldirectives">
            <title>Control directives</title>
            
        <para>Control directive statements end execution of the current block and force 
        the flow of execution to resume in some outer scope. They may only appear at the 
        end of a block.<!--, so the semicolon terminator is optional--></para>

        <programlisting>DirectiveStatement: Directive ";"</programlisting>
        
        <para>Ceylon provides the following control directives:</para>
        
        <itemizedlist>
            <listitem>the <literal>return</literal> directive&mdash;to return a value from 
            a non-<literal>void</literal> method or attribute getter or terminate execution 
            of a <literal>void</literal> method, setter, or class initializer,</listitem>
            <listitem>the <literal>break</literal> directive&mdash;to terminate a loop,</listitem>
            <listitem>the <literal>continue</literal> directive&mdash;to jump to the next iteration 
            of a loop, and</listitem>
            <listitem>the <literal>throw</literal> directive&mdash;to raise an exception.</listitem>
            <!--
            <listitem>the <literal>retry</literal> directive&mdash;to re-execute a <literal>try</literal> 
            block, reinitializing all resources.</listitem>
            -->
        </itemizedlist>
                
        <programlisting>Directive: Return | Throw | Break | Continue</programlisting>

        <para>For example:</para>
        
        <programlisting>throw Exception();</programlisting>
        <!--programlisting>retry;</programlisting-->
        <programlisting>return x+y;</programlisting>
        <programlisting>return "Hello";</programlisting>
        <programlisting>break;</programlisting>
        <programlisting>continue;</programlisting>
        
        <para>The <literal>return</literal> directive must sequentially occur in the body 
        of a method, attribute getter, attribute setter, or class initializer. In the 
        case of a <literal>void</literal> method, attribute setter, or class initializer, 
        no expression may be specified. In the case of a non-<literal>void</literal> method 
        or attribute getter, an expression must be specified. The expression type must be 
        assignable to the return type of the method or the type of the attribute. When the 
        directive is executed, the expression is evaluated to determine the return value of 
        the method or attribute getter.</para>
        
        <programlisting>Return: "return" Expression?</programlisting>
        
        <para>The <literal>break</literal> directive must sequentially occur in the body 
        of a loop.<!--If the loop has no <literal>fail</literal> block, the <literal>break</literal> 
        directive may not specify an expression. If the loop has a <literal>fail</literal> 
        block, the <literal>break</literal> directive must specify an expression of type 
        <literal>ceylon.language.Boolean</literal>. When the directive is executed, the 
        expression is evaluated and a value of <literal>false</literal> specifies that the 
        <literal>fail</literal> block should be executed.--></para>
        
        <programlisting>Break: "break"</programlisting>
        
        <para>The <literal>continue</literal> directive must sequentially occur in the body 
        of a loop.</para>
        
        <programlisting>Continue: "continue"</programlisting>
        
        <para>A <literal>throw</literal> directive may appear anywhere and may specify an 
        expression of type <literal>ceylon.language.Exception</literal>. When the directive 
        is executed, the expression is evaluated and the resulting exception is thrown. If 
        no expression is specified, the directive is equivalent to <literal>throw Exception()</literal>.</para>
        
        <programlisting>Throw: "throw" Expression?</programlisting>
        
        <!--
        <comment><para>TODO: Crazy idea: let <literal>...</literal> be a shortcut for
        <literal>throw NotYetImplemented();</literal>. Too cute?</para></comment>
        -->
        
        <!--
        <para>A <literal>retry</literal> directive may not appear outside of a
        <literal>catch</literal> block.</para>
        
        <programlisting>Retry: "retry"</programlisting>
        -->
        
        <!--comment><para>TODO: We could support <literal>for/else</literal> loops 
        that return a value by supporting a <literal>found expr</literal> directive. 
        We could support conditionals that return a value by adding a 
        <literal>then expr</literal> directive.</para></comment-->
        
        <!--
        <comment><para>TODO: Should we have a <literal>retry</literal> directive?</para></comment>
        -->
        
        </section>
        
        <section id="specificationstatements">
            <title>Specification statements</title>
            
        <para>A specification statement may specify the value of a forward-declared, 
        non-<literal>variable</literal> simple attribute or local or the method 
        reference of a forward-declared method.</para>
        
        <para>Note that the Ceylon language distinguishes between assignment to a 
        <literal>variable</literal> value (the <literal>:=</literal> operator) and 
        specification of the value of a non-<literal>variable</literal> local or 
        attribute (using <literal>=</literal>). The <literal>=</literal> character is 
        not an operator, and therefore a specification statement is not an expression 
        statement.</para>
        
        <para>A specification statement consists of an unqualified value reference and
        a specifier. The value reference must refer to a declaration which sequentially 
        occurs earlier in the body in which the specification statement occurs.</para>
        
        <programlisting>Specification: MemberName Specifier ";"</programlisting>
                
        <para>The type of the specified expression must be assignable to the type of 
        the simple attribute or local, or to the callable type of the method.</para>
        
        <!--
        <para>A specification may appear within an control structure, in which case the
        compiler validates that all paths of execution result in definite specification 
        of the simple attribute value or method reference before the attribute or value
        is used in an expression. For example:</para>
        
        <programlisting>String description;
Comparison order(Value x, Value y);
if (reverseOrder()) {
    description = "Reverse order";
    order = reverse;
}
else {
    description = "Natural order";
    order = natural;
}</programlisting>
        -->
        </section>
        
        <section id="definitereturn">
            <title>Definite return</title>
            
            <para>A sequence of statements may <emphasis>definitely return.</emphasis></para>
            
            <itemizedlist>
                <listitem>
                    <para>A sequence of statements definitely returns if it ends in a 
                    <literal>return</literal> or <literal>throw</literal> directive, or 
                    in a control structure that definitely returns.</para>
                </listitem>
                <listitem>
                    <para>A body definitely returns if it contains a list of statements
                    that definitely returns.</para>
                </listitem>
                <listitem>
                    <para>An <literal>if</literal> conditional definitely returns if it has
                    an <literal>else</literal> block and both the <literal>if</literal>
                    and <literal>else</literal> blocks definitely return.</para>
                </listitem>
                <listitem>
                    <para>A <literal>switch</literal> conditional definitely returns if all
                    <literal>case</literal> blocks definitely return and the <literal>else</literal> 
                    block, if any, definitely returns.</para>
                </listitem>
                <listitem>
                    <para>A <literal>for</literal> loop definitely returns if it has an
                    <literal>else</literal> block that definitely returns, and there is
                    no <literal>break</literal> directive in the <literal>for</literal>
                    block.</para>
                </listitem>
                <listitem>
                    <para>A <literal>while</literal> loop does not definitely return.</para>
                </listitem>
                <listitem>
                    <para>A <literal>do/while</literal> loop definitely returns if the 
                    <literal>do</literal> block definitely returns.</para>
                </listitem>
                <listitem>
                    <para>A <literal>try/catch</literal> exception manager definitely 
                    returns if the <literal>try</literal> block definitely returns and
                    all <literal>catch</literal> blocks definitely return or if the
                    <literal>finally</literal> block definitely returns.</para>
                </listitem>
            </itemizedlist>
            
            <para>The body of a non-<literal>void</literal> method or getter must definitely 
            return.</para>
            
            <para>A body may not contain an additional statement, control structure, or
            declaration following a sequence of statements that definitely returns. Such a 
            statement, control structure, or declaration is considered 
            <emphasis>unreachable</emphasis>.</para>
            
        </section>
        
        <section id="definiteinitialization">
            <title>Definite initialization</title>
            
            <para>A sequence of statements may <emphasis>definitely initialize</emphasis> a
            forward-declared local, simple attribute, or method.</para>
            
            <itemizedlist>
                <listitem>
                    <para>A sequence of statements definitely initializes a local, simple 
                    attribute, or method if one of the statements is a specification statement 
                    or assigment expression for the local or simple attribute or a control 
                    structure that definitely initializes the local or simple attribute, or 
                    if the sequence of statements ends in a <literal>return</literal> or 
                    <literal>throw</literal> directive.</para>
                </listitem>
                <listitem>
                    <para>An <literal>if</literal> conditional definitely initializes a local, 
                    simple attribute, or method if it has an <literal>else</literal> block and 
                    both the <literal>if</literal> and <literal>else</literal> blocks definitely
                    initialize the local or simple attribute.</para>
                </listitem>
                <listitem>
                    <para>A <literal>switch</literal> conditional definitely initializes a
                    local, simple attribute, or method if all <literal>case</literal> blocks 
                    definitely initialize the local, simple attribute, or method and the 
                    <literal>else</literal> block, if any, definitely initializes the local, 
                    simple attribute, or method.</para>
                </listitem>
                <listitem>
                    <para>A <literal>for</literal> loop definitely initializes a local, simple 
                    attribute, or method if it has an <literal>else</literal> block that 
                    definitely initializes the local, simple attribute, or method, and there is 
                    no <literal>break</literal> directive in the <literal>for</literal> block.</para>
                </listitem>
                <listitem>
                    <para>A <literal>while</literal> loop does not definitely initialize a local, 
                    simple attribute, or method.</para>
                </listitem>
                <!-- 
                <listitem>
                    <para>A <literal>do/while</literal> loop definitely initializes a local or 
                    simple attribute if the <literal>do</literal> block definitely initializes
                    the local or simple attribute.</para>
                </listitem>
                -->
                <listitem>
                    <para>A <literal>try/catch</literal> exception manager definitely initializes 
                    a local, simple attribute, or method if the <literal>try</literal> block 
                    definitely initializes the local, simple attribute, or method and all 
                    <literal>catch</literal> blocks definitely initialize the local, simple 
                    attribute, or method or if the <literal>finally</literal> block definitely 
                    initializes the local, simple attribute, or method.</para>
                </listitem>
            </itemizedlist>
            
            <para>A local, simple attribute, or method is considered <emphasis>definitely 
            initialized</emphasis> at a certain statement or declaration if its declaration has 
            a specifier or initilalizer or if it is definitely initialized by the sequence of 
            statements from its declaration to the given statement or declaration.</para>
            
            <para>A local, simple attribute, or method must be definitely initialized wherever any 
            value reference to it occurs as an expression within the body in which it is declared.</para>
            
            <para>A <emphasis>shared</emphasis> forward-declared simple attribute or method must be 
            definitely initialized:</para>
            
            <itemizedlist>
                <listitem>
                    <para>at every <literal>return</literal> statement of the initializer of the 
                    containing class, and</para>
                </listitem>
                <listitem>
                    <para>at the very last expression statement, directive statement or 
                    specification statement of the initializer of the containing class.</para>
                </listitem>
            </itemizedlist>
            
            <para>A specification statement for a method or non-<literal>variable</literal> simple 
            attribute or local may not (indirectly) occur in a <literal>for</literal> or 
            <literal>while</literal> block unless the declaration itself occurs within the same
            <literal>for</literal> or <literal>while</literal> block.</para>

        </section>
            
        <section id="definiteuninitialization">
            <title>Definite uninitialization</title>
            
            <para>A sequence of statements may <emphasis>possibly initialize</emphasis> a 
            forward-declared local, simple attribute, or method.</para>
            
            <itemizedlist>
                <listitem>
                    <para>A sequence of statements possibly initializes a local, simple attribute, 
                    or method if one of the statements is a specification statement for the local, 
                    simple attribute, or method or a control structure that possibly initializes 
                    the local, simple attribute, or method.</para>
                </listitem>
                <listitem>
                    <para>An <literal>if</literal> conditional possibly initializes a local, simple 
                    attribute, or method if either the <literal>if</literal> block possibly 
                    initializes the local, simple attribute, or method or if the <literal>else</literal> 
                    block, if any, possibly initializes the local, simple attribute, or method.</para>
                </listitem>
                <listitem>
                    <para>A <literal>switch</literal> conditional possibly initializes a local, 
                    simple attribute, or method if one of the <literal>case</literal> blocks possibly 
                    initializes the local, simple attribute, or method or the <literal>else</literal> 
                    block, if any, possibly initializes the local, simple attribute, or method.</para>
                </listitem>
                <listitem>
                    <para>A <literal>for</literal> loop possibly initializes a local, simple attribute, 
                    or method if the <literal>for</literal> block possibly initializes the local, simple 
                    attribute, or method or if it has an <literal>else</literal> block that possibly 
                    initializes the local, simple attribute, or method.</para>
                </listitem>
                <listitem>
                    <para>A <literal>while</literal> loop possibly initializes a local, simple attribute, 
                    or method if the <literal>while</literal> block possibly initializes the local, simple 
                    attribute, or method.</para>
                </listitem>
                <listitem>
                    <para>A <literal>try/catch</literal> exception manager possibly initializes a local, 
                    simple attribute, or method if the <literal>try</literal> block possibly initializes 
                    the local, simple attribute, or method, if one of the <literal>catch</literal> 
                    blocks possibly initializes the local, simple attribute, or method, or if the 
                    <literal>finally</literal> block possibly initializes the local, simple attribute, 
                    or method.</para>
                </listitem>
            </itemizedlist>
            
            <para>A forward-declared local, simple attribute, or method is considered <emphasis>definitely 
            uninitialized</emphasis> at a certain statement or declaration if:</para>
            
            <itemizedlist>
                <listitem>
                    <para>it is not possibly initialized by the sequence of statements from its declaration 
                    to the given statement or declaration,</para>
                </listitem>
                <listitem>
                    <para>the statement does not (indirectly) occur in the <literal>else</literal> block of 
                    a <literal>for</literal> loop with a <literal>for</literal> block that possibly 
                    initializes it,</para>
                </listitem>
                <listitem>
                    <para>the statement does not (indirectly) occur in a <literal>catch</literal> block 
                    of a <literal>try/catch</literal> exception manager with a <literal>for</literal> block 
                    that possibly initializes it, and</para>
                </listitem>
                <listitem>
                    <para>the statement does not (indirectly) occur in the <literal>finally</literal> block 
                    of a <literal>try/catch</literal> exception manager with a <literal>for</literal> block 
                    or <literal>catch</literal> block that possibly initializes it.</para>
                </listitem>
            </itemizedlist>
                        
            <para>A method or non-<literal>variable</literal> local or simple attribute must be definitely 
            uninitialized wherever any value reference to it occurs as a specification statement within
            the body in which it is declared.</para>
            
        </section>
            
    </section>
    
    <section id="controlstructures">
        <title>Control structures</title>
        
        <para>Control of execution flow may be achieved using control directives and control 
        structures. Control structures include conditionals, loops, and exception management. 
        <!--For many tasks, the use of these traditional control
        structures is considered bad style, and the use of expressions with functor 
        parameters is preferred. However, control structures support the use of the 
        <literal>return</literal> and <literal>break</literal> directives, whereas 
        functors do not. Therefore, some tasks may be accomplished only with control 
        structures.--></para>

        <para>Ceylon provides the following control structures:</para>
        
        <itemizedlist>
            <listitem>
                <para>the <literal>if/else</literal> conditional&mdash;for controlling execution 
                based upon a boolean condition, type condition, or check for a non-null or 
                non-empty value,</para>
            </listitem>
            <listitem>
                <para>the <literal>switch/case/else</literal> conditional&mdash;for controlling 
                execution using an enumerated list of values or types,</para>
            </listitem>
            <listitem>
                <para>the <literal>while</literal> loop&mdash;for loops which terminate based a 
                boolean condition,</para>
            </listitem>
            <listitem>
                <para>the <literal>for/else</literal> loop&mdash;for looping over elements of a 
                collection, and</para>
            </listitem>
            <listitem>
                <para>the <literal>try/catch/finally</literal> exception manager&mdash;for managing 
                exceptions and controlling the lifecycle of objects which require explicit 
                destruction.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>ControlStructure: IfElse | SwitchCaseElse | While | ForFail | TryCatchFinally</programlisting>
       
        <para>Control structures are not considered to be expressions, and therefore do not evaluate
        to a value.</para>
        
        <comment><para>TODO: Should we support, like C and Java, single-statement control structure 
        bodies without the braces.</para></comment>
        
        <section id="controlstructurevariables">
            <title>Control structure variables</title>
       
        <para>Some control structures allow inline declaration of a <emphasis>variable</emphasis>,
        a local that is scoped to the control structure body.</para>
        
        <programlisting>TypedVariable: UnionType MemberName</programlisting>
        
        <para>In most cases, the explicit type be omitted, forcing the compiler to infer it, by 
        specifying the keyword <literal>value</literal> where the type usually appears. The type 
        of the variable is inferred to be the type of the expression that follows.</para>
        
        <programlisting>Variable: UnionType? MemberName</programlisting>
        
        <para>If the type is missing from the declarations, the type of the variables is 
        inferred.</para>

        <comment><para>TODO: write down the rules for inferring the type of control structure
        variables!</para></comment>
        
        </section>
        
        <section id="iterationvariables">
            <title>Iteration variables</title>
       
            <para>A <literal>for</literal> loop requires an <emphasis>iteration variable</emphasis> 
            declaration. An iteration variable declaration must specify an iteration variable.</para>

            <programlisting>IteratorVariable: Variable | CallableVariable | EntryVariablePair</programlisting>
            
            <para>An iteration variable may be callable.</para>
            
            <programlisting>CallableVariable: (UnionType | "void")? MemberName Params+</programlisting>
        
            <para>If the return type is missing from the declaration, the return type of the 
            callable variable is inferred.</para>

            <para>An iteration variable of type <literal>Entry</literal> may be specified in 
            destructured form.</para>
        
            <programlisting>EntryVariablePair: Variable "->" Variable</programlisting>
            
        </section>
        
        <section id="controlstructureconditions">
            <title>Control structure conditions</title>
            
        <para>Some control structures expect conditions. There are five kinds of condition:</para>
        
        <itemizedlist>
            <listitem>
                <para>a <emphasis>boolean condition</emphasis> is satisfied when a boolean expression
                evaluates to <literal>true</literal>,</para>
            </listitem>
            <listitem>
                <para>an <emphasis>assignabilty condition</emphasis> is satisfied when an expression
                 evaluates to an instance of a specified type.</para>
            </listitem>
            <listitem>
                <para>an <emphasis>existence condition</emphasis> is satisfied when an expression of
                type <literal>X?</literal> evaluates to a non-null value,</para>
            </listitem>
            <listitem>
                <para>a <emphasis>nonemptiness condition</emphasis> is satisfied when an expression 
                of type <literal>X[]?</literal> evaluates to a non-null, non-empty value, and</para>
            </listitem>
            <listitem>
                <para>a <emphasis>subtype condition</emphasis> is satisfies when a given type is a 
                subtype of the specified type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Condition: BooleanCondition | IsCondition | ExistsOrNonemptyCondition | SatisfiesCondition</programlisting>
        
        </section>
        
        <section id="booleanconditions">
            <title>Boolean conditions</title>
        
        <para>A boolean condition is just an expression.</para>
        
        <programlisting>BooleanCondition: Expression</programlisting>
        
        <para>The expression must be of type <literal>Boolean</literal>.</para>
        
        <para>The condition is satisfied if the expression evaluates to <literal>true</literal> when 
        the containing control structure is executed.</para>
        
        </section>
        
        <section id="assignabilityexistencenonemptinessconditions">
            <title>Assignability, existence, and nonemptiness conditions</title>
        
        <para>Assignability, existence, and nonemptiness conditions may either contain:</para>
        
        <itemizedlist>
            <listitem>
                <para>an unqualified value reference to a non-<literal>variable</literal>
                attribute or local, or</para>
            </listitem>
            <listitem>
                <para>an inline variable declaration together with an expression.</para>
            </listitem>
        </itemizedlist>
        
        <para>In the case of assignability or existence conditions, the type of the variable may be 
        inferred.</para>
                
        <programlisting>IsCondition: "is" (TypedVariable Specifier | UnionType MemberName)</programlisting>
        
        <programlisting>ExistsOrNonemptyCondition: ("exists" | "nonempty") (Variable Specifier | MemberName)</programlisting>
        
        <para>The type of the value reference or expression must be:</para>
        
        <itemizedlist>
            <listitem>
                <para>a subtype of <literal>Object?</literal> for an assignability condition,</para>
            </listitem>
            <listitem>
                <para>of form <literal>X?</literal> for some type <literal>X</literal> for an existence 
                condition, or</para>
            </listitem>
            <listitem>
                <para>of form <literal>X[]</literal> or <literal>X[]?</literal> for some type 
                <literal>X</literal> for a nonemptiness condition, or</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that an existence or nonemptiness condition is equivalent to&mdash;and may be 
        considered an abbreviation of&mdash;an assignability condition.</para>
        
        <itemizedlist>
            <listitem>
                <para><literal>if (exists x)</literal> is equivalent to <literal>if (is X x)</literal>
                where <literal>x</literal> is an expression of type <literal>X?</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>if (nonempty x)</literal> is equivalent to <literal>if (is Sequence&lt;X&gt; x)</literal>
                where <literal>x</literal> is an expression of type <literal>X[]?</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>For <literal>exists</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>If the condition declares a variable, the variable must be declared of type 
                <literal>X</literal>, where the specifier expression is of type 
                <literal>Nothing|X</literal>.</para>
            </listitem>
            <listitem>
                <para>If the condition contains a value reference, the local will be treated by the 
                compiler as having type <literal>X</literal> inside the block that immediately 
                follows the condition, where the conditional expression is of type 
                <literal>Nothing|X</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>For <literal>nonempty</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>If the condition declares a variable, the variable must be declared of type 
                <literal>X</literal>, where the specifier expression is of type 
                <literal>Nothing|Empty|X</literal>.</para>
            </listitem>
            <listitem>
                <para>If the condition contains a value reference, the value will be treated by the 
                compiler as having type <literal>X</literal> inside the block that immediately 
                follows the condition, where the conditional expression is of type 
                <literal>Nothing|Empty|X</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>If you prefer, you can think of the following:</para>
        
        <programlisting>if (exists name) { ... }</programlisting>
        
        <para>As an abbreviation of:</para>
        
        <programlisting>if (exists String name = name) { ... }</programlisting>
        
        <para>Where the <literal>name</literal> declared by the condition hides the outer declaration
        of <literal>name</literal> inside the block that follows.</para>
                        
        <para>For <literal>is</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>If the condition declares a variable, the specifier expression type need not be 
                assignable to the declared type of the variable, or</para>
            </listitem>
            <listitem>
                <para>if the condition contains a value reference, the value will be treated by the 
                compiler as having the specified type inside the block that immediately follows the 
                condition.</para>
            </listitem>
        </itemizedlist>
                        
        <para>If you prefer, you can think of the following:</para>
        
        <programlisting>if (is Usable obj) { ... }</programlisting>
        
        <para>As an abbreviation of:</para>
        
        <programlisting>if (is Usable obj = obj) { ... }</programlisting>
        
        <para>Where the <literal>obj</literal> declared by the condition hides the outer declaration
        of <literal>obj</literal> inside the block that follows.</para>
        
        <para>The condition is satisfied if the value reference or expression evaluates to an 
        instance of the required type when the control structure containing the condition is
        executed:</para>
        
        <itemizedlist>
            <listitem>
                <para>for an assignability condition, the condition is satisfied if the expression 
                evaluates to an instance of the specified type when the control structure is 
                executed,</para>
            </listitem>
            <listitem>
                <para>for an existence condition, the condition is satisfied unless the expression 
                evaluates to an instance of <literal>Nothing</literal> when the control structure is 
                executed, or</para>
            </listitem>
            <listitem>
                <para>for a nonemptiness expression, the condition is satisfied unless the expression 
                evaluates to an instance of <literal>Empty</literal> or <literal>Nothing</literal>
                when the control structure is executed.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that these are formal definitions. In fact, the compiler erases 
        <literal>Nothing|T</literal> to <literal>T</literal> before generating bytecode.
        So <literal>if (exists x)</literal> is actually processed as <literal>if (x!=null)</literal>
        by the virtual machine.</para>
        
        </section>
                
        <section id="subtypeconditions">
            <title>Subtype conditions</title>
        
        <para>A subtype condition specifies a <emphasis>specified type</emphasis> (first) and a 
        <emphasis>given type</emphasis> (second).</para>
        
        <programlisting>SatisfiesCondition: "satisfies" Type Type</programlisting>        
        
        <para>The given type will be treated by the compiler as a subtype of the specified type 
        inside the block that immediately follows the condition.</para>
        
        <para>The condition is satisfied if the given type is a subtype of the specified type when 
        the control structure containing the condition is executed.</para>
        
        <comment><para>TODO: Should we support simultaneous narrowing to multiple types:</para>
        <programlisting>if (is Format &amp; IdentifiableObject object) { ... }</programlisting>
        <programlisting>if (satisfies Keyed &amp; Persistent Value) { ... }</programlisting>
        <para>(This would fall out naturally if we add ad hoc intersection types.)</para>
        </comment>
        
        </section>
        
        <section id="exhaustivecaselists">
            <title>Exhaustive lists of cases</title>
            
            <para>A <literal>switch</literal> may or may not have an <emphasis>exhaustive list of 
            cases</emphasis> of a certain type.</para>
            
            <para>A <literal>switch</literal> has an <emphasis>exhaustive list of cases of a type</emphasis> 
            <literal>T</literal> with an enumerated list of cases if:</para>
            
            <itemizedlist>
                <listitem>
                    <para>every case of <literal>T</literal> which is an anonymous class directly or
                    indirectly extends the class <literal>Case</literal> defined in 
                    <literal>ceylon.language</literal> and is explicitly listed as an ordinary 
                    <literal>case</literal> value of the <literal>switch</literal>, and</para>
                </listitem>
                <listitem>
                    <para>for every other case <literal>U</literal> of the type (every named class or 
                    interface), either <literal>U</literal> is explicitly listed as a 
                    <literal>case (is U)</literal> assignability condition, or, if <literal>U</literal> 
                    is also a type with an enumerated list of cases, the <literal>switch</literal> has 
                    an exhaustive list of cases of <literal>U</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>A <literal>switch</literal> has an <emphasis>exhaustive list of cases of a union 
            type</emphasis> <literal>T|U|V|...</literal> if:</para>
            
            <itemizedlist>
                <listitem>
                    <para>for every type <literal>U</literal> belonging to the union, either 
                    <literal>U</literal> is explicitly listed as a <literal>case (is U)</literal> 
                    assignability condition, or, if <literal>U</literal> is also a type with an 
                    enumerated list of cases, the <literal>switch</literal> has an exhaustive 
                    list of cases of <literal>U</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>A <literal>switch</literal> has an <emphasis>exhaustive list of cases of an optional
            type</emphasis> <literal>T?</literal> if:</para>
            
            <itemizedlist>
                <listitem>
                    <para>it has an exhaustive list of cases of <literal>T</literal>, and</para>
                </listitem>
                <listitem>
                    <para>it has a <literal>case (null)</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>A <literal>switch</literal> has an <emphasis>exhaustive list of cases of a metatype</emphasis> 
            <literal>Type&lt;T&gt;</literal> where <literal>T</literal> is a type with an enumerated 
            list of cases if:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>T</literal> has no cases which are anonymous classes, and</para>
                </listitem>
                <listitem>
                    <para>for every case <literal>U</literal> of the type (every named class or 
                    interface), either <literal>U</literal> is explicitly listed as a 
                    <literal>case (satisfies U)</literal> subtype condition, or, if <literal>U</literal> 
                    is also a type with an enumerated list of cases, the <literal>switch</literal> has 
                    an exhaustive list of cases of <literal>Type&lt;U&gt;</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <comment><para>TODO: for a covariant type like <literal>Sequence&lt;Node&lt;Element&gt;&gt;</literal>,
            should we treat the cases <literal>Sequence&lt;Root&lt;Element&gt;&gt;</literal>,
            <literal>Sequence&lt;Branch&lt;Element&gt;&gt;</literal>, and
            <literal>Sequence&lt;Leaf&lt;Element&gt;&gt;</literal> as an exhaustive list of cases?</para></comment>
            
        </section>
        
        <section id="ifelse">
            <title><literal>if/else</literal></title>
            
            <para>The <literal>if/else</literal> conditional has the following form:</para>
            
            <programlisting>IfElse: If Else?</programlisting>

            <programlisting>If: "if" "(" Condition ")" Block</programlisting>
            
            <programlisting>Else: "else" (Block | IfElse)</programlisting>

            <!--programlisting>IfElse: 
"if" "(" Condition ("," Condition)* ")"
( ClosedBlock | OpenBlock "else" ClosedBlock )</programlisting-->

            <para>When the construct is executed, the condition is evaluated. If the condition is 
            satisfied, the <literal>if</literal> block is executed. Otherwise, the <literal>else</literal> 
            block, if any, is executed.</para>

            <!--para>Condition expressions may refer to any local variable defined by a previous
            condition.</para-->
                                
            <para>For example:</para>
            
            <programlisting>if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid := true;
}
else {
    throw NotEnoughMoneyException();
}</programlisting>

            <programlisting>shared void welcome(User? user) {
    if (exists user) {
        log.info("Hi " user.name "!");
    }
    else {
        log.info("Hello, World!");
    }
}</programlisting>
            
            <programlisting>shared Payment payment(Order order) {
    if (exists Payment p = order.payment) {
        return p;
    }
    else { 
        return Payment(order);
    }
}</programlisting>

            <programlisting>if (exists Payment p = order.payment) {
    if (p.paid) { 
        log.info("already paid"); 
    }
}</programlisting>
            
            <programlisting>if (is CardPayment p = order.payment) {
    return p.card;
}</programlisting>
            
        <programlisting>List&lt;Element&gt; list = ...;
Element element = ...;
if (satisfies Comparable&lt;Element&gt; Element) {
    Element test;
    if (exists Element first = list.first) {
        test = max(element, first);
    }
    else {
        test = element;
    }
    return forAll(Element e in list) every (e&lt;=test);
}</programlisting>
<!-- 
        <programlisting>String string&lt;P...&gt;(Tuple&lt;P...&gt; tuple) {
    if (T, Q... satisfies P...) {
        return $tuple.head + ", " + string(tuple.tail);
    }
    else {
        return ";";
    }
}</programlisting>
-->
        </section>
        
        <section id="switchcaseelse">
            <title><literal>switch/case/else</literal></title>
            
            <para>The <literal>switch/case/else</literal> conditional has the following form:</para>
            
            <programlisting>SwitchCaseElse: Switch ( Cases | "{" Cases "}" )</programlisting>
            
            <programlisting>Switch: "switch" "(" Expression ")"</programlisting>
            
            <programlisting>Cases: CaseItem+ DefaultCaseItem?</programlisting>

            <programlisting>CaseItem: "case" "(" Case ")" Block</programlisting>
            
            <programlisting>DefaultCaseItem: "else" Block</programlisting>

            <para>The <literal>switch</literal> expression may be of any type. Each <literal>case</literal> 
            value must be:</para> 
            
            <itemizedlist>
                <listitem>
                    <para>a list of expressions of type assignable to <literal>Matcher&lt;X&gt;</literal>, 
                    where <literal>X</literal> or <literal>X?</literal> is a subtype of the 
                    <literal>switch</literal> expression type, or</para>
                </listitem>
                <listitem>
                    <para>if the <literal>switch</literal> expression is of type <literal>X?</literal>, 
                    for some type <literal>X</literal>, the expression <literal>null</literal>, or</para>
                </listitem>
                <listitem>
                    <para>an assignability condition of form <literal>case (is ...)</literal>, or</para>
                </listitem>
                <listitem>
                    <para>if the <literal>switch</literal> expression type is a subtype of 
                    <literal>Type&lt;T&gt;</literal> for some type <literal>T</literal>, a subtype 
                    condition of form <literal>case (satisfies ...)</literal>.</para>
                </listitem>
            </itemizedlist>

            <programlisting>Case: Expression ("," Expression)* | "is" UnionType | "satisfies" Type</programlisting>
            
            <!--
            <para>If the <literal>switch</literal> expression is of type <literal>Optional&lt;X&gt;</literal>, 
            there must be an explicit <literal>case (null)</literal>.</para>
            -->
            
            <para>We say that a <literal>switch</literal> is <emphasis>exhaustive</emphasis> if it has 
            an exhaustive list of cases of the switch expression type. If no <literal>else</literal> 
            block is specified, the <literal>switch</literal> must be exhaustive. Conversely, if the 
            <literal>switch</literal> is exhaustive, no <literal>else</literal> block may be specified.</para>
            
            <para>When the construct is executed, the <literal>switch</literal> expression is 
            evaluated, and the resulting value is tested against the <literal>case</literal> values 
            using <literal>Matcher.matchesCase()</literal>. The <literal>case</literal> block for the 
            first <literal>case</literal> value that tests <literal>true</literal> is executed. If 
            no <literal>case</literal> value tests <literal>true</literal>, and an <literal>else</literal> 
            block is defined, the <literal>else</literal> block is executed.</para>
                         
            <para>For an assignability condition <literal>case</literal>, if the <literal>switch</literal> 
            expression is a local, then the local will be treated by the compiler as having the 
            specified type inside the <literal>case</literal> block.</para>
            
            <para>For example:</para>

            <programlisting>shared PaymentProcessor processor {
    switch (payment.type) 
    case (null) { 
        throw NoPaymentTypeException();
    }
    case (credit, debit) { 
        return cardPaymentProcessor;
    }
    case (check) { 
        return checkPaymentProcessor;
    }
    else { 
        return interactivePaymentProcessor;
    }
}</programlisting>
            
            <programlisting>switch (payment.type) {
    case (credit, debit) { 
        log.debug("card payment");
        cardPaymentProcessor.process(payment, user.card);
    } 
    case (check) {
        log.debug("check payment");
        checkPaymentProcessor.process(payment);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

            <programlisting>switch (payment) {
    case (is CardPayment) { 
        pay(payment.amount, payment.card);
    } 
    case (is CheckPayment) {
        pay(payment.amount, payment.check);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

            <programlisting>switch (node) {
    case (root) { 
        handleRootNode();
    } 
    case (is Leaf) {
        handleLeafNode(node);
    }
    case (is Branch) {
        handleBranchNode(node);
    }
}</programlisting>
            
            <!--
            <comment><para>TODO: should it be a <literal>catch</literal>-style syntax,
            for example <literal>is (Leaf)</literal> instead of 
            <literal>case (is ...)</literal>?</para></comment>
            -->
            
            <para>A Java-style overloaded method may be emulated as follows:</para>
            
            <programlisting>shared void print&lt;Printable&gt;(Printable printable) 
        given Value of String | Integer | Float {
    switch (printable)
    case (is String) { 
        stream.writeLine(printable); 
    }
    case (is Integer) { 
        print($printable); 
    }
    case (is Float) { 
        print( FloatFormat(printable, 2) ); 
    }
}</programlisting>

            <para>Or, even better:</para>
            
            <programlisting>shared Value join&lt;Value&gt;(Value x, Value y) 
        given Value of String | Integer {
    switch (Value)
    case (satisfies String) { 
        return x+y;
    }
    case (satisfies Integer) { 
        return (IntegerFormat(x,2)+IntegerFormat(y,2)).parseInteger(2);
    }
}</programlisting>
            
        </section>
        
        <section id="forelse">
            <title><literal>for/else</literal></title>
            
             <para>The <literal>for/else</literal> loop has the following form:</para>
             
            <programlisting>ForFail: For Fail?</programlisting>

            <programlisting>For: "for" "(" ForIterator ")" Block</programlisting>
            
            <programlisting>Fail: "else" Block</programlisting>

            <!--programlisting>ForFail :=
"for" "(" Iteration (";" Iteration)* ")" 
( ClosedBlock | OpenBlock "fail" ClosedBlock )
</programlisting-->

            <para>The <literal>for</literal> iterator consists of an iteration variable 
            declaration and an iterated expression that contains the range of values to 
            be iterated.</para>
            
            <programlisting>ForIterator: IteratorVariable "in" Expression</programlisting>

            <para>The type of the iterated expression depends upon the iteration variable 
            declarations:</para>
            
            <itemizedlist>
            <listitem>
                <para>The iterated expression must be an expression of type assignable to 
                <literal>Iterable&lt;X&gt;</literal> <!--or <literal>Iterator&lt;X&gt;</literal>-->
                where <literal>X</literal> is the declared type of the iteration variable.</para> 
            </listitem>
            <listitem>
                <para>If two iteration variables are defined, the iterated expression type 
                must be assignable to <literal>Iterable&lt;Entry&lt;U,V&gt;&gt;</literal> <!--or 
                <literal>Iterator&lt;Entry&lt;U,V&gt;&gt;</literal>--> where <literal>U</literal>
                and <literal>V</literal> are the declared types of the iteration variables.</para>
            </listitem>
            </itemizedlist>
            
            <!--para>Iterated and constraint expressions may refer to any local variable 
            defined by a previous iteration.</para-->
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para><!--if the iterated expression is of type <literal>Iterable</literal>,-->
                    the iterator is obtained by evaluating <literal>iterator</literal>, and 
                    then</para>
                </listitem>
                <listitem>
                    <para>the <literal>for</literal> block is executed once for each value 
                    of type <literal>X</literal> produced by the iterator, until the iterator 
                    is exhausted, or until a <literal>break</literal>, <literal>return</literal>,
                    or <literal>throw</literal> directive is executed.</para>
                </listitem>
            </itemizedlist>
            
            <para>Note that:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the iterated expression is also of type <literal>Sequence&lt;X&gt;</literal>,
                    the compiler is permitted to optimize away the use of <literal>Iterator</literal>, 
                    instead using indexed element access.</para>
                </listitem>
                <listitem>
                    <para>if the iterated expression is a range constructor expression, the compiler 
                    is permitted to optimize away creation of the <literal>Range</literal>, and generate
                    the indices using the <literal>successor</literal> operation.</para>
                </listitem>
            </itemizedlist>
            
            <para>We say that the loop <emphasis>exits early</emphasis> if it ends via execution 
            of a <literal>break</literal>, <literal>return</literal>, or <literal>throw</literal>
            directive. Otherwise, we say that the loop <emphasis>completes</emphasis> normally.</para>
             
            <para>If the loop completes normally, the <literal>else</literal> block is executed. 
            Otherwise, if the loop exists early, the <literal>else</literal> block is not executed.</para>
                                
            <para>For example:</para>

            <programlisting>for (Person p in people) { 
    log.info(p.name);
}</programlisting>

            <programlisting>variable Float sum := 0.0;
for (Integer i in -10..+10) {
    sum += x[i] ? 0.0;
}</programlisting>
            
            <programlisting>for (Natural month -> Float temp in monthlyTempsList) { 
    plot(month,temp); 
}</programlisting>

            <programlisting>for (String word -> Natural freq in wordFrequencyMap) { 
    log.info("The frequency of " word " is " freq "."); 
}</programlisting>
            
            <programlisting>for (Person p in people) {
    log.debug("Testing person: " p.name ".");
    if (p.age >= 18) {
        log.info("Found an adult: " p.name ".");
        break;
    }
}
else {
    log.info("no adults");
}
</programlisting>

        </section>
        
        <section id="while">
            <title><literal>while</literal></title>
            
            <para>The <literal>while</literal> loop has the form:</para>
            
            <programlisting>While: LoopCondition Block</programlisting>
            
            <para>The loop condition determines when the loop terminates.</para>
            
            <programlisting>LoopCondition: "while" "(" Condition ")"</programlisting>

            <!--programlisting>DoWhileFail: 
( "do" ("(" Variable Specifier ")")? OpenBlock? )?
"while" "(" Condition ("," Condition)* ")" 
( ";" | ClosedBlock | OpenBlock? "fail" ClosedBlock )</programlisting-->
            
            <para>When the construct is executed, the loop condition is evaluated repeatedly
            until the first time the condition is not satisfied, or until a <literal>break</literal>, 
            <literal>return</literal>, or <literal>throw</literal> directive is executed. 
            Each time the condition is satisfied, the block is executed.</para>
            
            <comment><para>TODO: does <literal>while</literal> need a <literal>fail</literal> 
            block? Python has it, but what is the real usecase?</para></comment>
            
            <para>For example:</para>
            
            <programlisting>variable Natural n:=0;
OpenList&lt;Natural&gt; seq = ArrayList&lt;Natural&gt;();
while (n&lt;=max) {
    seq.append(n);
    n+=step(n);
}</programlisting>
            
            <programlisting>Iterator&lt;Person&gt; iter = org.employees.iterator;
while (exists Person p = iter.head) {
    log.info(p.name);
    iter.=tail;
}</programlisting>
                  
        </section>

        <section id="trycatchfinally">
            <title><literal>try/catch/finally</literal></title>
            
            <para>The <literal>try/catch/finally</literal> exception manager has the 
            form:</para>
            
            <programlisting>TryCatchFinally: Try Catch* Finally?</programlisting>

            <programlisting>Try: "try" ("(" Resource ")")? Block</programlisting>
            
            <programlisting>Catch: "catch" "(" Variable ")" Block</programlisting>
            
            <programlisting>Finally: "finally" Block</programlisting>

            <para>Each <literal>catch</literal> block defines a variable. The type of
            the variable must be assignable to <literal>ceylon.language.Exception</literal>. 
            If no type is explicitly specified, the type is inferred to be 
            <literal>ceylon.language.Exception</literal>.</para> 
            
            <para>If there are multiple <literal>catch</literal> blocks in a certain
            control structure, then:</para>
            
            <itemizedlist>
                <listitem>
                    <para>The type of a <literal>catch</literal> variable may not be 
                    a subtype of any catch variable of an earlier <literal>catch</literal> 
                    block belonging to the same control structure.</para>
                </listitem>
                <listitem>
                    <para>If the type of a <literal>catch</literal> variable is a union
                    type <literal>E1|E2|...|En</literal> then no member <literal>Ei</literal>
                    of the union may be a subtype of any catch variable of an earlier 
                    <literal>catch</literal> block belonging to the same control structure.</para>
                </listitem>
            </itemizedlist>
                        
            <para>The <literal>try</literal> block may declare a <emphasis>resource</emphasis>
            expression, which may be either:</para>
            
            <itemizedlist>
                <listitem><para>an unqualified value reference to a non-<literal>variable</literal> 
                attribute or local,</para></listitem>
                <listitem><para>an instantiation expression, or</para></listitem>
                <listitem><para>an inline variable declaration together with an expression.</para></listitem>
            </itemizedlist>
            
            <para>A resource expresson produces a heavyweight object that must be 
            released when execution of the <literal>try</literal> terminates. Each 
            resource expression must be of type assignable to 
            <literal>ceylon.language.Resource</literal>.</para>
            
            <programlisting>Resource: MemberName | InitializerReference Arguments | Variable Specifier </programlisting>
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the resource expression, if any, is evaluated, and then 
                    <literal>begin()</literal> is called on the resulting resource 
                    instance, then</para>
                </listitem>
                <listitem>
                    <para>the <literal>try</literal> block is executed, then</para>
                </listitem>
                <listitem>
                    <para><literal>end()</literal> or <literal>abort()</literal> is 
                    called on the resource instance, if any, with the exception that 
                    propagated out of the <literal>try</literal> block, if any, then</para>
                </listitem>
                <listitem>
                    <para>if an exception did propagate out of the <literal>try</literal> 
                    block, the first <literal>catch</literal> block with a variable 
                    to which the exception is assignable, if any, is executed, and 
                    then</para>
                </listitem>
                <listitem>
                    <para>the <literal>finally</literal> block, if any, is 
                    executed.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>try ( File file = File(name) ) {
    file.open(readOnly);
    ...
}
catch (FileNotFoundException fnfe) {
    log.info("file not found: " name "");
}
catch (FileReadException fre) {
    log.info("could not read from file: " name "");
}
finally {
    if (file.open) {
        file.close();
    }
}</programlisting>
            
            <programlisting>try (semaphore) {
    if ( !map.defines(key) ) {
        map[key] := item;
    }
}</programlisting>

            <para>(This example shows a Ceylon-ified version of the Java 
            <literal>synchronized</literal> block.)</para>
            
            <programlisting>try ( Transaction() ) {
    try ( Session s = Session() ) {
        return s.get(Person, id);
    }
    catch (NotFoundException|DeletedException e) {
        return null;
    }
}</programlisting>

<!--

            <para>The <literal>retry</literal> directive re-evaluates the resource 
            expression, if any, and then re-executes the <literal>try</literal> block, 
            calling <literal>begin()</literal> and <literal>end()</literal>/<literal>abort()</literal> 
            upon the resource instance.</para>

            <programlisting>variable Natural retries := 0;
try ( Transaction() ) {
    ...
}
catch (TransactionTimeoutException e) {
    if (retries &lt; 3) {
        retries++;
        retry;
    }
    else {
        throw e;
    }
}</programlisting>

-->
        </section>
         
    </section>

</chapter>