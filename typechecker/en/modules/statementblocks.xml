<chapter id="statementblocks">
    <title>Blocks and control structures</title>
    
    <para>Method, attribute and class bodies contain procedural code that is executed 
    when the method or attribute is invoked, or when the class is instantiated. The 
    code contains expressions and control directives and is organized using blocks and 
    control structures.</para>
    
    <section>
        <title>Name resolution</title>
        
        <para>An unqualified identifier (an identifier not preceded by <literal>.</literal>,
        <literal>[].</literal> or <literal>?.</literal>) that appears in a program 
        element refers to a declaration elsewhere: a class, interface, alias, method, 
        attribute, local or enumerated instance.</para>
        
        <para>A <emphasis>body</emphasis> is a block, class body or interface body.
        A declaration is <emphasis>in scope</emphasis> at a program element if:</para>
        
        <itemizedlist>
            <listitem>
                <para>it is a formal parameter, type parameter, or control structure 
                variable of a body that contains the program element, or</para>
            </listitem>
            <listitem>
                <para>it occurs earlier in a body that contains the program element, 
                or</para>
            </listitem>
            <listitem>
                <para>it occurs in the second part of a class body, after the last 
                statement or declaration of the initializer, and the program element 
                is contained in the second part of the class body, or</para>
            </listitem>
            <listitem>
                <para>it is a declaration imported by the compilation unit containing 
                the program element and is visible to the program element, or</para>
            </listitem>
            <listitem>
                <para>it is a toplevel declaration in the package containing the program
                element and is visible to the program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>If there is no declaration with the specified name in scope at the program
        element where the specified name occurs, a compilation error occurs.</para>
        
        <para>If multiple declarations with the specified name are in scope at the program
        element where the specified name occurs, the name refers to the declaration which
        is not <emphasis>hidden</emphasis> by another declaration:</para>
        
        <itemizedlist>
            <listitem>
                <para>if an inner body is contained (directly or indirectly) an outer body, 
                a declaration, formal parameter, type parameter or control structure variable 
                of the inner body hides a declaration, formal parameter, type parameter or 
                control structure variable in the outer body,</para>
            </listitem>
            <listitem>
                <para>a formal parameter of a class body hides an attribute of the class,</para>
            </listitem>
            <listitem>
                <para>a declaration occurring in a body containing the program element 
                hides a declaration imported by the compilation unit, and</para>
            </listitem>
            <listitem>
                <para>a declaration imported by the compilation unit hides a toplevel 
                declaration of the package containing the program element.</para>
            </listitem>
        </itemizedlist>
        
        <para>If there are multiple unhidden declarations with the specified name, and 
        they are not all overloaded declarations of the same method or class, the name 
        is ambiguous, and a compilation error occurs.</para>
        
        <para>A body may not contain two declarations with the same name unless they are 
        overloaded versions of the same method or class, or unless one is a formal parameter 
        of the class body and the other is an attribute of the class. A package may not 
        contain two toplevel declarations with the same name unless they are overloaded 
        versions of the same method or class.</para>
        
        <para>Note that this code is not legal:</para>
        
        <programlisting>String uppercase(String string) {
    String string = string.uppercase;  //compiler error!
    return string;
}</programlisting>

        <para>However, this code <emphasis>is</emphasis> legal, since class initialization 
        parameters and attributes may share a name:</para>
        
        <programlisting>public class Person(String name) {
    public String name = name;
}</programlisting>

        <para>Note that this code is not legal:</para>
        
        <programlisting>Entry&lt;Float,Float&gt; xy() {
    Float x { return y }  //compiler error!
    Float y { return x }
    return x->y;
}</programlisting>

        <para>Nor is this code legal, since all three statements occur inside the
        initializer of the class:</para>
        
        <programlisting>class Point() {
    Float x { return y }  //compiler error!
    Float y { return x }
    Entry&lt;Float,Float&gt; xy = x->y;
}</programlisting>

        <para>However, this code <emphasis>is</emphasis> legal, since the statements do not 
        occur in the initializer of the class:</para>
        
        <programlisting>public class Point() {
    Float x { return y }
    Float y { return x }
}</programlisting>

    </section>
    
    <section id="blocks">
        <title>Blocks and statements</title>
            
        <para>A <emphasis>block</emphasis> is list of semicolon-delimited statements, 
        method, attribute and local declarations, and control structures, surrounded by 
        braces. Some blocks end in a control directive. The statements, local specifiers 
        and control structures belonging to a block are executed sequentially in the 
        order that they appear inside the block. Execution of a block begins at the first 
        statement, local specifier, or control structure of the block. Execution of a block 
        terminates when the last statement, local specifier, or control structure of the 
        block finishes executing, when a control directive that terminates the block is 
        executed, or when an exception is thrown.</para>

        <programlisting>Block := "{" (Declaration | Statement)* DirectiveStatement? "}"</programlisting>
        
        <para>A <emphasis>statement</emphasis> is an assignment or specification, an 
        invocation of a method, an instantiation of a class, a control structure or a 
        control directive.</para>

        <programlisting>Statement := ExpressionStatement | Specification | ControlStructure</programlisting>
        
        <para>A simple attribute or local may not be used in an expression until its value 
        has been explicitly specified or initialized. The Ceylon compiler guarantees this
        by evaluating all conditional branches that lead to the first use of an attribute
        of local in an expression. Each conditional branch must specify or assign a value 
        to the simple attribute or local before using it in an expression.</para>
        
        <para>Every simple attribute of a non-<literal>abstract</literal> class must be 
        explicitly specified or initialized by the initializer of the class or by the
        initializer of one of its superclasses. The Ceylon compiler guarantees this by 
        evaluating all conditional branches that lead to termination of the initializer
        without an uncaught exception. Each conditional branch must specify or assign a value 
        to the simple attribute before the initializer terminates without an uncaught exception.</para>
        
        <para>A simple attribute or local may not be the target of a specifier expression if 
        its value has already been specified. The Ceylon compiler guarantees this by evaluating 
        all conditional branches that lead to the use of a simple attribute or local in a
        specifier expression. No conditional branch may specify a value to the simple attribute 
        or local before using it in a specifier expression.</para>
        
        <comment><para>TODO: chapter 16 of the JLS goes into way more detail about the notion
        of "definite assignment" and "definite unassignment". We eventually need something
        more like this level of detail, I suppose.</para></comment>
        
        <comment><para>TODO: should we allow blocks and control structures to be annotated, 
        for example:</para>
        <programlisting>doc "unsafe assignment" 
suppressWarnings(typesafety)
do { 
    apple = orange;
}</programlisting>
<programlisting>doc "synchronize on the lock"
try (lock) { ... }</programlisting>
</comment>
        
        <section>
            <title>Expression statements</title>
            
        <para>Only certain expressions are valid statements: assignment, prefix or 
        postfix increment or decrement, invocation of a method and instantiation of 
        a class.</para>
        
        <programlisting>ExpressionStatement := ( Assignment | IncrementOrDecrement | Invocation ) ";"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>x := 1;</programlisting>
        <programlisting>x++;</programlisting>
        <programlisting>log.info("Hello");</programlisting>
        <programlisting>Main(p);</programlisting>
        
        <comment><para>TODO: it would be possible to say that any expression is a valid
        statement, but this seems to just open up more potential programming errors. So
        I think it's better to limit statements to assignments, invocations
        and instantiations.</para></comment>
        
        <comment><para>TODO: should we let you leave off the <literal>;</literal> on the last
        expression statement in the block, like we do for directives?</para></comment>
        
        </section>
        
        <section id="controldirectives">
            <title>Control directives</title>
            
        <para>Control directive statements end execution of the current block and force 
        the flow of execution to resume in some outer scope. They may only appear at the 
        end of a block, so the semicolon terminator is optional.</para>

        <programlisting>DirectiveStatement := Directive ";"?</programlisting>
        
        <programlisting>Directive := Return | Throw | Break | Continue | Retry</programlisting>
        
        <para>Ceylon provides the following control directives:</para>
        
        <itemizedlist>
            <listitem>the <literal>return</literal> directive&mdash;to return a value from a method 
            or attribute getter,</listitem>
            <listitem>the <literal>break</literal> directive&mdash;to terminate a loop,</listitem>
            <listitem>the <literal>continue</literal> directive&mdash;to jump to the next iteration 
            of a loop,</listitem>
            <listitem>the <literal>throw</literal> directive&mdash;to raise an exception, and</listitem>
            <listitem>the <literal>retry</literal> directive&mdash;to re-execute a <literal>try</literal> 
            block, reinitializing all resources.</listitem>
        </itemizedlist>
                
        <programlisting>throw Exception()</programlisting>
        <programlisting>retry</programlisting>
        <programlisting>return x+y</programlisting>
        <programlisting>return "Hello"</programlisting>
        <programlisting>break true</programlisting>
        <programlisting>continue</programlisting>
        
        <para>The <literal>return</literal> directive may not appear outside the body of 
        a method or attribute getter. In the case of a <literal>void</literal> method, no 
        expression may be specified. In the case of a non-<literal>void</literal> method 
        or attribute getter, an expression must be specified. The expression type must be 
        assignable to the return type of the method. When the directive is executed, the 
        expression is evaluated to determine the return value of the method or attribute 
        getter.</para>
        
        <programlisting>Return := "return" Expression?</programlisting>
        
        <para>The <literal>break</literal> directive may not be appear outside the body 
        of a loop. If the loop has no <literal>fail</literal> block, the <literal>break</literal> 
        directive may not specify an expression. If the loop has a <literal>fail</literal> 
        block, the <literal>break</literal> directive must specify an expression of 
        type <literal>lang.Boolean</literal>. When the directive is executed, the expression 
        is evaluated and a value of <literal>false</literal> specifies that the 
        <literal>fail</literal> block should be executed.</para>
        
        <programlisting>Break := "break" Expression?</programlisting>
        
        <para>The <literal>continue</literal> directive may not be appear outside the body 
        of a loop.</para>
        
        <programlisting>Continue := "continue"</programlisting>
        
        <para>A <literal>throw</literal> directive may appear anywhere and may specify an 
        expression of type <literal>lang.Exception</literal>. When the directive is executed, 
        the expression is evaluated and the resulting exception is thrown. If no expression 
        is specified, the directive is equivalent to <literal>throw Exception()</literal>.</para>
        
        <programlisting>Throw := "throw" Expression?</programlisting>
        
        <para>A <literal>retry</literal> directive may not appear outside of a
        <literal>catch</literal> block.</para>
        
        <programlisting>Retry := "retry"</programlisting>
        
        <!--comment><para>TODO: We could support <literal>for/fail</literal> loops 
        that return a value by supporting a <literal>found expr</literal> directive. 
        We could support conditionals that return a value by adding a 
        <literal>then expr</literal> directive.</para></comment-->
        
        </section>
        
        <section id="specificationstatements">
            <title>Specification statements</title>
            
        <para>A specification statement may specify the value of a non-<literal>mutable</literal> 
        attribute or local that has already been declared earlier in the block. It may 
        even specify a value of type <literal>Callable</literal> for a method that was 
        declared earlier in the block.</para>
        
        <programlisting>Specification := MemberName Specifier ";"</programlisting>
                
        <para>The Ceylon language distinguishes between assignment to a <literal>mutable</literal> 
        value (the <literal>:=</literal> operator) and specification of the value of a 
        non-<literal>mutable</literal> local or attribute (using <literal>=</literal>). 
        A specification is not an expression.</para>
        
        <para>The specified expression type must be assignable to the type of the 
        attribute or local.</para>
        
        <para>A specification may appear inside an control structure, in which case the
        compiler validates that all paths result in a properly specified method or 
        attribute. For example:</para>
        
        <programlisting>String description;
Comparison order(X x, X y);
if (reverseOrder()) {
    description = "Reverse order";
    order = Order.reverse;
}
else {
    description = "Natural order";
    order = Order.natural;
}</programlisting>

        </section>
        
        <section id="nesteddeclarations">
            <title>Nested declarations</title>
        
            <para>Blocks may contain declarations. A declaration that occurs in a block is a 
            block local declaration&mdash;it is visible only to statements and declarations 
            that occur later in the same block, and therefore it may not declare a visibility 
            modifier.</para>
            
            <comment><para>TODO: Note that Java does not let you define an interface inside
            a method, so we should either add the same restriction, or figure out workaround.
            Note that Java doesn't let you define a method inside a method either, but we can
            wrap the nested method in an anonymous class. Note that Java has a funny semantic
            for a class nested inside an interface nexte</para></comment>
            
            <comment><para>TODO: Note that Java has a funny semantic for a class nested inside 
            an interface nested inside another class. All nested classes of interfaces are 
            considered static inner classes, so this class does not have access to the members
            of the containing class (unintuitively). We need to figure out how to treat this 
            case. Also consider the related case of a class nested inside an interface nested
            inside a method.</para></comment>
            
        </section>
        
    </section>
           
    <section id="controlstructures">
        <title>Control structures</title>
        
        <para>Control of execution flow may be achieved using control directives and 
        control structures. Control structures include conditionals, loops, and 
        exception management. <!--For many tasks, the use of these traditional control
        structures is considered bad style, and the use of expressions with functor 
        parameters is preferred. However, control structures support the use of the 
        <literal>return</literal> and <literal>break</literal> directives, whereas 
        functors do not. Therefore, some tasks may be accomplished only with control 
        structures.--></para>

        <para>Ceylon provides the following control structures:</para>
        
        <itemizedlist>
            <listitem>
                <para>the <literal>if/else</literal> conditional&mdash;for controlling execution 
                based upon a boolean value, and dealing with null values,</para>
            </listitem>
            <listitem>
                <para>the <literal>switch/case/else</literal> conditional&mdash;for controlling 
                execution using an enumerated list of values,</para>
            </listitem>
            <listitem>
                <para>the <literal>while</literal> and <literal>do/while</literal> loops&mdash;for 
                loops which terminate based upon the value of a boolean expression,</para>
            </listitem>
            <listitem>
                <para>the <literal>for/fail</literal> loop&mdash;for looping over elements of a 
                collection, and</para>
            </listitem>
            <listitem>
                <para>the <literal>try/catch/finally</literal> exception manager&mdash;for managing 
                exceptions and controlling the lifecycle of objects which require explicit destruction.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>ControlStructure := IfElse | SwitchCaseElse | While | DoWhile | ForFail | TryCatchFinally</programlisting>
       
        <para>Control structures are not considered to be expressions, and therefore do not evaluate
        to a value.</para>
        
        <comment><para>TODO: Should we support, like Java, single-statement control structure bodies 
        without the braces.</para></comment>
        
        <section id="controlstructurevariables">
            <title>Control structure variables</title>
       
        <para>Some control structures allow embedded declaration of a <emphasis>variable</emphasis> 
        that is available inside the control structure body.</para>
        
        <programlisting>Variable := Type MemberName</programlisting>
        
        <para>In certain cases, the explicit type be omitted, forcing the compiler to infer it, by 
        specifying the keyword <literal>local</literal> where the type usually appears. The type of 
        the variable is inferred to be the type of the expression that follows.</para>
        
        <programlisting>InferableVariable := InferableType MemberName</programlisting>
        
        <para>A variable is treated as a formal parameter of the control structure body.</para>
        
        </section>
        
        <section id="controlstructureconditions">
            <title>Control structure conditions</title>
            
        <para>Some control structures expect conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>a <emphasis>boolean condition</emphasis> is satisfied when a boolean expression
                evaluates to <literal>true</literal>,</para>
            </listitem>
            <listitem>
                <para>an <emphasis>existence condition</emphasis> is satisfied when an expression of
                type <literal>Optional&lt;X&gt;</literal> evaluates to a non-null value,</para>
            </listitem>
            <listitem>
                <para>a <emphasis>nonemptiness condition</emphasis> is satisfied when an expression 
                of type <literal>Optional&lt;Container&gt;</literal> evaluates to a non-null, non-empty 
                value, and</para>
            </listitem>
            <listitem>
                <para>a <emphasis>subtype condition</emphasis> is satisfied when an expression
                evaluates to an instance of a specified type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Condition := Expression | ExistsCondition | IsCondition</programlisting>
       
        <programlisting>ExistsCondition := ("exists" | "nonempty") (InferableVariable Specifier | Expression)</programlisting>
       
        <programlisting>IsCondition := "is" (Variable Specifier | Type Expression)</programlisting>
        
        <para>Any condition contains an expression. In the case of existence, nonemptiness and 
        subtype conditions, the expression may be a specifier of a variable declaration.</para>

        <para>The type of a condition expression depend upon whether the <literal>exists</literal>, 
        <literal>nonempty</literal> or <literal>is</literal> modifier appears:</para>

        <itemizedlist>
            <listitem>
                <para>If no <literal>is</literal>, <literal>exists</literal> or <literal>nonempty</literal> 
                modifier appears, the condition must be an expression of type <literal>Boolean</literal>.</para>
            </listitem>
            <listitem>
                <para>If the <literal>is</literal> modifier appears, the condition expression may 
                be of any type.</para>
            </listitem>
            <listitem>
                <para>If the <literal>exists</literal> modifier appears, the condition expression 
                must be of type <literal>Optional&lt;X&gt;</literal> for some type 
                <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>If the <literal>nonempty</literal> modifier appears, the condition must be an 
                expression of type <literal>Optional&lt;Container&gt;</literal>.</para>
            </listitem>
        </itemizedlist>

        <para>For <literal>exists</literal> or <literal>nonempty</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>If the condition declares a variable, the variable must be declared of 
                type <literal>X</literal>, where the specifier expression is of type 
                <literal>Optional&lt;X&gt;</literal>.</para>
            </listitem>
            <listitem>
                <para>If the condition expression is a local, the local will be treated by the 
                compiler as having type <literal>X</literal> inside the block that 
                follows immediately, where the conditional expression is of type 
                <literal>Optional&lt;X&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
                        
        <para>For <literal>is</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>If the condition declares a variable, the specifier expression type need 
                not be assignable to the declared type of the variable, or</para>
            </listitem>
            <listitem>
                <para>if the condition is a local, the local will be treated by the compiler 
                as having the specified type inside the block that follows immediately.</para>
            </listitem>
        </itemizedlist>
                        
        <para>The semantics of a condition depend upon whether the <literal>exists</literal>, 
        <literal>nonempty</literal> or <literal>is</literal> modifier appears:</para>

        <itemizedlist>
            <listitem>
                <para>If no <literal>is</literal>, <literal>exists</literal> or <literal>nonempty</literal> 
                modifier appears, the condition is satisfied if the expression evaluates to 
                <literal>true</literal> when the control structure is executed.</para>
            </listitem>
            <listitem>
                <para>If the <literal>is</literal> modifier appears, the condition is satisfied 
                if the expression evaluates to an instance of a class that is assignable to the 
                specified type when the control structure is executed.</para>
            </listitem>
            <listitem>
                <para>If the <literal>exists</literal> modifier appears, the condition is satisfied 
                if the expression evaluates to an instance of <literal>Existent&lt;X&gt;</literal> 
                when the control structure is executed.</para>
            </listitem>
            <listitem>
                <para>If the <literal>nonempty</literal> modifier appears, the condition is satisfied 
                if the expression evaluates to an instance of <literal>Existent&lt;Container&gt;</literal> 
                for which <literal>value.empty</literal> evaluates to <literal>false</literal>
                when the control structure is executed.</para>
            </listitem>
        </itemizedlist>
        
        <para>Note that these are formal definitions. In fact, the compiler erases 
        <literal>Optional&lt;T&gt;</literal> to <literal>T</literal> before generating bytecode.
        So <literal>if (exists x)</literal> is actually processed as <literal>if (x!=null)</literal>
        by the virtual machine.</para>

        </section>
        
        <section id="ifelse">
            <title><literal>if/else</literal></title>
            
            <para>The <literal>if/else</literal> conditional has the following form:</para>
            
            <programlisting>IfElse := If Else?</programlisting>

            <programlisting>If := "if" "(" Condition ")" Block</programlisting>
            
            <programlisting>Else := "else" (Block | IfElse)</programlisting>

            <!--programlisting>IfElse := 
"if" "(" Condition ("," Condition)* ")"
( ClosedBlock | OpenBlock "else" ClosedBlock )</programlisting-->

            <para>When the construct is executed, the condition is evaluated. If the condition is 
            satisfied, the <literal>if</literal> block is executed. Otherwise, the <literal>else</literal> 
            block, if any, is executed.</para>

            <!--para>Condition expressions may refer to any local variable defined by a previous
            condition.</para-->
            
            <para>For example:</para>
            
            <programlisting>if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid := true;
}
else {
    throw NotEnoughMoneyException();
}</programlisting>

            <programlisting>public void welcome(User? user) {
    if (exists user) {
        log.info("Hi " user.name "!");
    }
    else {
        log.info("Hello World!");
    }
}</programlisting>
            
            <programlisting>public Payment payment(Order order) {
    if (exists Payment p = order.payment) {
        return p
    }
    else { 
        return Payment(order)
    }
}</programlisting>

            <programlisting>if (exists Payment p = order.payment) {
    if (p.paid) { log.info("already paid"); }
}</programlisting>
            
            <programlisting>if (is CardPayment p = order.payment) {
    return p.card
}</programlisting>
            
        </section>
        
        <section id="switchcaseelse">
            <title><literal>switch/case/else</literal></title>
            
            <para>The <literal>switch/case/else</literal> conditional has the following form:</para>
            
            <programlisting>SwitchCaseElse := Switch ( Cases | "{" Cases "}" )</programlisting>
            
            <programlisting>Switch := "switch" "(" Expression ")"</programlisting>
            
            <programlisting>Cases := CaseItem+ DefaultCaseItem?</programlisting>

            <programlisting>CaseItem := "case" "(" Case ")" Block</programlisting>
            <programlisting>DefaultCaseItem := "else" Block</programlisting>

            <para>The <literal>switch</literal> expression may be of any type. The <literal>case</literal> 
            values must be expressions of type assignable to <literal>Case&lt;X&gt;</literal>, where 
            <literal>X</literal> is the <literal>switch</literal> expression type. Alternatively, the 
            <literal>case</literal>s may be subtype conditions.</para>

            <programlisting>Case := Expression ("," Expression)* | "is" Type</programlisting>
            
            <!--
            <para>If a <literal>case (null)</literal> occurs, the <literal>switch</literal> expression 
            must be of type <literal>Optional&lt;X&gt;</literal> for some type <literal>X</literal>.</para>

            <para>If the <literal>switch</literal> expression is of type <literal>Optional&lt;X&gt;</literal>, 
            there must be an explicit <literal>case (null)</literal>.</para>
            -->
            
            <para>If no <literal>else</literal> block is specified, the <literal>switch</literal> 
            expression type must be a class with a closed enumerated instance list, and all enumerated 
            <literal>case</literal>s of the class must be explicitly listed.</para>
            
            <para>If the <literal>switch</literal> expression type is a class with a closed enumerated 
            instance list, and all enumerated <literal>case</literal>s of the class are explicitly 
            listed, no <literal>else</literal> block may be specified.</para>
            
            <para>When the construct is executed, the <literal>switch</literal> expression is evaluated, 
            and the resulting value is tested against the <literal>case</literal> values using 
            <literal>Case.test()</literal>. The <literal>case</literal> block for the first 
            <literal>case</literal> value that tests <literal>true</literal> is executed. If no 
            <literal>case</literal> value tests <literal>true</literal>, and an <literal>else</literal> 
            block is defined, the <literal>else</literal> block is executed.</para>
            
            <para>For a subtype condition <literal>case</literal>, if the <literal>switch</literal> 
            expression is a local, then the local will be treated by the compiler as having the 
            specified type inside the <literal>case</literal> block.</para>
            
            <para>For example:</para>

            <programlisting>public PaymentProcessor processor {
    switch (payment.type) 
    case (null) { 
        throw NoPaymentTypeException()
    }
    case (credit, debit) { 
        return cardPaymentProcessor
    }
    case (check) { 
        return checkPaymentProcessor
    }
    else { 
        return interactivePaymentProcessor
    }
}</programlisting>
            
            <programlisting>switch (payment.type) {
    case (credit, debit) { 
        log.debug("card payment");
        cardPaymentProcessor.process(payment, user.card);
    } 
    case (check) {
        log.debug("check payment");
        checkPaymentProcessor.process(payment);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

            <programlisting>switch (payment) {
    case (is CardPayment) { 
        pay(payment.amount, payment.card);
    } 
    case (is CheckPayment) {
        pay(payment.amount, payment.check);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

            <comment><para>TODO: should it be a <literal>catch</literal>-style syntax 
            instead of <literal>case (is ...)</literal>?</para></comment>
            
        </section>
        
        <section id="forfail">
            <title><literal>for/fail</literal></title>
            
             <para>The <literal>for/fail</literal> loop has the following form:</para>
             
            <programlisting>ForFail := For Fail?</programlisting>

            <programlisting>For := "for" "(" ForIterator ")" Block</programlisting>
            
            <programlisting>Fail := "fail" Block</programlisting>

            <!--programlisting>ForFail :=
"for" "(" Iteration (";" Iteration)* ")" 
( ClosedBlock | OpenBlock "fail" ClosedBlock )
</programlisting-->

            <para>An iteration variable declaration must specify one or two iteration
            variables, and an iterated expression that contains the range of values to 
            be iterated. <!--It may optionally specify one or more iteration constraint 
            expressions (conditions).--></para>

            <programlisting>ForIterator := InferableVariable ("->" InferableVariable)? "in" Expression</programlisting>

            <!--programlisting>Iteration := FormalParam "in" Expression (":" Condition ("," Condition)*)? </programlisting-->

            <para>The type of the iterated expression depends upon the iterarion variable 
            declarations:</para>
            
            <itemizedlist>
            <listitem>
                <para>The iterated expression must be an expression of type assignable to 
                <literal>Iterable&lt;X&gt;</literal> or <literal>Iterator&lt;X&gt;</literal> 
                where <literal>&lt;X&gt;</literal> is the declared type of the iteration
                variable.</para> 
            </listitem>
            <listitem>
                <para>If two iteration variables are defined, the iterated expression type 
                must be assignable to <literal>Iterable&lt;Entry&lt;U,V&gt;&gt;</literal> or 
                <literal>Iterator&lt;Entry&lt;U,V&gt;&gt;</literal> where <literal>U</literal>
                and <literal>V</literal> are the declared types of the iteration variables, or
                of type <literal>Sequence&lt;X&gt;</literal> where <literal>Natural</literal> 
                is the type of the first iteration variable, and <literal>X</literal> is the 
                type of the second iteration variable.</para>
            </listitem>
            </itemizedlist>
            
            <comment><para>TODO: do we need the special case for <literal>Sequence</literal>?
            For lists, we could just make you write:</para>
            <programlisting>for (local i-&gt;local x in list.map) { ... }</programlisting>
            </comment>
            
            <!--para>Iterated and constraint expressions may refer to any local variable 
            defined by a previous iteration.</para-->
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the iterated expression is of type <literal>Iterable</literal>,
                    the <literal>Iterator</literal> is obtained by calling 
                    <literal>iterator()</literal>, and then</para>
                </listitem>
                <listitem>
                    <para>the <literal>for</literal> block is executed once for each element 
                    of the <literal>Iterator</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>If the loop exits early via execution of one of the control directives 
            <literal>break true</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the <literal>fail</literal> block is not executed. Otherwise, if the loop completes, 
            or if the loop exits early via execution of the control directive <literal>break false</literal>, 
            the <literal>fail</literal> block, if any, is executed.</para>
            
            <para>For example:</para>

            <programlisting>for (Person p in people) { log.info(p.name); }</programlisting>
            
            <programlisting>for (Natural month -> Float temp in monthlyTempsList) { plot(month,temp); }</programlisting>

            <programlisting>for (String word -> Natural freq in wordFrequencyMap) { 
    log.info("The frequency of the " word " is " freq "."); 
}</programlisting>
            
            <programlisting>for (Person p in people) {
    log.debug("Testing person: " p.name ".");
    if (p.age >= 18) {
        log.info("Found an adult: " p.name ".");
        break true
    }
}
fail {
    log.info("no adults");
}
</programlisting>

        </section>
        
        <section id="dowhile">
            <title><literal>while</literal> and <literal>do/while</literal></title>
            
            <para>The <literal>while</literal> loop has the form:</para>
            
            <programlisting>While := LoopCondition Block</programlisting>

            <para>The <literal>do/while</literal> loop has the form:</para>
            
            <programlisting>DoWhile := "do" Block LoopCondition ";"</programlisting>

            <para>The loop condition determines when the loop terminates.</para>
            
            <programlisting>LoopCondition := "while" "(" Condition ")"</programlisting>

            <!--programlisting>DoWhileFail := 
( "do" ("(" Variable Specifier ")")? OpenBlock? )?
"while" "(" Condition ("," Condition)* ")" 
( ";" | ClosedBlock | OpenBlock? "fail" ClosedBlock )</programlisting-->
            
            <para>When the construct is executed, the block is executed repeatedly, 
            until the loop condition first evaluates to <literal>false</literal>, 
            at which point iteration ends. In a <literal>while</literal> loop, the block 
            is executed after the condition is evaluated. In a <literal>do/while</literal> 
            loop, the second block is executed before it is evaluated.</para>
            
            <comment><para>TODO: does <literal>do/while</literal> need a fail block? Python has it, 
            but what is the real usecase?</para></comment>
            
            <!--para>If the loop exits early via execution of one of the control directives 
            <literal>found</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the fail block is not executed. Otherwise, if the loop completes, or if the
            loop exits early via execution of the control directive <literal>break</literal>, 
            the fail block is executed, if it is defined.</para-->
            
            <para>For example:</para>
            
            <programlisting>mutable Natural n:=0
do {
    log.info("count = " + $n);
}
while (n&lt;=10) { n++; }</programlisting>
            
            <programlisting>Iterator&lt;Person&gt; iter = org.employees.iterator();
while (iter.more) {
    log.info( iter.next().name );
}</programlisting>
            
            <programlisting>Iterator&lt;Person&gt; iter = people.iterator();
while (iter.more) {
    Person p = iter.next();
    log.debug(p.name);
    p.greet();
}</programlisting>
            
            <programlisting>mutable Person person := ....;
while (exists Person parent = person.parent) {
    log.info("The parent of " person.name " is " parent.name ".");
    person := parent;
}</programlisting>
            
            <programlisting>mutable Person person := ....;
do {
    log.info(person.name);
    person.=parent;
} 
while (!person.dead);</programlisting>

        </section>

        <section id="trycatchfinally">
            <title><literal>try/catch/finally</literal></title>
            
            <para>The <literal>try/catch/finally</literal> exception manager has the form:</para>
            
            <programlisting>TryCatchFinally := Try Catch* Finally?</programlisting>

            <programlisting>Try := "try" ("(" Resource ")")? Block</programlisting>
            
            <programlisting>Catch := "catch" "(" Variable ")" Block</programlisting>
            
            <programlisting>Finally := "finally" Block</programlisting>

            <para>The type of each <literal>catch</literal> variable declaration must be 
            assignable to <literal>lang.Exception</literal>.</para>
            
            <para>The <literal>try</literal> block may declare a <emphasis>resource</emphasis>
            expression. A resource expresson produces a heavyweight object that must be 
            released when execution of the <literal>try</literal> terminates. Each resource 
            expression must be of type assignable to <literal>lang.Usable</literal>.</para>
            
            <programlisting>Resource := InferableVariable Specifier | Expression</programlisting>
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the resource expression, if any, is evaluated, and then 
                    <literal>begin()</literal> is called upon the resulting
                    resource instance, then</para>
                </listitem>
                <listitem>
                    <para>the <literal>try</literal> block is executed, then</para>
                </listitem>
                <listitem>
                    <para><literal>end()</literal> is called the resource instance, 
                    if any, with the exception that propagated out of the 
                    <literal>try</literal> block, if any, then</para>
                </listitem>
                <listitem>
                    <para>if an exception did propagate out of the <literal>try</literal> 
                    block, the first <literal>catch</literal> block with a variable 
                    to which the exception is assignable, if any, is executed, and 
                    then</para>
                </listitem>
                <listitem>
                    <para>the <literal>finally</literal> block, if any, is 
                    executed.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>try ( File file = File(name) ) {
    file.open(readOnly);
    ...
}
catch (FileNotFoundException fnfe) {
    log.info("file not found: " name "");
}
catch (FileReadException fre) {
    log.info("could not read from file: " name "");
}
finally {
    if (file.open) file.close();
}</programlisting>
            
            <programlisting>try (semaphore) {
    if ( !map.defines(key) ) {
        map[key] := value;
    }
}</programlisting>

            <para>(This example shows a Ceylon-ified version of the Java 
            <literal>synchronized</literal> block.)</para>
            
            <programlisting>try ( Transaction() )
    try ( Session s = Session() ) {
        return s.get(#Person, id)
    }
    catch (NotFoundException e) {
        return null
    }
}</programlisting>

            <para>The <literal>retry</literal> directive re-evaluates the resource 
            expression, if any, and then re-executes the <literal>try</literal> block, 
            calling <literal>begin()</literal> and <literal>end()</literal> upon the 
            resource instance.</para>

            <programlisting>mutable Natural retries := 0;
try ( Transaction() ) {
    ...
}
catch (TransactonTimeoutException tte) {
    if (retries &lt; 3) {
        retries++;
        retry;
    }
    else {
        throw tte;
    }
}</programlisting>
            
         </section>
         
    </section>

</chapter>