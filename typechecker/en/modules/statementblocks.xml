<chapter id="statementblocks">
    <title>Blocks and control structures</title>
    
    <para>Method, attribute, converter, class and functor literal bodies contain 
    procedural code that is executed when the method, attribute or converter is 
    invoked. The code contains expressions, control directives and assertions and 
    is organized using blocks and control structures.</para>
    
    <section>
        <title>Blocks</title>
            
        <para>A <emphasis>block</emphasis> is list of semicolon-delimited statements, 
        assertions, method, attribute and local declarations, and control structures, 
        surrounded by braces. Some blocks end in a control directive. The expressions, 
        assertions, local initializers and control structures are executed sequentially.</para>

        <section>
        <title>Blocks and statements</title>

        <para>A statement is an expression, control structure, control statement or a
        method, attribute or local declaration.</para>

        <programlisting>Block := 
OPENBRACE 
Statement*
ControlStatement?
CLOSEBRACE</programlisting>

        <programlisting>Statement := 
Expression SEMICOLON | 
ControlStructure |
Declaration</programlisting>

        <programlisting>ControlStatement := ControlDirective SEMICOLON</programlisting>
        
        <programlisting>Declaration := Method | SimpleAttribute | AttributeGetter | AttributeSetter | Local</programlisting>
        
        </section>
        
    </section>
    
    <section>
        <title>Control directives</title>
        
        <para>A control directive is a statement that affects the flow of execution.</para>

        <para>Ceylon provides the following control directives:</para>
        
        <itemizedlist>
            <listitem>the <literal>return</literal> directive&mdash;to return a value from a method, 
            attribute getter or converter,</listitem>
            <listitem>the <literal>found</literal> directive&mdash;to terminate a loop<!-- or find block--> 
            successfully,</listitem>
            <listitem>the <literal>break</literal> directive&mdash;to terminate a loop<!--or find block-->
            unsuccessfully, and</listitem>
            <listitem>the <literal>throw</literal> directive&mdash;to raise an exception.</listitem>
        </itemizedlist>
        
         <programlisting>ControlDirective := 
"return" Expression | 
"found" Expression | 
"break" | 
"throw" Expression</programlisting>
        
        <para>The <literal>return</literal> directive may not be used outside of
        the body of an attribute getter, a non-<literal>void</literal> method or 
        a converter.</para>
        
        <para>The <literal>break</literal> directive may not be used outside of
        the body of a loop.</para>
        
        <para>The <literal>found</literal> directive may not be used outside of
        the body of a loop.</para>
        
    </section>
    
    <!--  
    <section>
        <title>Method, attribute and converter bodies</title>
        
        <para>A method, attribute or converter body consists of either an
        expression (void methods only), a <emphasis>return directive</emphasis>
        (non-void methods only), a <emphasis>throw directive</emphasis> or a 
        <emphasis>block</emphasis>.</para>
        
        <programlisting>OpenBody := Block | MethodDirective</programlisting>
        <programlisting>ClosedBody := Block | MethodDirective SEMICOLON</programlisting>
        <programlisting>VoidBody := VoidBlock | ( Expression | ThowDirective ) SEMICOLON</programlisting>
        
        <para>Where:</para>
        
        <programlisting>MethodDirective := ReturnDirective | ThrowDirective</programlisting>
        
        <para>Attribute getter, non-<literal>void</literal> method and converter bodies 
        must end at a <literal>return</literal> or <literal>throw</literal> directive
        for every possible execution path.</para>
        
    </section>
    -->
           
    <section id="controlstructures">
        <title>Control structures</title>
        
        <para>Control of execution flow may be achieved using control
        directives and control structures. Control structures include
        conditionals, loops, exception management and assertions:</para>

        <para>Ceylon provides the following control structures:</para>
        
        <itemizedlist>
            <listitem>
                <para>the <literal>if/else</literal> conditional&mdash;for controlling execution based
                upon a boolean value, and dealing with null values,</para>
            </listitem>
            <listitem>
                <para>the <literal>switch/case/else</literal> conditional&mdash;for controlling execution
                using an enumerated list of values,</para>
            </listitem>
            <listitem>
                <para>the <literal>do/while/fail</literal> loop&mdash;for loops which terminate based
                upon the value of a boolean expression,</para>
            </listitem>
            <listitem>
                <para>the <literal>for/fail</literal> loop&mdash;for looping over elements of a 
                collection, and</para>
            </listitem>
            <listitem>
                <para>the <literal>try/catch/finally</literal> exception manager&mdash;for managing 
                exceptions and controlling the lifecycle of objects which require explicit destruction.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>ControlStructure := 
IfElse | SwitchCaseElse | 
DoWhile | ForFail | 
Using | TryCatchFinally |
Assert</programlisting>

        <para><emphasis>Control structures</emphasis> are not considered to be expressions in Ceylon. 
        However, all control structures have a corresponding <emphasis>control expression</emphasis> 
        which may be used anywhere an expression may be used.</para>
        
        <para>A control structure body consists of an expression, a control directive or a block.</para>
        
        <programlisting>OpenBlock := Block | Expression | ControlDirective</programlisting>
        <programlisting>ClosedBlock := Block | (Expression | ControlDirective) SEMICOLON</programlisting>
        
        <para>Some control structures allow embedded declaration of a local. This local is available
        inside the control structure body.</para>
        
        <programlisting>Variable := Annotations? Type Identifier</programlisting>
        
        <para>Some control structures expect conditions:</para>
        
        <programlisting>Condition := 
Expression | 
(Variable Initializer | Expression) ("exists"|"nonempty")</programlisting>

        <para>The semantics of a condition depend upon whether the <literal>exists</literal> or 
        <literal>nonempty</literal> modifier appears:</para>

        <itemizedlist>
            <listitem>
                <para>If no <literal>exists</literal> or <literal>nonempty</literal> modifier appears, 
                the condition must be an expression of type <literal>Boolean</literal>. The condition
                is satisfied if the expression evaluates to <literal>true</literal> at runtime.</para>
            </listitem>
            <listitem>
                <para>If the <literal>exists</literal> modifier appears, the condition must be an 
                expression or local initializer of type <literal>optional: Object</literal>. The
                condition is satisfied if the expression or initializer evaluates to a non-null value
                at runtime.</para>
            </listitem>
            <listitem>
                <para>If the <literal>nonempty</literal> modifier appears, the condition must be an 
                expression or local initializer of type <literal>optional: Container</literal>. The
                condition is satisfied if the expression or initializer evaluates to a non-null value
                at runtime, and if the resulting <literal>Container</literal> is non-empty.</para>
            </listitem>
        </itemizedlist>

        <para>For <literal>exists</literal> or <literal>nonempty</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the condition is a local variable initializer, the local variable may be
                declared without the <literal>optional</literal> annotation, even though the 
                initializer expression is of type <literal>optional</literal>, or</para>
            </listitem>
            <listitem>
                <para>if the condition is a local variable, the local will be treated by the compiler 
                as having non-null type inside the block that follows immediately, relaxing the usual 
                compile-time restrictions upon <literal>optional</literal> types.</para>
            </listitem>
        </itemizedlist>
                        
        <section>
            <title><literal>if/else</literal></title>
            
            <para>The <literal>if/else</literal> conditional has the following form:</para>
            
            <programlisting>IfElse := "if" OPENPAREN Condition CLOSEPAREN (ClosedBlock | OpenBlock "else" ClosedBlock)</programlisting>

            <!--programlisting>IfElse := 
"if" OPENPAREN Condition (COMMA Condition)* CLOSEPAREN
( ClosedBlock | OpenBlock "else" ClosedBlock )</programlisting-->

            <para>If the condition is satisfied, the first block is executed. Otherwise, the 
            second block is executed, if it is defined.</para>

            <!--para>Condition expressions may refer to any local variable defined by a previous
            condition.</para-->
            
            <para>For example:</para>
            
            <programlisting>if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid = true;
}
else {
    throw NotEnoughMoneyException();
}</programlisting>

            <programlisting>public: void welcome(optional: User user) {
    if (user exists)
        log.info("Hi ${user.name}!") 
    else 
        log.info("Hello World!");
}</programlisting>
            
            <programlisting>public: Payment payment(Order order) {
    if (Payment p = order.payment exists) {
        return p;
    }
    else { 
        return Payment(order);
    }
}</programlisting>

            <programlisting>if (Payment p = order.payment exists) {
    if (p.paid) log.info("already paid");
}</programlisting>
            
        </section>
        
        <section>
            <title><literal>switch/case/else</literal></title>
            
            <para>The <literal>switch/case/else</literal> conditional has the following form:</para>
            
            <programlisting>SwitchCaseElse := 
"switch" OPENPAREN Expression CLOSEPAREN
(Cases SEMICOLON | OPENBRACE Cases CLOSEBRACE)</programlisting>
            
            <programlisting>Cases := 
("case" "null" OpenBlock)?
("case" OPENPAREN Case CLOSEPAREN OpenBlock)+
("else" OpenBlock)?</programlisting>

            <para>The switch expression may be of any type. The case values must be 
            expressions of type <literal>Case&lt;X&gt;</literal>, where <literal>X</literal> 
            is the switch expression type.</para>

            <programlisting>Case := Expression (COMMA Expression)*</programlisting>

            <para>If a <literal>case null</literal> is defined, the switch expression type must 
            be <literal>optional</literal>.</para>

            <para>If the switch expression type is <literal>optional</literal>, there must be 
            an explicit <literal>case null</literal> defined. </para> 
            
            <para>If no <literal>else</literal> block is defined, the switch expression
            must be of type <literal>Selector</literal>, and all enumerated instances of the 
            classs must be explicitly listed.</para>
            
            <para>If the switch expression is of type <literal>Selector</literal>, and all 
            values of the selector are explicitly listed, no <literal>else</literal> block may be 
            specified.</para>
            
            <para>When the construct is executed, the switch expression value is tested 
            against the case values (using <literal>Case.test()</literal>) , and the case 
            block for the first case value that tests true is executed. If no case value 
            tests true, and an <literal>else</literal> block is defined, the <literal>else</literal> 
            block is executed.</para>
            
            <para>For example:</para>

            <programlisting>public: PaymentProcessor processor {
    switch (payment.type) 
        case null throw NoPaymentTypeException()
        case (credit, debit) return cardPaymentProcessor 
        case (check) return checkPaymentProcessor
        else return interactivePaymentProcessor;
}</programlisting>
            
            <programlisting>switch (payment.type) {
    case (credit, debit) { 
        log.debug("card payment");
        cardPaymentProcessor.process(payment, user.card);
    } 
    case (check) {
        log.debug("check payment");
        checkPaymentProcessor.process(payment);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

        </section>
        
        <section>
            <title><literal>for/fail</literal></title>
            
             <para>The <literal>for/fail</literal> loop has the following form:</para>
             
            <programlisting>ForFail := "for" OPENPAREN ForIterator CLOSEPAREN (ClosedBlock | OpenBlock "fail" ClosedBlock)</programlisting>

            <!--programlisting>ForFail :=
"for" OPENPAREN Iteration (SEMICOLON Iteration)* CLOSEPAREN 
( ClosedBlock | OpenBlock "fail" ClosedBlock )
</programlisting-->

            <para>An iteration variable declaration must specify an iterated expression 
            that contains the range of values to be iterated. <!--It may optionally specify 
            one or more iteration constraint expressions (conditions).--></para>

            <programlisting>ForIterator := Variable ("->" Variable)? "in" Expression</programlisting>

            <!--programlisting>Iteration := Variable ("->" Variable)? "in" Expression (COLON Condition (COMMA Condition)*)? </programlisting-->

            <para>Each iterated expression must be of type <literal>Iterable</literal>
            or <literal>Iterator</literal>. If two iteration variables are defined, it 
            must be of type <literal>Iterable&lt;Entry&gt;</literal> or 
            <literal>Iterator&lt;Entry&gt;</literal>.</para>
            
            <!--para>Iterated and constraint expressions may refer to any local variable 
            defined by a previous iteration.</para-->
            
            <para>The body of the loop is executed once for each <!--combination of--> 
            iterated element<!--for which all constraint expressions are satisfied-->.</para>
            
            <para>If the loop exits early via execution of one of the control directives 
            <literal>found</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the fail block is not executed. Otherwise, if the loop completes, or if the
            loop exits early via execution of the control directive <literal>break</literal>, 
            the fail block is executed, if it is defined.</para>
            
            <para>For example:</para>

            <programlisting>for (Person p in people) log.info(p.name);</programlisting>

            <programlisting>for (String key -> Integer value in map) log.info("$key = $value");</programlisting>
            
            <programlisting>for (Person p in people) {
    log.debug("found $(p.name)");
    if (p.age >= 18) {
        log.info("found an adult: $(p.name)");
        found;
    }
}
fail {
    log.info("no adults");
}
</programlisting>

            <programlisting>for (Person p in people) {
    if (p.age>=18) {
        log.info("found an adult");
        found;
    }
}
fail {
    log.info("no adults");
}
</programlisting>

        </section>
        
        <section>
            <title><literal>do/while</literal></title>
            
            <para>The <literal>do/while</literal> loop has the form:</para>
            
            <programlisting>DoWhile := 
( "do" (OPENPAREN DoIterator CLOSEPAREN)? OpenBlock? )?
"while" OPENPAREN Condition CLOSEPAREN (SEMICOLON | ClosedBlock)</programlisting>

            <programlisting>DoIterator := Variable Initializer</programlisting>
            
            <!--programlisting>DoWhileFail := 
( "do" (OPENPAREN Variable Initializer CLOSEPAREN)? OpenBlock? )?
"while" OPENPAREN Condition (COMMA Condition)* CLOSEPAREN 
( SEMICOLON | ClosedBlock | OpenBlock? "fail" ClosedBlock )</programlisting-->
            
            <para>Both blocks are executed repeatedly, until the termination 
            condition first evaluates to false, at which point iteration ends. In each 
            iteration, the first block is executed before the condition is evaluated, 
            and the second block is executed after it is evaluated.</para>
            
            <para>TODO: does do/while need a fail block? Python has it, but what is 
            the real usecase?</para>
            
            <!--para>If the loop exits early via execution of one of the control directives 
            <literal>found</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the fail block is not executed. Otherwise, if the loop completes, or if the
            loop exits early via execution of the control directive <literal>break</literal>, 
            the fail block is executed, if it is defined.</para-->
            
            <para>For example:</para>
            
            <programlisting>do (Integer i=0) 
    log.info("count = " + $i) 
while (i&lt;=10) i++;</programlisting>

            <para>(The previous example is Ceylon's version of a traditional C for loop.)</para>
            
            <programlisting>do (Iterator&lt;Person&gt; iter = org.employees.iterator)
while (iter.more) 
    log.info( iter.next().name );</programlisting>
            
            <programlisting>do (Iterator&lt;Person&gt; iter = people.iterator)
while (iter.more) {
    Person p = iter.next();
    log.debug(p.name);
    p.greet();
}</programlisting>
            
            <programlisting>while (Person parent = person.parent exists) {
    log.info(parent.name);
    person = parent;
}</programlisting>
            
            <programlisting>do {
    log.info(person.name);
    person = person.parent;
} 
while (!person.dead);</programlisting>
            
            <programlisting>do (Person person = ...) {
    log.info(person.name);
} 
while (!person.parent.dead) {
    person = person.parent;    
}</programlisting>
    
        <para>TODO: do/while/fail is significantly enhanced compared to other Java-like languages. 
        Is this truly a good thing?</para>
                
        </section>
        
        <!--
        <section>
            <title><literal>using</literal></title>
            
            <para>The <literal>using</literal> resource manager has the form:</para>
            
            <programlisting>Using := "using" OPENPAREN Resource (COMMA Resource)* CLOSEPAREN ClosedBlock</programlisting>
            
            <para>TODO: do we really need a special syntax for using? Using functors, a 
            using could look like this:</para>
        
            <programlisting>Transaction().perform() {
    Session s = Session();
    s.perform() { 
        Person p = s.get(#Person, id)
        ...
        return p;
    }
};</programlisting>

        </section>
        -->

        <section>
            <title><literal>try/catch/finally</literal></title>
            
            <para>The <literal>try/catch/finally</literal> exception manager has the form:</para>
            
            <programlisting>TryCatchFinally := 
"try" (OPENPAREN Resource CLOSEPAREN)?
( ClosedBlock | OpenBlock (Catch OpenBlock)* (Catch ClosedBlock | "finally" ClosedBlock) )</programlisting>

            <para>When an exception occurs in the try block, the first matching catch block is 
            executed, if any. The finally block is always executed.</para>
            
            <para>The type of each catch local must extend <literal>lang.Exception</literal>.</para>
            
            <programlisting>Catch := "catch" OPENPAREN Variable CLOSEPAREN</programlisting>
            
            <para>The resource expression must be of type <literal>Usable</literal>.</para>
            
            <programlisting>Resource := Variable Initializer | Expression</programlisting>
            
            <para>When the construct is executed, <literal>begin()</literal> is called upon the 
            resource, the try block is executed, and then <literal>end()</literal> is called upon 
            the resource, with the thrown exception, if any.</para>
            
            <para>For example:</para>
            
            <programlisting>try ( File file = File(name) ) {
    file.open(readOnly);
    ...
}
catch (FileNotFoundException fnfe) {
    log.info("file not found: $name");
}
catch (FileReadException fre) {
    log.info("could not read from file: $name");
}
finally {
    if (file.open) file.close();
}</programlisting>
            
            <programlisting>try ( Transaction() ) try ( Session s = Session() ) {
    Person p = s.get(#Person, id);
    ...
}</programlisting>

            <programlisting>try (semaphore) map[key] = value;</programlisting>

            <para>(This example shows the Ceylon version of Java's <literal>synchronized</literal>
            keyword.)</para>
            
            <programlisting>try ( Transaction() ) try ( Session s = Session() ) {
    Person p = s.get(#Person, id)
    ...
    return p;
} 
catch (NotFoundException e) { 
    return null;
}</programlisting>
            
         </section>

    <section>
        <title>Assertions</title>
            
        <para>An assertion has the following form:</para>
        
        <programlisting>Assert := "assert" OPENPAREN Expression (COMMA Expression)* CLOSEPAREN Expression?</programlisting>
        
        <para>Assertions appearing in class declarations are checked after the class
        is instantiated. Assertions appearing in other blocks are checked when the 
        block is executed.</para>
        
        <para>The first expression is of type <literal>Boolean</literal>, and the second
        of type <literal>String</literal>.</para>
        
        <para>The following assertion:</para>
        
        <programlisting>assert (input nonempty) "input may not be empty";</programlisting>
        
        <para>Is equivalent to this Java:</para>
        
        <programlisting>if (ASSERTIONS_ENABLED &amp;&amp; ( input!=null &amp;&amp; !input.empty().get() ) ) 
    throw new AssertionFailedException(message);</programlisting>
    
        <para>TODO: do we really need a special syntax for assertions? They are barely 
        used in Java ... Using functors, an assertion could look like this:</para>
        
        <programlisting>"input may not be empty".assert () return input nonempty;</programlisting>

    </section>
    
    </section>

</chapter>