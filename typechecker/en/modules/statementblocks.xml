<chapter id="statementblocks">
    <title>Blocks and control structures</title>
    
    <para>Method, attribute, class and functor literal bodies contain procedural code 
    that is executed when the method, functor or attribute is invoked, or when the
    class is instantiated. The code contains expressions and control directives and is 
    organized using blocks and control structures.</para>
    
    <section id="blocks">
        <title>Blocks and statements</title>
            
        <para>A <emphasis>block</emphasis> is list of semicolon-delimited statements, 
        method, attribute and local declarations, and control structures, surrounded 
        by braces. Some blocks end in a control directive. The statements, local 
        specifiers and control structures are executed sequentially.</para>

        <para>A <emphasis>statement</emphasis> is an assignment, an invocation of a 
        method or functor, an instantiation of a class, a control structure, a control 
        directive, or a method, attribute or local declaration.</para>

        <programlisting>Block := "{" Statement* ControlStatement? "}"</programlisting>

        <programlisting>Statement := ExpressionStatement | DirectiveStatement | Specification | Declaration</programlisting>

        <para>Only certain expressions are valid statements: assignment, prefix or 
        postfix increment or decrement, invocation of a method or functor and
        instantiation of a class.</para>
        
        <programlisting>ExpressionStatement := ( Assignment | IncrementOrDecrement | Invocation ) ";"</programlisting>
        
        <programlisting>Invocation := MethodInvocation | StaticMethodInvocation | FunctorInvocation | Instantiation</programlisting>
        
        <comment><para>TODO: it would be possible to say that any expression is a valid
        statement, but this seems to just open up more potential programming errors. So
        I think it's better to limit statements to assignments, invocations
        and instantiations.</para></comment>
        
        <para>Control directive statements end execution of the current block and force 
        the flow of execution to resume in some outer scope. They may only appear at the 
        end of a block, so the semicolon terminator is optional.</para>

        <programlisting>DirectiveStatement := Directive ";"?</programlisting>
        
        <para>The Ceylon language distinguishes between assignment to a mutable value 
        (the <literal>:=</literal> operator) and specification of the value of an 
        immutable local or attribute (using <literal>=</literal>). A specification
        is not an expression.</para>
        
        <programlisting>Specification := MemberName Specifier ";"</programlisting>
        
        <para>Blocks may contain declarations, which are, by default, only visible inside
        the block:</para>
        
        <programlisting>Declaration := Method | SimpleAttribute | AttributeGetter | AttributeSetter | Local</programlisting>
        
        <comment><para>TODO: should we allow statements to be annotated, for example:</para></comment>
        
        <programlisting>doc "unsafe assignment" suppressWarnings(typesafety): apple = orange;</programlisting>
        
    </section>
    
    <section id="controldirectives">
        <title>Control directives</title>
        
        <para>A control directive is a statement that affects the flow of execution.</para>

        <para>Ceylon provides the following control directives:</para>
        
        <itemizedlist>
            <listitem>the <literal>return</literal> directive&mdash;to return a value from a method 
            or attribute getter,</listitem>
            <listitem>the <literal>produce</literal> directive&mdash;to return a value from a 
            functor,</listitem>
            <listitem>the <literal>found</literal> directive&mdash;to terminate a <literal>for/fail</literal> 
            loop successfully,</listitem>
            <listitem>the <literal>break</literal> directive&mdash;to terminate a loop unsuccessfully, 
            and</listitem>
            <listitem>the <literal>throw</literal> directive&mdash;to raise an exception.</listitem>
        </itemizedlist>
        
         <programlisting>Directive := "return" Expression? | "produce" Expression | "throw" Expression? | "found" | "break"</programlisting>
        
        <para>The <literal>return</literal> directive may not be used outside the 
        body of an attribute getter or method. A return value must be specified in 
        a non-<literal>void</literal> method or attribute getter. A return value 
        may not be specified in a <literal>void</literal> method.</para>
        
        <para>The <literal>produce</literal> directive may not be used outside
        the body of a non-<literal>void</literal> functor expression.</para>
        
        <para>The <literal>break</literal> directive may not be used outside the 
        body of a loop.</para>
        
        <para>The <literal>found</literal> directive may not be used outside the 
        body of a <literal>for/fail</literal> loop.</para>
        
        <para>A <literal>throw</literal> directive which specifies no exception
        is equivalent to <literal>throw Exception()</literal>.</para>
        
        <comment><para>TODO: instead of <literal>break</literal> and <literal>found</literal>,
        we could support <literal>break success</literal> and 
        <literal>break failure</literal>.</para></comment>
        
        <comment><para>TODO: We could support <literal>for/fail</literal> loops that return a 
        value by adding a <literal>found expr</literal> directive. We could support
        conditionals that return a value by adding a <literal>then expr</literal>
        directive.</para></comment>
        
    </section>
           
    <section id="controlstructures">
        <title>Control structures</title>
        
        <para>Control of execution flow may be achieved using control directives and 
        control structures. Control structures include conditionals, loops, and 
        exception management. For many tasks, the use of these traditional control
        structures is considered bad style, and the use of expressions with functor 
        parameters is preferred. However, control structures support the use of the 
        <literal>return</literal>, <literal>break</literal> and <literal>found</literal> 
        directives, whereas functors do not. Therefore, some tasks may be accomplished
        only with control structures.</para>

        <para>Control structures are not considered to be expressions in Ceylon.</para>
        
        <para>Ceylon provides the following control structures:</para>
        
        <itemizedlist>
            <listitem>
                <para>the <literal>if/else</literal> conditional&mdash;for controlling execution 
                based upon a boolean value, and dealing with null values,</para>
            </listitem>
            <listitem>
                <para>the <literal>switch/case/else</literal> conditional&mdash;for controlling 
                execution using an enumerated list of values,</para>
            </listitem>
            <listitem>
                <para>the <literal>do/while</literal> loop&mdash;for loops which terminate based 
                upon the value of a boolean expression,</para>
            </listitem>
            <listitem>
                <para>the <literal>for/fail</literal> loop&mdash;for looping over elements of a 
                collection, and</para>
            </listitem>
            <listitem>
                <para>the <literal>try/catch/finally</literal> exception manager&mdash;for managing 
                exceptions and controlling the lifecycle of objects which require explicit destruction.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>ControlStructure := IfElse | SwitchCaseElse | DoWhile | ForFail | TryCatchFinally</programlisting>
       
        <para>Some control structures allow embedded declaration of a local that is available
        inside the control structure body.</para>
        
        <programlisting>Variable := Type MemberName</programlisting>
        
        <para>Some control structures expect conditions:</para>
        
        <programlisting>Condition := Expression | ExistsCondition | IsCondition</programlisting>
       
        <programlisting>ExistsCondition := ("exists" | "nonempty") (Variable Specifier | Expression)</programlisting>
       
        <programlisting>IsCondition := "is" (Variable Specifier | Type Expression)</programlisting>

        <para>The semantics of a condition depend upon whether the <literal>exists</literal>, 
        <literal>nonempty</literal> or <literal>is</literal> modifier appears:</para>

        <itemizedlist>
            <listitem>
                <para>If no <literal>is</literal>, <literal>exists</literal> or <literal>nonempty</literal> 
                modifier appears, the condition must be an expression of type <literal>Boolean</literal>. 
                The condition is satisfied if the expression evaluates to <literal>true</literal> at 
                runtime.</para>
            </listitem>
            <listitem>
                <para>If the <literal>is</literal> modifier appears, the condition must be an 
                expression or local specifier of type <literal>Object</literal>. The condition is 
                satisfied if the expression or specifier evaluates to an instance of the specified 
                type at runtime.</para>
            </listitem>
            <listitem>
                <para>If the <literal>exists</literal> modifier appears, the condition must be an 
                expression or local specifier of type <literal>optional Object</literal>. The
                condition is satisfied if the expression or specifier evaluates to a non-null value
                at runtime.</para>
            </listitem>
            <listitem>
                <para>If the <literal>nonempty</literal> modifier appears, the condition must be an 
                expression or local specifier of type <literal>optional Container</literal>. The
                condition is satisfied if the expression or specifier evaluates to a non-null value
                at runtime, and if the resulting <literal>Container</literal> is non-empty.</para>
            </listitem>
        </itemizedlist>

        <para>For <literal>exists</literal> or <literal>nonempty</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the condition is a local variable specifier, the local variable may be
                declared without the <literal>optional</literal> annotation, even though the 
                specifier expression is of type <literal>optional</literal>, or</para>
            </listitem>
            <listitem>
                <para>if the condition is a local variable, the local will be treated by the compiler 
                as having non-null type inside the block that follows immediately, relaxing the usual 
                compile-time restrictions upon <literal>optional</literal> types.</para>
            </listitem>
        </itemizedlist>
                        
        <para>For <literal>is</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the condition is a local variable specifier, the local variable may be
                declared with the specified type, even though the specifier expression is not of 
                that type, or</para>
            </listitem>
            <listitem>
                <para>if the condition is a local variable, the local will be treated by the compiler 
                as having the specified type inside the block that follows immediately.</para>
            </listitem>
        </itemizedlist>
                        
        <comment><para>TODO: Should we support, like Java, single-statement control structure bodies 
        without the braces.</para></comment>
        
        <section>
            <title><literal>if/else</literal></title>
            
            <para>The <literal>if/else</literal> conditional has the following form:</para>
            
            <programlisting>IfElse := 
"if" "(" Condition ")" Block
("else" "if" "(" Condition ")" Block)* 
("else" Block)?</programlisting>

            <!--programlisting>IfElse := 
"if" "(" Condition ("," Condition)* ")"
( ClosedBlock | OpenBlock "else" ClosedBlock )</programlisting-->

            <para>If the condition is satisfied, the first block is executed. Otherwise, the 
            second block is executed, if it is defined.</para>

            <!--para>Condition expressions may refer to any local variable defined by a previous
            condition.</para-->
            
            <para>For example:</para>
            
            <programlisting>if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid := true;
}
else {
    throw NotEnoughMoneyException();
}</programlisting>

            <programlisting>public void welcome(optional User user) {
    if (exists user) {
        log.info("Hi ${user.name}!");
    }
    else {
        log.info("Hello World!");
    }
}</programlisting>
            
            <programlisting>public Payment payment(Order order) {
    if (exists Payment p = order.payment) { return p }
    else { return Payment(order) }
}</programlisting>

            <programlisting>if (exists Payment p = order.payment) {
    if (p.paid) { log.info("already paid"); }
}</programlisting>
            
            <programlisting>if (is CardPayment p = order.payment) {
    return p.card;
}</programlisting>
            
        </section>
        
        <section>
            <title><literal>switch/case/else</literal></title>
            
            <para>The <literal>switch/case/else</literal> conditional has the following form:</para>
            
            <programlisting>SwitchCaseElse := "switch" "(" Expression ")" (Cases | "{" Cases "}")</programlisting>
            
            <programlisting>Cases := 
("case" "(" Case ")" Block)+ 
("else" Block)?</programlisting>

            <para>The switch expression may be of any type. The case values must be 
            expressions of type <literal>Case&lt;X&gt;</literal>, where <literal>X</literal> 
            is the switch expression type, or an explicit <literal>null</literal>.</para>

            <programlisting>Case := Expression ("," Expression)* | "is" Type | "null"</programlisting>

            <para>If a <literal>case (null)</literal> is defined, the switch expression type must 
            be <literal>optional</literal>.</para>

            <para>If the switch expression type is <literal>optional</literal>, there must be 
            an explicit <literal>case (null)</literal> defined. </para> 
            
            <para>If no <literal>else</literal> block is defined, the switch expression must be 
            of type <literal>Selector</literal>, and all enumerated instances of the class must 
            be explicitly listed.</para>
            
            <para>If the switch expression is of type <literal>Selector</literal>, and all 
            enumerated instances of the class are explicitly listed, no <literal>else</literal> 
            block may be specified.</para>
            
            <para>When the construct is executed, the switch expression value is tested 
            against the case values (using <literal>Case.test()</literal>) , and the case 
            block for the first case value that tests true is executed. If no case value 
            tests true, and an <literal>else</literal> block is defined, the <literal>else</literal> 
            block is executed.</para>
            
            <para>For an <literal>is</literal> type case, if the switch expression is a local, 
            then the local will be treated by the compiler as having the specified type inside 
            the <literal>case</literal> block.</para>
            
            <comment><para>TODO: support <literal>catch</literal>-style syntax instead of 
            <literal>case (is ...)</literal>?</para></comment>
            
            <para>For example:</para>

            <programlisting>public PaymentProcessor processor {
    switch (payment.type) 
    case (null) { throw NoPaymentTypeException() }
    case (credit, debit) { return cardPaymentProcessor }
    case (check) { return checkPaymentProcessor }
    else { return interactivePaymentProcessor }
}</programlisting>
            
            <programlisting>switch (payment.type) {
    case (credit, debit) { 
        log.debug("card payment");
        cardPaymentProcessor.process(payment, user.card);
    } 
    case (check) {
        log.debug("check payment");
        checkPaymentProcessor.process(payment);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

            <programlisting>switch (payment) {
    case (is CardPayment) { 
        pay(payment.amount, payment.card);
    } 
    case (is CheckPayment) {
        pay(payment.amount, payment.check);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

        </section>
        
        <section>
            <title><literal>for/fail</literal></title>
            
             <para>The <literal>for/fail</literal> loop has the following form:</para>
             
            <programlisting>ForFail := 
"for" "(" ForIterator ")" Block 
("fail" Block)?</programlisting>

            <!--programlisting>ForFail :=
"for" "(" Iteration (";" Iteration)* ")" 
( ClosedBlock | OpenBlock "fail" ClosedBlock )
</programlisting-->

            <para>An iteration variable declaration must specify an iterated expression 
            that contains the range of values to be iterated. <!--It may optionally specify 
            one or more iteration constraint expressions (conditions).--></para>

            <programlisting>ForIterator := Variable ("->" Variable)? "in" Expression</programlisting>

            <!--programlisting>Iteration := FormalParam "in" Expression (":" Condition ("," Condition)*)? </programlisting-->

            <para>Each iterated expression must be of type <literal>Iterable</literal>
            or <literal>Iterator</literal>. If two iteration variables are defined, it 
            must be of type <literal>Iterable&lt;Entry&gt;</literal> or 
            <literal>Iterator&lt;Entry&gt;</literal>.</para>
            
            <!--para>Iterated and constraint expressions may refer to any local variable 
            defined by a previous iteration.</para-->
            
            <para>The body of the loop is executed once for each <!--combination of--> 
            iterated element<!--for which all constraint expressions are satisfied-->.</para>
            
            <para>If the loop exits early via execution of one of the control directives 
            <literal>found</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the fail block is not executed. Otherwise, if the loop completes, or if the
            loop exits early via execution of the control directive <literal>break</literal>, 
            the fail block is executed, if it is defined.</para>
            
            <para>For example:</para>

            <programlisting>for (Person p in people) { log.info(p.name); }</programlisting>

            <programlisting>for (String key -> Integer value in map) { 
    log.info("${key} = ${value}"); 
}</programlisting>
            
            <programlisting>for (Person p in people) {
    log.debug("found ${p.name}");
    if (p.age >= 18) {
        log.info("found an adult: ${p.name}");
        found
    }
}
fail {
    log.info("no adults");
}
</programlisting>

        </section>
        
        <section>
            <title><literal>do/while</literal></title>
            
            <para>The <literal>do/while</literal> loop has the form:</para>
            
            <programlisting>DoWhile := 
( "do" ("(" DoIterator ")")? Block? )?
"while" "(" Condition ")" (";" | Block)</programlisting>

            <para>The loop may declare an iterator variable, which may be mutable.</para>

            <programlisting>DoIterator := Annotation* Variable Initializer</programlisting>
            
            <!--programlisting>DoWhileFail := 
( "do" ("(" Variable Specifier ")")? OpenBlock? )?
"while" "(" Condition ("," Condition)* ")" 
( ";" | ClosedBlock | OpenBlock? "fail" ClosedBlock )</programlisting-->
            
            <para>Both blocks are executed repeatedly, until the termination condition 
            first evaluates to false, at which point iteration ends. In each iteration, 
            the first block is executed before the condition is evaluated, and the 
            second block is executed after it is evaluated.</para>
            
            <comment><para>TODO: does <literal>do/while</literal> need a fail block? Python has it, 
            but what is the real usecase?</para></comment>
            
            <!--para>If the loop exits early via execution of one of the control directives 
            <literal>found</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the fail block is not executed. Otherwise, if the loop completes, or if the
            loop exits early via execution of the control directive <literal>break</literal>, 
            the fail block is executed, if it is defined.</para-->
            
            <para>For example:</para>
            
            <programlisting>do (mutable Integer i:=0) {
    log.info("count = " + $i);
}
while (i&lt;=10) { i++; }</programlisting>
            
            <programlisting>do (Iterator&lt;Person&gt; iter = org.employees.iterator)
while (iter.more) {
    log.info( iter.next().name );
}</programlisting>
            
            <programlisting>do (Iterator&lt;Person&gt; iter = people.iterator)
while (iter.more) {
    Person p = iter.next();
    log.debug(p.name);
    p.greet();
}</programlisting>
            
            <programlisting>mutable Person person := ....;
while (exists Person parent = person.parent) {
    log.info(parent.name);
    person := parent;
}</programlisting>
            
            <programlisting>mutable Person person := ....;
do {
    log.info(person.name);
    person := person.parent;
} 
while (!person.dead);</programlisting>
            
            <programlisting>do (mutable Person person := ...) {
    log.info(person.name);
} 
while (!person.parent.dead) {
    person := person.parent;    
}</programlisting>
    
        <comment><para>TODO: <literal>do/while</literal> is significantly enhanced compared to other 
        Java-like languages. Is this truly a good thing?</para></comment>
                
        </section>
        
        <!--
        <section>
            <title><literal>using</literal></title>
            
            <para>The <literal>using</literal> resource manager has the form:</para>
            
            <programlisting>Using := "using" "(" Resource ("," Resource)* ")" ClosedBlock</programlisting>
            
            <para>TODO: do we really need a special syntax for using? Using functors, a 
            using could look like this:</para>
        
            <programlisting>Transaction().perform() {
    Session s = Session();
    s.perform() { 
        Person p = s.get(#Person, id)
        ...
        return p;
    }
};</programlisting>

        </section>
        -->

        <section>
            <title><literal>try/catch/finally</literal></title>
            
            <para>The <literal>try/catch/finally</literal> exception manager has the form:</para>
            
            <programlisting>TryCatchFinally := 
"try" ( "(" Resource ("," Resource)* ")" )? Block 
("catch" "(" Variable ")" Block)* 
("finally" Block)?</programlisting>

            <para>When an exception occurs in the try block, the first matching catch block is 
            executed, if any. The finally block is always executed.</para>
            
            <para>The type of each catch local must extend <literal>lang.Exception</literal>.</para>
                        
            <para>Each resource expression must be of type <literal>Usable</literal>.</para>
            
            <programlisting>Resource := Variable Specifier | Expression</programlisting>
            
            <para>When the construct is executed, <literal>begin()</literal> is called upon the 
            resource, the try block is executed, and then <literal>end()</literal> is called upon 
            the resource, with the thrown exception, if any.</para>
            
            <para>For example:</para>
            
            <programlisting>try ( File file = File(name) ) {
    file.open(readOnly);
    ...
}
catch (FileNotFoundException fnfe) {
    log.info("file not found: ${name}");
}
catch (FileReadException fre) {
    log.info("could not read from file: ${name}");
}
finally {
    if (file.open) file.close();
}</programlisting>
            
            <programlisting>try (semaphore) { map[key] := value; }</programlisting>

            <para>(This example shows the Ceylon version of Java's <literal>synchronized</literal>
            keyword.)</para>
            
            <programlisting>try ( Transaction(), Session s = Session() ) {
    Person p = s.get(#Person, id)
    ...
    return p
} 
catch (NotFoundException e) { 
    return null
}
</programlisting>
            
         </section>

<!--
    <section>
        <title>Assertions</title>
            
        <para>An assertion has the following form:</para>
        
        <programlisting>Assert := "assert" "(" Expression ("," Expression)* ")" Expression?</programlisting>
        
        <para>Assertions appearing in class declarations are checked after the class
        is instantiated. Assertions appearing in other blocks are checked when the 
        block is executed.</para>
        
        <para>The first expression is of type <literal>Boolean</literal>, and the second
        of type <literal>String</literal>.</para>
        
        <para>The following assertion:</para>
        
        <programlisting>assert (input nonempty) "input may not be empty";</programlisting>
        
        <para>Is equivalent to this Java:</para>
        
        <programlisting>if (ASSERTIONS_ENABLED &amp;&amp; ( input!=null &amp;&amp; !input.empty().get() ) ) 
    throw new AssertionFailedException(message);</programlisting>
    
        <para>TODO: do we really need a special syntax for assertions? They are barely 
        used in Java ... Using functors, an assertion could look like this:</para>
        
        <programlisting>assert ("input may not be empty") that input nonempty;</programlisting>

    </section>
-->

    </section>

</chapter>