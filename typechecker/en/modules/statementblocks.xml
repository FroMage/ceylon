<chapter id="statementblocks">
    <title>Blocks and control structures</title>
    
    <para>Method, attribute, converter, class and functor literal bodies contain 
    procedural code that is executed when the method, attribute or converter is 
    invoked. The code contains expressions and control directives and is organized 
    using blocks and control structures.</para>
    
    <section id="blocks">
        <title>Blocks and statements</title>
            
        <para>A <emphasis>block</emphasis> is list of semicolon-delimited statements, 
        method, attribute and local declarations, and control structures, surrounded 
        by braces. Some blocks end in a control directive. The statements, local 
        initializers and control structures are executed sequentially.</para>

        <para>A <emphasis>statement</emphasis> is an assignment, an invocation of a 
        method or functor, an instantiation of a class, a control structure, a control 
        directive, or a method, attribute or local declaration.</para>

        <programlisting>Block := "{" Statement* ControlStatement? "}"</programlisting>

        <programlisting>Statement := ( Assignment | Invocation | Instantiation ) ";" | ControlStructure | Declaration</programlisting>

        <programlisting>ControlStatement := ControlDirective ";"</programlisting>
        
        <programlisting>Declaration := Method | SimpleAttribute | AttributeGetter | AttributeSetter | Local</programlisting>
        
        <comment><para>TODO: should we allow expressions to be annotated, for example:</para></comment>
        
        <programlisting>doc "unsafe assignment" suppressWarnings(typesafety): apple = orange;</programlisting>
        
        <comment><para>TODO: it would be possible to say that any expression is a valid
        statement, but this seems to just open up more potential programming errors. So
        I think it's better to limit statements to assignments, invocations
        and instantiations.</para></comment>
        
    </section>
    
    <section id="controldirectives">
        <title>Control directives</title>
        
        <para>A control directive is a statement that affects the flow of execution.</para>

        <para>Ceylon provides the following control directives:</para>
        
        <itemizedlist>
            <listitem>the <literal>return</literal> directive&mdash;to return a value from a method, 
            attribute getter or converter,</listitem>
            <listitem>the <literal>produce</literal> directive&mdash;to return a value from a 
            functor,</listitem>
            <listitem>the <literal>found</literal> directive&mdash;to terminate a <literal>for/fail</literal> 
            loop successfully,</listitem>
            <listitem>the <literal>break</literal> directive&mdash;to terminate a loop unsuccessfully, 
            and</listitem>
            <listitem>the <literal>throw</literal> directive&mdash;to raise an exception.</listitem>
        </itemizedlist>
        
         <programlisting>ControlDirective := ("return" | "produce") Expression | "throw" Expression | "found" | "break"</programlisting>
        
        <para>The <literal>return</literal> directive may not be used outside the 
        body of an attribute getter, a non-<literal>void</literal> method or a 
        converter.</para>
        
        <para>The <literal>produce</literal> directive may not be used outside
        the body of a non-<literal>void</literal> functor expression.</para>
        
        <para>The <literal>break</literal> directive may not be used outside the 
        body of a loop.</para>
        
        <para>The <literal>found</literal> directive may not be used outside the 
        body of a <literal>for/fail</literal> loop.</para>
        
        <comment><para>TODO: instead of <literal>break</literal> and <literal>found</literal>,
        we could support <literal>break success</literal> and 
        <literal>break failure</literal>.</para></comment>
        
        <comment><para>TODO: We could support <literal>for/fail</literal> loops that return a 
        value by adding a <literal>found expr</literal> directive. We could support
        conditionals that return a value by adding a <literal>then expr</literal>
        directive.</para></comment>
        
    </section>
    
    <!--  
    <section>
        <title>Method, attribute and converter bodies</title>
        
        <para>A method, attribute or converter body consists of either an
        expression (void methods only), a <emphasis>return directive</emphasis>
        (non-void methods only), a <emphasis>throw directive</emphasis> or a 
        <emphasis>block</emphasis>.</para>
        
        <programlisting>OpenBody := Block | MethodDirective</programlisting>
        <programlisting>ClosedBody := Block | MethodDirective ";"</programlisting>
        <programlisting>VoidBody := VoidBlock | ( Expression | ThowDirective ) ";"</programlisting>
        
        <para>Where:</para>
        
        <programlisting>MethodDirective := ReturnDirective | ThrowDirective</programlisting>
        
        <para>Attribute getter, non-<literal>void</literal> method and converter bodies 
        must end at a <literal>return</literal> or <literal>throw</literal> directive
        for every possible execution path.</para>
        
    </section>
    -->
           
    <section id="controlstructures">
        <title>Control structures</title>
        
        <para>Control of execution flow may be achieved using control directives and 
        control structures. Control structures include conditionals, loops, and 
        exception management. For many tasks, the use of these traditional control
        structures is considered bad style, and the use of expressions with functor 
        parameters is preferred. However, control structures support the use of the 
        <literal>return</literal>, <literal>break</literal> and <literal>found</literal> 
        directives, whereas functors do not. Therefore, some tasks may be accomplished
        only with control structures.</para>

        <para>Control structures are not considered to be expressions in Ceylon.</para>
        
        <para>Ceylon provides the following control structures:</para>
        
        <itemizedlist>
            <listitem>
                <para>the <literal>if/else</literal> conditional&mdash;for controlling execution 
                based upon a boolean value, and dealing with null values,</para>
            </listitem>
            <listitem>
                <para>the <literal>switch/case/else</literal> conditional&mdash;for controlling 
                execution using an enumerated list of values,</para>
            </listitem>
            <listitem>
                <para>the <literal>do/while</literal> loop&mdash;for loops which terminate based 
                upon the value of a boolean expression,</para>
            </listitem>
            <listitem>
                <para>the <literal>for/fail</literal> loop&mdash;for looping over elements of a 
                collection, and</para>
            </listitem>
            <listitem>
                <para>the <literal>try/catch/finally</literal> exception manager&mdash;for managing 
                exceptions and controlling the lifecycle of objects which require explicit destruction.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>ControlStructure := IfElse | SwitchCaseElse | DoWhile | ForFail | TryCatchFinally</programlisting>

        <para>A control structure body consists of an expression, a control directive or a block.</para>
        
        <programlisting>OpenBlock := Block | Expression | ControlDirective</programlisting>
        <programlisting>ClosedBlock := Block | (Expression | ControlDirective) ";"</programlisting>
        
        <para>Some control structures allow embedded declaration of a local. This local is available
        inside the control structure body.</para>
        
        <para>Some control structures expect conditions:</para>
        
        <programlisting>Condition := Expression | (Variable Initializer | Expression) ("exists"|"nonempty")</programlisting>

        <para>The semantics of a condition depend upon whether the <literal>exists</literal> or 
        <literal>nonempty</literal> modifier appears:</para>

        <itemizedlist>
            <listitem>
                <para>If no <literal>exists</literal> or <literal>nonempty</literal> modifier appears, 
                the condition must be an expression of type <literal>Boolean</literal>. The condition
                is satisfied if the expression evaluates to <literal>true</literal> at runtime.</para>
            </listitem>
            <listitem>
                <para>If the <literal>exists</literal> modifier appears, the condition must be an 
                expression or local initializer of type <literal>optional Object</literal>. The
                condition is satisfied if the expression or initializer evaluates to a non-null value
                at runtime.</para>
            </listitem>
            <listitem>
                <para>If the <literal>nonempty</literal> modifier appears, the condition must be an 
                expression or local initializer of type <literal>optional Container</literal>. The
                condition is satisfied if the expression or initializer evaluates to a non-null value
                at runtime, and if the resulting <literal>Container</literal> is non-empty.</para>
            </listitem>
        </itemizedlist>

        <para>For <literal>exists</literal> or <literal>nonempty</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>if the condition is a local variable initializer, the local variable may be
                declared without the <literal>optional</literal> annotation, even though the 
                initializer expression is of type <literal>optional</literal>, or</para>
            </listitem>
            <listitem>
                <para>if the condition is a local variable, the local will be treated by the compiler 
                as having non-null type inside the block that follows immediately, relaxing the usual 
                compile-time restrictions upon <literal>optional</literal> types.</para>
            </listitem>
        </itemizedlist>
                        
        <section>
            <title><literal>if/else</literal></title>
            
            <para>The <literal>if/else</literal> conditional has the following form:</para>
            
            <programlisting>IfElse := "if" "(" Condition ")" (ClosedBlock | OpenBlock "else" ClosedBlock)</programlisting>

            <!--programlisting>IfElse := 
"if" "(" Condition ("," Condition)* ")"
( ClosedBlock | OpenBlock "else" ClosedBlock )</programlisting-->

            <para>If the condition is satisfied, the first block is executed. Otherwise, the 
            second block is executed, if it is defined.</para>

            <!--para>Condition expressions may refer to any local variable defined by a previous
            condition.</para-->
            
            <para>For example:</para>
            
            <programlisting>if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid = true;
}
else {
    throw NotEnoughMoneyException();
}</programlisting>

            <programlisting>public void welcome(optional User user) {
    if (user exists)
        log.info("Hi ${user.name}!") 
    else 
        log.info("Hello World!");
}</programlisting>
            
            <programlisting>public Payment payment(Order order) {
    if (Payment p = order.payment exists) {
        return p;
    }
    else { 
        return Payment(order);
    }
}</programlisting>

            <programlisting>if (Payment p = order.payment exists) {
    if (p.paid) log.info("already paid");
}</programlisting>
            
        </section>
        
        <section>
            <title><literal>switch/case/else</literal></title>
            
            <para>The <literal>switch/case/else</literal> conditional has the following form:</para>
            
            <programlisting>SwitchCaseElse := "switch" "(" Expression ")" (Cases ";" | "{" Cases "}")</programlisting>
            
            <programlisting>Cases := CaseNull? Case+ CaseElse?</programlisting>

            <programlisting>CaseNull := "case" "null" OpenBlock</programlisting>
            <programlisting>Case := "case" "(" Case ")" OpenBlock</programlisting>
            <programlisting>CaseElse := "else" OpenBlock</programlisting>

            <para>The switch expression may be of any type. The case values must be 
            expressions of type <literal>Case&lt;X&gt;</literal>, where <literal>X</literal> 
            is the switch expression type.</para>

            <programlisting>Case := Expression ("," Expression)*</programlisting>

            <para>If a <literal>case null</literal> is defined, the switch expression type must 
            be <literal>optional</literal>.</para>

            <para>If the switch expression type is <literal>optional</literal>, there must be 
            an explicit <literal>case null</literal> defined. </para> 
            
            <para>If no <literal>else</literal> block is defined, the switch expression must be 
            of type <literal>Selector</literal>, and all enumerated instances of the class must 
            be explicitly listed.</para>
            
            <para>If the switch expression is of type <literal>Selector</literal>, and all 
            enumerated instances of the class are explicitly listed, no <literal>else</literal> 
            block may be specified.</para>
            
            <para>When the construct is executed, the switch expression value is tested 
            against the case values (using <literal>Case.test()</literal>) , and the case 
            block for the first case value that tests true is executed. If no case value 
            tests true, and an <literal>else</literal> block is defined, the <literal>else</literal> 
            block is executed.</para>
            
            <para>For example:</para>

            <programlisting>public PaymentProcessor processor {
    switch (payment.type) 
        case null throw NoPaymentTypeException()
        case (credit, debit) return cardPaymentProcessor 
        case (check) return checkPaymentProcessor
        else return interactivePaymentProcessor;
}</programlisting>
            
            <programlisting>switch (payment.type) {
    case (credit, debit) { 
        log.debug("card payment");
        cardPaymentProcessor.process(payment, user.card);
    } 
    case (check) {
        log.debug("check payment");
        checkPaymentProcessor.process(payment);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

        </section>
        
        <section>
            <title><literal>for/fail</literal></title>
            
             <para>The <literal>for/fail</literal> loop has the following form:</para>
             
            <programlisting>ForFail := "for" "(" ForIterator ")" (ClosedBlock | OpenBlock "fail" ClosedBlock)</programlisting>

            <!--programlisting>ForFail :=
"for" "(" Iteration (";" Iteration)* ")" 
( ClosedBlock | OpenBlock "fail" ClosedBlock )
</programlisting-->

            <para>An iteration variable declaration must specify an iterated expression 
            that contains the range of values to be iterated. <!--It may optionally specify 
            one or more iteration constraint expressions (conditions).--></para>

            <programlisting>ForIterator := FormalParam "in" Expression</programlisting>

            <!--programlisting>Iteration := FormalParam "in" Expression (":" Condition ("," Condition)*)? </programlisting-->

            <para>Each iterated expression must be of type <literal>Iterable</literal>
            or <literal>Iterator</literal>. If two iteration variables are defined, it 
            must be of type <literal>Iterable&lt;Entry&gt;</literal> or 
            <literal>Iterator&lt;Entry&gt;</literal>.</para>
            
            <!--para>Iterated and constraint expressions may refer to any local variable 
            defined by a previous iteration.</para-->
            
            <para>The body of the loop is executed once for each <!--combination of--> 
            iterated element<!--for which all constraint expressions are satisfied-->.</para>
            
            <para>If the loop exits early via execution of one of the control directives 
            <literal>found</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the fail block is not executed. Otherwise, if the loop completes, or if the
            loop exits early via execution of the control directive <literal>break</literal>, 
            the fail block is executed, if it is defined.</para>
            
            <para>For example:</para>

            <programlisting>for (Person p in people) log.info(p.name);</programlisting>

            <programlisting>for (String key -> Integer value in map) log.info("${key} = ${value}");</programlisting>
            
            <programlisting>for (Person p in people) {
    log.debug("found ${p.name}");
    if (p.age >= 18) {
        log.info("found an adult: ${p.name}");
        found;
    }
}
fail {
    log.info("no adults");
}
</programlisting>

            <programlisting>for (Person p in people) {
    if (p.age>=18) {
        log.info("found an adult");
        found;
    }
}
fail {
    log.info("no adults");
}
</programlisting>

        </section>
        
        <section>
            <title><literal>do/while</literal></title>
            
            <para>The <literal>do/while</literal> loop has the form:</para>
            
            <programlisting>DoWhile := 
( "do" ("(" DoIterator ")")? OpenBlock? )?
"while" "(" Condition ")" (";" | ClosedBlock)</programlisting>

            <programlisting>DoIterator := Variable Initializer</programlisting>
            
            <!--programlisting>DoWhileFail := 
( "do" ("(" Variable Initializer ")")? OpenBlock? )?
"while" "(" Condition ("," Condition)* ")" 
( ";" | ClosedBlock | OpenBlock? "fail" ClosedBlock )</programlisting-->
            
            <para>Both blocks are executed repeatedly, until the termination 
            condition first evaluates to false, at which point iteration ends. In each 
            iteration, the first block is executed before the condition is evaluated, 
            and the second block is executed after it is evaluated.</para>
            
            <comment><para>TODO: does <literal>do/while</literal> need a fail block? Python has it, 
            but what is the real usecase?</para></comment>
            
            <!--para>If the loop exits early via execution of one of the control directives 
            <literal>found</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the fail block is not executed. Otherwise, if the loop completes, or if the
            loop exits early via execution of the control directive <literal>break</literal>, 
            the fail block is executed, if it is defined.</para-->
            
            <para>For example:</para>
            
            <programlisting>do (Integer i=0) 
    log.info("count = " + $i) 
while (i&lt;=10) i++;</programlisting>
            
            <programlisting>do (Iterator&lt;Person&gt; iter = org.employees.iterator)
while (iter.more) 
    log.info( iter.next().name );</programlisting>
            
            <programlisting>do (Iterator&lt;Person&gt; iter = people.iterator)
while (iter.more) {
    Person p = iter.next();
    log.debug(p.name);
    p.greet();
}</programlisting>
            
            <programlisting>while (Person parent = person.parent exists) {
    log.info(parent.name);
    person = parent;
}</programlisting>
            
            <programlisting>do {
    log.info(person.name);
    person = person.parent;
} 
while (!person.dead);</programlisting>
            
            <programlisting>do (Person person = ...) {
    log.info(person.name);
} 
while (!person.parent.dead) {
    person = person.parent;    
}</programlisting>
    
        <comment><para>TODO: <literal>do/while</literal> is significantly enhanced compared to other 
        Java-like languages. Is this truly a good thing?</para></comment>
                
        </section>
        
        <!--
        <section>
            <title><literal>using</literal></title>
            
            <para>The <literal>using</literal> resource manager has the form:</para>
            
            <programlisting>Using := "using" "(" Resource ("," Resource)* ")" ClosedBlock</programlisting>
            
            <para>TODO: do we really need a special syntax for using? Using functors, a 
            using could look like this:</para>
        
            <programlisting>Transaction().perform() {
    Session s = Session();
    s.perform() { 
        Person p = s.get(#Person, id)
        ...
        return p;
    }
};</programlisting>

        </section>
        -->

        <section>
            <title><literal>try/catch/finally</literal></title>
            
            <para>The <literal>try/catch/finally</literal> exception manager has the form:</para>
            
            <programlisting>TryCatchFinally := 
"try" ("(" Resource ")")?
( ClosedBlock | OpenBlock (Catch OpenBlock)* (Catch ClosedBlock | "finally" ClosedBlock) )</programlisting>

            <para>When an exception occurs in the try block, the first matching catch block is 
            executed, if any. The finally block is always executed.</para>
            
            <para>The type of each catch local must extend <literal>lang.Exception</literal>.</para>
            
            <programlisting>Catch := "catch" "(" Variable ")"</programlisting>
            
            <para>The resource expression must be of type <literal>Usable</literal>.</para>
            
            <programlisting>Resource := Variable Initializer | Expression</programlisting>
            
            <para>When the construct is executed, <literal>begin()</literal> is called upon the 
            resource, the try block is executed, and then <literal>end()</literal> is called upon 
            the resource, with the thrown exception, if any.</para>
            
            <para>For example:</para>
            
            <programlisting>try ( File file = File(name) ) {
    file.open(readOnly);
    ...
}
catch (FileNotFoundException fnfe) {
    log.info("file not found: ${name}");
}
catch (FileReadException fre) {
    log.info("could not read from file: ${name}");
}
finally {
    if (file.open) file.close();
}</programlisting>
            
            <programlisting>try ( Transaction() ) try ( Session s = Session() ) {
    Person p = s.get(#Person, id);
    ...
}</programlisting>

            <programlisting>try (semaphore) map[key] = value;</programlisting>

            <para>(This example shows the Ceylon version of Java's <literal>synchronized</literal>
            keyword.)</para>
            
            <programlisting>try ( Transaction() ) try ( Session s = Session() ) {
    Person p = s.get(#Person, id)
    ...
    return p;
} 
catch (NotFoundException e) { 
    return null;
}</programlisting>
            
         </section>

<!--
    <section>
        <title>Assertions</title>
            
        <para>An assertion has the following form:</para>
        
        <programlisting>Assert := "assert" "(" Expression ("," Expression)* ")" Expression?</programlisting>
        
        <para>Assertions appearing in class declarations are checked after the class
        is instantiated. Assertions appearing in other blocks are checked when the 
        block is executed.</para>
        
        <para>The first expression is of type <literal>Boolean</literal>, and the second
        of type <literal>String</literal>.</para>
        
        <para>The following assertion:</para>
        
        <programlisting>assert (input nonempty) "input may not be empty";</programlisting>
        
        <para>Is equivalent to this Java:</para>
        
        <programlisting>if (ASSERTIONS_ENABLED &amp;&amp; ( input!=null &amp;&amp; !input.empty().get() ) ) 
    throw new AssertionFailedException(message);</programlisting>
    
        <para>TODO: do we really need a special syntax for assertions? They are barely 
        used in Java ... Using functors, an assertion could look like this:</para>
        
        <programlisting>assert ("input may not be empty") that input nonempty;</programlisting>

    </section>
-->

    </section>

</chapter>