<chapter id="statementblocks">
    <title>Blocks and control structures</title>
    
    <para>Method, attribute and class bodies contain procedural code that is executed 
    when the method or attribute is invoked, or when the class is instantiated. The 
    code contains expressions and control directives and is organized using blocks and 
    control structures.</para>
    
    <section id="blocks">
        <title>Blocks and statements</title>
            
        <para>A <emphasis>block</emphasis> is list of semicolon-delimited statements, 
        method, attribute and local declarations, and control structures, surrounded 
        by braces. Some blocks end in a control directive. The statements, local 
        specifiers and control structures are executed sequentially.</para>

        <programlisting>Block := "{" (Declaration | Statement)* DirectiveStatement? "}"</programlisting>
        
        <para>A <emphasis>statement</emphasis> is an assignment or specification, an 
        invocation of a method, an instantiation of a class, a control structure or a 
        control directive.</para>

        <programlisting>Statement := ExpressionStatement | Specification | ControlStructure</programlisting>
        
        <para>A simple attribute or local may not be used in an expression until its value has
        been explicitly specified or initialized. The Ceylon compiler guarantees this
        by evaluating all conditional branches between the declaration of a simple 
        attribute or local and its first use in an expression. Each conditional branch must
        specify or assign a value to the simple attribute or local.</para>
        
        <comment><para>TODO: should we allow statements to be annotated, for example:</para></comment>
        
        <programlisting>@doc "unsafe assignment" suppressWarnings(typesafety): apple = orange;</programlisting>
        
        <section>
            <title>Expression statements</title>
            
        <para>Only certain expressions are valid statements: assignment, prefix or 
        postfix increment or decrement, invocation of a method and instantiation of 
        a class.</para>
        
        <programlisting>ExpressionStatement := ( Assignment | IncrementOrDecrement | Invocation ) ";"</programlisting>
        
        <para>For example:</para>
        
        <programlisting>x := 1;</programlisting>
        <programlisting>x++;</programlisting>
        <programlisting>log.info("Hello);</programlisting>
        <programlisting>Main(p);</programlisting>
        
        <comment><para>TODO: it would be possible to say that any expression is a valid
        statement, but this seems to just open up more potential programming errors. So
        I think it's better to limit statements to assignments, invocations
        and instantiations.</para></comment>
        
        <comment><para>TODO: should we let you leave off the <literal>;</literal> on the last
        expression statement in the block, like we do for directives?</para></comment>
        
        </section>
        
        <section id="controldirectives">
            <title>Control directives</title>
            
        <para>Control directive statements end execution of the current block and force 
        the flow of execution to resume in some outer scope. They may only appear at the 
        end of a block, so the semicolon terminator is optional.</para>

        <programlisting>DirectiveStatement := Directive ";"?</programlisting>
        
        <programlisting>Directive := Return | Throw | Break | Continue | Retry</programlisting>
        
        <para>Ceylon provides the following control directives:</para>
        
        <itemizedlist>
            <listitem>the <literal>return</literal> directive&mdash;to return a value from a method 
            or attribute getter,</listitem>
            <listitem>the <literal>break</literal> directive&mdash;to terminate a loop,</listitem>
            <listitem>the <literal>continue</literal> directive&mdash;to jump to the next iteration 
            of a loop,</listitem>
            <listitem>the <literal>throw</literal> directive&mdash;to raise an exception, and</listitem>
            <listitem>the <literal>retry</literal> directive&mdash;to re-execute a <literal>try</literal> 
            block, reinitializing all resources.</listitem>
        </itemizedlist>
                
        <programlisting>throw Exception()</programlisting>
        <programlisting>retry</programlisting>
        <programlisting>return x+y;</programlisting>
        <programlisting>return "Hello"</programlisting>
        <programlisting>break true</programlisting>
        <programlisting>continue</programlisting>
        
        <para>The <literal>return</literal> directive may not appear outside the body of 
        a method or attribute getter. In the case of a <literal>void</literal> method, no 
        expression may be specified. In the case of a non-<literal>void</literal> method 
        or attribute getter, an expression must be specified. The expression type must be 
        assignable to the return type of the method, and may not be <literal>optional</literal> 
        unless the method is annotated <literal>optional</literal>. When the directive is 
        executed, the expression is evaluated to determine the return value of the method 
        or attribute getter.</para>
        
        <programlisting>Return := "return" Expression?</programlisting>
        
        <para>The <literal>break</literal> directive may not be appear outside the body 
        of a loop. If the loop has no <literal>fail</literal> block, the <literal>break</literal> 
        directive may not specify an expression. If the loop has a <literal>fail</literal> 
        block, the <literal>break</literal> directive must specify an expression of 
        non-<literal>optional</literal> type <literal>lang.Boolean</literal>. When the 
        directive is executed, the expression is evaluated and a value of <literal>false</literal> 
        specifies that the <literal>fail</literal> block should be executed.</para>
        
        <programlisting>Break := "break" Expression?</programlisting>
        
        <para>The <literal>continue</literal> directive may not be appear outside the body 
        of a loop.</para>
        
        <programlisting>Continue := "continue"</programlisting>
        
        <para>A <literal>throw</literal> directive may appear anywhere and may specify an 
        expression of non-<literal>optional</literal> type <literal>lang.Exception</literal>.
        When the directive is executed, the expression is evaluated and the resulting
        exception is thrown. If no expression is specified, the directive is equivalent to 
        <literal>throw Exception()</literal>.</para>
        
        <programlisting>Throw := "throw" Expression?</programlisting>
        
        <para>A <literal>retry</literal> directive may not appear outside of a
        <literal>catch</literal> block.</para>
        
        <programlisting>Retry := "retry"</programlisting>
        
        <!--comment><para>TODO: We could support <literal>for/fail</literal> loops 
        that return a value by supporting a <literal>found expr</literal> directive. 
        We could support conditionals that return a value by adding a 
        <literal>then expr</literal> directive.</para></comment-->
        
        </section>
        
        <section id="specificationstatements">
            <title>Specification statements</title>
            
        <para>A specification statement may specify the value of a non-<literal>mutable</literal> 
        attribute or local that has already been declared earlier in the block. It may 
        even specify a method reference for a method that was declared earlier in the 
        block.</para>
        
        <programlisting>Specification := MemberName Specifier ";"</programlisting>
                
        <para>The Ceylon language distinguishes between assignment to a <literal>mutable</literal> 
        value (the <literal>:=</literal> operator) and specification of the value of a 
        non-<literal>mutable</literal> local or attribute (using <literal>=</literal>). 
        A specification is not an expression.</para>
        
        <para>The specified expression type must be assignable to the type of the 
        attribute or local, and may not be of <literal>optional</literal> type unless
        the attribute or local is declared <literal>optional</literal>.</para>
        
        <para>A specification may appear inside an control structure, in which case the
        compiler validates that all paths result in a properly specified method or 
        attribute. For example:</para>
        
        <programlisting>String description;
Comparison order(X x, X y);
if (reverseOrder()) {
    description = "Reverse order";
    order = Order.reverse;
}
else {
    description = "Natural order";
    order = Order.natural;
}</programlisting>

        </section>
        
        <section id="nesteddeclarations">
            <title>Nested declarations</title>
        
            <para>Blocks may contain declarations. A declaration that occurs in a block is a 
            block local declaration&mdash;it is visible only to statements and declarations 
            that occur later in the same block, and therefore it may not declare a visibility 
            modifier.</para>
            
            <comment><para>TODO: Note that Java does not let you define an interface inside
            a method, so we should either add the same restriction, or figure out workaround.
            Note that Java doesn't let you define a method inside a method either, but we can
            wrap the nested method in an anonymous class.</para></comment>
            
        </section>
        
    </section>
           
    <section id="controlstructures">
        <title>Control structures</title>
        
        <para>Control of execution flow may be achieved using control directives and 
        control structures. Control structures include conditionals, loops, and 
        exception management. <!--For many tasks, the use of these traditional control
        structures is considered bad style, and the use of expressions with functor 
        parameters is preferred. However, control structures support the use of the 
        <literal>return</literal> and <literal>break</literal> directives, whereas 
        functors do not. Therefore, some tasks may be accomplished only with control 
        structures.--></para>

        <para>Ceylon provides the following control structures:</para>
        
        <itemizedlist>
            <listitem>
                <para>the <literal>if/else</literal> conditional&mdash;for controlling execution 
                based upon a boolean value, and dealing with null values,</para>
            </listitem>
            <listitem>
                <para>the <literal>switch/case/else</literal> conditional&mdash;for controlling 
                execution using an enumerated list of values,</para>
            </listitem>
            <listitem>
                <para>the <literal>while</literal> and <literal>do/while</literal> loops&mdash;for 
                loops which terminate based upon the value of a boolean expression,</para>
            </listitem>
            <listitem>
                <para>the <literal>for/fail</literal> loop&mdash;for looping over elements of a 
                collection, and</para>
            </listitem>
            <listitem>
                <para>the <literal>try/catch/finally</literal> exception manager&mdash;for managing 
                exceptions and controlling the lifecycle of objects which require explicit destruction.</para>
            </listitem>
        </itemizedlist>
                
        <programlisting>ControlStructure := IfElse | SwitchCaseElse | While | DoWhile | ForFail | TryCatchFinally</programlisting>
       
        <para>Control structures are not considered to be expressions, and therefore do not evaluate
        to a value.</para>
        
        <comment><para>TODO: Should we support, like Java, single-statement control structure bodies 
        without the braces.</para></comment>
        
        <section>
            <title>Control structure variables</title>
       
        <para>Some control structures allow embedded declaration of a <emphasis>variable</emphasis> 
        that is available inside the control structure body.</para>
        
        <programlisting>Variable := Type MemberName</programlisting>
        
        <para>A variable is treated as a formal parameter of the control structure body.</para>
        
        <comment><para>TODO: Should we say that type declarations in control structure variables are 
        optional? The compiler should be able to infer the type of the variable.</para></comment>
        
        </section>
        
        <section>
            <title>Control structure conditions</title>
            
        <para>Some control structures expect conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>a <emphasis>boolean condition</emphasis> is satisfied when a boolean expression
                evaluates to <literal>true</literal>,</para>
            </listitem>
            <listitem>
                <para>an <emphasis>existence condition</emphasis> is satisfied when an expression of
                <literal>optional</literal> type evaluates to any value other than 
                <literal>null</literal>,</para>
            </listitem>
            <listitem>
                <para>a <emphasis>nonemptiness condition</emphasis> is satisfied when an expression 
                of type <literal>optional Container</literal> evaluates to a non-empty instance,
                and</para>
            </listitem>
            <listitem>
                <para>a <emphasis>subtype condition</emphasis> is satisfied when an expression
                evaluates to an instance of a specified type.</para>
            </listitem>
        </itemizedlist>
        
        <programlisting>Condition := Expression | ExistsCondition | IsCondition</programlisting>
       
        <programlisting>ExistsCondition := ("exists" | "nonempty") (Variable Specifier | Expression)</programlisting>
       
        <programlisting>IsCondition := "is" (Variable Specifier | Type Expression)</programlisting>
        
        <para>Any condition contains an expression. In the case of existence, nonemptiness and 
        subtype conditions, the expression may be a specifier of a variable declaration.</para>

        <para>The type of a condition expression depend upon whether the <literal>exists</literal>, 
        <literal>nonempty</literal> or <literal>is</literal> modifier appears:</para>

        <itemizedlist>
            <listitem>
                <para>If no <literal>is</literal>, <literal>exists</literal> or <literal>nonempty</literal> 
                modifier appears, the condition must be an expression of non-<literal>optional</literal> 
                type <literal>Boolean</literal>.</para>
            </listitem>
            <listitem>
                <para>If the <literal>is</literal> modifier appears, the condition expression must 
                be of non-<literal>optional</literal> type.</para>
            </listitem>
            <listitem>
                <para>If the <literal>exists</literal> modifier appears, the condition expression 
                must be of <literal>optional</literal> type.</para>
            </listitem>
            <listitem>
                <para>If the <literal>nonempty</literal> modifier appears, the condition must be an 
                expression of type <literal>optional Container</literal>.</para>
            </listitem>
        </itemizedlist>

        <para>For <literal>exists</literal> or <literal>nonempty</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>If the condition declares a variable, the variable may be declared without 
                the <literal>optional</literal> annotation, even though the specifier expression 
                is of <literal>optional</literal> type. The type of the specifier expression must
                be assignable to the declared type of the variable.</para>
            </listitem>
            <listitem>
                <para>If the condition expression is a local, the local will be treated by the 
                compiler as having non-<literal>optional</literal> type inside the block that 
                follows immediately, relaxing the usual compile-time restrictions upon 
                <literal>optional</literal> types.</para>
            </listitem>
        </itemizedlist>
                        
        <para>For <literal>is</literal> conditions:</para>
        
        <itemizedlist>
            <listitem>
                <para>If the condition declares a variable, the specifier expression type need 
                not be assignable to the declared type of the variable, or</para>
            </listitem>
            <listitem>
                <para>if the condition is a local, the local will be treated by the compiler 
                as having the specified type inside the block that follows immediately.</para>
            </listitem>
        </itemizedlist>
                        
        <para>The semantics of a condition depend upon whether the <literal>exists</literal>, 
        <literal>nonempty</literal> or <literal>is</literal> modifier appears:</para>

        <itemizedlist>
            <listitem>
                <para>If no <literal>is</literal>, <literal>exists</literal> or <literal>nonempty</literal> 
                modifier appears, the condition is satisfied if the expression evaluates to 
                <literal>true</literal> when the control structure is executed.</para>
            </listitem>
            <listitem>
                <para>If the <literal>is</literal> modifier appears, the condition is satisfied 
                if the expression evaluates to an instance of the specified type when the control 
                structure is executed.</para>
            </listitem>
            <listitem>
                <para>If the <literal>exists</literal> modifier appears, the condition is satisfied 
                if the expression evaluates to a non-null value when the control structure is 
                executed.</para>
            </listitem>
            <listitem>
                <para>If the <literal>nonempty</literal> modifier appears, the condition is satisfied 
                if the expression evaluates to a non-null, non-empty instance of <literal>Container</literal>
                when the control structure is executed.</para>
            </listitem>
        </itemizedlist>

        </section>
        
        <section id="ifelse">
            <title><literal>if/else</literal></title>
            
            <para>The <literal>if/else</literal> conditional has the following form:</para>
            
            <programlisting>IfElse := If Else?</programlisting>

            <programlisting>If := "if" "(" Condition ")" Block</programlisting>
            
            <programlisting>Else := "else" (Block | IfElse)</programlisting>

            <!--programlisting>IfElse := 
"if" "(" Condition ("," Condition)* ")"
( ClosedBlock | OpenBlock "else" ClosedBlock )</programlisting-->

            <para>When the construct is executed, the condition is evaluated. If the condition is 
            satisfied, the <literal>if</literal> block is executed. Otherwise, the <literal>else</literal> 
            block, if any, is executed.</para>

            <!--para>Condition expressions may refer to any local variable defined by a previous
            condition.</para-->
            
            <para>For example:</para>
            
            <programlisting>if (payment.amount &lt;= account.balance) {
    account.balance -= payment.amount;
    payment.paid := true;
}
else {
    throw NotEnoughMoneyException();
}</programlisting>

            <programlisting>public void welcome(optional User user) {
    if (exists user) {
        log.info("Hi " user.name "!");
    }
    else {
        log.info("Hello World!");
    }
}</programlisting>
            
            <programlisting>public Payment payment(Order order) {
    if (exists Payment p = order.payment) { return p }
    else { return Payment(order) }
}</programlisting>

            <programlisting>if (exists Payment p = order.payment) {
    if (p.paid) { log.info("already paid"); }
}</programlisting>
            
            <programlisting>if (is CardPayment p = order.payment) {
    return p.card;
}</programlisting>
            
        </section>
        
        <section id="switchcaseelse">
            <title><literal>switch/case/else</literal></title>
            
            <para>The <literal>switch/case/else</literal> conditional has the following form:</para>
            
            <programlisting>SwitchCaseElse := Switch ( Cases | "{" Cases "}" )</programlisting>
            
            <programlisting>Switch := "switch" "(" Expression ")"</programlisting>
            
            <programlisting>Cases := CaseItem+ DefaultCaseItem?</programlisting>

            <programlisting>CaseItem := "case" "(" Case ")" Block</programlisting>
            <programlisting>DefaultCaseItem := "else" Block</programlisting>

            <para>The <literal>switch</literal> expression may be of any type. The <literal>case</literal> 
            values must be expressions of type <literal>Case&lt;X&gt;</literal>, where <literal>X</literal> 
            is the <literal>switch</literal> expression type, or an explicit <literal>null</literal>.
            Alternatively, the <literal>case</literal>s may be subtype conditions.</para>

            <programlisting>Case := Expression ("," Expression)* | "is" Type | "null"</programlisting>

            <para>If a <literal>case (null)</literal> occurs, the <literal>switch</literal> expression 
            must be of <literal>optional</literal> type.</para>

            <para>If the <literal>switch</literal> expression is of <literal>optional</literal> type, 
            there must be an explicit <literal>case (null)</literal>.</para> 
            
            <para>If no <literal>else</literal> block is specified, the <literal>switch</literal> 
            expression type must be a class with a closed enumerated instance list, and all enumerated 
            <literal>case</literal>s of the class must be explicitly listed.</para>
            
            <para>If the <literal>switch</literal> expression type is a class with a closed enumerated 
            instance list, and all enumerated <literal>case</literal>s of the class are explicitly 
            listed, no <literal>else</literal> block may be specified.</para>
            
            <para>When the construct is executed, the <literal>switch</literal> expression is evaluated, 
            and the resulting value is tested against the <literal>case</literal> values using 
            <literal>Case.test()</literal>. The <literal>case</literal> block for the first 
            <literal>case</literal> value that tests <literal>true</literal> is executed. If no 
            <literal>case</literal> value tests <literal>true</literal>, and an <literal>else</literal> 
            block is defined, the <literal>else</literal> block is executed.</para>
            
            <para>For a subtype condition <literal>case</literal>, if the <literal>switch</literal> 
            expression is a local, then the local will be treated by the compiler as having the specified 
            type inside the <literal>case</literal> block.</para>
            
            <para>For example:</para>

            <programlisting>public PaymentProcessor processor {
    switch (payment.type) 
    case (null) { 
        throw NoPaymentTypeException()
    }
    case (credit, debit) { 
        return cardPaymentProcessor
    }
    case (check) { 
        return checkPaymentProcessor
    }
    else { 
        return interactivePaymentProcessor
    }
}</programlisting>
            
            <programlisting>switch (payment.type) {
    case (credit, debit) { 
        log.debug("card payment");
        cardPaymentProcessor.process(payment, user.card);
    } 
    case (check) {
        log.debug("check payment");
        checkPaymentProcessor.process(payment);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

            <programlisting>switch (payment) {
    case (is CardPayment) { 
        pay(payment.amount, payment.card);
    } 
    case (is CheckPayment) {
        pay(payment.amount, payment.check);
    }
    else {
        log.debug("other payment type");
    }
}</programlisting>

            <comment><para>TODO: should it be a <literal>catch</literal>-style syntax 
            instead of <literal>case (is ...)</literal>?</para></comment>
            
        </section>
        
        <section id="forfail">
            <title><literal>for/fail</literal></title>
            
             <para>The <literal>for/fail</literal> loop has the following form:</para>
             
            <programlisting>ForFail := For Fail?</programlisting>

            <programlisting>For := "for" "(" ForIterator ")" Block</programlisting>
            
            <programlisting>Fail := "fail" Block</programlisting>

            <!--programlisting>ForFail :=
"for" "(" Iteration (";" Iteration)* ")" 
( ClosedBlock | OpenBlock "fail" ClosedBlock )
</programlisting-->

            <para>An iteration variable declaration must specify one or two iteration
            variables, and an iterated expression that contains the range of values to 
            be iterated. <!--It may optionally specify one or more iteration constraint 
            expressions (conditions).--></para>

            <programlisting>ForIterator := Variable ("->" Variable)? "in" Expression</programlisting>

            <!--programlisting>Iteration := FormalParam "in" Expression (":" Condition ("," Condition)*)? </programlisting-->

            <para>The type of the iterated expression depends upon the iterarion variable 
            declarations:</para>
            
            <itemizedlist>
            <listitem>
            <para>The iterated expression must be an expression of type assignable to 
            <literal>Iterable&lt;X&gt;</literal> or <literal>Iterator&lt;X&gt;</literal> 
            where <literal>&lt;X&gt;</literal> is the declared type of the iteration
            variable.</para> 
            </listitem>
            <listitem>
            <para>If two iteration variables are defined, the iterated expression type 
            must be assignable to <literal>Iterable&lt;Entry&lt;U,V&gt;&gt;</literal> or 
            <literal>Iterator&lt;Entry&lt;U,V&gt;&gt;</literal> where <literal>U</literal>
            and <literal>V</literal> are the declared types of the iteration variables.</para>
            </listitem>
            </itemizedlist>
            
            <!--para>Iterated and constraint expressions may refer to any local variable 
            defined by a previous iteration.</para-->
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para>if the iterated expression is of type <literal>Iterable</literal>,
                    the <literal>Iterator</literal> is obtained by calling 
                    <literal>iterator()</literal>, and then</para>
                </listitem>
                <listitem>
                    <para>the <literal>for</literal> block is executed once for each element 
                    of the <literal>Iterator</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>If the loop exits early via execution of one of the control directives 
            <literal>break true</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the <literal>fail</literal> block is not executed. Otherwise, if the loop completes, 
            or if the loop exits early via execution of the control directive <literal>break false</literal>, 
            the <literal>fail</literal> block, if any, is executed.</para>
            
            <para>For example:</para>

            <programlisting>for (Person p in people) { log.info(p.name); }</programlisting>

            <programlisting>for (String key -> Natural value in map) { 
    log.info("" key " = " value ""); 
}</programlisting>
            
            <programlisting>for (Person p in people) {
    log.debug("found " p.name "");
    if (p.age >= 18) {
        log.info("found an adult: " p.name "");
        break true
    }
}
fail {
    log.info("no adults");
}
</programlisting>

        </section>
        
        <section id="dowhile">
            <title><literal>while</literal> and <literal>do/while</literal></title>
            
            <para>The <literal>while</literal> loop has the form:</para>
            
            <programlisting>While := LoopCondition Block</programlisting>

            <para>The <literal>do/while</literal> loop has the form:</para>
            
            <programlisting>DoWhile := "do" Block LoopCondition ";"</programlisting>

            <para>The loop condition determines when the loop terminates.</para>
            
            <programlisting>LoopCondition := "while" "(" Condition ")"</programlisting>

            <!--programlisting>DoWhileFail := 
( "do" ("(" Variable Specifier ")")? OpenBlock? )?
"while" "(" Condition ("," Condition)* ")" 
( ";" | ClosedBlock | OpenBlock? "fail" ClosedBlock )</programlisting-->
            
            <para>When the construct is executed, the block is executed repeatedly, 
            until the loop condition first evaluates to <literal>false</literal>, 
            at which point iteration ends. In a <literal>while</literal> loop, the block 
            is executed after the condition is evaluated. In a <literal>do/while</literal> 
            loop, the second block is executed before it is evaluated.</para>
            
            <comment><para>TODO: does <literal>do/while</literal> need a fail block? Python has it, 
            but what is the real usecase?</para></comment>
            
            <!--para>If the loop exits early via execution of one of the control directives 
            <literal>found</literal>, <literal>return</literal> or <literal>throw</literal>, 
            the fail block is not executed. Otherwise, if the loop completes, or if the
            loop exits early via execution of the control directive <literal>break</literal>, 
            the fail block is executed, if it is defined.</para-->
            
            <para>For example:</para>
            
            <programlisting>mutable Natural n:=0
do {
    log.info("count = " + $n);
}
while (n&lt;=10) { n++; }</programlisting>
            
            <programlisting>Iterator&lt;Person&gt; iter = org.employees.iterator();
while (iter.more) {
    log.info( iter.next().name );
}</programlisting>
            
            <programlisting>Iterator&lt;Person&gt; iter = people.iterator();
while (iter.more) {
    Person p = iter.next();
    log.debug(p.name);
    p.greet();
}</programlisting>
            
            <programlisting>mutable Person person := ....;
while (exists Person parent = person.parent) {
    log.info(parent.name);
    person := parent;
}</programlisting>
            
            <programlisting>mutable Person person := ....;
do {
    log.info(person.name);
    person := person.parent;
} 
while (!person.dead);</programlisting>

        </section>

        <section id="trycatchfinally">
            <title><literal>try/catch/finally</literal></title>
            
            <para>The <literal>try/catch/finally</literal> exception manager has the form:</para>
            
            <programlisting>TryCatchFinally := Try Catch* Finally?</programlisting>

            <programlisting>Try := "try" ("(" Resource ")")? Block</programlisting>
            
            <programlisting>Catch := "catch" "(" Variable ")" Block</programlisting>
            
            <programlisting>Finally := "finally" Block</programlisting>

            <para>The type of each <literal>catch</literal> variable declaration must be 
            assignable to <literal>lang.Exception</literal>.</para>
            
            <para>The <literal>try</literal> block may declare a <emphasis>resource</emphasis>
            expression. A resource expresson produces a heavyweight object that must be 
            released when execution of the <literal>try</literal> terminates. Each resource 
            expression must be of non-<literal>optional</literal> type assignable to 
            <literal>lang.Usable</literal>.</para>
            
            <programlisting>Resource := Variable Specifier | Expression</programlisting>
            
            <para>When the construct is executed:</para>
            
            <itemizedlist>
                <listitem>
                    <para>the resource expression, if any, is evaluated, and then 
                    <literal>begin()</literal> is called upon the resulting
                    resource instance, then</para>
                </listitem>
                <listitem>
                    <para>the <literal>try</literal> block is executed, then</para>
                </listitem>
                <listitem>
                    <para><literal>end()</literal> is called the resource instance, 
                    if any, with the exception that propagated out of the 
                    <literal>try</literal> block, if any, then</para>
                </listitem>
                <listitem>
                    <para>if an exception did propagate out of the <literal>try</literal> 
                    block, the first <literal>catch</literal> block with a variable 
                    to which the exception is assignable, if any, is executed, and 
                    then</para>
                </listitem>
                <listitem>
                    <para>the <literal>finally</literal> block, if any, is 
                    executed.</para>
                </listitem>
            </itemizedlist>
            
            <para>For example:</para>
            
            <programlisting>try ( File file = File(name) ) {
    file.open(readOnly);
    ...
}
catch (FileNotFoundException fnfe) {
    log.info("file not found: " name "");
}
catch (FileReadException fre) {
    log.info("could not read from file: " name "");
}
finally {
    if (file.open) file.close();
}</programlisting>
            
            <programlisting>try (semaphore) {
    if ( !map.defines(key) ) {
        map[key] := value;
    }
}</programlisting>

            <para>(This example shows a Ceylon-ified version of the Java's 
            <literal>synchronized</literal> block.)</para>
            
            <programlisting>try ( Transaction() )
    try ( Session s = Session() ) {
        Person p = s.get(#Person, id)
        ...
        return p
    } 
    catch (NotFoundException e) { 
        return null
    }
}</programlisting>

            <para>The <literal>retry</literal> directive re-evaluates the resource 
            expression, if any, and then re-executes the <literal>try</literal> block, 
            calling <literal>begin()</literal> and <literal>end()</literal> upon the 
            resource instance.</para>

            <programlisting>mutable Natural retries := 0;
try ( Transaction() ) {
    ...
}
catch (TransactonTimeoutException tte) {
    if (retries &lt; 3) {
        retries++;
        retry;
    }
    else {
        throw tte;
    }
}</programlisting>
            
         </section>
         
    </section>

</chapter>