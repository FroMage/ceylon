<chapter id="introduction">
    <title>Introduction</title>
    
    <para>This document defines the syntax and semantics of the Ceylon language.
    The intended audience includes compiler implementors, interested parties
    who wish to contribute to the evolution of the language, and experienced 
    developers seeking a precise definition of language constructs. However, in
    light of the newness of the language, we will begin with an overview of the
    main features of the language and SDK and a brief introduction to programming 
    in the language.</para>
    
    <section id="languageoverview">
        <title>Language overview</title>
    
    <para>
    Ceylon is a general-purpose, imperative, statically-typed, object-oriented, 
    higher-order language featuring a syntax similar to Java and C#. By 
    <emphasis>object-oriented</emphasis>, we mean that the language features a 
    nominative type system where a type is a set of named attributes and 
    operations, and that it supports inheritance and subtype polymorphism. By 
    <emphasis>higher-order</emphasis>, we mean that every named program element
    (every attribute, every operation, and every type) is a value. 
    </para>
    
    <para>
    Ceylon programs execute in any standard Java Virtual Machine and, like Java, 
    take advantage of the memory management and concurrency features of that 
    environment. The Ceylon compiler is able to compile Ceylon code that calls 
    Java classes or interfaces, and Java code that calls Ceylon classes or 
    interfaces. 
    </para>
    
    <para>
    Ceylon improves upon the Java language and type system to reduce verbosity 
    and increase typesafety compared to Java and C#. Ceylon encourages a more 
    functional style of programming, resulting in code which is easier to reason 
    about, and easier to refactor. Moreover, Ceylon provides its own native SDK 
    as a replacement for the Java platform class libraries.
    </para>
    
    <section id="thetypesystem">
    <title>The type system</title>
    
    <para>
    Ceylon features a similar inheritance and generic type model to Java. A type 
    is either an <emphasis>interface</emphasis>, a <emphasis>class</emphasis>, or
    a <emphasis>type parameter</emphasis>. An interface may extend an arbitrary 
    number of other interfaces. A class may implement an arbitrary number of 
    interfaces and must extend another class. A class or interface may declare 
    type parameters. A type parameter abstracts the definition of a class or 
    interface over all types which can be substituted for the type parameter.
    </para>
    
    <para>
    There are no primitive types or arrays in Ceylon&mdash;every Ceylon type can 
    be represented within the language itself. So all values are instances of the 
    type hierarchy root <literal>lang.Void</literal>. However, the Ceylon compiler 
    is permitted to optimize certain code to take advantage of the optimized 
    performance of primitive types on the JVM.
    </para>
    
    <para>
    Interfaces may define concrete members, allowing a restricted form of multiple 
    inheritance ("mixin" inheritance), but may not hold state (references to other 
    objects) or initialization logic, which eliminates the problems traditionally 
    associated with multiple inheritance.
    </para>
    
    <para>
    Ceylon does not feature enumerated types as a first-class construct. Instead,
    any abstract type may specify its <emphasis>cases</emphasis>&mdash;an 
    enumerated list of subtypes. This facility may be used to simulate both
    enumerated types and functional-style algebraic data types.  
    </para>
    
    <para>
    Ceylon supports <emphasis>type aliases</emphasis>, similar to C-style 
    <literal>typedef</literal>.
    </para>
    
    <para>
    Ceylon does not support Java-style wildcard type parameters, raw types, or
    any other kind of "existential type". Instead, a type parameter may be marked 
    as covariant or contravariant by the class or interface that declares the 
    parameter. Type arguments are reified in Ceylon, eliminating many problems 
    related to type erasure in Java. Ceylon supports parameterization of type 
    parameters (a form of higher-order polymorphism), and a more expressive 
    system of generic type constraints.
    </para>
    
    </section>
    
    <section id="compilerenforcednamingconventions">
    <title>Compiler-enforced naming conventions</title>
    
    <para>
    The Ceylon compiler enforces the traditional Smalltalk naming convention:
    type names begin with an initial uppercase letter&mdash;for example, 
    <literal>Liberty</literal> or <literal>RedWine</literal>&mdash;member names 
    and local names with an initial lowercase letter or underscore&mdash;for
    example, <literal>blonde</literal>, <literal>immanentize()</literal> or 
    <literal>boldlyGo()</literal>. This innovation allows a much cleaner 
    syntax for program element annotations than the syntax found in either Java 
    or C#.
    </para>
    
    </section>
    
    <section id="initializationandinstantiation">
    <title>Class initialization and instantiation</title>
    
    <para>
    Ceylon does not feature any Java-like constructor declaration and so each 
    Ceylon class has a parameter list, and exactly one 
    <emphasis>initializer</emphasis>&mdash;the body of the class. This helps
    reduce verbosity and results in a more regular block structure.
    </para>
    
    
    <para>
    <!--In place of constructor overloading, Ceylon allows class names to be 
    overloaded. Even better,--> Member classes of a class may be overridden by 
    subclasses. Instantiation is therefore a polymorphic operation in Ceylon, 
    eliminating the need for factory methods.
    </para>
    
    <para>
    Ceylon provides a streamlined syntax for defining an anonymous class which 
    is only instantiated in exactly the place it is defined. Among other uses,
    the <literal>object</literal> declaration is useful for creating singleton 
    objects or method-local interface implementations. 
    </para>
    
    </section>
    
   <section id="methodsandattributes">
    <title>Methods and attributes</title>
    
    <para>
    Ceylon types have members: <emphasis>methods</emphasis> and 
    <emphasis>attributes</emphasis>. Ceylon methods are similar to Java methods. 
    However, Ceylon classes do not contain fields, in the traditional sense. 
    Instead, Ceylon supports only a higher-level construct: polymorphic 
    attributes, which are similar to C# properties. Attributes abstract the
    internal representation of the state of an object.
    </para>
    
    <para>
    Ceylon does not support method overloading. Each method of a class has
    a distinct name.
    </para>
    
    <para>There are no <literal>static</literal> members. Instead, 
    <emphasis>toplevel</emphasis> methods and attributes are declared as direct 
    members of a package. This, along with certain other features, gives the 
    language a more regular block structure.
    </para>

    </section>
    
    <section id="defaultparameters">
    <title>Defaulted parameters and sequenced parameters</title>
    
    <para>
    Instead of method and constructor overloading, Ceylon supports parameters 
    with default values and <emphasis>sequenced</emphasis> ("varargs") 
    parameters. Furthermore, a generic method may be used to emulate parameter
    type overloading. Therefore, a single method in Ceylon may emulate the 
    signatures of several overloaded methods in Java. 
    </para>
    
    </section>
    
    <section id="firstclassfunctions">
    <title>First-class functions and higher-order programming</title>
    
    <para>
    Ceylon supports first-class function types and higher-order functions, 
    with minimal extensions to the traditional C syntax. A method declaration 
    may specify a <emphasis>callable parameter</emphasis> that accepts 
    references to other methods with a certain signature. The argument of such 
    a callable parameter may be either a reference to a named method declared 
    elsewhere, or a new method defined inline as part of the method invocation. 
    A method may even return an invocable reference to another method. Finally, 
    nested method declarations receive a closure of immutable references defined 
    in the surrounding scope.
    </para>
    
    </section>
    
    <section id="lazyevaluationpassbyreference">
    <title>Lazy evaluation and pass by reference</title>
    
    <para>
    Using a "trick" in the Ceylon type system, it's possible to take advantage 
    of lazy evaluation of expressions and pass by reference for attributes.
    </para>
    
    </section>
    
    <section id="immutability">
    <title>Immutability by default</title>
    
    <para>
    By default, Ceylon attributes and locals are immutable. Mutable attributes 
    and variable locals must be explicitly declared using the <literal>variable</literal> 
    annotation. An immutable attribute or local may not be assigned after its 
    initial value is specified.
    </para>
    
    </section>
    
    <section id="compiletimesafety">
    <title>Compile-time safety for optional values and type narrowing</title>
    
    <para>
    By default, Ceylon attributes and locals do not accept null values. 
    Optional locals and attributes must be explicitly declared. Optional 
    expressions are not assignable to non-optional locals or attributes, 
    except via use of the <literal>if (exists ... )</literal> construct. 
    Thus, the Ceylon compiler is able to detect illegal use of a null value 
    at compile time. Therefore, there is no equivalent to Java's 
    <literal>NullPointerException</literal> in Ceylon.
    </para>
    
    <para>
    Ceylon does not feature C-style typecasts. Instead, the 
    <literal>if (is ... )</literal> and <literal>case (is ... )</literal> 
    constructs may be used to narrow the type of an object reference 
    without risk of a <literal>ClassCastException</literal>.
    </para>
    
    </section>
    
    <section id="controlflow">
    <title>Control flow</title>
    
    <para>
    Ceylon's built in control flow structures are very similar to the 
    traditional constructs found in C, C# and Java. However, inline methods 
    can be used together with a special Smalltalk-style method invocation 
    protocol to achieve more specialized flow control and other 
    functional-style constructs such as comprehensions.
    </para>
    
    <para>
    Ceylon features an exceptions model inspired by Java and C#. Checked 
    exceptions are not supported.
    </para>
    
    </section>
    
    <section id="operatorsandoperatorpolymorphism">
    <title>Operators and operator polymorphism</title>
    
    <para>
    Ceylon features a rich set of operators, including most of the operators 
    supported by C and Java. True operator overloading is not supported. 
    However, each operator is defined to act upon a certain class or interface 
    type, allowing application of the operator to any class which extends or 
    implements that type. This is called <emphasis>operator polymorphism</emphasis>.
    </para>
    
    </section>
    
    <section id="numerictypes">
    <title>Numeric types</title>
    
    <para>Ceylon's numeric type system is much simpler than C, C# or Java, 
    with exactly five built-in numeric types (compared to eight in Java and
    eleven in C#). The built-in types are classes representing natural numbers, 
    integers, floating point numbers, arbitrary precision integers and 
    arbitrary precision decimals. <literal>Natural</literal>, 
    <literal>Integer</literal>, and <literal>Float</literal> values are 64 bit 
    by default, and may be optimized for 32 bit architectures via use of the 
    <literal>small</literal> annotation.</para>
    
    </section>
    
    <!-- 
    <section id="dimensioned types">
    <title>Dimensioned types</title>
    
    <para>Ceylon supports <emphasis>dimensional type parameters</emphasis>,
    allowing types with fixed dimensions such as vectors or matrices to be
    represented within the type system, and enabling compile-time bounds 
    checking of indexing operations.</para>
    
    </section>
    -->
    
    <section id="typeextensions">
    <title>Type extensions</title>
    
    <para>
    True open classes are not supported. However, Ceylon supports 
    <emphasis>extensions</emphasis>, which allow addition of methods and 
    interfaces to existing types, and transparent conversion between types, 
    within a textual scope. Extensions only affect the operations provided 
    by a type, not its state. <!--This facility makes it easy for Ceylon code 
    to transparently interoperate and inter-compile with Java code.-->
    </para>
    
    </section>
    
    <section id="structureddata">
    <title>Structured data</title>
    
    <para>
    Ceylon introduces a set of syntax extensions that support the definition 
    of domain-specific languages and expression of structured data. These 
    extensions include specialized syntax for initializing objects and 
    collections and expressing literal values or user-defined types. The goal 
    of this facility is to replace the use of XML for expressing hierarchical 
    structures such as documents, user interfaces, configuration and serialized 
    data. An especially important application of this facility is Ceylon's 
    built-in support for program element annotations.
    </para>
    
    </section>
    
    <section id="metaprogramming">
    <title>Metaprogramming</title>
    
    <para>
    Ceylon provides sophisticated support for meta-programming, including a 
    typesafe <emphasis>metamodel</emphasis> and <emphasis>events</emphasis>. 
    Generic code may invoke members reflectively and intercept member invocations. 
    This facility is more powerful, and much more typesafe, than reflection in 
    Java.
    </para>
    
    <para>
    An even more powerful feature is <emphasis>metatypes</emphasis>&mdash;a
    type definition may introduce a user-defined interface to its metamodel,
    allowing a form of generic programing with polymorphic abstraction at the 
    meta level. This facility is an object-oriented flavor of the notion of 
    "type classes" in Haskell.
    </para>
    
    </section>
    
    <section id="modularity">
    <title>Modularity</title>
    
    <para>
    Ceylon features language-level <emphasis>package</emphasis> and 
    <emphasis>module</emphasis> constructs, along with language-level access 
    control via the <literal>shared</literal> annotation which can be used to 
    express block-local, package-private, module-private, and public visibility 
    for program elements. There's no equivalent to Java's <literal>protected</literal>.
    </para>
    
    </section>
    
    </section>
    
    <section id="sdkmodules">
        <title>Modules included in the SDK</title>
    
    <para>The Ceylon SDK includes the following important modules:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>ceylon.language</literal> - basic types provided to support
            built-in language features</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.module</literal> - the module runtime (based on
            JBoss Modules)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.collection</literal> - the collections framework
            (with the underlying implementation provided by the Java collections
            framework)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.datetime</literal> - support for representing
            dates and times (based on JSR-310)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.security</literal> - the security API</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.io</literal> - the I/O facility (based on 
            <literal>java.io</literal>)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.concurrent</literal> - the concurrency API (based
            on JSR-166)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.http</literal> - the HTTP client and server (based 
            on JBoss Netty)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.transaction</literal> - the transaction server (based 
            on JBoss Transactions)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.rdbc</literal> - relational database connectivity 
            (based on JDBC)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.message</literal> - the message server (based 
            on JBoss HornetQ)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.xml</literal> - the XML parser</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.html</literal> - the HTML construction kit</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.compiler</literal> - a compiler for Ceylon source
            code</para>
        </listitem>
    </itemizedlist>
    
    <section id="parsingceylon">
        <title>Parsing and compiling the Ceylon language</title>
        
        <para>The Ceylon language has been shown to be lexable and parseable using 
        an ANTRL grammar with no hand-coded special cases. Where lookahead was 
        necessary, this was handled using syntactic predicates.</para>
        
        <para>Ceylon is a language for the Java Virtual Machine, therefore Ceylon
        programs compile to a set of platform-independent <literal>.class</literal> 
        files that comply with the published specification for the Java class file 
        format.</para>
        
    </section>
    
    </section>
    
    <section id="brieftutorial">
    <title>A brief tutorial</title>
    
    <para>The following tutorial assumes some background in Java or a Java-like
    language such as C#. Ceylon has very much in common with Java, but here we 
    emphasize how and why Ceylon differs from Java.</para>
    
    <section>
        <title>Writing a simple program in Ceylon</title>
        
        <para>
        Here's a classic example, implemented in Ceylon:
        </para>
        
        <programlisting>void hello() {
    process.writeLine("Hello, World!");
}</programlisting>

        <para>
        This code defines a <emphasis>toplevel method</emphasis> named 
        <literal>hello()</literal>. A toplevel method is just like a C function&mdash;it
        belongs directly to the package that contains it, and is not a member of 
        a specific type. You don't need a recieving object to invoke a toplevel
        method. Ceylon doesn't have <literal>static</literal> methods, but you 
        can think of toplevel methods as filling the same role. (Java-style
        <literal>static</literal> methods would break the strict block structure
        of the language.)
        </para>
        
        <para>
        This method is declared using the <literal>void</literal> keyword, which 
        means that it doesn't return a value. When the method is executed, it 
        calls the <literal>writeLine()</literal> method of an object named 
        <literal>process</literal>. (This method displays its parameter on the 
        console.)
        </para>
        
        <para>Copy this code into a file named <literal>hello.ceylon</literal>
        and put the file in the <literal>ceylon/source/</literal> directory of 
        your Ceylon SDK installation.</para>
        
        <para>Now, in the <literal>ceylon</literal> directory, run the 
        following command:</para>
        
        <programlisting>ceylon hello</programlisting>
        
        <para>This command compiles the source to bytecode and runs the Java 
        Virtual Machine. You should see the following output in the console:</para>
        
        <programlisting>Hello, World!</programlisting>
        
    </section>
    
    <section>
        <title>Adding inline documentation</title>
        
        <para>It's usually a good idea to add some kind of documentation to 
        important methods. One way we could do this is by using a C-style
        comment, either like this:</para>
        
        <programlisting>/* The classic Hello World program */
void hello() {
    process.writeLine("Hello, World!");
}</programlisting>

        <para>Or like this:</para>
        
        <programlisting>//The classic Hello World program
void hello() {
    process.writeLine("Hello, World!");
}</programlisting>
        
        <para>But it's much better to use the <literal>doc</literal>
        annotation for comments that describe declarations.</para>

        <programlisting>doc "The classic Hello World program"
void hello() {
    process.writeLine("Hello, World!");
}</programlisting>

        <para>
        The <literal>doc</literal> annotation contains documentation that 
        is included in the output of the Ceylon documentation compiler.
        The documentation compiler supports several other annotations, 
        including <literal>by</literal>, for specifying the author of a
        program element, <literal>see</literal>, for referring to related 
        code elements, and <literal>throws</literal>, for alerting the user 
        to exception types thrown by an executable program element.
        </para>
        
        <programlisting>doc "The classic Hello World program"
by "Gavin"
see (goodbye)
throws (IOException)
void hello() {
    process.writeLine("Hello, World!");
}</programlisting>
        
        <para>There's also a <literal>deprecated</literal> annotation for
        marking program elements that will be removed in a future version
        of the module.</para>
        
    </section>
        
    <section>
        <title>Dealing with objects that aren't there</title>
        
        <para>
        This improved version of the program takes a name as input from the 
        command line. We have to account for the case where nothing was
        specified at the command line, which gives us an opportunity to
        explore how null values are treated in Ceylon, which is quite 
        different to what you're probably used to in Java or C#.
        </para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
void hello() {
    String? name = process.args.first;
    String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    process.writeLine(greeting);
}]]></programlisting>

        <para>The <literal>process</literal> object has an attribute named 
        <literal>args</literal>, which holds a <literal>List</literal> of the 
        program's command line arguments. The local <literal>name</literal> is 
        initialized with the first of these arguments, if any. This local is 
        declared to have type <literal>String?</literal>, to indicate that it 
        may contain a null value. The <literal>if (exists ...)</literal> control 
        structure is used to initialize the value of the non-null local named 
        <literal>greeting</literal>, interpolating the value of 
        <literal>name</literal> into the message string whenever 
        <literal>name</literal> is not null. Finally, the message is printed
        to the console.</para>
        
        <para>Unlike Java, locals, parameters, and attributes that may contain 
        null values must be explicitly declared as being of type 
        <literal>Optional&lt;X&gt;</literal> where <literal>X</literal> is the
        type of value they contain when not holding a null value. Ceylon lets
        us abbreviate the type name <literal>Optional&lt;X&gt;</literal> to
        <literal>X?</literal>. The value <literal>null</literal> is an instance
        of type <literal>Optional&lt;X&gt;</literal>, but it's not an instance 
        of <literal>Object</literal>. So there's simply no way to assign 
        <literal>null</literal> to a local that isn't of type 
        <literal>Optional</literal>. The compiler won't let you.</para>
        
        <para>Nor will the Ceylon compiler let you do anything "dangerous" with 
        a value of type <literal>Optional</literal>&mdash;that is, anything that 
        could cause a <literal>NullPointerException</literal> in 
        Java&mdash;without first checking that the value is not null using 
        <literal>if (exists ... )</literal>. More formally, the 
        <literal>if (exists ... )</literal> construct lets us extract a value of 
        type <literal>X</literal> from a value of type 
        <literal>Optional&lt;X&gt;</literal>, thereby allowing us to invoke the 
        members of <literal>X</literal> upon the value.</para>
        
        <para>In fact, it's not even possible to use the equality operator 
        <literal>==</literal> with an expression of type <literal>Optional</literal>.
        You can't write <literal>if (x==null)</literal> like you can in Java. 
        This helps avoid the undesirable behavior of <literal>==</literal> in Java
        where <literal>x==y</literal> evaluates to <literal>true</literal> if
        <literal>x</literal> and <literal>y</literal> both evaluate to 
        <literal>null</literal>.</para>
        
        <para>If you're worried about the performance implications of wrapping
        values in instances of <literal>Optional</literal>, don't be. 
        <literal>Optional</literal> isn't a <emphasis>reified</emphasis>
        type&mdash;it exists at compile time, when the compiler is validating
        your code for typesafety, but the compiler eliminates it as part of 
        the compilation process, allowing the resulting bytecode to take advantage 
        of the efficient handling of null values in the virtual machine.</para>
        
        <para>It's possible to declare the local <literal>name</literal> inside
        the <literal>if (exists ... )</literal> condition:</para>
        
        <programlisting><![CDATA[String greeting;
if (exists String name = process.args.first) {
    greeting = "Hello, " name "!";
}
else {
    greeting = "Hello, World!";
}
process.writeLine(greeting);]]></programlisting>
        
        <para>This is the prefered style most of the time, since we can't actually
        use <literal>name</literal> for anything useful outside of the 
        <literal>if (exists ... )</literal> construct.</para>
        
        <para>Copy this new version of the program into <literal>hello.ceylon</literal> 
        and run, as before:</para>
        
        <programlisting>ceylon hello</programlisting>
        
        <para>You should see the same output as before:</para>
        
        <programlisting>Hello, World!</programlisting>
        
        <para>Now, run the program again, with a command-line argument:</para>
        
        <programlisting>ceylon hello everybody</programlisting>
        
        <para>You should see the following output:</para>
        
        <programlisting>Hello, everybody!</programlisting>
        
        <!-- 
        <para>There's also a postfix operator named <literal>exists</literal>. The
        <literal>exists</literal> operator simply evaluates to a <literal>Boolean</literal>
        value. It doesn't narrow its argument to a non-<literal>Optional</literal>
        type.</para>
        -->
         
        </section>
        
        <section>
            <title>Creating your own classes</title>

        <para>
        Our method now has too many responsibilities, and is not at all reusable. 
        Let's refactor the code. Ceylon is an object oriented language, so we 
        usually write most of our code in <emphasis>classes</emphasis>. A class
        is a type that packages:
        </para>
        
        <itemizedlist>
            <listitem><para>operations&mdash;called <emphasis>methods</emphasis>,</para></listitem>
            <listitem><para>state&mdash;held by <emphasis>attributes</emphasis>, and,</para></listitem>
            <listitem><para>sometimes, other nested types.</para></listitem>
        </itemizedlist>
          
        <para>
        Types (interfaces, classes, and type parameters) have names that begin with 
        uppercase letters. Members (methods and attributes) and locals have names that 
        begin with lowercase letters. This is the rule you're used to from Java. <!--
        (it's different to, and much prettier than, the naming conventions in C#)--> 
        Unlike Java, the Ceylon compiler enforces these rules. If you try to write 
        <literal>class hello</literal> or <literal>String Name</literal>, you'll get a 
        compilation error.
        </para>
        
        <para>Our first version of the <literal>Hello</literal> class has a
        single attribute and a single method:</para>
        
        <programlisting><![CDATA[doc "A personalized greeting"
class Hello(String? name) {
    
    doc "The greeting"
    shared String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    
    doc "Print the greeting"
    shared void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>To understand this code completely, we're going to need to first
            explore Ceylon's approach to program element accessibility&mdash; the
            <literal>shared</literal> annotation above, then meet the concept of an 
            attribute, and finally discuss how object initialization works in 
            Ceylon.</para>

        </section>
        
        <section>
            <title>Hiding implementation details</title>
            
        <para>
        In Java and C#, a class controls the accessibility of its members using 
        visibility modifier annotations, allowing the class to hide its internal 
        implementation from other code. The visibility modifiers select between 
        pre-defined, definite visibility levels like <literal>public</literal>,
        <literal>protected</literal>, package private, and <literal>private</literal>.
        Ceylon provides just one annotation for access control. The key difference
        is that Ceylon's <literal>shared</literal> annotation does not represent
        a single definite scope. Rather, its meaning is contextual, relative to
        the program element at which it appears. The <literal>shared</literal> 
        annotation is in some cases more flexible, in certain cases less flexible, 
        but almost always simpler and easier to use than the approach taken by Java 
        and C#. And it's a far better fit to a language like Ceylon with a regular,
        recursive block structure.
        </para>
        
        <para>
        Members of a class are hidden from code outside the body of the class 
        <emphasis>by default</emphasis>&mdash;only members explicitly annotated 
        <literal>shared</literal> are visible to other toplevel types or methods, 
        other compilation units, other packages, or other modules. A 
        <literal>shared</literal> member is visible to any code to which the class 
        itself is visible.
        </para>
        
        <para>
        And, of course, a class itself may be hidden from other code. By default, a 
        toplevel class is hidden from code outside the package in which the class is 
        defined&mdash;only toplevel classes explicitly annotated <literal>shared</literal> 
        are visible to other packages or modules. A <literal>shared</literal> toplevel
        class is visible to any code to which the package containing the class is
        visible.
        </para>
        
        <para>Finally, a package may be hidden from packages in other modules. In 
        fact, packages are hidden from code outside the module to which the package 
        belongs <emphasis>by default</emphasis>&mdash;only explicitly 
        <emphasis>shared</emphasis> packages are visible to other modules.</para>
        
        <para>It's not possible to create a <literal>shared</literal> toplevel class 
        with package-private members. Members of a <literal>shared</literal> toplevel 
        class must be either <literal>shared</literal>&mdash;in which case they're 
        visible outside the package containing the class, or 
        un-<literal>shared</literal>&mdash;in which case they're only visible to the 
        class itself. Package-private functionality <emphasis>must</emphasis> be
        defined in un-<literal>shared</literal> (package-private) toplevel classes or 
        interfaces. Likewise, a shared package can't contain a module-private toplevel 
        class. Module-private toplevel classes must belong to unshared (module-private) 
        packages.</para>
        
        <para>Note also that Ceylon doesn't have anything like Java's <literal>protected</literal>. 
        On the other hand, Java doesn't support any kind of module-private visibility 
        level, since Java has no standard module architecture.</para>
                    
        </section>
        
        <section>
            <title>Abstracting state using attributes</title>
            
            <para>The attribute <literal>greeting</literal> is a <emphasis>simple 
            attribute</emphasis>, the closest thing Ceylon has to a Java field. Its 
            value is specified immediately after it is declared. Usually we can declare
            and specify the value of an attribute in a single line of code.</para>
            
            <programlisting>shared String greeting = "Hello, " name "!";</programlisting>
            <programlisting>shared Natural months = years * 12;</programlisting>
        
            <para>An attribute is a bit different to a Java field. It's an abstraction
            of the notion of a value. Some attributes are simple value holders like
            the one we've just seen; others are more like a getter method, or, sometimes, 
            like a getter and setter method pair. Like methods, attributes are 
            polymorphic&mdash;an attribute definition may be refined (overridden) by a 
            subclass.</para>
            
            <para>We could rewrite the attribute <literal>greeting</literal> as a 
            <emphasis>getter</emphasis>:</para>

            <programlisting><![CDATA[shared String greeting {
    if (exists name) {
        return "Hello, " name "!"
    }
    else {
        return "Hello, World!"
    }
}]]></programlisting>

            <para>Notice that the syntax of a getter declaration looks a lot like a 
            method declaration with no parameter list.</para>

            <para>Clients of a class never need to know whether the attribute they 
            access holds state directly, or is a getter that derives its value from
            other attributes of the same object or other objects. In Ceylon, you don't 
            need to go around declaring all your attributes <literal>private</literal> 
            and wrapping them in getter and setter methods. Get out of that habit right 
            now!</para>
        
        </section>
        
        <section>
            <title>Understanding object initialization</title>
        
        <para>In Ceylon, classes don't have constructors. Instead:</para>
        
        <itemizedlist>
            <listitem>
                <para>the parameters needed to instantiate the class&mdash;the 
                <emphasis>initializer parameters</emphasis>&mdash;are declared 
                directly after the name of the class, and</para>
            </listitem>
            <listitem>
                <para>code to initialize the new instance  of the class&mdash;the 
                <emphasis>class initializer</emphasis>&mdash;goes directly in the 
                body of the class.</para>
            </listitem>
        </itemizedlist>
        
        <para>Take a close look at the following code fragment:</para>
        
<programlisting>String greeting;
if (exists name) {
    greeting = "Hello, " name "!";
}
else {
    greeting = "Hello, World!";
}</programlisting>

        <para>In Ceylon, this code could appear in the body of a class, where 
        it would be declaring and specifying the value of an immutable attribute, 
        or it could appear in the body of a method definition, where it would be 
        declaring and specifying the value of an immutable local variable. That's
        not the case in Java, where initialization of fields looks very different
        to initialization of local variables! Thus the syntax of Ceylon is more
        <emphasis>regular</emphasis> than Java. Regularity makes a language easy
        to learn and easy to refactor.</para>
        
        <para>Now let's turn our attention to a different possible implementation
        of <literal>greeting</literal>:</para>
        
        <programlisting><![CDATA[class Hello(String? name) {
    
    shared String greeting {
        if (exists name) {
            return "Hello, " name "!"
        }
        else {
            return "Hello, World!"
        }
    }
    
    ...
    
}]]></programlisting>

        <para>You might be wondering why we're allowed to use the parameter 
        <literal>name</literal> inside the body of the getter of
        <literal>greeting</literal>. Doesn't the parameter go out of scope as 
        soon as the initializer terminates? Well, that's true, but Ceylon is 
        a language with a very strict block structure, and the scope of 
        declarations is governed by that block structure. In this case, the 
        scope of <literal>name</literal> is the whole body of the class, and 
        the definition of <literal>greeting</literal> sits inside that scope, 
        so <literal>greeting</literal> is permitted to access 
        <literal>name</literal>.</para>
        
        <para>We've just met our first example of <emphasis>closure</emphasis>, 
        a concept from functional programming. We say that method and attribute 
        definitions receive a closure of values defined in the class body to which 
        they belong. That's just a fancy way of obfuscating the idea that 
        <literal>greeting</literal> holds onto the value of <literal>name</literal>, 
        even after the initializer completes.</para>
        
        <para>In fact, one way to look at the whole notion of a class in Ceylon 
        is to think of it as a function which returns a closure of its own local 
        variables. This helps explain why the syntax of class declarations is so 
        similar to the syntax of method declarations (a class declaration looks a 
        lot like a method declaration where the return type and the name of the 
        method are the same).</para>
        
        <para>Oh, by the way, there's an even easier way to define 
        <literal>greeting</literal>, using the <literal>?</literal>
        operator.</para>
        
        <programlisting><![CDATA[shared String greeting = "Hello, " name ? "World" "!";]]></programlisting>

        <para>The <literal>?</literal> operator returns its first argument if the
        first argument is not null, or its second argument otherwise. Its a more
        convenient way to handle null values in simple cases. It can even be chained:</para>
        
        <programlisting><![CDATA[shared String greeting = "Hello, " nickName ? name ? "World" "!";]]></programlisting>
        
        </section>
        
        <section>
            <title>Instantiating classes and overloading their initializer parameters</title>
         
        <para>Oops, I got so excited about attributes and closure that I forgot to show 
        you the code that uses <literal>Hello</literal>!</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
void hello() {
    Hello(process.args.first).say(process);
}]]></programlisting>
        
        <para>Our rewritten <literal>hello()</literal> method just creates a new instance
        of <literal>Hello</literal>, and invokes <literal>say()</literal>. Ceylon doesn't 
        need a <literal>new</literal> keyword to know when you're instantiating a class. 
        No, we don't know why Java needs it. You'll have to ask James.</para>
        
        <!--
        <para>(You'll always be able to tell immediately if something is an invocation or
        an instantiation: just look at the case of the identifier!)</para>
        -->
        
        <para>I suppose you're worried that if Ceylon classes don't have constructors,
        then they also can't have multiple constructors. Does that mean we can't overload
        the initialization parameter list of a class?</para>
        
        <para>I guess now's as good a time as any to break some more bad news: Ceylon doesn't
        support method overloading either! But, actually, this isn't as bad as it sounds. 
        The sad truth is that overloading is the source of various problems in Java, especially 
        when generics come into play. And in Ceylon, we can emulate almost any non-evil use of 
        constructor or method overloading using:</para>
        
        <itemizedlist>
            <listitem>
                <para><emphasis>defaulted parameters</emphasis>, to emulate the effect of
                overloading a method or class by "arity" (the number of parameters),</para>
            </listitem>
            <listitem>
                <para><emphasis>sequenced parameters</emphasis>, i.e. "varargs", and</para>
            </listitem>
            <listitem>
                <para><emphasis>enumerated type constraints</emphasis>, to emulate the effect 
                of overloading a method or class by parameter type.</para>
            </listitem>
        </itemizedlist>
        
        <para>We're not going to get into all the details of these workarounds right now, but
        here's a quick example of each of the three techniques:</para>
        
        <programlisting>//defaulted parameter
void print(String string = "\n") {
    process.writeLine(string);
}</programlisting>

        <programlisting>//sequenced parameter
void print(String... strings) {
    for (String string in strings) {
        process.writeLine(string);
    }
}</programlisting>

        <programlisting>//enumerated type constraint
void print&lt;T&gt;(T printable) 
        given T of String | Named {
    String string;
    switch (T)
    case (satisfies String) {
        string = printable;
    }
    case (satisfies Named) {
        string = printable.name;
    }
    process.writeLine(string);
}</programlisting>
        
        <para>Don't worry if you don't completely understand the third example just yet. Just
        think of it as a completely typesafe version of how you would write an "overloaded"
        operation in a dynamic language like Smalltalk, Python, or Ruby.</para>
          
        <para>To be completely honest, there are some circumstances where this approach ends
        up slightly more awkward than Java-style overloading. But that's a small price to pay
        for a language with clearer semantics, without nasty corner cases, that is ultimately
        more powerful.</para>
        
        <!--<para>Well, not exactly. Ceylon doesn't
        have constructor overloading, but it does have <emphasis>class overloading</emphasis>.
        Believe it or not, Ceylon lets you write multiple classes with the same name! Let's
        overload <literal>Hello</literal>:</para>-->
        
        <para>Let's "overload" <literal>Hello</literal>, and its <literal>say()</literal>
        method, using defaulted parameters:</para>
        
        <programlisting><![CDATA[doc "A command line greeting"
class Hello(String? name = process.args.first) {
    ...

    doc "Print the greeting" 
    shared void say(OutputStream stream = process) {
        stream.writeLine(greeting);
    }
    
}]]></programlisting>
        
        <!--
        <para>A class can overload a second class by extending it and declaring different
        initializer parameters. An overloaded class with an empty body is the Ceylon
        approach to "constructor" overloading. Of course, overloaded classes can do much
        more than just this!</para>
        -->
        
        <para>Our <literal>hello()</literal> method is now looking <emphasis>really</emphasis>
        simple:</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
void hello() {
    Hello().say();
}]]></programlisting>
        
        </section>
        
        <section>
            <title>Inheritance and refinement</title>
        
            <para>In object-oriented programming, we often replace conditionals 
            (<literal>if</literal>, and especially <literal>switch</literal>) with
            subtyping. Let's try refactoring <literal>Hello</literal> into two classes,
            with two different implementations of <literal>greeting</literal>:</para>
            
            <programlisting><![CDATA[doc "A default greeting"
class DefaultHello() {
    
    doc "The greeting"
    shared default String greeting = "Hello, World!";
    
    doc "Print the greeting"
    shared void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>Notice that Ceylon forces as to declare attributes or methods that can be 
            refined (overridden) by annotating them <literal>default</literal>.</para>
            
            <!--
            <para>We don't need to declare the visibility of the attribute annotated 
            <literal>default</literal>. The visibility&mdash;in this case, 
            <literal>package</literal>&mdash;is inherited from the class to which the
            attribute belongs.</para>
            -->
            
            <para>Subclasses specify their superclass using the <literal>extends</literal>
            keyword, followed by the name of the superclass, followed by a list of arguments
            to be sent to the superclass initializer parameters. It looks just like an
            expression that instantiates the superclass:</para>
            
            <programlisting><![CDATA[doc "A personalized greeting"
class PersonalizedHello(String name) extends DefaultHello() {
    
    doc "The personalized greeting"
    shared actual String greeting { 
        return "Hello, " name "!" 
    }
    
}]]></programlisting>

            <para>Ceylon also forces us to declare that an attribute or method refines (overrides) 
            an attribute or method of a superclass by annotating it <literal>actual</literal>. 
            All this annotating stuff costs a few extra keystrokes, but it helps the compiler
            detect errors. We can't inadvertantly refine a member or the superclass, or
            inadvertantly <emphasis>fail</emphasis> to refine it.</para>
            
            <!--
            <para>On the other hand, we don't need to declare the visibility of the attribute
            annotated <literal>actual</literal>. The <literal>package</literal> annotation
            is inherited from the attribute it refines.</para>
            -->
            
            <para>There's one problem with what we've just seen. A personalized greeting 
            is not really a kind of default greeting. This is a case for introducing an
            abstract superclass:</para>

            <programlisting><![CDATA[doc "A greeting"
abstract class Hello() {
    
    doc "The (abstract) greeting"
    shared formal String greeting;
    
    doc "Print the greeting"
    shared void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>Ceylon requires us to annotate abstract classes <literal>abstract</literal>,
            just like Java. This annotation specifies that a class cannot be instantiated,
            and can define abstract members. Like Java, Ceylon also requires us to annotate 
            "abstract" members that don't specify an implementation. However, in this case, 
            the required annotation is <literal>formal</literal>. Note that an attribute 
            that is never initialized is <emphasis>always</emphasis> a <literal>formal</literal> 
            attribute&mdash;Ceylon doesn't initialize attributes to zero unless you explicitly 
            tell it to!</para>
            
            <!--
            <para>We don't need to declare the visibility of the attribute annotated 
            <literal>formal</literal>. The visibility&mdash;in this case, 
            <literal>package</literal>&mdash;is inherited from the class to which the
            attribute belongs.</para>
            -->
            
            <para>One way to define an implementation for an inherited abstract attribute is 
            to simply assign a value to it in the subclass.</para>

            <programlisting><![CDATA[doc "A default greeting"
class DefaultHello() extends Hello() {
    greeting = "Hello, World!";
}]]></programlisting>

        <para>Of course, we can also define an implementation for an inherited abstract 
        attribute by refining it.</para>

        <programlisting><![CDATA[doc "A personalized greeting"
class PersonalizedHello(String name) extends Hello() {
    
    doc "The personalized greeting"
    shared actual String greeting { 
        return "Hello, " name "!" 
    }
    
}]]></programlisting>

        </section>
        
        <section>
            <title>Interfaces and "mixin" inheritance</title>
            
            <para>From time to time we come across a case where a class needs to inherit
            functionality from more than one supertype. Java's inheritance model doesn't
            support this, since an interface can never define a member with a concrete
            implementation. Interfaces in Ceylon are a little more flexible. An interface
            may define concrete methods, attribute getters, and attribute setters. It may
            not define simple attributes or initialization logic. Let's take advantage of
            this to define a reusable <literal>Writer</literal> interface for Ceylon.</para>
            
            <programlisting><![CDATA[shared interface Writer {
    
    shared formal Formatter formatter;
    
    shared formal void write(String string);
    
    shared void writeLine(String string) {
        write(string);
        write(process.newLine);
    }
    
    shared void writeFormattedLine(String formatString, Object... args) {
        writeLine( formatter.format(formatString, args) );
    }
    
}]]></programlisting>
            
            <para>Note that we can't define a concrete value for the <literal>formatter</literal>
            attribute, since an interface may not define a simple attribute, and may not 
            hold a reference to another object.</para>
            
            <para>Now let's define a concrete implementation of this interface.</para>
            
            <programlisting>shared class ConsoleWriter() satisfies Writer {
    
    formatter = StringFormatter();
    
    shared actual void write(String string) {
        process.write(string);
    }
    
}</programlisting>
            
            <para>The <literal>satisfies</literal> keyword is used to specify that an 
            interface extends another interface or that a class implements an interface.
            Unlike an <literal>extends</literal> declaration, a <literal>satisfies</literal>
            declaration does not specify arguments, since interfaces do not have
            parameters or initialization logic. Furthermore, the <literal>satisfies</literal>
            declaration can specify more than one interface.</para>
            
            <para>Ceylon's approach to interfaces eliminates a common pattern in Java
            where a separate abstract class defines a default implementation of some of 
            the members of an interface. In Ceylon, the default implementations can be
            specified by the interface itself. Even better, it's possible to add a new
            member to an interface without breaking existing implementations of the
            interface.</para>
            
        </section>
        
    <section>
        <title>Type aliases</title>
        
        <para>It's often useful to provide a shorter or more semantic name to an 
        existing class or interface type, especially if the class or interface is
        a parameterized type. For this, we use a type alias, for example:</para>
        
        <programlisting>interface People = Set&lt;Person&gt;;</programlisting>
        
        <para>A class alias must declare its parameters:</para>
        
        <programlisting>shared class People(Person... people) = ArrayList&lt;Person&gt;;</programlisting>
        
        <para>An alias may be declared <literal>shared</literal>, and imported by a 
        different package.</para>
        
        <para>Note that neither of these declarations defines a new type. We're just
        defining extra names for pre-existing types. Any instance
        of <literal>People</literal> is an instance of <literal>Set&lt;Person&gt;</literal>
        and any instance of <literal>Set&lt;Person&gt;</literal> is an instance of
        <literal>People</literal>. A type alias is very similar to a C-style
        <literal>typedef</literal>.</para>
        
    </section>
        
        <section>
            <title>Member classes and member class refinement</title>
            
            <para>You're probably used to the idea of an "inner" class in Java&mdash;a
            class declaration nested inside another class or method. Since Ceylon is a 
            language with a recursive block structure, the idea of a nested class is
            more than natural. But in Ceylon, a non-<literal>abstract</literal> nested
            class is actually considered a member of the containing type. For example,
            <literal>BufferedReader</literal> defines the member class 
            <literal>Buffer</literal>:</para>
            
            <programlisting>class BufferedReader(Reader reader) satisfies Reader {
    shared default class Buffer() 
            satisfies Character[] { ... }
    ...
}</programlisting>

            <para><literal>Buffer</literal> is annotated <literal>shared</literal>, so
            we can instantiate it like this:</para>
            
            <programlisting>BufferedReader br = BufferedReader(reader);
BufferedReader.Buffer b = br.Buffer();</programlisting>

            <para>Note that a nested type name must be qualified by the containing type
            name when used outside of the containing type.</para>

            <para><literal>Buffer</literal> is also annotated <literal>default</literal>, 
            so we can refine it in a subtype of <literal>BufferedReader</literal>:</para>
            
            <programlisting>shared class BufferedFileReader(File file)
        extends BufferedReader(FileReader(file)) {
    shared actual class Buffer() 
            extends BufferedReader.Buffer() { ... }
}</programlisting>
            
            <para>That's right: Ceylon lets us "override" a nested class defined by a 
            supertype!</para>
            
            <para>Note that <literal>BufferedFileReader.Buffer</literal> is a subclass 
            of <literal>BufferedReader.Buffer</literal>.</para>
            
            <para>Now the instantiation <literal>br.Buffer()</literal> above is a 
            polymorphic operation! It might return an instance of 
            <literal>BufferedFileReader.Buffer</literal> or an instance of 
            <literal>BufferedReader.Buffer</literal>, depending upon whether 
            <literal>br</literal> refers to a plain <literal>BufferedReader</literal> 
            or a <literal>BufferedFileReader</literal>. This is more than a cute trick.
            Polymorphic instantiation lets us eliminate the "factory method pattern"
            from our code.</para>
            
            <para>It's even possible to define a <literal>formal</literal> member class
            of an <literal>abstract</literal> class:</para>
            
            <programlisting>abstract class BufferedReader(Reader reader) satisfies Reader {
    shared formal class Buffer() 
            satisfies Character[];
    ...
}</programlisting>

            <para>In this case, a concrete implementation of the member class might 
            just be a type alias of another class, even a toplevel class.</para>

            <programlisting>shared class BufferedFileReader(File file)
        extends BufferedReader(FileReader(file)) {
    shared actual class Buffer() = ArrayList&lt;Character&gt;;
}</programlisting>
            
            <para>Here, <literal>BufferedFileReader.Buffer</literal> is actually an
            alias of <literal>ArrayList&lt;Character&gt;</literal>.</para>
            
        </section>
    
    <section>
        <title>Anonymous classes</title>
        
        <para>If a class has no parameters, it's often possible to use a shortcut 
        declaration which defines a named instance of the class, without providing any 
        actual name for the class itself. This is usually most useful when we're extending
        an abstract class or implementing an interface.</para>
        
        <programlisting><![CDATA[doc "A default greeting"
object defaultHello extends Hello() {
    greeting = "Hello, World!";
}]]></programlisting>
        
            <programlisting>shared object consoleWriter satisfies Writer {
    
    formatter = StringFormatter();
    
    shared actual void write(String string) {
        process.write(string);
    }
    
}</programlisting>
        
        <para>The downside to an <literal>object</literal> declaration is that we can't
        write code that refers to the concrete type of <literal>defaultHello</literal> 
        or <literal>consoleWriter</literal>, only to the named instances.</para>
        
        <para>A toplevel <literal>object</literal> declaration defines a singleton. An
        <literal>object</literal> declaration nested inside a class defines an object
        per instance of the containing class. An <literal>object</literal> declaration
        nested inside a method, getter, or setter results in an new object each time the 
        method, getter, or setter is executed.</para>
        
        <programlisting><![CDATA[shared Subscription register(Subscriber s) {
    subscribers.append(s);
    object subscription satisfies Subscription {
        shared actual void cancel() {
            subscribers.remove(s);
        }
    }
    return subscription
}]]></programlisting>
        
        <para>Notice how this code example makes clever use of the fact that the nested
        <literal>object</literal> declaration recieves a closure of the locals defined 
        in the containing method declaration!</para>
        
        <para>A different way to think about the difference between <literal>object</literal> 
        and <literal>class</literal> is to think of a class as a parameterized 
        <literal>object</literal>. (Of course, there's one big difference: a 
        <literal>class</literal> declaration defines a named type that we can refer to in
        other parts of the program.) We'll see later that Ceylon also lets us think of
        a method as a parameterized attribute.</para>
        
        <para>An <literal>object</literal> declaration can refine an attribute declared 
        <literal>formal</literal> or <literal>default</literal>.</para>
        
        <programlisting>shared abstract class App() {
    shared formal OutputStream stream;
    ...
}</programlisting>
        
        <programlisting>class ConsoleApp() extends App() {
    shared actual object stream satisfies OutputStream { ... }
    ...
}</programlisting>
        
        <para>However, an <literal>object</literal> may not itself be declared 
        <literal>formal</literal> or <literal>default</literal>.</para>
        
    </section>
    
    <section>
        <title>Testing the type of an object</title>
        
        <para>In any language with subtyping there is the hopefully occasional need 
        to perform narrowing conversions. Ceylon doesn't have C-style typecasts.
        Instead, we must test and narrow the type of an object reference in one step, 
        using the special <literal>if (is ... )</literal> construct. This construct 
        is very, very similar to <literal>if (exists ... )</literal>, which we met 
        earlier.</para>
        
        <programlisting>Object obj = ... ;
if (is Hello obj) {
    obj.say();
}</programlisting>
        
        <para>The <literal>switch</literal> statement can be used in a similar 
        way:</para>
        
        <programlisting>Object obj = ... ;
switch(obj)
case (is Hello) {
    obj.say();
}
case (is Person) {
    stream.writeLine(obj.firstName);
}
else {
    stream.writeLine($obj);
}</programlisting>

        <para>These constructs protect us from inadvertantly writing code that 
        would cause a <literal>ClassCastException</literal> in Java, just like
        <literal>if (exists ... )</literal> protects us from writing code that
        would cause a <literal>NullPointerException</literal>.</para>
        
        <para>Oh, the <literal>$</literal> operator just formats an object to 
        a printable string.</para>
        
        <!--
        <para>There's also a binary operator named <literal>is</literal>. The
        <literal>is</literal> operator simply evaluates to a 
        <literal>Boolean</literal> value. It does not narrow its argument to a 
        different type.</para>
        
        <programlisting>Boolean electronicPayment {
    return payment is CreditCardPayment 
        || payment is DebitCardPayment 
        || payment is DirectDebitPayment
}</programlisting>
                
        -->
        
        <para>Usually, the Ceylon compiler forces us to write an <literal>else</literal>
        clause in a <literal>switch</literal>, to remind us that there might be
        additional cases which we have not handled. If we want to write an 
        <emphasis>exhaustive</emphasis> list of cases in a switch statement, and 
        have the compiler check that we really did provide for every possibility, 
        we need to define an abstract type with an enumerated list of cases.</para>
        
        <programlisting>abstract class Hello() 
        of defaultHello | PersonalizedHello
        extends Case() {
    ...
}</programlisting>
        
        <para>When a type definition specifies an <literal>of</literal> clause,
        the compiler prevents us declaring any additional subtypes of the type.
        Therefore, we can write <literal>switch</literal> statements without an
        <literal>else</literal> clause:</para>
        
        <programlisting>Hello hello = ... ;
switch(hello)
case (defaultHello) {
    process.writeLine("What's your name?");
}
case (is PersonalizedHello) {
    process.writeLine("Nice to hear from you again!");
}</programlisting>
        
        <para>This is Ceylon's version of a Java <literal>enum</literal>:</para>
        
        <programlisting>shared class Suit() 
        of hearts | diamonds | clubs | spades 
        extends Case() {}
        
shared object hearts extends Suit() {}
shared object diamonds extends Suit() {}
shared object clubs extends Suit() {}
shared object spades extends Suit() {}</programlisting>
        
        <para>Of course, this is significantly more verbose than Java's version.
        But Ceylon's <literal>of</literal> clause is also a lot more flexible 
        than Java's <literal>enum</literal>, since it allows both classes and
        values in the enumerated list of subtypes.</para>
        
        <para>Another situation where we're allowed to use an exhaustive list of 
        cases is with an <emphasis>enumerated type bound</emphasis>. This is a 
        constraint upon a generic type parameter that restricts the type
        argument to any one of several types. The main usecase for enumerated 
        type bounds is emulating method overloading. For example:</para>
        
        <programlisting>void say&lt;T&gt;(T dest) 
        given T of OutputStream | Log | Buffer {
    switch(dest)
    case (is Outputstream) {
        dest.writeLine(greeting);
    }
    case (is Log) {
        dest.info(greeting);
    }
    case (is Buffer) {
        dest.append(greeting);
    }
}</programlisting>
        
        <para>We can call this method passing any instance of <literal>OutputStream</literal>,
        <literal>Log</literal>, or <literal>Buffer</literal>.</para>
        
        <para>Actually, a better, more elegant, more flexible, way to implement an 
        "overloaded" method is to write a <literal>switch</literal> against the type 
        parameter itself:</para>
        
        <programlisting>void say&lt;T&gt;(T dest) 
        given T of OutputStream | Log | Buffer {
    switch(T)
    case (satisfies Outputstream) {
        dest.writeLine(greeting);
    }
    case (satisfies Log) {
        dest.info(greeting);
    }
    case (satisfies Buffer) {
        dest.append(greeting);
    }
}</programlisting>
        
        <para>Don't worry if you don't completely understand this code. We'll come
        back to the topic of generics and type constraints later.</para>
        
        <!--
        <para>A second usecase for union types is writing a <literal>catch</literal>
        block which handles multiple disjoint types:</para>
        
        <programlisting>try (File file = File(path)) {
    file.open();
    file.writeLine("Hello, world!");
    file.close();
}
catch (FileExistsException|FileWriteException fe) {
    log.error("Could not write file", fe); 
    throw fe
}
catch (FileCloseEception fe) {
    log.error("Could not close file", fe); 
    throw fe
}</programlisting>
        -->
        
    </section>
    
       <section>
           <title>Named arguments</title>
           
           <para>Consider the following declaration:</para>
           
           <programlisting>void printf(OutputStream to, String format, Object... values) { ... }</programlisting>
           
           <para>(The last parameter is a <emphasis>sequenced parameter</emphasis> 
           which accepts multiple arguments, just like a Java "varargs" parameter.)</para>
           
           <para>We've seen lots of examples of invoking a method or instantiating
           a class using a familiar C-style syntax where arguments are delimited by 
           in parentheses and separated by commas. Arguments are matched to parameters 
           by their position in the list. Let's see just one more example, just in 
           case:</para>
                      
           <programlisting>printf(process, "Thanks, %s. You have been charged %.2f. Your confirmation number is %d.", 
        user.name, order.total, order.confimationNumber);</programlisting>
           
           <para>This works fine, I suppose. However, Ceylon provides an alternative 
           method invocation protocol that is usually easier to read when there are 
           more than one or two arguments:</para>
           
           <programlisting>printf { 
    to = process; 
    format = "Thanks, %s. You have been charged %.2f. Your confirmation number is %d."; 
    user.name, order.total, order.confimationNumber 
};</programlisting>
                      
           <para>This invocation protocol is called a <emphasis>named argument 
           list</emphasis>. We can recognize a named argument list by the use of 
           braces as delimiters instead of parentheses. Notice that arguments are 
           separated by semicolons, except for arguments to the sequenced parameter,
           which are separated by commas. We explicitly specify the name of each
           parameter, except for the sequenced parameter, whose arguments always
           appear at the end of the named parameter list.</para>
           
           <para>Named arguments are very commonly used for building graphs of
           objects. Therefore, Ceylon provides a special abbreviated syntax that
           simplifies the declaration of an attribute getter, named parameter, or 
           method that builds an object by specifying named arguments to the 
           class initializer.</para>
           
           <para>We're allowed to abbreviate an attribute definition of the 
           following form:</para>
           
           <programlisting>Payment payment = Payment {
    method = user.paymentMethod;
    currency = order.currency;
    amount = order.total;
};</programlisting>
    
           <para>or a named argument specification of this form:</para>
           
           <programlisting>payment = Payment {
    method = user.paymentMethod;
    currency = order.currency;
    amount = order.total;
};</programlisting>
           
           <para>to the following more declarative (and less redundant) style:</para> 
           
           <programlisting>Payment payment {
    method = user.paymentMethod;
    currency = order.currency;
    amount = order.total;
}</programlisting>

           <para>We're even allowed to write a method of the following form:</para>
        
           <programlisting>Payment createPayment(Order order) {
    return Payment {
        method = user.paymentMethod;
        currency = order.currency;
        amount = order.total;
    }
}</programlisting>
        
           <para>using the following abbreviated syntax:</para>

           <programlisting>Payment createPayment(Order order) {
    method = user.paymentMethod;
    currency = order.currency;
    amount = order.total;
}</programlisting>
        
           <para>Perhaps you're worried that this looks like a method that assigns the
           values of three attributes of the declaring class, rather than a shortcut 
           syntax for a named argument instantiation of the <literal>Payment</literal>
           class. And that's a fair point. To a Java developer, that <emphasis>is</emphasis> 
           what it looks like. There's two things that should alert you to what's really 
           going on. The above method:</para>
           
           <itemizedlist>
               <listitem>
                   <para>has no <literal>return</literal> statement, but it's 
                   not declared <literal>void</literal>, and</para>
               </listitem>
               <listitem>
                   <para>contains a list of <literal>=</literal> specification 
                   statements instead of <literal>:=</literal> assignment 
                   expressions.</para>
               </listitem>
           </itemizedlist>
           
           <para>Once you're used to Ceylon's more flexible syntax, these differences
           will usually stand out immediately.</para>
           
           <para>We'll have much more to say on the topic of named argument lists later. 
           For now, all we need to know is that there are two different syntaxes for 
           calling a method or instantiating a class. </para>
                       
       </section>

        <section>
            <title>Working with mutable state</title>

            <para>Ceylon encourages you to use <emphasis>immutable</emphasis> attributes
            as much as possible. An immutable attribute has its value specified when the 
            object is initialized, and is never reassigned. If we want to be able to
            assign a value to a simple attribute we need to annotate it 
            <literal>variable</literal>:</para>
            
            <programlisting>shared variable String greeting := "Hello World";
if (exists name) {
    greeting := "Hello, " name "!";
}</programlisting>

            <para>Notice the use of <literal>:=</literal> instead of <literal>=</literal>
            here. This is important! In Ceylon, specification of an immutable value is 
            done using <literal>=</literal>. Assignment to a <literal>variable</literal> 
            attribute or local is considered a different kind of thing, always performed 
            using the <literal>:=</literal> operator.</para>
            
            <!--
            <para>To force you to think twice before adding a <literal>variable</literal>
            attribute to your class, Ceylon requires that classes with mutable attributes
            be explicitly annotated <literal>variable</literal>. Hopefully, you'll find
            yourself doing this less frequently than you would do it in Java.</para>
            -->
            
            <para>If we want to make an attribute with a getter mutable, we need to 
            define a matching <emphasis>setter</emphasis>. Usually this is only useful if 
            you have some other internal attribute you're trying to set the value of
            indirectly.</para>
            
            <para>Suppose our class has the following <literal>variable</literal> simple 
            attribute, intended for internal consumption only, so un-<literal>shared</literal>:</para>
            
            <programlisting>variable String grtng := "Hello World";</programlisting>
            
            <para>Then we can abstract the simple attribute using a second attribute defined 
            as a getter/setter pair:</para>
            
            <programlisting>doc "gets the greeting"
shared String greeting { 
    return grtng 
}

doc "sets the greeting"
shared assign greeting { 
    grtng := greeting; 
}</programlisting>

            <para>Yes, this is a <emphasis>lot</emphasis> like a Java get/set method pair,
            though the syntax is significantly streamlined.
            But since Ceylon attributes are polymorphic, and since you can redefine a simple
            attribute as a getter or getter/setter pair without affecting clients that call 
            the attribute, you rarely need to write this code unless you're doing something 
            special in the getter or setter. So here's a more realistic example:</para>
       
            <programlisting>doc "gets the greeting"
shared String greeting { 
    return grtng 
}

doc "sets the greeting"
shared assign greeting {
    if (nonempty greeting) {
        grtng := greeting.strip().normalize();
    }
    else {
        throw IllegalArgumentException("greeting can not be empty")
    }
}</programlisting>

            <para>Get used to using the <literal>nonempty</literal> operator to check that 
            a value of type <literal>String</literal> or <literal>String?</literal> is an 
            actual non-empty string of characters. It's much more readable than the 
            equivalent Java idiom <literal>!"".equals(greeting)</literal>.</para>
            
        </section>
        
        <section>
            <title>Packages and imports</title>
            
            <para>There's no special <literal>package</literal> statement in Ceylon. The 
            compiler determines the package and module to which a toplevel program element
            belongs by the location of the source file in which it is declared. A class named
            <literal>Hello</literal> in the package <literal>org.jboss.hello</literal> must 
            be defined in the file <literal>org/jboss/hello/Hello.ceylon</literal>.</para>
            
            <para>When a source file in one package refers to a toplevel program element
            in another package, it must explicitly import that program element. Ceylon, 
            unlike Java, does not support the use of qualified names within the source file.
            We can't write <literal>org.jboss.hello.Hello</literal> in Ceylon.</para> 
            
            <para>The syntax of the <literal>import</literal> statement is slightly different 
            to Java. To import a program element, we write:</para>
            
            <programlisting>import org.jboss.hello { Hello }</programlisting>
            
            <para>To import several program elements from the same package, we write:</para>
            
            <programlisting>import org.jboss.hello { Hello, defaultHello, PersonalizedHello }</programlisting>
           
            <para>To import all toplevel program elements of a package, we write:</para>
            
            <programlisting>import org.jboss.hello { ... }</programlisting>
            
            <para>To resolve a name conflict, we can rename an imported declaration:</para>
            
            <programlisting>import org.jboss.hello { local Hi = Hello, ... }</programlisting>
        
        </section>
        
        <section>
            <title>An overview of the built-in types</title>
            
            <para>Just like Java, Ceylon has a class named <literal>Object</literal>. But
            in Ceylon, <literal>Object</literal> isn't the root of the type system. An
            expression of type <literal>Object</literal> has a definite, well-defined, 
            non-null value. As we've seen, the Ceylon type system can also represent some
            more exotic types, for example <literal>Optional&lt;T&gt;</literal>, which
            represents a value that may be null. A second example of a type that doesn't
            extend <literal>Object</literal> is <literal>Gettable&lt;T&gt;</literal>, 
            which represents a value that has not yet been evaluated.</para>
            
            <para>Therefore, Ceylon's <literal>Object</literal> has a superclass, named 
            <literal>Void</literal>. All Ceylon types are assignable to <literal>Void</literal>.
            Expressions of type <literal>Void</literal> aren't useful for very much, 
            since <literal>Void</literal> has no members or operations. You can't even narrow 
            an expression of type <literal>Void</literal> to a different type. The one useful 
            thing you <emphasis>can</emphasis> do with <literal>Void</literal> is use it to 
            represent the signature of a method when you don't care about the return type, 
            since a method declared <literal>void</literal> is considered to have return type
            <literal>Void</literal>.</para>
            
            <para>The exotic types we just mentioned&mdash;<literal>Optional</literal> and
            <literal>Gettable</literal>&mdash;directly extend <literal>Void</literal>. All 
            types that represent well-defined values extend <literal>Object</literal>,
            including:</para>
            
            <itemizedlist>
                <listitem>
                    <para>user-written classes,</para>
                </listitem>
                <listitem>
                    <para>all interfaces, and</para>
                </listitem>
                <listitem>
                    <para>the types that are considered primitive in Java, such as
                    <literal>Integer</literal>, <literal>Float</literal> and 
                    <literal>Character</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Since an expression of type <literal>Object</literal> always evaluates to
            a definite, well-defined value, it's possible to obtain the runtime type of an
            <literal>Object</literal>, or narrow an expression of type <literal>Object</literal> 
            to a more specific type.</para>
            
            <para>On the other hand,
            since <literal>Object</literal> is a supertype of types like <literal>Float</literal>
            which are passed by value at the level of the Java Virtual Machine, you can't use 
            the <literal>===</literal> operator to test the identity of two values of type
            <literal>Object</literal>. Instead, there is a subclass of <literal>Object</literal>,
            named <literal>IdentifiableObject</literal>, which represents a type which is always 
            passed by reference. The <literal>===</literal> operator accepts expressions of 
            type <literal>IdentifiableObject</literal>. It's possible for a user-written class to 
            directly extend <literal>Object</literal>, but most of the classes you write will be
            subclasses of <literal>IdentifiableObject</literal>. All classes with 
            <literal>variable</literal> attributes must extend <literal>IdentifiableObject</literal>.</para>
            
            <para><literal>IdentifiableObject</literal> defines a default implementation of the
            interface <literal>Equality&lt;IdentifiableObject&gt;</literal>, which is very similar
            to the <literal>equals()</literal> and <literal>hashCode()</literal> methods defined
            by <literal>java.lang.Object</literal>. Just like in Java, you can refine this
            default implementation in your own classes. This is the normal way to get a customized 
            behavior for the <literal>==</literal> operator, the only constraint being, that for
            subtypes of <literal>IdentifiableObject</literal>, <literal>x==y</literal> should
            imply <literal>x===y</literal>&mdash;equality should be consistent with identity.</para>
            
            <para>Occasionally that's not what we want. For example, for numeric types, I don't
            care whether a value is of class <literal>Natural</literal>, <literal>Integer</literal>, 
            or <literal>Whole</literal> when comparing it to <literal>0</literal>. Therefore, 
            numeric types must extend <literal>Object</literal> directly. Indeed, all the built in
            numeric types do directly extend <literal>Object</literal>. The built-in numeric types
            also implement the interface <literal>Numeric&lt;T&gt;</literal>, which extends 
            <literal>Equality&lt;T&gt;</literal>. This captures the notion that equality for numeric
            types is fundamentally different to equality for objects with well-defined identity.
            It's not possible to compare an <literal>Integer</literal> with an <literal>Order</literal>
            using <literal>==</literal> (at least not if you expect to have a symmetrical 
            <literal>==</literal> operator).</para>
            
            <para>Thus, Ceylon is able to capture within the type system much of the behavior that 
            Java introduces by fiat special-case rules in the language definition.</para>
            
            <para>Finally, the <literal>BaseObject</literal> class&mdash;which is the class you extend
            by default if you don't specify a superclass explicitly in the <literal>extends</literal>
            declaration&mdash;is a subclass of <literal>Object</literal> that implements support for
            using the <literal>id</literal> annotation to refine <literal>equals()</literal>, 
            <literal>hash</literal> and <literal>string</literal>, as we're about to see.</para>
            
        </section>
        
        <section>
            <title>Operator polymorphism</title>
            
            <para>Ceylon discourages the creation of intriguing executable ASCII art. 
            Therefore, true operator overloading is not supported by the language. Instead,
            almost every operator (every one except the primitive <literal>.</literal>,
            <literal>()</literal>, <literal>is</literal>, and <literal>:=</literal> operators) 
            is considered a shortcut way of writing some more complex expression involving
            other operators and ordinary method calls. For example, the <literal>&lt;</literal>
            operator is defined in terms of the interface <literal>Comparable&lt;T&gt;</literal>, 
            which has a method named <literal>smallerThan()</literal>, which is in turn defined
            in terms of another method named <literal>compare()</literal>.</para>
            
            <programlisting>x&lt;y</programlisting>
            
            <para>means, by definition,</para>
            
            <programlisting>x.smallerThan(y)</programlisting>
            
            <para>The equality operator <literal>==</literal> is defined in terms of the 
            interface <literal>Equality&lt;T&gt;</literal>, which has a method named 
            <literal>equals()</literal>.</para>
            
            <programlisting>x==y</programlisting>
            
            <para>means, by definition,</para>
            
            <programlisting>x.equals(y)</programlisting>
            
            <para>Therefore, it's easy to customize operators like <literal>&lt;</literal> 
            and <literal>==</literal> with specific behavior for our own classes, just by 
            implementing or refining methods like <literal>compare()</literal> and 
            <literal>equals()</literal>. Thus, we say that operators are 
            <emphasis>polymorphic</emphasis> in Ceylon.</para>
            
            <para>For example, we could refine the <literal>default</literal> 
            implementations of <literal>equals()</literal> and <literal>hash</literal> that
            <literal>Hello</literal> inherits from <literal>BaseObject</literal>:</para>
            
        <programlisting><![CDATA[doc "A greeting"
abstract class Hello() {
    
    doc "The (abstract) greeting"
    shared formal String greeting;
    
    shared actual Boolean equals(IdentifiableObject that) {
        if (is Hello that) {
            if (this.type!=that.type) {
                return false
            }
            else {
                return that.greeting==this.greeting
            }
        } 
        else {
            return false
        }
    }
    
    shared actual Integer hash = greeting.hash;
    
    shared actual String string { 
        return greeting 
    }
    
    ...
    
}]]></programlisting>

            <para>If we refine <literal>equals()</literal>, we're required to also refine
            the <literal>hash</literal> attribute.</para>
            
            <para>Since it's very common to refine <literal>equals()</literal>, <literal>hash</literal>
            and <literal>string</literal> at the same time, there's an easy way to do it using
            the <literal>id</literal> annotation. The previous code is equivalent to this much
            shorter version:</para>
            
        <programlisting><![CDATA[doc "A greeting"
abstract class Hello() {
    
    id
    doc "The (abstract) greeting"
    shared formal String greeting;
    
    ...
        
}]]></programlisting>
            
            <para>Check out the <literal>default</literal> implementation of <literal>equals()</literal>, 
            <literal>hash</literal> and <literal>string</literal> in <literal>BaseObject</literal>
            to see exactly how this works.</para>
            
            <para>Apart from <literal>Comparable</literal> and <literal>Equality</literal>, 
            which provide the underlying definition of comparison and equality operators,
            the following interfaces are also important in the definition of Ceylon's
            polymorphic operators:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>Numeric</literal> supports arithmetic operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Slots</literal> supports bitwise operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Comparable</literal> supports the comparison operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Container</literal> and <literal>Category</literal>
                    support the <literal>nonempty</literal> and <literal>in</literal> 
                    operators, respectively,</para>
                </listitem>
                <listitem>
                    <para><literal>Correspondence</literal> and <literal>Sequence</literal>
                    support indexing and subrange operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Boolean</literal> is the basis of the logical operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Optional</literal> supports the <literal>exists</literal>
                    and <literal>?</literal> operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Callable</literal> supports invocation, and</para>
                </listitem>
                <listitem>
                    <para><literal>Settable</literal> supports assignment and compound
                    assigment operators.</para>
                </listitem>
            </itemizedlist>
            
        </section>
        
        <section>
            <title>Using numeric types</title>
            
            <para>Ceylon doesn't have anything like Java's primitive types. The types that
            represent numeric values are just ordinary classes. Ceylon has fewer built-in
            numeric types than other C-like languages:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>Natural</literal> represents the unsigned integers 
                    and zero,</para>
                </listitem>
                <listitem>
                    <para><literal>Integer</literal> represents signed integers,</para>
                </listitem>
                <listitem>
                    <para><literal>Float</literal> represents floating point approximations
                    to the real numbers,</para>
                </listitem>
                <listitem>
                    <para><literal>Whole</literal> represents arbitrary-precision signed 
                    integers, and</para>
                </listitem>
                <listitem>
                    <para><literal>Decimal</literal> represents arbitrary-precision and 
                    arbitrary-scale decimals.</para>
                </listitem>
            </itemizedlist>
            
            <para><literal>Natural</literal>, <literal>Integer</literal> and 
            <literal>Float</literal> have 64-bit precision by default. You can specify that 
            a value has 32-bit precision by annotating it <literal>small</literal>. But note 
            that this annotation is really just a hint that the compiler is free to ignore.</para>
            
            <para>There are only two kinds of numeric literals: literals for 
            <literal>Natural</literal>s, and literals for <literal>Float</literal>s:</para>
            
            <programlisting>Natural one = 1;</programlisting>
            <programlisting>Float oneHundredth = 0.01;</programlisting>
            <programlisting>Float oneMillion = 1.0E+6;</programlisting>
            
            <para>Widening type conversions are implicit, since the <literal>ceylon.language</literal> 
            package defines a set of built-in <emphasis>extensions</emphasis> (a concept 
            we'll meet later) that take care of this:</para>
            
            <programlisting>Decimal oneTenth = 0.1;</programlisting>
            <programlisting>Whole zero = 0;</programlisting>            
            <programlisting>Integer minusOne = -1;</programlisting>
            
            <para>To perform a narrowing type conversion, you need to call one of the 
            operations (well, they're attributes, actually) defined by the interface
            <literal>Number</literal>:</para>
            
            <programlisting>Natural one = 1.003.natural;</programlisting>
            <programlisting>Integer int = whole.integer;</programlisting>
            
            <para>Of course, a narrowing conversion can result in an exception at run 
            time, so take care!</para>
            
            <para>You can use all the operators you're used to from other C-style languages
            with the numeric types. You can also use the <literal>**</literal> operator to
            raise a number to a power:</para>
            
            <programlisting>Float diagonal = (length**2+width**2)**0.5;</programlisting>
            
            <para>Of course, if you want to use the increment <literal>++</literal> operator,
            decrement <literal>--</literal> operator, or one of the compound assignment
            operators such as <literal>+=</literal>, you'll have to declare the value 
            <literal>variable</literal>.</para>
            
            <programlisting>shared class Counter() {
            
    variable Natural count := 0;

    shared Natural next() {
        return ++count
    }

}</programlisting>
            
            <!--
            <para>You can even apply the slotwise and, or, xor, and complement operators
            to the type <literal>Natural</literal>:</para>
            
            <programlisting>Natural result = color&amp;mask;</programlisting>
            -->
            
            <para>Operators in Ceylon are, in principle, just abbreviations for some expression
            involving a method call. So the numeric types all implement the <literal>Numeric</literal> 
            interface, which declares the methods <literal>plus()</literal>, <literal>minus()</literal>,
            <literal>times()</literal>, <literal>divided()</literal> and <literal>power()</literal>.
            The numeric operators are defined in terms of these methods of <literal>Numeric</literal>.</para>
            
            <para>But don't worry about the performance implications of this&mdash;in practice, 
            the compiler is permitted to optimize away the method invocations. In fact, the compiler
            is permitted to optimize the built-in numeric types down to the virtual machine's native
            numeric types.</para>
            
            <para>The real value of <literal>Numeric</literal>&mdash;apart from eliminating special 
            cases in the language definition and type checker&mdash;is that you can implement the
            interface yourself, to introduce your own, more specialized numeric type. And you'll be 
            able to apply all the usual numeric operators to it. That's why we've been making a big
            deal out of operator polymorphism.</para>
            
        </section>
        
        <section>
            <title>An overview of the language-level collection types</title>
            
            <para>The collections module is one of the best features of Ceylon. However,
            collections are not considered part of the core language. Instead, the language 
            module defines a number of important interfaces which are extended by types in 
            the collections module, and Ceylon defines some useful operators and control
            structures in terms of these interfaces.</para> 
            
            <itemizedlist>
                <listitem>
                    <para>The most abstract types related to collections are the interfaces 
                    <literal>Container</literal>, <literal>Category</literal> and 
                    <literal>Iterable</literal>. They define the most basic capabilities of
                    an object that contains other objects.</para>
                </listitem>
                <listitem>
                    <para>The types <literal>Correspondence</literal> and 
                    <literal>Sequence</literal> define the ability to access an element by
                    key or index.</para>
                </listitem>
            </itemizedlist>
            
            <para>These are very simple interfaces, so many different types extend or implement 
            them.</para>
            
            <para>A <literal>Container</literal> is an object that might be empty. Any 
            <literal>Container</literal> can be the subject of the <literal>nonempty</literal>
            operator or of the <literal>if (nonempty ...)</literal> construct.</para>
            
            <programlisting>Container con = .... ;
if (nonempty con) { .... }</programlisting>
            
            <para>A <literal>Category</literal> is an object to which other objects
            belong. Any <literal>Category</literal> can be the second argument of the 
            <literal>in</literal> operator.</para>
            
            <programlisting>Category cat = .... ;
if (obj in cat) { .... }</programlisting>

            <para>An <literal>Iterable&lt;T&gt;</literal> is an object which can produce an 
            <literal>Iterator&lt;T&gt;</literal>. An <literal>Iterable</literal> object can 
            be used in a <literal>for</literal> loop.</para>
            
            <programlisting>Iterable&lt;Person&gt; people = ... ;
for (Person p in people) { ... }</programlisting>

            <para>(Note that the keyword <literal>in</literal> here is not really the
            <literal>in</literal> operator. In this case, it's actually just part of the 
            syntax of the <literal>for</literal> loop.)</para>
            
            <para>Much less abstract are the interfaces <literal>Correspondence</literal> and 
            <literal>Sequence</literal>. Let's start with <literal>Sequence</literal>, even 
            though a sequence is just a special type of <literal>Correspondence</literal>.</para>
            
        </section>
        
        <section>
            <title>Sequences</title>
            
            <para>There's no arrays in Ceylon, but you can write the following code:</para>
            
            <programlisting>String[] voyage = { "Melbourne", "San Francisco", "Boston", "Atlanta", "Guanajuato" };
String? sf = voyage[2];
String[] usLeg = voyage[1..3];
String[] longerVoyage := voyage + { "Rome", "Paris", "Edinburgh" };</programlisting>
            
            <para>The syntax <literal>String[]</literal> is just an abbreviation for the 
            type <literal>Sequence&lt;String&gt;</literal>. Don't be scared by the fancy 
            syntax&mdash;it's just sugar. There's actually nothing much special about the 
            interface <literal>Sequence</literal> from the point of view of the type system. 
            But sequences of values are a common occurrence in computing, so Ceylon provides 
            a streamlined syntax for dealing with them. Let's break down this code.</para>
            
            <para>We can instantiate a <literal>Sequence</literal> using a streamlined syntax
            where the elements of the sequence are enclosed in braces.</para>
            
            <programlisting>String[] voyage = { "Melbourne", "San Francisco", "Boston", "Atlanta", "Guanajuato" };</programlisting>
            
            <para>Again, this is just syntactic sugar. The above is <emphasis>exactly</emphasis> 
            equivalent to the following regular instantiation:</para>

            <programlisting>String[] voyage = Sequence { "Melbourne", "San Francisco", "Boston", "Atlanta", "Guanajuato" };</programlisting>
            
            <para>The expression <literal>voyage[2]</literal> evaluates to the third item in 
            the sequence (the item with index <literal>2</literal>).</para>
            
            <programlisting>String? sf = voyage[2];</programlisting>
            
            <para>Note that the lookup operator returns an optional type, in this case 
            <literal>String?</literal>, to account for the possibility that the given index 
            was outside of the range of indexes of the sequence. As we'll soon see, the lookup 
            operator works with more than just sequences.</para>
            
            <para>The range expression <literal>voyage[1..3]</literal> evaluates to the 
            subsequence from the lower index <literal>1</literal> to the upper index 
            <literal>3</literal> (a subsequence containing the second, third, and fourth items 
            of the sequence).</para> 
            
            <programlisting>String[] usLeg = voyage[1..3];</programlisting>
            
            <para>The range operator only works for sequences.</para>
            
            <para>The <literal>+</literal> operator joins two sequences together.</para>
            
            <programlisting>String[] longerVoyage := voyage + { "Rome", "Paris", "Edinburgh" };</programlisting>
            
            <para>This <literal>+</literal> operator has absolutely nothing to do with addition 
            of numeric values. Rather, this is the single example of an overloaded operator in 
            Ceylon.</para>
            
            <para>(Remember, these operators are just syntactic sugar for method invocation.)</para>
            
            <para>Just like in Java, the collection types are <emphasis>parameterized</emphasis> 
            or <emphasis>generic</emphasis> types. Unlike Java, there are no raw types&mdash;if
            a type declares type parameters, a type argument for each parameter is required
            everywhere the type is used. For example, the following declaration is not legal:</para>
            
            <programlisting>Sequence voyage = Sequence { "Atlanta", "Boston", "San Francisco" };  //error! missing type argument</programlisting>
            
            <para>The closest thing to a raw type, in this case, would be a 
            <literal>Sequence&lt;Object&gt;</literal>.</para>
            
            <programlisting>Sequence&lt;Object&gt; voyage = Sequence { "Atlanta", "Boston", "San Francisco" };</programlisting>
            
            <para>Which Ceylon lets us abbreviate like this:</para>
            
            <programlisting>Object[] voyage = { "Atlanta", "Boston", "San Francisco" };</programlisting>
            
            <para>Sequences of ordinal values are especially common, so there's an
            operator for constructing them, called the <emphasis>range</emphasis>
            operator:</para>
            
            <programlisting>Natural[] from1To10 = 1..10;</programlisting>
            <programlisting>Integer[] fromNegative10To10 = -10..10;</programlisting>
            <programlisting>Character[] alphanum = (`A`..`Z`) + (`0`..`9`);</programlisting>

            <para>The <literal>Sequence</literal> interface extends <literal>Iterable</literal>,
            so we can iterate a <literal>Sequence</literal> using a <literal>for</literal>
            loop:</para>
            
            <programlisting>for (String city in voyage) {
    stream.writeLine(city);
}</programlisting>

            <para>If, for some reason, we need access to the index of each element, 
            we can also do the following:</para>
            
            <programlisting>for (Natural i -> String city in voyage) {
    stream.writeLine($i + ": " + city);
}</programlisting>

            <para>This works because there's a built-in extension method (a concept we'll
            meet later) that produces an <literal>Iterable&lt;Entry&lt;Natural,X&gt;&gt;</literal>
            for any <literal>Sequence&lt;X&gt;</literal>.</para>
            
            <para>A <literal>Sequence</literal> is a <literal>Container</literal>, so we
            can use the <literal>nonempty</literal> operator to determine if it has any
            elements:</para>
            
            <programlisting>if (nonempty voyage) { ... }</programlisting>
            
            <para>We can find the exact number of elements using the <literal>size</literal>
            attribute:</para>
            
            <programlisting>Natural stops = voyage.size;</programlisting>
            
            <para>A <literal>Sequence</literal> is a <literal>Category</literal>, so we can 
            use the <literal>in</literal> operator with sequences:</para>
            
            <programlisting>if ("Paris" in voyage) { ... }</programlisting>
            
        </section>
        
        <section>
            <title>Correspondences</title>
            
            <para>Sometimes the keys of our collection elements aren't natural numbers, 
            so we need something other than a <literal>Sequence</literal>. A
            <literal>Correspondence&lt;U,V&gt;</literal> is a mapping from keys of type
            <literal>U</literal> to values of type <literal>V</literal>. In fact, a 
            <literal>Sequence</literal> is just a special case of a 
            <literal>Correspondence</literal> where the keys are <literal>Natural</literal> 
            numbers. <literal>Sequence&lt;X&gt;</literal> is a subtype of 
            <literal>Correspondence&lt;Natural, X&gt;</literal>.</para>
            
            <para>We often use the class <literal>Entry</literal>, which represents a 
            key/value pair, when working with <literal>Correspndences</literal>. The
            operator <literal>-></literal> constructs a new <literal>Entry</literal>.</para>
            
            <programlisting>Entry&lt;String,Person&gt; entry = person.name->person;</programlisting>
            
            <para>We can instantiate a <literal>Correspondence</literal> using a similar
            syntax to the one we used for sequences:</para>
                              
            <programlisting>Correspondence&lt;String,String&gt; cities = 
        Correspondence { "Emmanuel"->"Paris",
                           "Andrew"->"Cambridge", 
                             "Pete"->"Edinburgh",
                            "Gavin"->"Guanajuato" };</programlisting>
            
            <para>We can extract values from a <literal>Correspondence</literal> by key 
            using the lookup operator:</para>

            <programlisting>String? paris = cities["Emmanuel"];</programlisting>
            
            <para>Again, notice that the lookup operator returns an <literal>Optional</literal>
            result, to account for the possibility that there is no value defined for
            the given key.</para>
            
            <para>So far we haven't met anything from the collections module proper. 
            <literal>Sequence</literal> and <literal>Correspondence</literal> are part 
            of the module <literal>ceylon.language</literal>. They're there to abstract 
            away the nice syntax we've just met from the (relatively) gory details of 
            the collections package.</para>
            
        </section>
        
        <section>
            <title>The collections module</title>
            
            <para>Inside the collections module you'll find some interfaces with pretty
            familiar names: <literal>Collection</literal>, <literal>Set</literal>, 
            <literal>List</literal> and <literal>Map</literal>. (There's even a
            <literal>Bag</literal>.) But these interfaces aren't quite what you're used 
            to from Java. Most importantly, none of them provide operations to change
            the elements of the collection. If you need to mutate a collection, you'll
            need one of their evil twins: <literal>OpenCollection</literal>, 
            <literal>OpenSet</literal>, <literal>OpenList</literal> and 
            <literal>OpenMap</literal> (and we can't forget <literal>OpenBag</literal>).</para>
            
            <para>You can obtain an immutable copy of any collection by calling
            <literal>copy()</literal>. You can obtain a mutable copy of a collection
            by calling <literal>openCopy()</literal>.</para>
            
            <programlisting>Set&lt;String&gt; names {
    OpenSet&lt;String&gt; set = none;
    for (Person p in people) { set.add(p.name); }
    return set.copy()
}

...

OpenSet&lt;String&gt; set = names.openCopy();</programlisting>

            <para>Splitting the collection interfaces into a "read-only" view and a
            "writable" view has several advantages, but the most important is that you
            now don't need to worry about exposing collections as part of the public 
            contract of your classes. In Java, it's always difficult for a client to 
            know if you're returning a copy of your internal list, a reference to your
            internal list (which you might have done inadvertantly), or a reference 
            wrapped in an <literal>immutableList()</literal>&mdash;you know, that wonderful 
            beastie which helpfully throws exceptions at runtime to let you know that it 
            is supposed to be "read-only". In Ceylon, you can protect the state of your 
            internal data structures by simply not returning the "writable" view to 
            clients. Send them back a <literal>List</literal>, and they know what they're 
            allowed to do with it.</para>
            
            <para>A <literal>Map</literal> is the most important kind of 
            <literal>Correspondence</literal>. We can add or override entries in an 
            <literal>OpenMap</literal> using the assignment operator:</para>
            
            <programlisting><![CDATA[OpenMap<String,String> cities = none;
cities["Gavin"] := "Guanajuato";
cities["Emmanuel"] := "Paris";
cities["Pete"] := "Edinburgh";
cities["Andrew"] := "Cambridge";]]></programlisting>
            
            <para>It's even possible to define multiple entries at once:</para>
            
            <programlisting><![CDATA[OpenMap<String,String> cities = none;
cities.define("Emmanuel"->"Paris",
                 "Gavin"->"Guanajuato",
                  "Pete"->"Edinburgh",
                "Andrew"->"Cambridge");]]></programlisting>
            
            <para>A <literal>Map</literal> is a collection of entries, a 
            <literal>Collection&lt;Entry&gt;</literal>. This is a big improvement over 
            Java where, unaccountably, a <literal>Map</literal> isn't actually a 
            <literal>Collection</literal>!</para>
            
            <para>Since <literal>Collection</literal>s are <literal>Iterable</literal>, 
            we can iterate a <literal>Map</literal> like this:</para>

            <programlisting>for (Entry&lt;String,String&gt; entry in cities) {
    stream.writeLine(entry.key + " lives in " + entry.value);
}</programlisting>

            <para>Or, much more commonly:</para>
            
            <programlisting>for (String person -> String city in cities) {
    stream.writeLine(person + " lives in " + city);
}</programlisting>
            
            <para>(Note that the <literal>-&gt;</literal> symbol here isn't
            really the entry construction operator we saw above. In this case it's
            actually part of the syntax of the <literal>for</literal> loop.)</para>
            
            <para>A <literal>List</literal> is the most important kind of 
            <literal>Sequence</literal>. We usually add entries to an 
            <literal>OpenList</literal> using the <literal>append()</literal> 
            method:</para>
            
            <programlisting><![CDATA[OpenList<String> voyage = none;
voyage.append("Melbourne");
voyage.append("San Francisco");
voyage.append("Atlanta);]]></programlisting>
            
            <para>It's even possible to add multiple elements at once:</para>
            
            <programlisting><![CDATA[OpenList<String> voyage = none;
voyage.append("Melbourne", "San Francisco", "Atlanta");]]></programlisting>

            <para>We can also change the value at a particular index in an 
            <literal>OpenList</literal>:</para>
            
            <programlisting><![CDATA[voyage[1] := "Los Angeles";]]></programlisting>
            
            <para>Finally, <literal>Set</literal> represents the most important kind
            of collection in mathematics. The most important thing we can do with
            a <literal>Set</literal> is ask if an object belongs to it. We usually
            use the <literal>in</literal> operator, since <literal>Set</literal>, 
            like all collections, is a suptype of <literal>Category</literal>:</para>
            
            <programlisting>Set&lt;String&gt; names = ... ;
if ("gavin" in names) { ... }</programlisting>
            
            <para>We usually add entries to an <literal>OpenSet</literal> using the
            <literal>add()</literal> method.</para>
            
            <programlisting><![CDATA[OpenSet<String> names = none;
names.add("Gavin");
names.add("Andrew");]]></programlisting>
            
            <para>It's possible to add multiple elements at once:</para>
            
            <programlisting><![CDATA[OpenList<String> names = none;
names.add("Gavin", "Andrew");]]></programlisting>
            
            <para>Set union and intersection closely resemble bitwise or and bitwise and. 
            Therefore, Ceylon generalizes the traditional bitwise operators to 
            <literal>Set</literal>s.</para>
            
            <programlisting>Set&lt;String&gt; someSet = ... ;
Set&lt;String&gt; someOtherSet = ... ;
Set&lt;String&gt; union = someSet | someOtherSet;
Set&lt;String&gt; intersection = someSet &amp; someOtherSet;
Set&lt;String&gt; complement = someSet ~ someOtherSet;</programlisting>
                        
        </section>
        
        <section>
            <title>Understanding first-class functions</title>
            
            <para>Ceylon isn't a functional language: it has variable locals and mutable 
            attributes and so methods can have side effects. But Ceylon does let you use 
            functions as values, which makes the language a kind of hybrid of the functional 
            and procedural. There's nothing very new about this idea&mdash;Smalltalk, one of 
            the first and still one of the cleanest object oriented languages, was the same kind 
            of hybrid. Ceylon, like Smalltalk and a number of other object oriented languages, 
            lets you treat a function as an object and pass it around the system. Unlike most 
            of these languages, Ceylon doesn't have a special syntax for declaring anonymous 
            functions (often called lambda expressions). Instead, Ceylon has something else, 
            which is just as good, but fits more cleanly with a traditional C-like syntax.</para>
            
            <para>Before we get to that, first, let's see how we can define:</para> 
            
            <itemizedlist>
                <listitem>
                    <para>a method which accepts a function as a parameter, and then</para>
                </listitem>
                <listitem>
                    <para>a method which returns a function.</para>
                </listitem>
            </itemizedlist>
            
            <para>Suppose we have some kind of user interface component which can be 
            observed by other objects in the system. We could use something like Java's
            <literal>Observer</literal>/<literal>Observable</literal> pattern:</para>
            
            <programlisting>shared interface Observer {
    shared formal void observe(Event event);
}</programlisting>
            
            <programlisting>shared abstract class Component() {
            
    OpenList&lt;Observer&gt; observers = none;
    
    shared void addObserver(Observer o) {
        observers.append(o);
    }
    
    shared void fire(Event event) {
        for (Observer o in observers) {
            o.observe(event);
        }
    }
    
}</programlisting>
            
            <para>But now all event observers have to implement the interface 
            <literal>Observer</literal>, which has just one method. Why don't
            we cut out the interface, and let event observers just register a
            function object as their event listener? In the following code,
            we define the <literal>addObserver()</literal> method to accept
            a function as a parameter.</para>

            <programlisting>shared abstract class Component() {
            
    OpenList&lt;Callable&lt;Void,Event&gt;&gt; observers = none;
    
    shared void addObserver(void observe(Event event)) {
        observers.append(observe);
    }
    
    shared void fire(Event event) {
        for (void observe(Event event) in observers) {
            observe(event);
        }
    }
    
}</programlisting>

            <para>In this example, we can see two different ways of specifying
            the type of the function:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>void observe(Event event)</literal> is more
                    readable in parameter lists, where <literal>observe</literal>
                    is the name of the parameter, but</para>
                </listitem>
                <listitem>
                    <para><literal>Callable&lt;Void,Event&gt;</literal> is useful
                    as a generic type argument.</para>
                </listitem>
            </itemizedlist>
            
            <para>Now, any event observer can just pass a reference to one of its
            own methods to <literal>addObserver()</literal>:</para>
            
            <programlisting>shared class Listener(Component component) {
    
    void onEvent(Event e) {
        //respond to the event
        ...
    }
    
    component.addObserver(onEvent);
    
    ...
    
}</programlisting>

            <para>When the name of a method appears in an expression without a
            list of arguments after it, it is a <emphasis>reference</emphasis> to
            the method, not an invocation of the method. Here, the expression
            <literal>onEvent</literal> is an expression of type 
            <literal>Callable&lt;Void,Event&gt;</literal> that refers to the
            method <literal>onEvent()</literal>.</para>
            
            <para>It's also possible to declare a method that returns a function.
            A method that returns a function has multiple parameter lists. The 
            following method returns a function which increments its argument by 
            <literal>n</literal>:</para>
            
            <programlisting>Natural incrementor(Natural n)(Natural arg) {
    Natural increment(Natural arg) {
        return n+arg
    }
    return increment
}</programlisting>

            <para>Here, we define a method <literal>increment()</literal> inside
            the body of the <literal>incrementor()</literal> method, and return
            a reference to the inner method from the outer method. The inner method, 
            <literal>increment()</literal> can't be called directly from outside 
            the body of the <literal>incrementor()</literal> method, since it is a 
            block local declaration. But the reference to 
            <literal>increment()</literal> returned by <literal>incrementor()</literal>
            can be called by any code that obtains the reference.</para>

            <para>Notice that <literal>increment()</literal> is able to use the 
            parameter <literal>n</literal> of <literal>incrementor()</literal>. 
            We say that the inner method receives a closure of the 
            non-<literal>variable</literal> locals and parameters of the outer 
            method&mdash;just like a method of a class receives a closure of the
            class initialization parameters and non-<literal>variable</literal> 
            locals of the class initializer. In general, any inner class, method, 
            or attribute declaration always receives the closure of the 
            non-<literal>variable</literal> values of the class, method, or attribute 
            declaration in which it is enclosed. This is an example of how regular
            the language is.</para>
            
            <para>We could invoke our method like this:</para>
            
            <programlisting>Natural five = incrementor(3)(2);</programlisting>
            
            <para>But if we were planning to use the method in this way, there 
            would be no good reason for giving it two parameter lists. It's much 
            more likely that we're planning to store or pass the reference to the 
            inner method somewhere before invoking it.</para>

            <programlisting>Natural add3(Natural arg) = incrementor(3);
Natural five = add3(2);</programlisting>

            <para>The first line demonstrates how a method can be defined using
            a <literal>=</literal> specification statement, just like a simple 
            attribute definition. The second line of code simply invokes the returned 
            reference to <literal>increment()</literal>.</para> 
            
            <para>We've already seen how an attribute can be defined using a block of 
            code. Now we see that a method can be defined using a specifier. So, if 
            you like, you can start thinking of a method as an attribute of type 
            <literal>Callable</literal>&mdash;an attribute with parameters. Or if you 
            prefer, you can think of an attribute as member with zero parameter lists, 
            and of a method as a member with one or more parameter lists. Either kind 
            of member can be defined by reference, using <literal>=</literal>, or 
            directly, by specifying a block of code to be executed.</para>
                        
            <para>There are two alternative, shorter ways to write the 
            <literal>incrementor()</literal> function. Here's the first 
            alternative:</para>
            
            <programlisting>Natural incrementor(Natural n)(Natural arg) {
    return n.plus
}</programlisting>

            <para>In this case, we simply return a reference to the <literal>plus()</literal>
            method of the <literal>Natural</literal> instance <literal>n</literal>. This 
            method accepts a single parameter of type <literal>Natural</literal> and 
            returns a <literal>Natural</literal>, so its type is compatible with the
            return type of <literal>incrementor()</literal>&mdash;that is to say, its
            type is <literal>Callable&lt;Natural,Natural&gt;</literal>. In case you're
            wondering, the type of the method <literal>incrementor()</literal> is
            <literal>Callable&lt;Callable&lt;Natural,Natural&gt;,Natural&gt;</literal>.</para>

            <para>And here's the second alternative:</para>

            <programlisting>Natural incrementor(Natural n)(Natural arg) {
    return n+arg
}</programlisting>

            <para>In this case, the compiler does the job of automatically inferring 
            the definition of the inner method named <literal>increment()</literal>
            above. The body of the method is not executed until the second argument
            list has been specified&mdash;that is, until the returned function is
            invoked.</para>
            
            <!-- 
            <para>Finally, here's a third alternative, that makes use of a built-in
            extension to "curry" the first parameter of a method:</para>
            
            <programlisting>Natural add(Natural n, Natural m) {
    return n+m
}

Natural inc(Natural arg) = add.partial(3);</programlisting>
            -->
            
            <para>As you've probably noticed, all the functions we've defined so far 
            have been declared with a name, using a traditional C-like syntax. Now 
            let's see what Ceylon has instead of anonymous functions.</para>
            
        </section>

        <section>
            <title>Taking advantage of functional-style programming</title>
        
        <para>Let's go back, once again, to the attribute <literal>greeting</literal> 
        of <literal>Hello</literal>:</para>
        
        <programlisting><![CDATA[shared String greeting {
    if (exists name) {
        return "Hello, " name "!"
    }
    else {
        return "Hello, World!"
    }
}]]></programlisting>

        <para>This definition works well enough, but it's quite procedural, with two 
        <literal>return</literal> statements. That's not usually considered good style 
        in Ceylon, though there are certainly times when it's necessary. Instead, Ceylon 
        lets you write code like this using a more functional style.</para>
        
        <para>In procedural programming we usually pass a list of values to a method, 
        which performs computations using those values, and returns another value. In 
        functional programming, we can pass an operation to a method, which calls our
        operation, and returns a value, or, perhaps, a different operation.</para>
        
        <para>For example, the Ceylon standard librares define a method called
        <literal>with()</literal> that accepts an <literal>Optional</literal> value and 
        two functions. (A method parameter that accepts a function is called a 
        <emphasis>callable parameter</emphasis>.) If the first value is not null, 
        <literal>with()</literal> invokes the first function. Otherwise, 
        <literal>with()</literal> invokes the second function. We can use 
        <literal>with()</literal> to rewrite <literal>greeting</literal>:</para>

<programlisting><![CDATA[shared String greeting {
    String helloName() { return "Hello, " name "!" }
    String helloWorld() { return "Hello, World!" }
    return with(name, helloName, helloWorld)
}]]></programlisting>

        <para>Well, that's certainly more functional, but it's also a lot more verbose. 
        But this is not the way <literal>with()</literal> is really intended to be
        used. Ceylon provides a special method argument syntax for defining a method 
        that is passed to another method inline, as part of the invocation. An inline 
        method definition is called an <emphasis>inline callable argument</emphasis>. 
        Inline callable arguments follow the normal parenthesized argument list.</para>
        
        <para>As a first step, we could rewrite <literal>greeting</literal> as follows, 
        to make it really clear that we're defining methods that are passed as arguments 
        to the callable parameters <literal>then</literal> and 
        <literal>otherwise</literal>.</para>

<programlisting><![CDATA[shared String greeting {
    return with (name)
        //first inline callable argument
        then () {
            return "Hello, " name "!"
        }
        //second inline callable argument
        otherwise () {
            return "Hello, World!"
        }
}]]></programlisting>

        <para>Note that there are three <literal>return</literal> statements here. The 
        nested <literal>return</literal> statements specify the return values of the two 
        inline methods. They do not end the execution of <literal>greeting</literal>!</para>

        <para>This syntax was chosen to make it possible to define new control structures 
        that closely mimic the syntactic form of the traditional C-style built-in control 
        structures.</para>
        
        <para>Usually, we would abbreviate the above code by:</para>
        
        <itemizedlist>
            <listitem>
                <para>eliminating the empty parameter lists&mdash;we can leave off the 
                <literal>()</literal>, and</para>
            </listitem>
            <listitem>
                <para>specifying the method return values in parentheses, instead of 
                writing <literal>return</literal> statements surrounded by 
                braces&mdash;we're allowed to write <literal>("Hello, World!")</literal> 
                instead of <literal>{ return "Hello, World!" }</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The abbreviated code looks like this:</para>

<programlisting><![CDATA[shared String greeting {
    return with (name) 
        then ("Hello, " name "!")
        otherwise ("Hello, World!")
}]]></programlisting>
        
        <para>This syntax might look a little unfamiliar at first, but you'll soon get 
        used to it. In Ceylon, we use method invocations with inline callable arguments 
        to express things that are difficult to express without specialized syntax in 
        other languages, for example:</para>
        
        <itemizedlist>
            <listitem>
                <para><emphasis>assertion</emphasis>, such as: 
                <programlisting>assert ("x must be zero") that (x&equals;0.0);</programlisting></para>
            </listitem>
            <listitem><emphasis>conditional expressions</emphasis>, such as:
            <programlisting>return when (x>100.0) then (100.0) otherwise (x)</programlisting>
            </listitem>
            <listitem>
                <para><emphasis>repetition</emphasis>, such as:
                <programlisting>repeat (3) times { stream.writeLine("Hello!"); }</programlisting></para>
            </listitem>
            <listitem>
                <para><emphasis>tabulation</emphasis>, such as:
                <programlisting>Natural[] cubes = list (30) containing (Natural i) (i**3);</programlisting></para>
            </listitem>
            <listitem>
                <para><emphasis>comprehension</emphasis>, such as:
                <programlisting>String[] names = from (people) select (Person p) (p.name);</programlisting></para>
            </listitem>
            <listitem>
                <para><emphasis>quantification</emphasis>, such as:
                <programlisting>Boolean adults = forAll (people) every (Person p) (p.age>=18);</programlisting></para>
            </listitem>
            <listitem>
                <para><emphasis>folds</emphasis>, such as:
                <programlisting>Float total = fold (items, 0.0) 
                using (Float sum, Item item) 
                    (sum + item.quantity*item.product.price);</programlisting></para>
            </listitem>
            <listitem>
                <para>and, finally, coming back to the example from the previous section, 
                <emphasis>callback registration</emphasis>:
                <programlisting>shared class Listener(Component component) {
    component.addObserver() onEvent (Event e) {
        //respond to the event
        ...
    }
    ...
}</programlisting></para>
            </listitem>
        </itemizedlist>
                
        <para>Look at each of these examples, and ask yourself:</para>
        
        <itemizedlist>
            <listitem>
                <para>What is the name of the method that is being called?</para>
            </listitem>
            <listitem>
                <para>Are there any ordinary arguments? Which are they?</para>
            </listitem>
            <listitem>
                <para>Which is the inline callable argument? What is its name?</para>
            </listitem>
            <listitem>
                <para>Are there any parameters of the inline callable argument? 
                What are the parameter names?</para>
            </listitem>
            <listitem>
                <para>Where is the implementation of the inline callable argument?
                What happens when the inline callable argument is invoked?</para>
            </listitem>
        </itemizedlist>
        
        <para>Well, if you thought you were starting to feel comfortable with this new 
        syntax, I've got something extra to throw at you! A method parameter can be 
        declared as an <emphasis>iterator</emphasis> method, which allows us to move 
        the declaration of the parameters of the inline callable arguments. For example, 
        the <literal>ceylon.language</literal> package defines a <literal>from()</literal> 
        method that is intended to be called like this:</para>
        
        <programlisting>String[] names = from (Person p in people) select (p.name) where (p.age>18);</programlisting>
        
        <para>Which is exactly equivalent to, but much more readable than, the
        following:</para>
        
        <programlisting>String[] names = from (people) select (Person p) (p.name) where (Person p) (p.age>18);</programlisting>
        
        <para>We won't go into the details how to declare an iterator method here 
        (it's just a couple of annotations). It's much more important to be able
        to <emphasis>use</emphasis> iterator methods than actually write them
        yourself.</para>
        
        </section>
        
       <section>
           <title>Named arguments revisited</title>
           
           <para>The following classes define a data structure for building
           tables:</para>
           
           <programlisting>class Table(String title, Natural rows, Border border, Column... columns) { ... }
class Column(String heading, Natural width, String content(Natural row)) { ... }
class Border(Natural padding, Natural weight) { ... }</programlisting>
           
           <para>Of course, we could built a <literal>Table</literal> using 
           positional argument lists:</para>
                      
           <programlisting>Table table = Table("Squares", 5, Border(2,1)
        Column("x",10) content (Natural row) ($row), 
        Column("x**2",12) content (Natural row) ($row**2));</programlisting>
           
           <para>(Note the use of inline callable arguments!)</para>
           
           <para>However, it's far more common to use named arguments to build 
           a complex graph of objects. In this section we're going to meet some 
           new features of named argument lists, that make it especially 
           convenient to build object graphs.</para>
           
           <para>First, note that the syntax we've already seen for specifying 
           a named argument value looks exactly like the syntax for refining a 
           <literal>formal</literal> attribute. If you think about it, taking 
           into account that a method parameter may accept references to other 
           methods, the whole problem of specifying values for named parameters 
           starts to look a lot like the problem of refining abstract members. 
           Therefore, Ceylon let's us reuse much of the member declaration syntax 
           inside a named argument list, including:</para>
           
           <itemizedlist>
               <listitem>
                   <para>method declarations&mdash;specify the "value" of a
                   parameter that accepts a method,</para>
               </listitem>    
               <listitem>
                   <para><literal>object</literal> (anonymous class) 
                   declarations&mdash;are most useful for specifing the value 
                   of a parameter whose type is an interface or abstract class,
                   and</para>
               </listitem>    
               <listitem>
                   <para>getter declarations&mdash;let us compute the value of
                   an argument inline.</para>
               </listitem>    
           </itemizedlist>
           
           <para>This helps explain why named argument lists are delimited by
           braces: the fully general syntax for a named argument list is very, 
           very close to the syntax for a class, method, or attribute body.
           Notice, again, how flexibility derives from language regularity.</para>
           
           <para>So we could rewrite the code that builds a <literal>Table</literal>
           as follows:</para>
           
           <programlisting>Table table = Table { 
    title="Squares"; 
    rows=5;
    border = Border {
        padding=2;
        weight=1;
    };
    Column { 
        heading="x"; 
        width=10;
        String content(Natural row) {
            return $row
        }
    }, 
    Column { 
        heading="x**2"; 
        width=12;
        String content(Natural row) {
            return $row**2
        }
    }
};</programlisting>

           <para>Notice that we've specified the value of the parameter named
           <literal>content</literal> using the usual syntax for declaring a
           method.</para>
           
           <para>Even better, our example can be abbreviated like this:</para>
           
           <programlisting>Table table { 
    title="Squares"; 
    rows=5;
    Border border {
        padding=2;
        weight=1;
    }
    Column { 
        title="x"; 
        width=10; 
        String content(Natural row) {
            return $row
        }
    }, 
    Column { 
        title="x**2"; 
        width=10; 
        String content(Natural row) {
            return $row**2
        }
    } 
}</programlisting>
            
            <para>Notice how we've transformed our code from a form which 
            emphasized <emphasis>invocation</emphasis> into a form that 
            emphasizes <emphasis>declaration</emphasis> of a hierarchical
            structure. Semantically, the two forms are equivalent. But in
            terms of readability, they are very different.</para>
            
            <para>We could put the above totally declarative code in a file
            named <literal>table.ceylon</literal> and it would look like
            some kind of domain specific language for defining tables.
            In fact, it's executable Ceylon code that may be validated for
            syntactic correctness by the Ceylon compiler and then compiled 
            to Java bytecode. Even better, any Ceylon IDE provides authoring 
            support for our DSL. In complete contrast to the DSL support 
            in some dynamic languages, any Ceylon DSL is completely 
            typesafe! You can think of the definition of the 
            <literal>Table</literal>, <literal>Column</literal> and 
            <literal>Border</literal> classes as defining the "schema" or
            "grammar" of the DSL. (In fact, they are really defining the 
            syntax tree for the DSL.)</para>
            
            <para>Now let's see an example of a named argument list with 
            an inline getter declaration:</para>
            
            <programlisting>shared class Payment(PaymentMethod method, Currency currency, Float amount) { ... }</programlisting>
            
            <programlisting>Payment payment {
    method = user.paymentMethod;
    currency = order.currency;
    Float amount { 
        variable Float total := 0.0;
        for (Item item in order.items) {
            total += item.quantity * item.product.unitPrice;
        }
        return total
    }
}</programlisting>
            
            <para>Finally, here's an example of a named argument list with 
            an inline <literal>object</literal> declaration:</para>
            
            <programlisting><![CDATA[shared interface Observable {
    shared void addObserver<T>(Observer<T> observer) { ... }
}

shared interface Observer<T> {
    shared formal on(T event);
}]]></programlisting>
            
            <programlisting><![CDATA[observable.addObserver {
    object observer satisfies Observer<UpdateEvent> {
        shared actual void on(UpdateEvent e) {
            log.info("Update:" + $e);
        }
    }
};]]></programlisting>
            
            <para>Of course, as we saw earlier, a better way to solve this 
            problem is to eliminate the <literal>Observer</literal> interface 
            and pass a method directly:</para>
            
            <programlisting><![CDATA[shared interface Observable {
    shared void addObserver<T>(void on(T event)) { ... }
}]]></programlisting>
            
            <programlisting><![CDATA[observable.addObserver {
    void on(UpdateEvent e) {
        log.info("Update:" + $e);
    }
};]]></programlisting>
            
       </section>

        <section>
            <title>Defining user interfaces declaratively</title>

        <para>Let's create a web-based user interface for our greeting
        program. We're going to use the module <literal>ceylon.html</literal>,
        which defines an API for specifying HTML pages as a tree of
        objects.</para>
        
        <para>Of course, we could create a tree of objects as follows:</para>
        
        <programlisting>Html(
    Head('hello.css', "Hello World"),
    Body(
        Div("greeting", "Hello World"),
        Div("footer", "Powered by Ceylon")
    )
)</programlisting>

        <para>But by now you'll realize that a named argument list is a much more 
        natural to define a heirarchical structure like this. We could rewrite
        the expression above as follows:</para>

<!-- 
        <programlisting>Html {
    head = Head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    };
    body = Body {
        Div {
            cssClass = "greeting";
            "Hello World" 
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon" 
        }
    };
}</programlisting>

        <para>Or, even better, we could further simplify the syntax to the 
        following:</para>
-->

        <programlisting>Html {
    Head head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    }
    Body body {
        Div {
            cssClass = "greeting";
            "Hello World" 
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon" 
        }
    }
}</programlisting>

        <para>We're going to use this syntax to define the "template" for 
        our web page.</para>
        
        <programlisting><![CDATA[import ceylon.html { ... }

doc "A web page that displays a greeting"
page '/hello.html'
Html hello(Request request) {
    
    Head head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    }
    
    Body body {
        Div {
            cssClass = "greeting";
            Hello( request.parameters["name"] ).greeting
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon"
        }
    }

}]]></programlisting>

        <para>The <literal>page</literal> annotation specifies the URL at which 
        this HTML should be accessible. A single-quoted string literal is used, 
        allowing the format of the URL to be validated at compile time.</para>
        
    </section>
    
    <!--
    <section>
        <title>Defining structured data formats</title>
        
        <comment><para>TODO: I don't like the example used in the following two 
        sections. Need to come up with a better example to use to illustrate
        these ideas.</para></comment>
        
        <para>Let's try and define our own structured data format, to personalize
        our program a little. First, we'll create a class to represent people:</para>
        
        <programlisting>doc "Represents a person"
class Person(String firstName, String lastName, Language lang) {
    shared String firstName = firstName;
    shared String lastName = lastName;
    shared Language language = lang;
}</programlisting>
        
        <para>Now, we'll create an interface which enumerates its cases&mdash;almost 
        exactly like a Java <literal>enum</literal>&mdash;to represent the built-in 
        languages that our program supports.</para>
        
        <programlisting>interface Language of english | french | spanish | italian {}

object english extends Case("English") satisfies Language {}
object french extends Case("French") satisfies Language {}
object spanish extends Case("Spanish") satisfies Language {}
object italian extends Case("Italian") satisfies Language {}</programlisting>

        <para>Now we can define the set of people known to our application like
        this:</para>
        
        <programlisting>Set&lt;Person&gt; people = {
        Person {
            firstName = "Gavin";
            lastName = "King";
            language = english;
        },
        Person {
            firstName = "Emmanuel";
            lastName = "Bernard";
            language = french;
        },
        Person {
            firstName = "Pete";
            lastName = "Muir
            language = english;
        },
        Person {
            firstName = "Andrew";
            lastName = "Haley";
            language = english;
        }
    };</programlisting>
    
        <para>But where should we put our list of people? Well, just for fun, let's
        specify them using an annotation of <literal>Hello</literal>. First we'll 
        need to learn how to define new annotations.</para>
        
    </section>
    
    <section>
        <title>Defining annotations</title>
        
        <para>In Ceylon, an annotation is just a method that produces an ordinary 
        type. An annotation for specifying a set of people could be defined like 
        this:</para>
        
        <programlisting>doc "An annotation for specifying a list of 
     people"
shared annotation {
    of = classes; 
    withType = Greeting;
    occurs = onceEachType; 
}
Set&lt;People&gt; people(Person... people) {
    return HashSet(people)
}</programlisting>

        <para>The meta-annotation <literal>annotation</literal> specifies that this 
        annotation can only occur an the class <literal>Greeting</literal>, and can 
        only occur once.</para>
        
        <para>Ceylon provides a typesafe <emphasis>metamodel</emphasis> for types, 
        classes, interfaces, methods and attributes. This is Ceylon's version of
        Java's reflection API, but it's much, much easier to use and much more 
        powerful. We'll need to use the metamodel to gain access to program element
        annotations at runtime.</para>
        
        <para>We're not going to go into all the details of the metamodel here. All
        you need to know is that in the code we're about to see, the expression 
        <literal>Greeting</literal> evaluates to the metamodel object of type 
        <literal>Class&lt;Greeting&gt;</literal>. We could write:</para>
        
        <programlisting>Class&lt;Greeting&gt; greetingClass = Greeting;</programlisting>
        
        <para>Similarly, the expression <literal>Set&lt;Person&gt;</literal> evaluates 
        to the metamodel object of type <literal>Type&lt;Set&lt;Person&gt;&gt;</literal>.
        We could write:</para>
        
        <programlisting>Type&lt;Set&lt;Person&gt;&gt; personSetType = Set&lt;Person&gt;;</programlisting>

        <para>We obtain the annotations of a program element&mdash;in this case, the 
        class <literal>Greeting</literal>&mdash;using reflection upon the metamodel 
        object that represents the program element. We must specify the type returned by 
        the annotation&mdash;in this case, <literal>Set&lt;People&gt;</literal>&mdash;by 
        passing its metamodel object.</para>
        
        <programlisting>Set&lt;Person&gt;[] annotations = Greeting.annotations(Set&lt;Person&gt;);</programlisting>
        
        <para>Careful, there may be multiple annotations producing the same type of 
        object!</para>
        
        <para>We're already ready to use our new annotation. Just like with other 
        method invocations, we have the choice between specifying the arguments of 
        an annotation using a positional argument list surrounded by parenthesis, 
        or using a named argument list surrounded by braces. In this case, the 
        braces look more visually appealing:</para>
        
        <programlisting>doc "A personalized greeting"
people {
    Person {
        firstName = "Gavin";
        lastName = "King";
        language = english;
    },
    Person {
        firstName = "Emmanuel";
        lastName = "Bernard";
        language = french;
    },
    Person {
        firstName = "Pete";
        lastName = "Muir
        language = english;
    },
    Person {
        firstName = "Andrew";
        lastName = "Haley";
        language = english;
    }
}
class Hello(String? name) {

    doc "The list of people"
    Set&lt;Person&gt; people;
    if (exists Set&lt;Person&gt; annotation = 
            type.annotations(Set&lt;Person&gt;).first) {
        people = annotation;
    }
    else {
        throw Exception("Not annotated people")
    }
    
    doc "The word for \"Hello\" in the given 
         language"
    String word(Language language) {
        switch (language) {
            case (english) { return "Hello" }
            case (spanish) { return "Hola" }
            case (french) { return "Bonjour" }
            case (italian) { return "Ciao" }
        }
    }
    
    doc "The greeting"
    shared String greeting {
        if (exists name) {
            if (exists Person person = 
                    first (Person p in people) 
                        where (p.firstName &equals; name)) {
                return "" word(p.language) ", " 
                       person.firstName " " person.lastName "!"
            }
            else {
                return "Hello, " name "!"
            }
        }
        else {
            return "Hello, World!"
        }
    }
    
    doc "Print the greeting"
    shared void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}</programlisting>
        
    </section>
    -->
    
    <section>
        <title>Defining annotations</title>
        
        <para>We've seen plenty of examples of annotations built into Ceylon.
        Application developers don't often define their own annotations, but
        framework developers do this all the time. Let's see how we could define
        an annotation for declarative transaction management in Ceylon.</para>
        
        <para>In Ceylon, an annotation is just a toplevel method that produces 
        an ordinary type. The method must have the meta-annotation 
        <literal>annotation</literal>.</para>
        
        <programlisting>shared annotation {
    of = methods;
    occurs = onceEachElement; 
}
Transactional transactional(Boolean requiresNew = false) {
    return Transactional(requiresNew)
}</programlisting>
        
        <para>This method simply produces an instance of the class
        <literal>Transactional</literal> that will be attached to the metamodel
        of an annotated method. The meta-annotation specifies that the annotation
        may be applied to methods, and may occur at most once on any method.</para>
        
        <programlisting>shared class Transactional(Boolean requiresNew) {
    shared Boolean requiresNew = requiresNew;
}</programlisting>
        
        <para>Now we can apply our annotation to a method of any class.</para>
        
        <programlisting>shared class OrderManager() {
    shared transactional void createOrder(Order order) { ... }
    ...
}</programlisting>
        
        <para>For annotations with parameters, we might need to specify an
        argument list. As with any other method invocation expression, we have a 
        choice between the use of positional arguments or named arguments. We 
        could specify an explicit argument to the parameter of 
        <literal>transactional</literal> using a positional argument list:</para>
        
        <programlisting>shared transactional (true) 
void createOrder(Order order) { ... }</programlisting>
        
        <para>Alternatively, we could use a named argument list:</para>
        
        <programlisting>shared transactional { requiresNew=true; } 
void createOrder(Order order) { ... }</programlisting>

        <para>Or, as we've previously seen&mdash;check our various examples of the
        <literal>doc</literal> annotation, for example&mdash;when the argument
        of an annotation is a literal value such as a string or numeric literal, 
        we can omit the punctuation entirely.</para>
        
        <para>Annotations are available via the <emphasis>metamodel</emphasis>&mdash;Ceylon's
        typesafe version of Java's reflection API. We're not going to discuss the metamodel 
        in detail here, but here's a quick example of one way we could obtain the annotation 
        of the <literal>createOrder()</literal> method:</para>
        
        <programlisting>if (exists Transactional t = OrderManager.createOrder.annotations(Transactional).first) {
    Boolean requiresNew = t.requiresNew;
    ...
}</programlisting>
        
        <para>Note that:</para>
        
        <itemizedlist>
            <listitem>
                <para>the expression <literal>Transactional</literal> evaluates
                to the metamodel object representing the class&mdash;an instance of 
                <literal>ConcreteClass&lt;Transactional&gt;</literal>, and</para>
            </listitem>
            <listitem>
                <para><literal>OrderManager.createOrder</literal> evaluates to the 
                metamodel object representing the method&mdash;an instance of
                <literal>Method&lt;OrderManager,Void,Order&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>We won't need to use reflection in our example, since Ceylon's
        module architecture includes special built-in support for using annotations 
        to add interceptors to methods.</para>
        
    </section>
    
    <section>
        <title>Interceptors</title>
        
        <para>An <emphasis>interceptor</emphasis> allows frameworks to react to 
        events like method invocations, class instantiations, or attribute 
        evaluations. We don't need to write any special annotation scanning code 
        to make use of interceptors. Ceylon handles this for us at class-loading 
        time.</para>
        
        <para>All we need to do is have our <literal>Transactional</literal>
        class implement the interface <literal>MethodAnnotation</literal>:</para>
        
        <programlisting><![CDATA[shared class Transactional(Boolean requiresNew) 
        satisfies MethodAnnotation {
        
    shared Boolean requiresNew = requiresNew;
    
    doc "This method is called whenever Ceylon loads a class with a method
         annotated |transactional|. It registers a transaction management
         interceptor for the method."
    shared actual void onDefineMethod<X,T,P...>(OpenMethod<X,T,P...> method) {
        method.intercept() 
                onInvoke(X instance, T proceed(P... args), P... args) {
            if (currentTransaction.inProcess || !requiresNew) {
                return proceed(args)
            }
            else {
                currentTransaction.begin();
                try {
                    T result = proceed(args);
                    currentTransaction.commit();
                    return result
                }
                catch (Exception e) {
                    currentTransaction.rollback();
                    throw e
                }
            }
        }
    }
    
}]]></programlisting>
        
        <para>The <literal>intercept()</literal> method of <literal>OpenMethod</literal>
        registers the interceptor&mdash;a kind of callback method. Note that
        we're using the inline callable argument syntax we met earlier to 
        define the callback method as an inline callable argument to the 
        parameter <literal>onInvoke()</literal>.</para>
        
        <para>You're probably 
        not sure quite what to make of the syntax <literal>P...</literal> that 
        appears in this code. Don't worry, we'll get to that later, when we 
        discuss <emphasis>sequenced type parameters</emphasis>.</para>
        
    </section>
    
    <!--  
    <section>
        <title>Reflection and interception</title>
        
        <para>Now we need to define the framework code that makes use of the
        <literal>transactional</literal> annotation. We're going to make use
        of Ceylon's metamodel and demonstrate how reflection and interception
        works in Ceylon.</para>
        
        <para>The first thing we're going to need to know is how to query the
        annotations of a program element at runtime. How can we obtain the
        instance of <literal>Transactional</literal> that the 
        <literal>transaction</literal> annotation attached to an annotated
        method from inside our framework code?</para>
        
        <para>We're going to use the Ceylon metamodel here. This isn't the right
        time to get into the details of Ceylon's typesafe metamodel. All you really
        need to understand right now is that an expression like <literal>Hello</literal> 
        evaluates to the metamodel object representing the class 
        <literal>Hello</literal>&mdash;an instance of 
        <literal>Class&lt;Hello&gt;</literal>.</para>
        
        <para>We can obtain metamodel objects representing the methods of
        <literal>Hello</literal> like this:</para>
        
        <programlisting>UntypedMethod&lt;Hello&gt;[] methods = Hello.untypedMethods(Hello);</programlisting>
        
        <para>We can obtain all instances of <literal>Transactional</literal>
        attached to a method by annotations of the method using the following
        statement:</para>
        
        <programlisting>Transactional[] annotations = method.annotations(Transactional);</programlisting>
        
        <para>Where <literal>method</literal> is a metamodel object representing
        the method.</para>
        
        <para>We're going to perform transaction management using an interceptor
        that gets called whenever any method annotated <literal>transactional</literal>
        is invoked. We have to explicitly register our interceptor with every
        class that has transactional instances. Without further ado, here's a 
        method that registers the interceptors for a class.</para>
        
        <programlisting><![CDATA[shared void addTransactionInterceptor<T>(Class<T> c) {
    //iterate the methods of the class
    for (UntypedMethod<T> m in c.untypedMethods(T)) {
        //let's see if the method is annotated "transactional"
        if ( exists Transactional t = m.annotations(Transactional).first ) {
            class TransactionInterceptor() 
                    satisfies Usable {
                variable Boolean begun:=false;
                shared actual void begin() {
                    if (!currentTransaction.inProcess || t.requiresNew) {
                        currentTransaction.begin();
                        begun:=true;
                    }
                }
                shared actual void end() {
                    if (begun) {
                        currentTransaction.commit();  
                    }
                }
                shared actual void abort(Exception e) {
                    if (begun) {
                        currentTransaction.rollback();
                    }
                }
            }
            //register TransactionInterceptor
            m.use(TransactionInterceptor);
        }
    }
}]]></programlisting>
        
        <para>Because this is completely generic code, it uses the slightly 
        awkward untyped version of the metamodel. If we know more about the
        signature of a method we're intercepting, writing an interceptor
        becomes much easier. For example, suppose that we're only interested
        in action methods in some web framework, and we know that all action
        methods have the following signature:</para>
        
        <programlisting>Result action(Request request, Session session) { .. }</programlisting>
         
        <para>Then the code above could be dramatically simplified:</para>
        
        <programlisting><![CDATA[shared void addTransactionInterceptor<T>(Class<T> c) {
    //iterate the action methods of the class
    for (OpenMethod<T,Result,Request,Session> m 
                in c.openMethods(T,Callable<Result,Request,Session>)) {
        //let's see if the method is annotated "transactional"
        if ( exists Transactional t = m.annotations(Transactional).first ) {
            //register interceptor method
            m.intercept() 
                onInvoke(Object instance, Result proceed(Request r, Session s), Request r, Session s) {
                    if (!currentTransaction.inProcess || t.requiresNew) {
                        currentTransaction.begin();
                        try {
                            Result result = proceed(r,s);
                            currentTransaction.commit();
                            return result
                        }
                        catch (Exception e) {
                            currentTransaction.rollback();
                        }
                    }
                    else {
                        return proceed(r,s)
                    }
                };
        }
    }
}]]></programlisting>
        
    </section>
    -->
    
    <section>
        <title>Defining generic types</title>
    
        <para>Programming with generic types is one of the most difficult parts of
        Java. That's still true, to some extent, in Ceylon. But because the Ceylon
        language and SDK were designed for generics from the ground up, Ceylon is
        able to alleviate the most painful aspects of Java's bolted-on-later model.</para>
        
        <para>Just like in Java, type parameters are listed before ordinary
        parameters, enclosed in angle brackets.</para>
        
        <programlisting>interface Collection&lt;X&gt; { ... }</programlisting>  
        <programlisting>class Array&lt;T&gt;(T... elements) satisfies T[] { ... }</programlisting>
        <programlisting>T[] singleton&lt;T&gt;(T element) { .... }</programlisting>
        
        <para>We usually don't need to explicitly specify type arguments in method
        invocations or class instantiations (the type arguments can very often be 
        inferred from the ordinary arguments), but, unlike Java, we always do need 
        to specify type arguments in a type declaration (there are no raw types in 
        Ceylon).</para>
        
        <programlisting>Array&lt;String&gt; strings = Array("Hello", "World");</programlisting>
        <programlisting>Person[] onlyMe = singleton(me);</programlisting>
        <programlisting>Collection&lt;Order&gt; orders = getOrders();</programlisting>
        
        <para>The root cause of very many problems when working with generic types 
        in Java is <emphasis>type erasure</emphasis>. Generic type parameters and
        arguments are discarded by the compiler, and simply aren't available at 
        runtime. So the following, perfectly sensible, code fragments just wouldn't 
        compile in Java:</para>
        
        <programlisting>if (is List&lt;Person&gt; list) { ... }</programlisting>
        <programlisting>if (is T obj) { ... }</programlisting>
        <programlisting>Type&lt;T&gt; tType = T;</programlisting>
        
        <para>(Where <literal>T</literal> is a generic type parameter.)</para>
        
        <para>You'll be pleased to know that in Ceylon, these three code fragments 
        compile and function as expected. Like Java, the Ceylon compiler performs
        erasure, discarding type parameters from the schema of the generic type.
        But unlike Java, type arguments are <emphasis>reified</emphasis> (available 
        at runtime). Of course, generic type arguments aren't checked for typesafety 
        by the underlying virtual machine at runtime, but type arguments are at least 
        available at runtime to code that wants to make use of them explicitly. You
        can even use reflection to discover the type arguments of an instance of a 
        generic type.</para>
        
        <programlisting>String[] strings = { "Gavin", "Andrew", "Gary" };
Object[] objects = strings;
Type&lt;Object[]&gt; otype = objects.type;
assert() that (otype.arguments.first == String);  //assertion succeeds</programlisting>
                
        <para>Furthermore, Ceylon is able to eliminate one of the bits of Java 
        generics that's really hard to get your head around: wildcard types. 
        Wildcard types were Java's solution to the problem of <emphasis>covariance</emphasis> 
        in a generic type system. Let's first explore the idea of covariance, and 
        then see how Ceylon's solution, copied from Scala, works.</para>
        
    </section>
    
    <section>
        <title>Covariance and contravariance</title>
        
        <para>It all starts with the intuitive expectation that a collection of
        <literal>Geek</literal>s is a collection of <literal>Person</literal>s.
        That's a reasonable intuition, but in procedural languages, where 
        collections can be mutable, it turns out to be incorrect. Consider the
        following possible definition of <literal>Collection</literal>:</para>
        
        <programlisting>shared interface Collection&lt;X&gt; {
    shared formal Iterator&lt;X&gt; iterator();
    shared formal void add(X x);
}</programlisting>

        <para>And let's suppose that <literal>Geek</literal> is a subtype of 
        <literal>Person</literal>.</para>
        
        <para>The intuitive expectation is that the following code should work:</para>
        
        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Collection&lt;Person&gt; people = geeks;   //compiler error
for (Person person in people) { ... }</programlisting>
        
        <para>This code is, frankly, perfectly reasonable taken at face value. Yet
        in both Java and Ceylon, this code results in a compiler error at the 
        second line, where the <literal>Collection&lt;Geek&gt;</literal> is assigned 
        to a <literal>Collection&lt;Person&gt;</literal>. Why? Well, because if we 
        let the assignment through, the following code would also compile:</para>
        
        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Collection&lt;Person&gt; people = geeks;   //compiler error
people.add( Person("Fonzie") );</programlisting>

        <para>We can't let that code by&mdash;Fonzie isn't a <literal>Geek</literal>!</para>
        
        <para>Using big words, we say that <literal>Collection</literal> is
        <emphasis>nonvariant</emphasis> in <literal>X</literal>. Or, when we're not
        trying to impress people with opaque terminology, we say that 
        <literal>Collection</literal> both <emphasis>produces</emphasis>&mdash;via the
        <literal>iterator()</literal> method&mdash;and <emphasis>consumes</emphasis>&mdash;via
        the <literal>add()</literal> method&mdash;instances of <literal>X</literal>.</para>
        
        <para>Here's where Java goes off and dives down a rabbit hole, inventing 
        wildcards to try and squeeze a covariant or contravariant type out of a 
        nonvariant type, but mainly succeeding in thoroughly confusing everybody.
        We're not going to follow Java down the hole.</para>
        
        <para>Instead, we're going to refactor <literal>Collection</literal> into
        a pure producer interface and a pure consumer interface:</para>
        
        <programlisting>shared interface Producer&lt;out X&gt; {
    shared formal Iterator&lt;X&gt; iterator();
}</programlisting>

        <programlisting>shared interface Consumer&lt;in X&gt; {
    shared formal void add(X x);
}</programlisting>

        <para>Notice that we've annotated the type parameters of these interfaces.</para>
        
        <itemizedlist>
            <listitem>
                <para>The <literal>out</literal> annotation specifies that 
                <literal>Producer</literal> is <emphasis>covariant</emphasis>
                in <literal>X</literal>; that it produces instances of 
                <literal>X</literal>, but never consumes instances of 
                <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>The <literal>in</literal> annotation specifies that 
                <literal>Consumer</literal> is <emphasis>contravariant</emphasis>
                in <literal>X</literal>; that it consumes instances of 
                <literal>X</literal>, but never produces instances of 
                <literal>X</literal>.</para>
            </listitem>
        </itemizedlist>
        
        
        <para>The Ceylon compiler validates the schema of the type declaration to 
        ensure that the variance annotations are satisfied. If you try to declare 
        an <literal>add()</literal> method on <literal>Producer</literal>, a
        compilation error results. If you try to declare an <literal>iterate()</literal>
        method on <literal>Consumer</literal>, you get a similar compilation 
        error.</para>
        
        <para>Now, let's see what that buys us:</para>
        
        <itemizedlist>
            <listitem>
        <para>Since <literal>Producer</literal> is covariant in its type parameter
        <literal>X</literal>, and since <literal>Geek</literal> is a subtype 
        of <literal>Person</literal>, Ceylon lets you assign
        <literal>Producer&lt;Geek&gt;</literal> to 
        <literal>Producer&lt;Person&gt;</literal>.</para>
            </listitem>
            <listitem>
        <para>Furthermore, 
        since <literal>Consumer</literal> is contravariant in its type parameter
        <literal>X</literal>, and since <literal>Geek</literal> is a subtype 
        of <literal>Person</literal>, Ceylon lets you assign
        <literal>Consumer&lt;Person&gt;</literal> to 
        <literal>Consumer&lt;Geek&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>We can define our <literal>Collection</literal> interface as a
        mixin of <literal>Producer</literal> with <literal>Consumer</literal>.</para>
        
        <programlisting>shared interface Collection&lt;X&gt; 
        satisfies Producer&lt;X&gt; &amp; Consumer&lt;X&gt; {}</programlisting>
        
        <para>Notice that <literal>Collection</literal> remains nonvariant in
        <literal>X</literal>. If we tried to add a variance annotation to
        <literal>X</literal> in <literal>Collection</literal>, a compile time
        error would result.</para>
        
        <para>Now, the following code finally compiles:</para>

        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Producer&lt;Person&gt; people = geeks;
for (Person person in people) { ... }</programlisting>

        <para>Which matches our original intuition.</para>

        <para>The following code also compiles:</para>
        
        <programlisting>Collection&lt;Person&gt; people = ... ;
Consumer&lt;Geek&gt; geekConsumer = people;
geekConsumer.add( Geek("James Gosling") );</programlisting>

        <para>Which is also intuitively correct&mdash;James is most certainly
        a <literal>Person</literal>!</para>
        
        <para>You're unlikely to spend much time writing your own collection
        classes, since the Ceylon SDK has a powerful collections framework
        built in. But you'll still appreciate Ceylon's approach to covariance
        as a user of the built-in collection types. The collections framework 
        defines two interfaces for each basic kind of collection. For example, 
        there's an interface <literal>List&lt;X&gt;</literal> which represents 
        a read-only view of a list, and is covariant in <literal>X</literal>, 
        and <literal>OpenList&lt;X&gt;</literal>, which represents a mutable 
        list, and is nonvariant in <literal>X</literal>.</para>
        
    </section>
    
    <section>
        <title>Generic type constraints</title>
        
        <para>Very commonly, when we write a parameterized type, we want to be
        able to invoke methods or evaluate attributes upon instances of the
        type parameter. For example, if we were writing a parameterized type
        <literal>Set&lt;T&gt;</literal>, we would need to be able to compare
        instances of <literal>T</literal> using <literal>==</literal> to see if 
        a certain instance of <literal>T</literal> is contained in the
        <literal>Set</literal>. Since <literal>==</literal> is only defined for 
        expressions of type <literal>Equality</literal>, we need some way to 
        assert that <literal>T</literal> is a subtype of 
        <literal>Equality&lt;T&gt;</literal>. This is an example of a
        <emphasis>type constraint</emphasis>&mdash;in fact, it's an example of 
        the most common kind of type constraint, an <emphasis>upper 
        bound</emphasis>.</para>
        
        <programlisting>shared class Set&lt;out T&gt;(T... elements)
        given T satisfies Equality&lt;T&gt; {
    ...
        
    shared Boolean contains(Object obj) {
        if (is T obj) {
            return forAny (T t in bucket(obj.hash)) 
                        some (t==obj)
        }
        else {
            return false
        }
    }

}</programlisting>
        
        <para>A type argument to <literal>T</literal> must be a type that
        extends or implements <literal>Equality&lt;T&gt;</literal>.</para>
        
        <programlisting>Set&lt;String&gt; set = Set("C", "Java", "Ceylon");  //ok</programlisting>
        <programlisting>Set&lt;Character[]&gt; set = Set("C", "Java", "Ceylon"); //compile error</programlisting>

        <para>In Ceylon, a generic type parameter is considered a proper type,
        so a type constraint looks a lot like a class or interface declaration.
        This is another way in which Ceylon is more regular than some other
        C-like languages.</para>
        
        <para>An upper bound lets us call methods and attributes of the bound, 
        but it doesn't let us instantiate new instances of <literal>T</literal>.  
        The second-most common kind of type constraint in Ceylon is an 
        <emphasis>initialization parameter specification</emphasis>.</para>
        
        <programlisting>shared class Factory&lt;out T&gt;() 
        given T(String s) {
        
    shared T produce(String string) {
        return T(string)
    }
    
}</programlisting>

        <para>A type argument to <literal>T</literal> must be a class with a 
        single initialization parameter of type <literal>String</literal>.</para>
        
        <programlisting>Factory&lt;Hello&gt; = Factory&lt;PersonalizedHello&gt;();  //ok</programlisting>
        <programlisting>Factory&lt;Hello&gt; = Factory&lt;DefaultHello&gt;();  //compile error</programlisting>
        
        <para>We've already seen an example of the third kind of type constraint.
        An <emphasis>enumerated type bound</emphasis> constrains the type argument
        to be one of an enumerated list of types. It lets us write an exhaustive 
        <literal>switch</literal> on the type parameter:</para>
        
        <programlisting>T sqrt&lt;T&gt;(T x) 
        given T of Float | Decimal {
    switch (T)
    case (satisfies Float) {
        return sqrtFloat(x)
    }
    case (satisfies Decimal) {
        return sqrtDecimal(x)
    }
}</programlisting>

        <para>Finally, the fourth kind of type constraint, which is much less
        common, and which most people find much more confusing, is a 
        <emphasis>lower bound</emphasis>. A lower bound is the opposite of an 
        upper bound. It says that a type parameter is a supertype of some other 
        type. There's only really one situation where this is useful. Consider 
        adding a <literal>union()</literal> operation to our <literal>Set</literal> 
        interface. We might try the following:</para>
        
        <programlisting>shared class Set&lt;out T&gt;(T... elements)
        given T satisfies Equality&lt;T&gt; {
    ...
    
    shared Set&lt;T&gt; union(Set&lt;T&gt; set) {   //compile error
        return ....
    }
    
}</programlisting>

        <para>This doesn't compile because we can't use the covariant type 
        parameter <literal>T</literal> in the type declaration of a method
        parameter. The following declaration would compile:</para>
        
        <programlisting>shared class Set&lt;out T&gt;(T... elements)
        given T satisfies Equality&lt;T&gt; {
    ...
    
    shared Set&lt;Object&gt; union(Set&lt;Object&gt; set) {
        return ....
    }
    
}</programlisting>
        
        <para>But, unfortunately, we get back a <literal>Set&lt;Object&gt;</literal>
        no matter what kind of set we pass in. A lower bound is the solution
        to our dilemma:</para>
        
        <programlisting>shared class Set&lt;out T&gt;(T... elements)
        given T satisfies Equality&lt;T&gt; {
    ...
    
    shared Set&lt;X&gt; union(Set&lt;X&gt; set) 
            given X abstracts T {
        return ....
    }
    
}</programlisting>
        
        <para>The compiler chooses an appropriate <literal>X</literal> for
        the given argument to <literal>union()</literal>:</para>
        
        <programlisting>Set&lt;String&gt; strings = Set("abc", "xyz") ;
Set&lt;String&gt; moreStrings = Set("foo", "bar", "baz");
Set&lt;String&gt; allTheStrings = strings.union(moreStrings);</programlisting>
        
        <programlisting>Set&lt;Decimal&gt; decimals = Set(1.2.decimal, 3.67.decimal) ;
Set&lt;Float&gt; floats = Set(0.33, 22.0, 6.4);
Set&lt;Number&gt; allTheNumbers = decimals.union(floats);</programlisting>
        
        <programlisting>Set&lt;Hello&gt; hellos = Set( DefaultHello(), PersonalizedHello(name) );
Set&lt;Object&gt; objects = Set("Gavin", 12, `%`, true);
Set&lt;Object&gt; allTheObjects = hellos.union(objects);</programlisting>
        
    </section>
    
    <section>
        <title>Sequenced type parameters</title>
        
            <para>Most static type systems have problems representing the type of a 
            function, because a single generic type parameter can't capture a variable 
            number of parameter types. Other statically typed languages feature a 
            variety of ways of working around this problem, but Ceylon's unique solution 
            is cleaner and ultimately more powerful.</para>
            
            <para>Ceylon, like Java, lets you write a method with a parameter that accepts 
            multiple arguments, for example:</para>
            
            <programlisting>void print(String... strings) {
    for (String s in strings) {
        process.write(s);
    }
    process.writeLine();
}</programlisting>
            
            <para>In Ceylon, we call this a <emphasis>sequenced parameter</emphasis>.</para>
            
            <para>By analogy, a <emphasis>sequenced type parameter</emphasis> is a type 
            parameter that accepts multiple type arguments. A sequenced type paramet is
            written as <literal>P...</literal> in the type parameter list of a generic
            type. Here's how Ceylon represents the type of a function:</para>
            
            <programlisting><![CDATA[shared interface Callable<out R, P...> {
    shared formal R call(P... args);
}]]></programlisting>
            
            <para>For example:</para>
            
            <itemizedlist>
                <listitem>
                    <para>A function which accepts a <literal>String</literal> and returns 
                    a <literal>Decimal</literal> is a 
                    <literal>Callable&lt;Decimal,String&gt;</literal>. Its 
                    <literal>call()</literal> method has the signature 
                    <literal>Decimal call(String arg)</literal>.</para>
                </listitem>
                <listitem>
                    <para>A function which accepts two <literal>Integer</literal>s and 
                    returns an <literal>Integer</literal> is a 
                    <literal>Callable&lt;Integer,Integer,Integer&gt;</literal>. Its 
                    <literal>call()</literal> method has the signature 
                    <literal>Integer call(Integer arg1, Integer arg2)</literal>.</para>
                </listitem>
                <listitem>
                    <para>A <literal>void</literal> function that accepts a sequence of
                    <literal>String</literal>s is a <literal>Callable&lt;Void,String...&gt;</literal>.
                    Its <literal>call()</literal> method has the signature 
                    <literal>void call(String... args)</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Thus, sequenced type parameters let us write types that abstract over 
            methods with arbitrary signatures in a typesafe way.</para>
            
            <para>Going back to our earlier example, we could write:</para>
            
            <programlisting>Hello hello = DefaultHello();
Callable&lt;Void,OutputStream&gt; say = hello.say;
say(stream);</programlisting>
            
            <para>Sequenced type parameters are the foundation of Ceylon's unique 
            statically typesafe metamodel (Ceylon's version of Java's reflection API).
            A metamodel type like <literal>Class</literal> and <literal>Method</literal>
            is a generic type with a sequenced type parameter representing the parameter 
            types of the class or method.</para>
            
            <programlisting>Class&lt;DefaultHello&gt; dh = DefaultHello;</programlisting>
            <programlisting>Class&lt;PersonalizedHello,String&gt; ph = PersonalizedHello;</programlisting>
            <programlisting>Method&lt;Hello,Void,OutputStream&gt; hsay = Hello.say;</programlisting>
            
            <para>We can invoke a <literal>Class</literal> or <literal>Method</literal>
            object (since both types extend <literal>Callable</literal>). The following:</para>
            
            <programlisting>Class&lt;PersonalizedHello,String&gt; ph = PersonalizedHello;
Method&lt;Hello,Void,OutputStream&gt; hsay = Hello.say;
Hello hello = ph("gavin");
void say(OutputStream stream) = hsay(hello);
say(outputStream);</programlisting>

            <para>is equivalent to:</para>
        
            <programlisting>Hello hello = PersonalizedHello("gavin");
void say(OutputStream stream) = hello.say;
say(outputStream);</programlisting>
            
            <para>Thus, we say that Ceylon is a <emphasis>higher-order</emphasis>
            language, since almost any declaration, including classes, interfaces, 
            methods, attributes, locals, and type parameters are values that can
            be passed around.</para>
            
    </section>
    
    <section>
        <title>Introducing a new type to an object</title>
        
        <para>Ceylon doesn't have full multiple inheritance. If you're used to the 
        single-inheritance-with-interfaces model of Java, you'll find yourself 
        pretty much right at home with inheritance in Ceylon.</para>
        
        <para>However, Ceylon does have something else, that's usually almost as
        good as, and often better than, true multiple inheritance. An
        <emphasis>extension</emphasis> adds a type, call an <emphasis>introduced</emphasis>
        type, to an existing type, called the <emphasis>extended</emphasis> type.
        An extension doesn't change the original definition of the extended type,
        and it doesn't affect the internal workings of an object of that type in
        any way. But from the point of view of a client of the object, the object
        now has all the attributes and methods of the introduced type, and is
        assignable to the introduced type.</para>
        
        <para>Let's introduce a type onto every object. Ceylon's
        <literal>Object</literal> class defines an attribute named 
        <literal>log</literal> of type <literal>Log</literal> that you can use
        to log stuff. Usually, you use it like this:</para>
        
        <programlisting>log.debug("Hello, I'm a debug message");</programlisting>
        
        <para>But perhaps you don't like having to type the "<literal>log.</literal>"
        bit every time you write out a log message, and suppose you don't expect
        to ever need methods named <literal>info()</literal>, <literal>error()</literal>
        <literal>warn()</literal> or <literal>debug()</literal> in your application.
        If so, wouldn't it be nice to just write:</para>
        
        <programlisting>debug("Do you think anyone ever reads me?");</programlisting>
        
        <para>Obviously, one way to do this would be to copy and paste all the
        <literal>info()</literal>, <literal>error()</literal>
        <literal>warn()</literal> and <literal>debug()</literal> methods from
        <literal>Log</literal> onto <literal>Object</literal>, and have them
        delegate back to <literal>log</literal>. But we don't like copy/paste
        programming here.</para>
        
        <para>Another way might be to make <literal>Object</literal> extend 
        <literal>Log</literal>, but that way <literal>Log</literal>
        would be the logical root of the Ceylon type system, instead of 
        <literal>Object</literal>. That doesn't feel right.</para>
        
        <para>Instead, we're going to introduce <literal>Log</literal> onto
        <literal>Object</literal> using an extension. If we were able to modify 
        the code of <literal>Object</literal>, this would be as easy as adding 
        an <literal>extension</literal> annotation to the <literal>log</literal>
        attribute like this:</para>
        
        <programlisting>shared extension Log log { ... }</programlisting>
        
        <para>But since <literal>Object</literal> is built into the Ceylon SDK, 
        we don't have control over its code, and so we need to take a different 
        approach. We'll write a toplevel <emphasis>extension method</emphasis>,
        sometimes called a <emphasis>converter</emphasis>:</para>
        
        <programlisting>shared extension Log objectToLog(Object this) { 
    return this.log
}</programlisting>
        
        <para>The extended type is the type of the parameter of the converter.
        The introduced type is the return type of the converter.</para>
        
        <para>Now, we can't just have hundreds of third-party extensions all
        vandalizing <literal>Object</literal> with their own introduced types,
        and polluting the namespace with thousands of introduced methods and
        attributes. So the client code that uses the extension is responsible
        for explicitly activating the extension in the compilation unit where
        it is used. To activate an extension we <literal>import</literal> 
        it, specifying that it is <literal>implicit</literal>.</para>
        
        <programlisting>import com.domain.util { implicit objectToLog }
        
class Hello(String? name) {

    ...
    
    info(greeting);
    
    ...

}</programlisting>

        <para>The compiler automatically inserts a call to <literal>objectToLog()</literal>. 
        So the above code is equivalent to:</para>

        <programlisting>import com.domain.util { objectToLog }
        
class Hello(String? name) {

    ...
    
    if (is Log this) {
        this.info(greeting);
    }
    else {
        objectToLog(this).info(greeting);
    }
    
    ...

}</programlisting>

        <para>A compilation unit that doesn't <literal>implicit</literal>ly 
        import <literal>objectToLog</literal> won't be affected by the 
        extension, and won't be able to call the <literal>info()</literal> 
        method without explicitly invoking the <literal>log</literal> 
        attribute.</para>
        
        <para>In the next sections, we're going to see a two very different 
        applications of extensions.</para>
        
    </section>
    
    <section>
        <title>String interpolation and the format operator</title>
        
        <para>We've already seen a couple of of examples of 
        <emphasis>string interpolation</emphasis>:</para>
        
        <programlisting>"Hello, " name "!"</programlisting>
        
        <para>And of the <emphasis>format operator</emphasis>, the prefix 
        <literal>$</literal>:</para>
        
        <programlisting>stream.writeLine($obj);</programlisting>
        
        <para>You might have wondered earlier exactly what expression types are 
        permitted in an interpolated string or as arguments to the format operator. 
        The answer is that the expression must be of type <literal>Format</literal>.
        The only built-in type that directly implements <literal>Format</literal>
        is <literal>String</literal>. That might seem pretty limiting at first glance.
        After all, shouldn't we at very least be able to use numeric expressings in an 
        interpolated string?</para>
        
        <para>Well, the problem is that we don't always want to use exactly the same
        formatting rules for printing out objects or numeric values. For example, in
        in log and assertion messages, it's normal to represent a null value as the 
        string <literal>"null"</literal>, and a complex object as a list of its named 
        property values. On the other hand, in a HTML page, it probably makes more
        sense to represent a null value as an empty string, and a complex object by 
        its unique business key. Likewise, in many, but not all, contexts it makes
        sense to truncate floating point values to a certain fixed number of decimal
        places.</para>
        
        <para>Therefore, it is normal to define a format in a separate class, for
        example:</para>
        
        <programlisting>shared class FloatFormat(Float float) 
        satisfies Format {
    shared actual String formatted {
        return ... 
    }
}</programlisting>
        
        <para>Now, of course, one option we have is to explicitly wrap each object 
        we're printing out in an instance of the appropriate <literal>Format</literal>.</para>
        
        <programlisting>stream.writeLine("2 / 3 = " + $FloatFormat(2.0/3))</programlisting>
        
        <para>But this gets verbose and boring. So we can define our format as an 
        extension, for example:</para>
        
        <programlisting>shared extension class FloatFormat(Float this) 
        satisfies Format {
    shared actual String formatted {
        return ... 
    }
}</programlisting>
        
        <para>And we can enable the appropriate default format by 
        <literal>import</literal>ing the extension:</para>
        
        <programlisting>import org.mycompany.format { implicit FloatFormat }</programlisting>
        
        <para>And now, when we don't explicitly specify a format, the format defaults
        to the extension format:</para>
        
        <programlisting>stream.writeLine("2 / 3 = " + $(2.0/3))</programlisting>
        
        <para>Ceylon includes a built-in extension, 
        <literal>ceylon.language.util.DebugFormat</literal> that formats any expression 
        assignable to <literal>Object?</literal> to an appropriate representation for 
        log and assertion messages, delegating back to <literal>Object.string</literal>
        for non-null values.</para>
        
    </section>
    
    <section>
        <title>Single quoted literals</title>
        
        <para>Ceylon doesn't have a built-in literal syntax for any of the following 
        types of object commonly encountered in procedural or declarative code:</para>
        
        <itemizedlist>
            <listitem>
                <para>dates, times, and durations,</para>
            </listitem>
            <listitem>
                <para>hexadecimal and binary numbers,</para>
            </listitem>
            <listitem>
                <para>regular expressions,</para>
            </listitem>
            <listitem>
                <para>URLs and URIs,</para>
            </listitem>
            <listitem>
                <para>email addresses, and</para>
            </listitem>
            <listitem>
                <para>cron expressions.</para>
            </listitem>
        </itemizedlist>
        
        <para>All of these are examples of special-purpose "mini-languages" with their
        own parsing and validation rules that are not encoded into the Ceylon compiler.
        In many other programming languages, it is common practice to embed mini-languages
        in strings, resulting in code that can't be validated for syntactic correctness
        at compile time.</para>
        
        <para>In Ceylon, we embed mini-languages using single-quoted literals. For
        example:</para>
        
        <programlisting>Datetime datetime = Datetime('25/03/2005', '12:00 AM PST');</programlisting>
        <programlisting>shared pattern('^\w+@((\w+)\.)+$') variable String emailAddress; </programlisting>
        <programlisting>Button { color = 'FF3B66'; label = "Click me"; }</programlisting>
        <programlisting>A { href = 'http://jboss.org/ceylon'; "Ceylon site" }</programlisting>
        
        <para>A single quoted literal is an expression of type <literal>Quoted</literal>.
        We write an extension to convert an instance of <literal>Quoted</literal> to a
        more semantic type, for example:</para>
        
        <programlisting>shared extension Color hexToColor(Quoted this) { return ... }</programlisting>
        
        <para>The Ceylon compiler treats extensions with the extended type 
        <literal>Quoted</literal> as a very special case. Unlike other extensions, an 
        extension of <literal>Quoted</literal> is called by the compiler at compile time.
        If the extension throws an exception, a compilation error results. Thus, it's 
        possible to validate the syntax of embedded mini-languages are compile-time.</para>
        
        <para>The Ceylon SDK includes built-in support for quoted literals representing
        dates, times, URLs, hexadecimal and binary numbers, and PERL-style regular 
        expressions.</para>
        
    </section>
    
    </section>
    
</chapter>