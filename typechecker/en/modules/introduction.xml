<chapter id="introduction">
    <title>Introduction</title>
    
    <para>
    Ceylon is a statically-typed, general-purpose, object-oriented language
    featuring a syntax similar to Java and C#. Ceylon programs execute in any 
    standard Java Virtual Machine and, like Java, take advantage of the memory 
    management and concurrency features of that environment. The Ceylon 
    compiler is able to compile Ceylon code that calls Java classes or 
    interfaces, and Java code that calls Ceylon classes or interfaces. Ceylon 
    improves upon the Java language and type system to reduce verbosity and 
    increase typesafety compared to Java and C#. Ceylon encourages a more 
    functional style of programming, resulting in code which is easier to 
    reason about, and easier to refactor. Moreover, Ceylon provides its 
    own native SDK as a replacement for the Java platform class libraries.
    </para>
    
    <para>
    Ceylon features a similar inheritance and generic type model to Java. 
    There are no primitive types or arrays in Ceylon, so all values are
    instances of the type hierarchy root <literal>lang.Object</literal>.
    However, the Ceylon compiler is permitted to optimize certain code to 
    take advantage of the better performance of primitive types on the JVM.
    Ceylon does not support Java-style wildcard type parameters. Instead,
    like Scala, a type parameter may be marked as covariant or 
    contravariant by the class or interface that declares the parameter.
    Ceylon supports <emphasis>type aliases</emphasis>, similar to C-style
    <literal>typedef</literal>.
    </para>
    
    <para>
    The Ceylon compiler enforces the traditional Smalltalk naming convention:
    type names begin with an initial uppercase letter, member names and local
    names with an initial lowercase letter or underscore. This innovation 
    allows a much cleaner syntax for program element annotations than the
    syntax found in either Java or C#.
    </para>
    
    <para>
    Ceylon methods are similar to Java methods. Ceylon does not, strictly
    speaking, support first-class function types. However, higher-order
    functions are supported, with minimal extensions to the traditional
    C syntax. A method declaration may specify a <emphasis>functional 
    parameter</emphasis> that accepts references to other methods with a 
    certain signature. The argument of such a functional parameter may be 
    either a reference to a named method declared elsewhere, or a new 
    method defined inline as part of the method invocation. A method may 
    even return method references. Finally, nested method declarations 
    receive a closure of immutable values in the surrounding scope.
    </para>
    
    <para>
    Ceylon does not feature any Java-like constructor declaration and so 
    each Ceylon class has a formal parameter list, and exactly one 
    <emphasis>initializer</emphasis>&mdash;the body of the class. In place
    of constructor overloading, Ceylon allows class names to be overloaded.
    Even better, member classes of a class may be overridden by subclasses.
    Instantiation is therefore a polymorphic operation in Ceylon, eliminating
    the need for factory methods.
    </para>
    
    <para>
    As an alternative to method or class overloading, Ceylon supports method 
    and class initialization parameters with default values. 
    </para>
    
    <para>
    Ceylon classes do not contain fields, in the traditional sense. Instead, 
    Ceylon supports only a higher-level construct: polymorphic 
    <emphasis>attributes</emphasis>, which are similar to C# properties.
    </para>
    
    <para>
    By default, Ceylon classes, attributes and locals are immutable. 
    Mutable classes, attributes and locals must be explicitly declared
    using the <literal>mutable</literal> annotation. An immutable class may 
    not declare <literal>mutable</literal> attributes or extend a 
    <literal>mutable</literal> class. An immutable attribute or local may 
    not be assigned after its initial value is specified.
    </para>
    
    <para>
    By default, Ceylon attributes and locals do not accept null values. 
    Nullable locals and attributes must be explicitly declared using the 
    <literal>optional</literal> annotation. Nullable expressions are not 
    assignable to non-<literal>optional</literal> locals or attributes, 
    except via use of the <literal>if (exists ... )</literal> construct. 
    Thus, the Ceylon compiler is able to detect illegal use of a null value 
    at compile time. Therefore, there is no equivalent to Java's 
    <literal>NullPointerException</literal> in Ceylon.
    </para>
    
    <para>
    Ceylon does not feature C-style typecasts or Java's 
    <literal>instanceof</literal> operator. Instead, the 
    <literal>if (is ... )</literal> and 
    <literal>case (is ... )</literal> constructs may be used to narrow
    the type of an object reference without risk of a 
    <literal>ClassCastException</literal>.
    </para>
    
    <para>
    Ceylon control flow structures are very similar to the traditional 
    constructs found in C, C# and Java. However, inline methods can be 
    used together with a special Smalltalk-style method invocation protocol 
    to achieve more specialized flow control and other more functional-style 
    constructs such as comprehensions.
    </para>
    
    <para>
    Ceylon features a rich set of operators, including most of the operators 
    supported by C and Java. True operator overloading is not supported. 
    However, each operator is defined to act upon a certain class or interface 
    type, allowing application of the operator to any class which extends or 
    implements that type. This is called <emphasis>operator polymorphism</emphasis>.
    </para>
    
    <para>Ceylon's numeric type system is much simpler than C, C# or Java, 
    with exactly five built-in numeric types (compared to eight in Java and
    eleven in C#). The built-in types are classes representing natural numbers, 
    integers, floating point numbers, arbitrary precision integers and 
    arbitrary precision decimals. <literal>Natural</literal>, 
    <literal>Integer</literal> and <literal>Float</literal> values are 64 bit 
    by default, and may be optimized for 32 bit architectures via use of the 
    <literal>small</literal> annotation. <!--Unlike Java and C#, Ceylon features
    language-level support for dates and times.--></para>
    
    <para>
    True open classes are not supported. However, Ceylon supports 
    <emphasis>extensions</emphasis>, which allow addition of methods and 
    interfaces to existing types, and transparent conversion between types, 
    within a textual scope. Extensions only affect the operations provided 
    by a type, not its state. <!--This facility makes it easy for Ceylon code to 
    transparently interoperate and inter-compile with Java code.-->
    </para>
    
    <para>
    Ceylon features an exceptions model inspired by Java and C#. Checked 
    exceptions are not supported.
    </para>
    
    <para>
    Ceylon introduces a set of syntax extensions that support the definition 
    of domain-specific languages and expression of structured data. These 
    extensions include specialized syntax for initializing objects and 
    collections and expressing literal values or user-defined types. The goal 
    of this facility is to replace the use of XML for expressing hierarchical 
    structures such as documents, user interfaces, configuration and serialized 
    data. An especially important application of this facility is Ceylon's 
    built-in support for program element annotations.
    </para>
    
    <para>
    Ceylon provides sophisticated support for meta-programming, including 
    a typesafe metamodel and events. This facility is inspired by similar 
    features found in dynamic languages such as Smalltalk, Python and Ruby, 
    and by the much more complex features found in aspect oriented languages
    like Aspect J. Ceylon does not, however, support aspect oriented
    programming as a language feature.
    </para>
    
    <para>
    Ceylon features language-level package and module constructs, and 
    language-level access control with five levels of visibility for 
    program elements: block local (the default), <literal>private</literal>, 
    <literal>package</literal>, <literal>module</literal> and 
    <literal>public</literal>. There's no equivalent to Java's 
    <literal>protected</literal>.
    </para>
    
    <section>
        <title>Getting started</title>
        
        <para>
        Here's a classic example, implemented in Ceylon:
        </para>
        
        <programlisting>doc "The classic Hello World program"
public void hello(Process process) {
    process.writeLine("Hello, World!");
}</programlisting>

        <para>
        This code defines a Ceylon method named <literal>hello()</literal>
        with a parameter of type <literal>lang.Process</literal>. The 
        method is annotated <literal>public</literal>, which makes it
        accessible to code in other compilation units. When the method is 
        invoked, it calls the <literal>writeLine()</literal> method of the 
        class <literal>Process</literal>. (This method displays its parameter 
        on the console.) The <literal>doc</literal> annotation contains 
        documentation that is included in the output of the Ceylon 
        documentation compiler.
        </para>
        
        <para>
        This improved version of the program takes a name as input from the 
        command line. We have to account for the case where nothing was
        specified at the command line, which gives us an opportunity to
        explore how null values are treated in Ceylon, which is quite 
        different to what you're probably used to in Java or C#.
        </para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    optional String name = process.args.first;
    String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    process.writeLine(greeting);
}]]></programlisting>

        <para>
        The <literal>Process</literal> class has an attribute named 
        <literal>args</literal>, which holds a <literal>List</literal> of the 
        program's command line arguments. The local <literal>name</literal> is 
        initialized with the first of these arguments, if any. This local is 
        annotated <literal>optional</literal> to indicate that it may contain 
        a null value. The <literal>if (exists ...)</literal> control structure 
        is used to initialize the value of the non-<literal>optional</literal> 
        local named <literal>greeting</literal>, interpolating the value of 
        <literal>name</literal> into the message string whenever 
        <literal>name</literal> is not null. Finally, the message is printed
        to the console.
        </para>
        
        <para>Unlike Java, locals, parameters, and attributes that may contain 
        null values must be explicitly declared using the <literal>optional</literal>
        annotation. There's simply no way to assign <literal>null</literal> to
        a local that isn't annotated <literal>optional</literal>. The compiler
        won't let you.</para>
        
        <para>
        Nor will the Ceylon compiler let you do anything "dangerous" with a 
        value declared <literal>optional</literal>&mdash;that is, anything that 
        could cause a <literal>NullPointerException</literal> in 
        Java&mdash;without first checking that the value is not null using 
        <literal>if (exists ... )</literal>.
        </para>
        
        </section>
        
        <section>
            <title>Using objects</title>

        <para>
        Our method now has too many responsibilities, and is not at all reusable. 
        Let's refactor the code. Ceylon is an object oriented language, so we 
        usually write most of our code in <emphasis>classes</emphasis>. A class
        is a type that packages:
        </para>
        
        <itemizedlist>
            <listitem><para>operations&mdash;called <emphasis>methods</emphasis>,</para></listitem>
            <listitem><para>state&mdash;held by <emphasis>attributes</emphasis>, and,</para></listitem>
            <listitem><para>sometimes, other nested types.</para></listitem>
        </itemizedlist>
          
        <para>
        A Ceylon attribute is a bit different to a Java field&mdash;it's more like 
        a getter method, or, sometimes, like a getter and setter method pair. In
        Ceylon, you don't need to go around declaring all your attributes 
        <literal>private</literal> and wrapping them in getter and setter methods.
        Get out of that habit right now!
        </para>
        
        <para>
        Types (interfaces, classes, and aliases) have names that begin with uppercase 
        letters. Members (methods and attributes) and locals have names that begin with 
        lowercase letters. This is the rule you're used to from Java (it's different to, 
        and much prettier than, the naming conventions in C#). Unlike Java, the Ceylon 
        compiler enforces these rules. If you try to write <literal>class hello</literal>
        or <literal>String Name</literal>, you'll get a compilation error.
        </para>
        
        <para>
        Just like in Java or C#, a class defines the accessibility of its members 
        using <emphasis>visibility modifier annotations</emphasis>, allowing the 
        class to hide its internal implementation from clients. Unlike Java, members 
        are hidden from code outside the body of the class <emphasis>by 
        default</emphasis>&mdash;only members with explicit visibility modifiers are
        visible to other toplevel types or methods, other compilation units, other 
        packages, or other modules.
        </para>
        
        <para>Our first version of the <literal>Hello</literal> class has a
        single attribute and a single method, both declared to have 
        <literal>package</literal> visibility, making them accessible to other
        code in the same package:</para>
        
        <programlisting><![CDATA[doc "A personalized greeting"
class Hello(optional String name) {
    
    package String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

        <para>The attribute <literal>greeting</literal> is a <emphasis>simple 
        attribute</emphasis>, very similar to a Java field. Its value is
        initialized immediately after it is declared.</para>
        
        <para>In Ceylon, classes don't have constructors. Instead:</para>
        
        <itemizedlist>
            <listitem>
                <para>the parameters needed to instantiate the class&mdash;the 
                <emphasis>initialization parameters</emphasis>&mdash;are declared 
                directly after the name of the class, and</para>
            </listitem>
            <listitem>
                <para>code to initialize the new instance  of the class&mdash;the 
                <emphasis>class initializer</emphasis>&mdash;goes directly in the 
                body of the class.</para>
            </listitem>
        </itemizedlist>
        
       <para>We could rewrite the attribute <literal>greeting</literal>
        as a <emphasis>getter</emphasis>:</para>

        <programlisting><![CDATA[doc "A personalized greeting"
class Hello(optional String name) {
    
    doc "The greeting"
    package String greeting {
        if (exists name) {
            return "Hello, " name "!"
        }
        else {
            return "Hello, World!"
        }
    }
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

        <para>You might wonder why we're allowed to use the parameter 
        <literal>name</literal> inside the body of the getter of
        <literal>greeting</literal>. Doesn't the parameter go out of scope 
        as soon as the initializer terminates? Well, that's true, but 
        Ceylon is a language with a very strict block structure, and the 
        scope of declarations is governed by that block structure. In this 
        case, the scope of <literal>name</literal> is the whole body of the 
        class, and the definition of <literal>greeting</literal> sits inside 
        that scope, so <literal>greeting</literal> is permitted to access 
        <literal>name</literal>. We've just met our first example of 
        <emphasis>closure</emphasis>, a concept from functional programming. 
        We say that method and attribute definitions receive a closure of 
        immutable values defined in the class body to which they belong.
        That's just a fancy way of obfuscating the idea that 
        <literal>greeting</literal> holds onto the value of 
        <literal>name</literal>, even after the initializer completes.</para>

         
        <para>Oops, I forgot to show you the code that uses <literal>Hello</literal>!</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    Hello(process.args.first).say(process);
}]]></programlisting>
        
        <para>Our rewritten <literal>hello()</literal> method just creates a new instance
        of <literal>Hello</literal>, and invokes <literal>say()</literal>. Ceylon doesn't 
        need a <literal>new</literal> keyword to know when you're instantiating a class. 
        No, we don't know why Java needs it. You'll have to ask James.</para>
        
        <para>I suppose you're worried that if Ceylon classes don't have constructors,
        then they also can't have multiple constructors. Does that mean we can't overload
        the initialization parameter list of a class? Well, not exactly. Ceylon doesn't
        have constructor overloading, but it does have <emphasis>class overloading</emphasis>.
        Believe it or not, Ceylon lets you write multiple classes with the same name! Let's
        overload <literal>Hello</literal>:</para>
        
        <programlisting><![CDATA[doc "A command line greeting"
class Hello(Process process) 
    extends Hello(process.args.first) {}]]></programlisting>
    
        <para>A class can overload second class by extending it and declaring different
        initialization parameters.</para>
        
        <para>Our <literal>hello()</literal> method is now looking <emphasis>really</emphasis>
        simple:</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    Hello(process).say(process);
}]]></programlisting>
        
        </section>
        
        <section>
            <title>Taking advantage of functional-style programming</title>
        
        <para>Let's go back to the attribute <literal>greeting</literal> of
        <literal>Hello</literal>:</para>
        
        <programlisting><![CDATA[package String greeting {
    if (exists name) {
        return "Hello, " name "!"
    }
    else {
        return "Hello, World!"
    }
}]]></programlisting>

        <para>This definition of  works
        well enough, but it's quite procedural, with two <literal>return</literal>
        statements. That's not usually considered good style in Ceylon, though
        there are certainly times when it's necessary. Instead, Ceylon lets you
        write code like this using a more functional style. In procedural
        programming we usually pass a list of values to a method, which performs 
        computations using those values, and returns another value. In functional
        programming, we can pass an operation to a method, which calls our
        operation, and returns a value, or, perhaps, a different operation.</para>
        
        <para>For example, the Ceylon standard librares define a method called
        <literal>ifExists()</literal> that accepts an object and two 
        <emphasis>method references</emphasis>. (A method parameter that accepts 
        a method reference is called a <emphasis>functional parameter</emphasis>.)
        If the object is not null, <literal>ifExists()</literal> invokes the first
        method. Otherwise, <literal>ifExists()</literal> invokes the second method.
        We can use <literal>ifExists()</literal> to rewrite 
        <literal>greeting</literal>:</para>

<programlisting><![CDATA[package String greeting {
    return ifExists(name, helloName, helloWorld)
}

String helloName() {
    return "Hello, " name "!"
}

String helloWorld() {
    return "Hello, World!"
}]]></programlisting>

        <para>Well, that's certainly more functional, but it's also a lot more
        verbose. But this is not the way <literal>ifExists()</literal> is really
        intended to be used. Ceylon provides a special method argument syntax
        for defining a method that is passed to another method, inline, as part
        of the invocation. An inline method definition is called a
        <emphasis>functional argument</emphasis>. Functional arguments follow
        the normal parenthesized argument list.</para>
        
        <para>Using functional arguments, we could write <literal>greeting</literal> 
        as follows, to make it really clear that we are defining methods that are 
        passed as arguments to the functional parameters <literal>then</literal> 
        and <literal>otherwise</literal>.</para>

<programlisting><![CDATA[package String greeting {
    return ifExists(name)
        //inline definition of the first
        //functional argument
        then () {
            return "Hello, " name "!"
        }
        //inline definition of the second
        //functional argument
        otherwise () {
            return "Hello, World!"
        }
}]]></programlisting>

        <para>Usually, however, we would abbreviate the above code by:</para>
        
        <itemizedlist>
            <listitem>
                <para>eliminating the empty formal parameter lists&mdash;we 
                can leave off the <literal>()</literal>, and</para>
            </listitem>
            <listitem>
                <para>specifying the method return values in parentheses, 
                instead of writing <literal>return</literal> statements
                surrounded by braces&mdash;we can write
                <literal>("Hello, World!")</literal> instead of 
                <literal>{ return "Hello, World!" }</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The abbreviated code looks like this:</para>

<programlisting><![CDATA[package String greeting {
    return ifExists(name) 
        then ("Hello, " name "!")
        otherwise ("Hello, World!")
}]]></programlisting>
    
        <para>This syntax was chosen to make it possible to define new
        control structures that closely mimic the syntactic form of the
        traditional C-style built-in control structures.</para>
        
        <para>By the way, there's an even easier way to define 
        <literal>greeting</literal>, using the <literal>?</literal>
        operator.</para>
        
<programlisting><![CDATA[package String greeting {
    return "Hello, " (name ? "World") "!"
}]]></programlisting>
    
        </section>
        
        <section>
            <title>Defining user interfaces declaratively</title>

        <para>Finally, lets create a web-based user interface for our
        program.</para>
        
        <para>We've seen lots of examples of invoking a method or instantiating
        a class using the traditional C-style argument list where arguments are
        surrounded in parentheses and separated by commas. Arguments are matched
        to parameters by their position in the list. Using this syntax, we could
        create a tree of objects as follows:</para>
        
        <programlisting>Html(
    Head('hello.css', "Hello World"),
    Body(
        Div("greeting", "Hello World"),
        Div("footer", "Powered by Ceylon")
    )
)</programlisting>

        <para>However, Ceylon provides an alternative way of writing
        argument lists that makes it much more natural to define heirarchical
        structures. A <emphasis>named argument list</emphasis> is a list of 
        arguments surrounded by braces and separated by semicolons. Varargs 
        parameters in a named argument list don't need names, and are 
        separated by commas. For example:</para>

        <programlisting>Html {
    head = Head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    };
    body = Body {
        Div {
            cssClass = "greeting";
            "Hello World" 
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon" 
        }
    };
}</programlisting>
        
        <para>We're going to use this syntax to define our web page.</para>
        
        <programlisting><![CDATA[import html.*;

doc "A web page that displays a greeting"
page '/hello.html'
class Hello(Request request) 
        extends Html(request) {

    Hello hello = Hello(request.parameters["name"]);
    
    head = Head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    };
    body = Body {
        Div {
            cssClass = "greeting";
            hello.greeting
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon"
        }
    };

}]]></programlisting>

        <para>This program demonstrates Ceylon's support for defining structured 
        data, in this case, HTML. The <literal>Hello</literal> class extends Ceylon's
        <literal>Html</literal> class and initializes its <literal>head</literal> and
        <literal>body</literal> attributes. The <literal>page</literal> annotation 
        specifies the URL at which this HTML should be accessible. A single-quoted
        string literal is used, allowing the format of the URL to be validated by
        the Ceylon compiler.</para>

    </section>
    
</chapter>