<chapter id="introduction">
    <title>Introduction</title>
    
    <para>
    Ceylon is a statically-typed, general-purpose, object-oriented language
    featuring a syntax similar to Java and C#. Ceylon programs execute in any 
    standard Java Virtual Machine and, like Java, take advantage of the memory 
    management and concurrency features of that environment. The Ceylon 
    compiler is able to compile Ceylon code that calls Java classes or 
    interfaces, and Java code that calls Ceylon classes or interfaces. Ceylon 
    improves upon the Java language and type system to reduce verbosity and 
    increase typesafety compared to Java and C#. Ceylon encourages a more 
    functional style of programming, resulting in code which is easier to 
    reason about, and easier to refactor. Moreover, Ceylon provides its 
    own native SDK as a replacement for the Java platform class libraries.
    </para>
    
    <para>
    Ceylon features a similar inheritance and generic type model to Java. 
    There are no primitive types or arrays in Ceylon, so all values are
    instances of the type hierarchy root <literal>lang.Object</literal>.
    However, the Ceylon compiler is permitted to optimize certain code to 
    take advantage of the better performance of primitive types on the JVM.
    Ceylon does not support Java-style wildcard type parameters. Instead,
    like Scala, a type parameter may be marked as covariant or 
    contravariant by the class or interface that declares the parameter.
    Ceylon supports <emphasis>type aliases</emphasis>, similar to C-style
    <literal>typedef</literal>.
    </para>
    
    <para>
    The Ceylon compiler enforces the traditional Smalltalk naming convention:
    type names begin with an initial uppercase letter, member names and local
    names with an initial lowercase letter or underscore. This innovation 
    allows a much cleaner syntax for program element annotations than the
    syntax found in either Java or C#.
    </para>
    
    <para>
    Ceylon methods are similar to Java methods. Ceylon does not, strictly
    speaking, support first-class function types. However, higher-order
    functions are supported, with minimal extensions to the traditional
    C syntax. A method declaration may specify a <emphasis>functional 
    parameter</emphasis> that accepts references to other methods with a 
    certain signature. The argument of such a functional parameter may be 
    either a reference to a named method declared elsewhere, or a new 
    method defined inline as part of the method invocation. A method may 
    even return method references. Finally, nested method declarations 
    receive a closure of immutable values in the surrounding scope.
    </para>
    
    <para>
    Ceylon does not feature any Java-like constructor declaration and so 
    each Ceylon class has a formal parameter list, and exactly one 
    <emphasis>initializer</emphasis>&mdash;the body of the class. In place
    of constructor overloading, Ceylon allows class names to be overloaded.
    Even better, member classes of a class may be overridden by subclasses.
    Instantiation is therefore a polymorphic operation in Ceylon, eliminating
    the need for factory methods.
    </para>
    
    <para>
    As an alternative to method or class overloading, Ceylon supports method 
    and class initialization parameters with default values. 
    </para>
    
    <para>
    Ceylon classes do not contain fields, in the traditional sense. Instead, 
    Ceylon supports only a higher-level construct: polymorphic 
    <emphasis>attributes</emphasis>, which are similar to C# properties.
    </para>
    
    <para>
    By default, Ceylon classes, attributes and locals are immutable. 
    Mutable classes, attributes and locals must be explicitly declared
    using the <literal>mutable</literal> annotation. An immutable class may 
    not declare <literal>mutable</literal> attributes or extend a 
    <literal>mutable</literal> class. An immutable attribute or local may 
    not be assigned after its initial value is specified.
    </para>
    
    <para>
    By default, Ceylon attributes and locals do not accept null values. 
    Nullable locals and attributes must be explicitly declared using the 
    <literal>optional</literal> annotation. Nullable expressions are not 
    assignable to non-<literal>optional</literal> locals or attributes, 
    except via use of the <literal>if (exists ... )</literal> construct. 
    Thus, the Ceylon compiler is able to detect illegal use of a null value 
    at compile time. Therefore, there is no equivalent to Java's 
    <literal>NullPointerException</literal> in Ceylon.
    </para>
    
    <para>
    Ceylon control flow structures are enhanced versions of the traditional 
    constructs found in C, C# and Java. Even better, inline methods can be 
    used together with a special Smalltalk-style method invocation protocol 
    to achieve more specialized flow control and other more functional-style 
    constructs such as comprehensions.
    </para>
    
    <para>
    Ceylon features a rich set of operators, including most of the operators 
    supported by C and Java. True operator overloading is not supported. 
    However, each operator is defined to act upon a certain class or interface 
    type, allowing application of the operator to any class which extends or 
    implements that type. This is called <emphasis>operator polymorphism</emphasis>.
    </para>
    
    <para>Ceylon's numeric type system is much simpler than C, C# or Java, 
    with exactly five built-in numeric types (compared to eight in Java and
    eleven in C#). The built-in types are classes representing natural numbers, 
    integers, floating point numbers, arbitrary precision integers and 
    arbitrary precision decimals. <literal>Natural</literal>, 
    <literal>Integer</literal> and <literal>Float</literal> values are 64 bit 
    by default, and may be optimized for 32 bit architectures via use of the 
    <literal>small</literal> annotation. <!--Unlike Java and C#, Ceylon features
    language-level support for dates and times.--></para>
    
    <para>
    True open classes are not supported. However, Ceylon supports 
    <emphasis>extensions</emphasis>, which allow addition of methods and 
    interfaces to existing types, and transparent conversion between types, 
    within a textual scope. Extensions only affect the operations provided 
    by a type, not its state. <!--This facility makes it easy for Ceylon code to 
    transparently interoperate and inter-compile with Java code.-->
    </para>
    
    <para>
    Ceylon features an exceptions model inspired by Java and C#. Checked 
    exceptions are not supported.
    </para>
    
    <para>
    Ceylon introduces a set of syntax extensions that support the definition 
    of domain-specific languages and expression of structured data. These 
    extensions include specialized syntax for initializing objects and 
    collections and expressing literal values or user-defined types. The goal 
    of this facility is to replace the use of XML for expressing hierarchical 
    structures such as documents, user interfaces, configuration and serialized 
    data. An especially important application of this facility is Ceylon's 
    built-in support for program element annotations.
    </para>
    
    <para>
    Ceylon provides sophisticated support for meta-programming, including 
    a typesafe metamodel and events. This facility is inspired by similar 
    features found in dynamic languages such as Smalltalk, Python and Ruby, 
    and by the much more complex features found in aspect oriented languages
    like Aspect J. Ceylon does not, however, support aspect oriented
    programming as a language feature.
    </para>
    
    <para>
    Ceylon features language-level package and module constructs, and 
    language-level access control with five levels of visibility for 
    program elements: block local (the default), <literal>private</literal>, 
    <literal>package</literal>, <literal>module</literal> and 
    <literal>public</literal>. There's no equivalent to Java's 
    <literal>protected</literal>.
    </para>
    
    <section>
        <title>A simple example</title>
        
        <para>
        Here's a classic example, implemented in Ceylon:
        </para>
        
        <programlisting>doc "The classic Hello World program"
public void hello(Process process) {
    process.writeLine("Hello, World!");
}</programlisting>

        <para>
        This code defines a Ceylon method named <literal>hello()</literal>
        with a parameter of type <literal>lang.Process</literal>. The 
        method is annotated <literal>public</literal>, which makes it
        accessible to code in other compilation units. When the method is 
        invoked, it calls the <literal>writeLine()</literal> method of the 
        class <literal>Process</literal>. (This method displays its parameter 
        on the console.) The <literal>doc</literal> annotation contains 
        documentation that is included in the output of the Ceylon 
        documentation compiler.
        </para>
        
        <para>
        This improved version of the program takes a name as input from the 
        console:
        </para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    optional String name = process.args.first;
    String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    process.writeLine(greeting);
}]]></programlisting>

        <para>
        The <literal>Process</literal> class has an attribute named 
        <literal>args</literal>, which holds a <literal>List</literal> of the 
        program's command line arguments. The local <literal>name</literal> is 
        initialized from these arguments. This local is annotated 
        <literal>optional</literal> to indicate that it may contain a null
        value. The <literal>if (exists ...)</literal> control structure is
        used to initialize the value of the non-<literal>optional</literal> 
        local named <literal>greeting</literal>, interpolating the value of 
        <literal>name</literal> into the message string whenever 
        <literal>name</literal> is not null. Finally, the message is printed
        to the console.
        </para>

        <para>
        The method now has too many responsibilities. Let's refactor the code:
        </para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    Hello(process).say();
}

doc "A personalized greeting"
class Hello(optional String name, OutputStream out) {
    
    doc "The greeting"
    String greeting {
        if (exists name) {
            return "Hello, " name "!"
        }
        else {
            return "Hello, World!"
        }
    }
    
    doc "Print the greeting"
    private void say() { 
        out.writeLine(greeting); 
    }
    
}

doc "A command line greeting"
class Hello(Process process) 
    extends Hello(process.args.first, process) {}

]]></programlisting>

        <para>Here we have two classes named <literal>Hello</literal>. The
        class name is said to be <emphasis>overloaded</emphasis>. One class 
        has two parameters, a string <literal>name</literal>, and an 
        <literal>OutputStream</literal>, that must both be supplied when the 
        class is instantiated. It defines an an attribute, 
        <literal>greeting</literal>, that evaluates to the message, and a 
        method, <literal>say()</literal>, that prints the message. The method 
        <literal>say()</literal> is annotated <literal>private</literal>,
        which makes it accessible to other code in the same compilation unit. 
        The second class extends the first class, and defines just one parameter,
        of type <literal>Process</literal>. The <literal>hello()</literal>
        method instantiates this class, and calls the <literal>say()</literal>
        method it inherits from its superclass.</para>

        <para>Finally, lets rewrite the program as a web page:</para>

        <programlisting><![CDATA[import html.*;

doc "A web page that displays a greeting"
page '/hello.html'
class Hello(Request request) 
        extends Html(request) {

    optional String name = request.parameters["name"];
    
    doc "The greeting"
    String greeting {
        if (exists name) {
            return "Hello, " name "!"
        }
        else {
            return "Hello, World!"
        }
    }
    
    head = Head { title="Hello World"; };
    
    body = Body {
        Div {
            cssClass = "greeting";
            greeting
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon."
        }
    };

}]]></programlisting>

        <para>This program demonstrates Ceylon's support for defining structured 
        data, in this case, HTML. The <literal>Hello</literal> class extends Ceylon's
        <literal>Html</literal> class and initializes its <literal>head</literal> and
        <literal>body</literal> attributes. The <literal>page</literal> annotation 
        specifies the URL at which this HTML should be accessible. A single-quoted
        string literal is used, allowing the format of the URL to be validated by
        the Ceylon compiler.</para>

    </section>
    
</chapter>