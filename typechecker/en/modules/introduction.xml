<chapter id="introduction">
    <title>Introduction</title>
    
    <para>This document defines the syntax and semantics of the Ceylon language.
    The intended audience includes compiler implementors, interested parties
    who wish to contribute to the evolution of the language, and experienced 
    developers seeking a precise definition of language constructs. However, in
    light of the newness of the language, we will begin with an overview of the
    main features of the language and SDK. A brief introduction to programming 
    in the language may be found at the following address:</para>
    
    <programlisting>http://in.relation.to/tag/Introduction+to+Ceylon</programlisting>
    
    <section id="languageoverview">
        <title>Language overview</title>
    
    <para>
    Ceylon is a general-purpose, imperative, statically-typed, block-structured, 
    object-oriented, higher-order language featuring a syntax similar to Java and 
    C#. By <emphasis>statically-typed</emphasis>, we mean that the compiler
    performs type checking, with the help of type annotations that appear in the 
    code. By <emphasis>object-oriented</emphasis>, we mean that the language 
    features a nominative type system where a type is a set of named attributes 
    and operations, and that it supports inheritance and subtype polymorphism. By 
    <emphasis>higher-order</emphasis>, we mean that every named program element
    (every attribute, every operation, and every type) is a value. By 
    <emphasis>block-structured</emphasis>, we mean to say that the language features
    lexical scoping and an extremely regular recursive syntax for declarations and
    statements.
    </para>
    
    <para>
    Ceylon programs execute in any standard Java Virtual Machine and, like Java, 
    take advantage of the memory management and concurrency features of that 
    environment. The Ceylon compiler is able to compile Ceylon code that calls 
    Java classes or interfaces, and Java code that calls Ceylon classes or 
    interfaces. 
    </para>
    
    <para>
    Ceylon improves upon the Java language and type system to reduce verbosity 
    and increase typesafety compared to Java and C#. Ceylon encourages a more 
    functional style of programming, resulting in code which is easier to reason 
    about, and easier to refactor. Moreover, Ceylon provides its own native SDK 
    as a replacement for the Java platform class libraries.
    </para>
    
    <section id="thetypesystem">
    <title>The type system</title>
    
    <para>
    Ceylon features a similar inheritance and generic type model to Java. A type 
    is either a stateless <emphasis>interface</emphasis>, a stateful 
    <emphasis>class</emphasis>, a <emphasis>type parameter</emphasis>, or a 
    <emphasis>union</emphasis> of other types. An interface may satisfy (extend) 
    an arbitrary number of other interfaces. A class may satisfy (implement) an 
    arbitrary number of interfaces and must extend another class. A class or 
    interface may declare type parameters. A type parameter abstracts the 
    definition of a class or interface over all types which can be substituted 
    for the type parameter.
    </para>
    
    <para>
    There are no primitive types or arrays in Ceylon&mdash;every Ceylon type can 
    be represented within the language itself. So all values are instances of the 
    type hierarchy root <literal>Void</literal>, which is a class. However, the 
    Ceylon compiler is permitted to optimize certain code to take advantage of the 
    optimized performance of primitive types on the JVM.
    </para>
    
    <para>
    Interfaces may define concrete members, allowing a restricted form of multiple 
    inheritance ("mixin" inheritance), but may not hold state (references to other 
    objects) or initialization logic, which eliminates the problems traditionally 
    associated with multiple inheritance. Ceylon never performs any kind of 
    "linearization" of the supertypes of a type.
    </para>
    
    <para>
    Ceylon does not feature enumerated types as a first-class construct. Instead,
    any abstract type may specify its <emphasis>cases</emphasis>&mdash;an 
    enumerated list of subtypes. This facility may be used to simulate both
    enumerated types and functional-style algebraic data types.  
    </para>
    
    <para>
    Ceylon does not support Java-style wildcard type parameters, raw types, or
    any other kind of existential type. Instead, a type parameter may be marked 
    as covariant or contravariant by the class or interface that declares the 
    parameter. Type arguments are reified in Ceylon, eliminating many problems 
    related to type erasure in Java. Ceylon also supports <!--parameterization 
    of type parameters (a form of higher-order polymorphism), and--> a more 
    expressive system of generic type constraints.
    </para>
    
    </section>
    
    <section id="adhocuniontypes">
    <title>Union types</title>

    <para>
    A <emphasis>union type</emphasis>, for example <literal>String|Number</literal>, 
    may be formed from two or more types defined elsewhere. Union types make it 
    possible to write code that operates polymorphically over types defined in 
    disparate branches of the type heirarchy without the need for intermediate 
    adaptor classes.
    </para>
    
    <para>
    Unions are used to define <emphasis>optional</emphasis> types&mdash;which 
    accept null values&mdash;and <emphasis>sequence types</emphasis>&mdash;which 
    accept multiple values. Union types also play a central role in generic type 
    argument inference.
    </para>
    
    </section>
    
    <section id="typealiases">   
    <title>Type aliases and type inference</title>
    
    <para>
    Ceylon supports <emphasis>type aliases</emphasis>, similar to C-style 
    <literal>typedef</literal>, and type inference for local declarations. 
    Type aliases and type inference help reduce the verbosity of code which 
    uses generic types, eliminating the need to repeatedly specify generic
    type arguments.
    </para>
    
    <para>
    By limiting type inference to local declarations, Ceylon ensures that
    all types may be inferred by the compiler in a single pass of the source 
    code. Type inference works in the "forward" and "outward" directions. 
    Every expression has a decideable type without the need to consider the 
    rest of the statement or declaration in which it appears.
    </para>
    
    </section>
    
    <section id="lexicalmixin">
    <title>Introductions</title>
    
    <para>
    Ceylon doesn't have open classes or any kind of implicit type conversion.
    Instead, Ceylon features lexically-scoped <emphasis>introduction</emphasis>
    of interfaces&mdash;a much more powerful cousin of the notion of extension 
    methods.
    </para>
    
    <para>
    Usually, the interfaces inherited by a type are specified as part of the 
    type definition. But a special kind of interface, called an 
    <emphasis>adapter</emphasis> may be <emphasis>introduced</emphasis> 
    ("mixed in") to a pre-existing type at the point of use. Introduction does 
    not in any way affect the internal behavior of any instance of the type to 
    which the interface is introduced, but does allows the type to be treated 
    as a subtype of the introduced interface within the lexical scope of the 
    introduction.
    </para>
    
    </section>
    
    <section id="compilerenforcednamingconventions">
    <title>Compiler-enforced naming conventions</title>
    
    <para>
    The Ceylon compiler enforces the traditional Smalltalk naming convention:
    type names begin with an initial uppercase letter&mdash;for example, 
    <literal>Liberty</literal> or <literal>RedWine</literal>&mdash;member names 
    and local names with an initial lowercase letter or underscore&mdash;for
    example, <literal>blonde</literal>, <literal>immanentize()</literal> or 
    <literal>boldlyGo()</literal>. This innovation allows a much cleaner syntax 
    for program element annotations than the syntax found in either Java or C#.
    </para>
    
    </section>
    
    <section id="initializationandinstantiation">
    <title>Class initialization and instantiation</title>
    
    <para>
    Ceylon does not feature any Java-like constructor declaration and so each 
    Ceylon class has a parameter list, and exactly one 
    <emphasis>initializer</emphasis>&mdash;the body of the class. This helps
    reduce verbosity and results in a more regular block structure.
    </para>
    
    <para>The Ceylon compiler guarantees that the value of any attribute of
    a class is initialized before it is used in an expression.</para>
    
    <para>
    <!--In place of constructor overloading, Ceylon allows class names to be 
    overloaded. Even better,--> A member class of a class may be refined
    (overridden) by a subclass of the class. Instantiation is therefore a 
    polymorphic operation in Ceylon, eliminating the need for factory methods.
    </para>
    
    <para>
    Ceylon provides a streamlined syntax for defining an anonymous class which 
    is only instantiated in exactly the place it is defined. Among other uses,
    the <literal>object</literal> declaration is useful for creating singleton 
    objects or method-local interface implementations. 
    </para>
    
    </section>
    
   <section id="methodsandattributes">
    <title>Methods and attributes</title>
    
    <para>
    Ceylon types have members: <emphasis>methods</emphasis> and 
    <emphasis>attributes</emphasis>. Ceylon methods are similar to Java methods. 
    However, Ceylon classes do not contain fields, at least not in the 
    traditional sense. Instead, Ceylon supports only a higher-level construct: 
    polymorphic attributes, which are similar to C# properties. Attributes 
    abstract the internal representation of the state of an object. An attribute 
    of a class may be refined (overridden) by a subclass of the class.
    </para>
    
    <para>The Ceylon compiler guarantees that the value of any local declared in 
    the body of a method or attribute is initialized before it is used in an 
    expression.</para>
    
    <para>
    Ceylon does not support method overloading. Each method of a type has a 
    distinct name.
    </para>
    
    <para>There are no <literal>static</literal> members. Instead, 
    <emphasis>toplevel</emphasis> methods and attributes are declared as direct 
    members of a package. This, along with certain other features, gives the 
    language a more regular block structure.
    </para>

    </section>
    
    <section id="defaultparameters">
    <title>Defaulted parameters and sequenced parameters</title>
    
    <para>
    Instead of method and constructor overloading, Ceylon supports parameters 
    with default values and <emphasis>sequenced</emphasis> ("varargs") 
    parameters. Furthermore, a generic method may be used to emulate parameter
    type overloading. Therefore, a single method in Ceylon may emulate the 
    signatures of several overloaded methods in Java. 
    </para>
    
    </section>
    
    <section id="firstclassfunctions">
    <title>First-class functions and higher-order programming</title>
    
    <para>
    Ceylon supports first-class function types and higher-order functions, 
    with minimal extensions to the traditional C syntax. A method declaration 
    may specify a <emphasis>callable parameter</emphasis> that accepts 
    references to other methods with a certain signature. The argument of such 
    a callable parameter may be either a reference to a named method declared 
    elsewhere, or a new method defined inline as part of the method invocation. 
    A method may even return an invocable reference to another method. Finally, 
    nested method declarations receive a closure of immutable references defined 
    in the surrounding scope.
    </para>
    
    </section>
    
    <!--
    <section id="lazyevaluationpassbyreference">
    <title>Lazy evaluation and pass by reference</title>
    
    <para>
    Using a "trick" in the Ceylon type system, it's possible to take advantage 
    of lazy evaluation of expressions and pass by reference for attributes.
    </para>
    
    </section>
    -->
    
    <section id="immutability">
    <title>Immutability by default</title>
    
    <para>
    By default, an attribute or local may not be assigned a new value after
    its initial value has been specified. Mutable attributes and variable 
    locals must be explicitly declared using the <literal>variable</literal> 
    annotation.
    </para>
    
    </section>
    
    <section id="compiletimesafety">
    <title>Compile-time safety for optional values and type narrowing</title>
    
    <para>
    There is no primitive null in Ceylon, and the null value is not assignable 
    to class or interface types. Only explicit <emphasis>optional types</emphasis>
    accept the null value. An optional type is not assignable to a non-optional 
    type except via use of the special-purpose <literal>if (exists ... )</literal> 
    construct. Thus, the Ceylon compiler is able to detect illegal use of a 
    null value at compile time. Therefore, there is no equivalent to Java's 
    <literal>NullPointerException</literal> in Ceylon.
    </para>
    
    <para>
    Similarly, there are no C-style typecasts in Ceylon. Instead, the 
    <literal>if (is ... )</literal> and <literal>case (is ... )</literal> 
    constructs may be used to narrow the type of an object reference without 
    risk of a <literal>ClassCastException</literal>.
    </para>
    
    </section>
    
    <section id="controlflow">
    <title>Control flow</title>
    
    <para>
    Ceylon's built in control flow structures are very similar to the 
    traditional constructs found in C, C# and Java. However, inline methods 
    can be used together with a special Smalltalk-style method invocation 
    protocol to achieve more specialized flow control and other 
    functional-style constructs such as comprehensions.
    </para>
    
    <para>
    Ceylon features an exceptions model inspired by Java and C#. Checked 
    exceptions are not supported.
    </para>
    
    </section>
    
    <section id="operatorsandoperatorpolymorphism">
    <title>Operators and operator polymorphism</title>
    
    <para>
    Ceylon features a rich set of operators, including most of the operators 
    supported by C and Java. True operator overloading is not supported. 
    However, each operator is defined to act upon a certain class or interface 
    type, allowing application of the operator to any class which extends or 
    satisfies that type. This approach is called <emphasis>operator 
    polymorphism</emphasis>.
    </para>
    
    </section>
    
    <section id="numerictypes">
    <title>Numeric types</title>
    
    <para>Ceylon's numeric type system is much simpler than C, C# or Java, 
    with exactly five built-in numeric types (compared to eight in Java and
    eleven in C#). The built-in types are classes representing natural numbers, 
    integers, floating point numbers, arbitrary precision integers and 
    arbitrary precision decimals. <literal>Natural</literal>, 
    <literal>Integer</literal>, and <literal>Float</literal> values are 64 bit 
    by default, and may be optimized for 32 bit architectures via use of the 
    <literal>small</literal> annotation.</para>
    
    </section>
    
    <!-- 
    <section id="dimensioned types">
    <title>Dimensioned types</title>
    
    <para>Ceylon supports <emphasis>dimensional type parameters</emphasis>,
    allowing types with fixed dimensions such as vectors or matrices to be
    represented within the type system, and enabling compile-time bounds 
    checking of indexing operations.</para>
    
    </section>
    -->
    
    <section id="structureddata">
    <title>User interfaces and structured data</title>
    
    <para>
    Ceylon introduces a set of syntax extensions that support the definition 
    of domain-specific languages and expression of structured data. These 
    extensions include specialized syntax for initializing objects and 
    collections and expressing literal values of user-defined types. The goal 
    of this facility is to replace the use of XML for expressing hierarchical 
    structures such as documents, user interfaces, configuration and serialized 
    data. An especially important application of this facility is Ceylon's 
    built-in support for program element annotations.
    </para>
    
    </section>
    
    <section id="metaprogramming">
    <title>Metaprogramming</title>
    
    <para>
    Ceylon provides sophisticated support for meta-programming, including a 
    typesafe <emphasis>metamodel</emphasis> and <emphasis>events</emphasis>. 
    Generic code may invoke members reflectively and intercept member invocations. 
    This facility is more powerful, and much more typesafe, than reflection in 
    Java.
    </para>
    
    <!--  
    <para>
    An even more powerful feature is <emphasis>metatypes</emphasis>&mdash;a
    type definition may introduce a user-defined interface to its metamodel,
    allowing a form of generic programing with polymorphic abstraction at the 
    meta level. This facility is an object-oriented flavor of the notion of 
    "type classes" in Haskell.
    </para>
    -->
    </section>
    
    <section id="modularity">
    <title>Modularity</title>
    
    <para>
    Ceylon features language-level <emphasis>package</emphasis> and 
    <emphasis>module</emphasis> constructs, along with language-level access 
    control via the <literal>shared</literal> annotation which can be used to 
    express block-local, package-private, module-private, and public visibility 
    for program elements. There's no equivalent to Java's <literal>protected</literal>.
    </para>
    
    </section>
    
    </section>
    
    <section id="sdkmodules">
        <title>Modules included in the SDK</title>
    
    <para>The Ceylon SDK includes the following important modules:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>ceylon.language</literal> - basic types provided to support
            built-in language features</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.module</literal> - the module runtime (based on
            JBoss Modules)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.collection</literal> - the collections framework
            (with the underlying implementation provided by the Java collections
            framework)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.datetime</literal> - support for representing
            dates and times (based on JSR-310)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.security</literal> - the security API</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.io</literal> - the I/O facility (based on 
            <literal>java.io</literal>)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.concurrent</literal> - the concurrency API (based
            on JSR-166)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.http</literal> - the HTTP client and server (based 
            on JBoss Netty)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.transaction</literal> - the transaction server (based 
            on JBoss Transactions)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.rdbc</literal> - relational database connectivity 
            (based on JDBC)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.message</literal> - the message server (based 
            on JBoss HornetQ)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.xml</literal> - the XML parser</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.html</literal> - the HTML construction kit</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.compiler</literal> - a compiler for Ceylon source
            code</para>
        </listitem>
    </itemizedlist>
    
    <section id="parsingceylon">
        <title>Parsing and compiling the Ceylon language</title>
        
        <para>The Ceylon language has been shown to be lexable and parseable using 
        a context-free ANTRL grammar with no hand-coded special cases.</para>
        
        <para>Ceylon is a language for the Java Virtual Machine, therefore Ceylon
        programs compile to a set of platform-independent <literal>.class</literal> 
        files that comply with the published specification for the Java class file 
        format.</para>
        
    </section>
    
    </section>
 
    
</chapter>