<chapter id="introduction">
    <title>Introduction</title>
    
    <para>
    Ceylon is a statically-typed, general-purpose, object-oriented language
    featuring a syntax similar to Java and C#. Ceylon programs execute in any 
    standard Java Virtual Machine and, like Java, take advantage of the memory 
    management and concurrency features of that environment. The Ceylon 
    compiler is able to compile Ceylon code that calls Java classes or 
    interfaces, and Java code that calls Ceylon classes or interfaces. Ceylon 
    improves upon the Java language and type system to reduce verbosity and 
    increase typesafety compared to Java and C#. Ceylon encourages a more 
    functional style of programming, resulting in code which is easier to 
    reason about, and easier to refactor. Moreover, Ceylon provides its 
    own native SDK as a replacement for the Java platform class libraries.
    </para>
    
    <para>
    Ceylon features a similar inheritance and generic type model to Java. 
    There are no primitive types or arrays in Ceylon, so all values are
    instances of the type hierarchy root <literal>lang.Object</literal>.
    However, the Ceylon compiler is permitted to optimize certain code to 
    take advantage of the better performance of primitive types on the JVM.
    Ceylon does not support Java-style wildcard type parameters or raw types. 
    Instead, like Scala, a type parameter may be marked as covariant or 
    contravariant by the class or interface that declares the parameter.
    Type arguments are reified in Ceylon, eliminating many problems related
    to type erasure in Java. Ceylon supports <emphasis>type aliases</emphasis>, 
    similar to C-style <literal>typedef</literal>.
    </para>
    
    <para>
    The Ceylon compiler enforces the traditional Smalltalk naming convention:
    type names begin with an initial uppercase letter, member names and local
    names with an initial lowercase letter or underscore. This innovation 
    allows a much cleaner syntax for program element annotations than the
    syntax found in either Java or C#.
    </para>
    
    <para>
    Ceylon methods are similar to Java methods. Ceylon does not, strictly
    speaking, support first-class function types. However, higher-order
    functions are supported, with minimal extensions to the traditional
    C syntax. A method declaration may specify a <emphasis>functional 
    parameter</emphasis> that accepts references to other methods with a 
    certain signature. The argument of such a functional parameter may be 
    either a reference to a named method declared elsewhere, or a new 
    method defined inline as part of the method invocation. A method may 
    even return method references. Finally, nested method declarations 
    receive a closure of immutable values in the surrounding scope.
    </para>
    
    <para>
    Ceylon does not feature any Java-like constructor declaration and so 
    each Ceylon class has a formal parameter list, and exactly one 
    <emphasis>initializer</emphasis>&mdash;the body of the class. In place
    of constructor overloading, Ceylon allows class names to be overloaded.
    Even better, member classes of a class may be overridden by subclasses.
    Instantiation is therefore a polymorphic operation in Ceylon, eliminating
    the need for factory methods.
    </para>
    
    <para>
    As an alternative to method or class overloading, Ceylon supports method 
    and class initialization parameters with default values. 
    </para>
    
    <para>
    Ceylon classes do not contain fields, in the traditional sense. Instead, 
    Ceylon supports only a higher-level construct: polymorphic 
    <emphasis>attributes</emphasis>, which are similar to C# properties.
    </para>
    
    <para>
    By default, Ceylon classes, attributes and locals are immutable. 
    Mutable classes, attributes and locals must be explicitly declared
    using the <literal>mutable</literal> annotation. An immutable class may 
    not declare <literal>mutable</literal> attributes or extend a 
    <literal>mutable</literal> class. An immutable attribute or local may 
    not be assigned after its initial value is specified.
    </para>
    
    <para>
    By default, Ceylon attributes and locals do not accept null values. 
    Optional locals and attributes must be explicitly declared. Optional 
    expressions are not assignable to non-optional locals or attributes, 
    except via use of the <literal>if (exists ... )</literal> construct. 
    Thus, the Ceylon compiler is able to detect illegal use of a null value 
    at compile time. Therefore, there is no equivalent to Java's 
    <literal>NullPointerException</literal> in Ceylon.
    </para>
    
    <para>
    Ceylon does not feature C-style typecasts or Java's 
    <literal>instanceof</literal> operator. Instead, the 
    <literal>if (is ... )</literal> and 
    <literal>case (is ... )</literal> constructs may be used to narrow
    the type of an object reference without risk of a 
    <literal>ClassCastException</literal>.
    </para>
    
    <para>
    Ceylon control flow structures are very similar to the traditional 
    constructs found in C, C# and Java. However, inline methods can be 
    used together with a special Smalltalk-style method invocation protocol 
    to achieve more specialized flow control and other more functional-style 
    constructs such as comprehensions.
    </para>
    
    <para>
    Ceylon features a rich set of operators, including most of the operators 
    supported by C and Java. True operator overloading is not supported. 
    However, each operator is defined to act upon a certain class or interface 
    type, allowing application of the operator to any class which extends or 
    implements that type. This is called <emphasis>operator polymorphism</emphasis>.
    </para>
    
    <para>Ceylon's numeric type system is much simpler than C, C# or Java, 
    with exactly five built-in numeric types (compared to eight in Java and
    eleven in C#). The built-in types are classes representing natural numbers, 
    integers, floating point numbers, arbitrary precision integers and 
    arbitrary precision decimals. <literal>Natural</literal>, 
    <literal>Integer</literal> and <literal>Float</literal> values are 64 bit 
    by default, and may be optimized for 32 bit architectures via use of the 
    <literal>small</literal> annotation. <!--Unlike Java and C#, Ceylon features
    language-level support for dates and times.--></para>
    
    <para>
    True open classes are not supported. However, Ceylon supports 
    <emphasis>extensions</emphasis>, which allow addition of methods and 
    interfaces to existing types, and transparent conversion between types, 
    within a textual scope. Extensions only affect the operations provided 
    by a type, not its state. <!--This facility makes it easy for Ceylon code to 
    transparently interoperate and inter-compile with Java code.-->
    </para>
    
    <para>
    Ceylon features an exceptions model inspired by Java and C#. Checked 
    exceptions are not supported.
    </para>
    
    <para>
    Ceylon introduces a set of syntax extensions that support the definition 
    of domain-specific languages and expression of structured data. These 
    extensions include specialized syntax for initializing objects and 
    collections and expressing literal values or user-defined types. The goal 
    of this facility is to replace the use of XML for expressing hierarchical 
    structures such as documents, user interfaces, configuration and serialized 
    data. An especially important application of this facility is Ceylon's 
    built-in support for program element annotations.
    </para>
    
    <para>
    Ceylon provides sophisticated support for meta-programming, including 
    a typesafe metamodel and events. This facility is inspired by similar 
    features found in dynamic languages such as Smalltalk, Python and Ruby, 
    and by the much more complex features found in aspect oriented languages
    like Aspect J. Ceylon does not, however, support aspect oriented
    programming as a language feature.
    </para>
    
    <para>
    Ceylon features language-level package and module constructs, and 
    language-level access control with five levels of visibility for 
    program elements: block local (the default), <literal>private</literal>, 
    <literal>package</literal>, <literal>module</literal> and 
    <literal>public</literal>. There's no equivalent to Java's 
    <literal>protected</literal>.
    </para>
    
    <section>
        <title>Writing a simple program in Ceylon</title>
        
        <para>
        Here's a classic example, implemented in Ceylon:
        </para>
        
        <programlisting>doc "The classic Hello World program"
public void hello(Process process) {
    process.writeLine("Hello, World!");
}</programlisting>

        <para>
        This code defines a Ceylon method named <literal>hello()</literal>
        with a parameter of type <literal>lang.Process</literal>. The 
        method is annotated <literal>public</literal>, which makes it
        accessible to code in other compilation units. When the method is 
        invoked, it calls the <literal>writeLine()</literal> method of the 
        class <literal>Process</literal>. (This method displays its parameter 
        on the console.) The <literal>doc</literal> annotation contains 
        documentation that is included in the output of the Ceylon 
        documentation compiler.
        </para>
        
        <para>Copy this code into a file named <literal>hello.ceylon</literal>
        and put the file in the <literal>ceylon/source/</literal> directory of 
        your Ceylon SDK installation.</para>
        
        <para>Now, in the <literal>ceylon</literal> directory, run the 
        following command:</para>
        
        <programlisting>ceylon hello</programlisting>
        
        <para>This command compiles the source to bytecode and runs the Java 
        virtual machine. You should see the following output in the console:</para>
        
        <programlisting>Hello World!</programlisting>
        
    </section>
        
    <section>
        <title>Dealing with objects that aren't there</title>
        
        <para>
        This improved version of the program takes a name as input from the 
        command line. We have to account for the case where nothing was
        specified at the command line, which gives us an opportunity to
        explore how null values are treated in Ceylon, which is quite 
        different to what you're probably used to in Java or C#.
        </para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    String? name = process.args.first;
    String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    process.writeLine(greeting);
}]]></programlisting>

        <para>
        The <literal>Process</literal> class has an attribute named 
        <literal>args</literal>, which holds a <literal>List</literal> of the 
        program's command line arguments. The local <literal>name</literal> is 
        initialized with the first of these arguments, if any. This local is 
        declared to have type <literal>String?</literal>, to indicate that it 
        may contain a null value. The <literal>if (exists ...)</literal> control 
        structure is used to initialize the value of the non-null local named 
        <literal>greeting</literal>, interpolating the value of 
        <literal>name</literal> into the message string whenever 
        <literal>name</literal> is not null. Finally, the message is printed
        to the console.
        </para>
        
        <para>Unlike Java, locals, parameters, and attributes that may contain 
        null values must be explicitly declared as being of type 
        <literal>Optional&lt;X&gt;</literal> where <literal>X</literal> is the
        type of value they contain when not holding a null value. Ceylon lets
        us abbreviate the type name <literal>Optional&lt;X&gt;</literal> to
        <literal>X?</literal>. The value <literal>null</literal> is an instance
        of type <literal>Optional&lt;X&gt;</literal>, but it's not an instance 
        of <literal>Object</literal>. So there's simply no way to assign 
        <literal>null</literal> to a local that isn't of type 
        <literal>Optional</literal>. The compiler won't let you.</para>
        
        <para>
        Nor will the Ceylon compiler let you do anything "dangerous" with a 
        value of type <literal>Optional</literal>&mdash;that is, anything that 
        could cause a <literal>NullPointerException</literal> in 
        Java&mdash;without first checking that the value is not null using 
        <literal>if (exists ... )</literal>.
        </para>
        
        <para>If you're worried about the performance implications of wrapping
        values in instances of <literal>Optional</literal>, don't be. 
        <literal>Optional</literal> isn't a <emphasis>reified</emphasis>
        type&mdash;it exists at compile time, when the compiler is validating
        your code for typesafety, but then the compiler eliminates it as part of 
        the compilation process, allowing the resulting bytecode to take advantage 
        of the efficient handling of null values in the virtual machine.</para>
        
        <para>Copy this new version of the program into <literal>hello.ceylon</literal> 
        and run:</para>
        
        <programlisting>ceylon hello everybody</programlisting>
        
        <para>You should see the following output:</para>
        
        <programlisting>Hello everybody!</programlisting>
        
        </section>
        
        <section>
            <title>Creating your own classes</title>

        <para>
        Our method now has too many responsibilities, and is not at all reusable. 
        Let's refactor the code. Ceylon is an object oriented language, so we 
        usually write most of our code in <emphasis>classes</emphasis>. A class
        is a type that packages:
        </para>
        
        <itemizedlist>
            <listitem><para>operations&mdash;called <emphasis>methods</emphasis>,</para></listitem>
            <listitem><para>state&mdash;held by <emphasis>attributes</emphasis>, and,</para></listitem>
            <listitem><para>sometimes, other nested types.</para></listitem>
        </itemizedlist>
          
        <para>
        Types (interfaces, classes, and aliases) have names that begin with uppercase 
        letters. Members (methods and attributes) and locals have names that begin with 
        lowercase letters. This is the rule you're used to from Java (it's different to, 
        and much prettier than, the naming conventions in C#). Unlike Java, the Ceylon 
        compiler enforces these rules. If you try to write <literal>class hello</literal>
        or <literal>String Name</literal>, you'll get a compilation error.
        </para>
        
        <para>
        Just like in Java or C#, a class defines the accessibility of its members 
        using <emphasis>visibility modifier annotations</emphasis>, allowing the 
        class to hide its internal implementation from clients. Unlike Java, members 
        are hidden from code outside the body of the class <emphasis>by 
        default</emphasis>&mdash;only members with explicit visibility modifiers are
        visible to other toplevel types or methods, other compilation units, other 
        packages, or other modules.
        </para>
        
        <para>Our first version of the <literal>Hello</literal> class has a
        single attribute and a single method, both declared to have 
        <literal>package</literal> visibility, making them accessible to other
        code in the same package:</para>
        
        <programlisting><![CDATA[doc "A personalized greeting"
class Hello(String? name) {
    
    doc "The greeting"
    package String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>To understand this code completely, we're going to need to first
            explore the concept of an attribute, and then discuss how object
            initialization works in Ceylon.</para>

        </section>
        
        <section>
            <title>Abstracting state using attributes</title>
            
            <para>The attribute <literal>greeting</literal> is a <emphasis>simple 
            attribute</emphasis>, very similar to a Java field. Its value is
            specified immediately after it is declared. Usually we can declare
            and specify the value of an attribute in a single line of code.</para>
            
            <programlisting>package String greeting = "Hello, " name "!";</programlisting>
        
            <para>An attribute is a bit different to a Java field. It's an abstraction
            of the notion of a value. Some attributes are simple value holders like
            the one we've just seen; others are more like a getter method, or, sometimes, 
            like a getter and setter method pair. Like methods, attributes are 
            polymorphic&mdash;an attribute definition may be overridden by a subclass.</para>
            
            <para>We could rewrite the attribute <literal>greeting</literal> as a 
            <emphasis>getter</emphasis>:</para>

            <programlisting><![CDATA[package String greeting {
    if (exists name) {
        return "Hello, " name "!"
    }
    else {
        return "Hello, World!"
    }
}]]></programlisting>

            <para>Clients of a class never need to know whether the attribute they 
            access holds state directly, or is a getter that derives its value from
            other attributes of the same object or other objects. In Ceylon, you don't 
            need to go around declaring all your attributes <literal>private</literal> 
            and wrapping them in getter and setter methods. Get out of that habit right 
            now!</para>
            
            <para>Ceylon encourages you to use <emphasis>immutable</emphasis> attributes
            as much as possible. An immutable attribute has its value specified when 
            the object is initialized, and is never reassigned. If we want to be able to
            assign a value to a simple attribute we need to annotate it 
            <literal>mutable</literal>:</para>
            
            <programlisting>package mutable String greeting := "Hello World";
if (exists name) {
    greeting := "Hello, " name "!";
}</programlisting>

            <para>Notice the use of <literal>:=</literal> instead of <literal>=</literal>
            here. This is important! In Ceylon, specification of immutable values uses 
            <literal>=</literal>. Assignment to a <literal>mutable</literal> attribute 
            or local is considered a different kind of thing, always performed using the
            <literal>:=</literal> operator.</para>
            
            <para>A getter/setter pair is also a mutable attribute:</para>
            
            <programlisting>mutable String grtng := "Hello World";
package String greeting { return grtng }
private assign greeting { grtng = greeting; }</programlisting>
            

        </section>

        <section>
            <title>Understanding object initialization</title>
        
        <para>In Ceylon, classes don't have constructors. Instead:</para>
        
        <itemizedlist>
            <listitem>
                <para>the parameters needed to instantiate the class&mdash;the 
                <emphasis>initialization parameters</emphasis>&mdash;are declared 
                directly after the name of the class, and</para>
            </listitem>
            <listitem>
                <para>code to initialize the new instance  of the class&mdash;the 
                <emphasis>class initializer</emphasis>&mdash;goes directly in the 
                body of the class.</para>
            </listitem>
        </itemizedlist>
        
        <para>Take a close look at the following code fragment:</para>
        
<programlisting>String greeting;
if (exists name) {
    greeting = "Hello, " name "!";
}
else {
    greeting = "Hello, World!";
}</programlisting>

        <para>In Ceylon, this code could appear in the body of a class, where 
        it would be declaring and specifying the value of an immutable attribute, 
        or it could appear in the body of a method definition, where it would be 
        declaring and specifying the value of an immutable local variable. That's
        not the case in Java, where initialization of fields looks very different
        to initialization of local variables! Thus the syntax of Ceylon is more
        <emphasis>regular</emphasis> than Java. Regularity makes a language easy
        to learn and easy to refactor.</para>
        
        <para>Now let's turn our attention to a different possible implementation
        of <literal>greeting</literal>:</para>
        
        <programlisting><![CDATA[class Hello(String? name) {
    
    package String greeting {
        if (exists name) {
            return "Hello, " name "!"
        }
        else {
            return "Hello, World!"
        }
    }
    
    ...
    
}]]></programlisting>

        <para>You might be wondering why we're allowed to use the parameter 
        <literal>name</literal> inside the body of the getter of
        <literal>greeting</literal>. Doesn't the parameter go out of scope 
        as soon as the initializer terminates? Well, that's true, but 
        Ceylon is a language with a very strict block structure, and the 
        scope of declarations is governed by that block structure. In this 
        case, the scope of <literal>name</literal> is the whole body of the 
        class, and the definition of <literal>greeting</literal> sits inside 
        that scope, so <literal>greeting</literal> is permitted to access 
        <literal>name</literal>.</para>
        
        <para>We've just met our first example of 
        <emphasis>closure</emphasis>, a concept from functional programming. 
        We say that method and attribute definitions receive a closure of 
        immutable values defined in the class body to which they belong.
        That's just a fancy way of obfuscating the idea that 
        <literal>greeting</literal> holds onto the value of 
        <literal>name</literal>, even after the initializer completes.</para>
        
        </section>
        
        <section>
            <title>Instantiating classes and overloading their initialization parameters</title>
         
        <para>Oops, I got so excited about attributes and closure that I forgot to show 
        you the code that uses <literal>Hello</literal>!</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    Hello(process.args.first).say(process);
}]]></programlisting>
        
        <para>Our rewritten <literal>hello()</literal> method just creates a new instance
        of <literal>Hello</literal>, and invokes <literal>say()</literal>. Ceylon doesn't 
        need a <literal>new</literal> keyword to know when you're instantiating a class. 
        No, we don't know why Java needs it. You'll have to ask James.</para>
        
        <para>I suppose you're worried that if Ceylon classes don't have constructors,
        then they also can't have multiple constructors. Does that mean we can't overload
        the initialization parameter list of a class? Well, not exactly. Ceylon doesn't
        have constructor overloading, but it does have <emphasis>class overloading</emphasis>.
        Believe it or not, Ceylon lets you write multiple classes with the same name! Let's
        overload <literal>Hello</literal>:</para>
        
        <programlisting><![CDATA[doc "A command line greeting"
class Hello(Process process) 
    extends Hello(process.args.first) {}]]></programlisting>
    
        <para>A class can overload a second class by extending it and declaring different
        initialization parameters. An overloaded class with an empty body is the Ceylon
        approach to "constructor" overloading. Of course, overloaded classes can do much
        more than just this!</para>
        
        <para>Our <literal>hello()</literal> method is now looking <emphasis>really</emphasis>
        simple:</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    Hello(process).say(process);
}]]></programlisting>
        
        </section>
        
        <section>
            <title>Taking advantage of functional-style programming</title>
        
        <para>Let's go back, once again, to the attribute <literal>greeting</literal> 
        of <literal>Hello</literal>:</para>
        
        <programlisting><![CDATA[package String greeting {
    if (exists name) {
        return "Hello, " name "!"
    }
    else {
        return "Hello, World!"
    }
}]]></programlisting>

        <para>This definition works
        well enough, but it's quite procedural, with two <literal>return</literal>
        statements. That's not usually considered good style in Ceylon, though
        there are certainly times when it's necessary. Instead, Ceylon lets you
        write code like this using a more functional style.</para>
        
        <para>In procedural
        programming we usually pass a list of values to a method, which performs 
        computations using those values, and returns another value. In functional
        programming, we can pass an operation to a method, which calls our
        operation, and returns a value, or, perhaps, a different operation.</para>
        
        <para>For example, the Ceylon standard librares define a method called
        <literal>ifExists()</literal> that accepts an object and two 
        <emphasis>method references</emphasis>. (A method parameter that accepts 
        a method reference is called a <emphasis>functional parameter</emphasis>.)
        If the object is not null, <literal>ifExists()</literal> invokes the first
        method. Otherwise, <literal>ifExists()</literal> invokes the second method.
        We can use <literal>ifExists()</literal> to rewrite 
        <literal>greeting</literal>:</para>

<programlisting><![CDATA[package String greeting {
    String helloName() { return "Hello, " name "!" }
    String helloWorld() { return "Hello, World!" }
    return ifExists(name, helloName, helloWorld)
}]]></programlisting>

        <para>Well, that's certainly more functional, but it's also a lot more
        verbose. But this is not the way <literal>ifExists()</literal> is really
        intended to be used. Ceylon provides a special method argument syntax
        for defining a method that is passed to another method inline, as part
        of the invocation. An inline method definition is called a
        <emphasis>functional argument</emphasis>. Functional arguments follow
        the normal parenthesized argument list.</para>
        
        <para>Using functional arguments, we could write <literal>greeting</literal> 
        as follows, to make it really clear that we're defining methods that are 
        passed as arguments to the functional parameters <literal>then</literal> 
        and <literal>otherwise</literal>.</para>

<programlisting><![CDATA[package String greeting {
    return ifExists(name)
        //inline definition of the first
        //functional argument
        then () {
            return "Hello, " name "!"
        }
        //inline definition of the second
        //functional argument
        otherwise () {
            return "Hello, World!"
        }
}]]></programlisting>

        <para>Note that there are three <literal>return</literal> statements
        here. The nested <literal>return</literal> statements specify the 
        return values of the two inline methods. They do not end the execution
        of <literal>greeting</literal>!</para>

        <para>This syntax was chosen to make it possible to define new
        control structures that closely mimic the syntactic form of the
        traditional C-style built-in control structures.</para>
        
        <para>Usually, we would abbreviate the above code by:</para>
        
        <itemizedlist>
            <listitem>
                <para>eliminating the empty formal parameter lists&mdash;we 
                can leave off the <literal>()</literal>, and</para>
            </listitem>
            <listitem>
                <para>specifying the method return values in parentheses, 
                instead of writing <literal>return</literal> statements
                surrounded by braces&mdash;we're allowed to write
                <literal>("Hello, World!")</literal> instead of 
                <literal>{ return "Hello, World!" }</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The abbreviated code looks like this:</para>

<programlisting><![CDATA[package String greeting {
    return ifExists(name) 
        then ("Hello, " name "!")
        otherwise ("Hello, World!")
}]]></programlisting>
        
        <para>This syntax might look a little unfamiliar at first, but 
        you'll soon get used to it. In Ceylon, we use method invocations 
        with functional arguments to express things that are difficult
        to express without specialized syntax in other languages, for
        example:</para>
        
        <itemizedlist>
            <listitem>
                <para><emphasis>assertion</emphasis>, such as 
                <literal>assert() that (x==0.0);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>comprehension</emphasis>, such as 
                <literal>List&lt;String&gt; names = from (people) select (Person p) (p.name);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>quantification</emphasis>, such as
                <literal>Boolean adults = forAll (people) every (Person p) (p.age>=18);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>repetition</emphasis>, such as
                <literal>repeat (3) times { stream.writeLine("Hello!"); }</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>Look at each of these examples, and ask yourself:</para>
        
        <itemizedlist>
            <listitem>
                <para>What is the name of the method that is being called?</para>
            </listitem>
            <listitem>
                <para>Are there any ordinary arguments? Which are they?</para>
            </listitem>
            <listitem>
                <para>Which is the functional argument? What is its name?</para>
            </listitem>
            <listitem>
                <para>Are there any formal parameters of the functional argument? 
                What are the parameter names?</para>
            </listitem>
            <listitem>
                <para>Where is the implementation of the functional argument?
                What happens when the functional argument is invoked?</para>
            </listitem>
        </itemizedlist>
        
        <para>By the way, there's an even easier way to define 
        <literal>greeting</literal>, using the <literal>?</literal>
        operator.</para>
        
<programlisting><![CDATA[package String greeting {
    return "Hello, " (name ? "World") "!"
}]]></programlisting>
    
        </section>
        
        <section>
            <title>Defining user interfaces declaratively</title>

        <para>Finally, lets create a web-based user interface for our
        program.</para>
        
        <para>We've seen lots of examples of invoking a method or instantiating
        a class using the traditional C-style argument list where arguments are
        surrounded in parentheses and separated by commas. Arguments are matched
        to parameters by their position in the list. Using this syntax, we could
        create a tree of objects as follows:</para>
        
        <programlisting>Html(
    Head('hello.css', "Hello World"),
    Body(
        Div("greeting", "Hello World"),
        Div("footer", "Powered by Ceylon")
    )
)</programlisting>

        <para>However, Ceylon provides an alternative way of writing
        argument lists that makes it much more natural to define heirarchical
        structures. A <emphasis>named argument list</emphasis> is a list of 
        arguments surrounded by braces and separated by semicolons. Varargs 
        parameters in a named argument list don't need names, and are 
        separated by commas. For example:</para>

        <programlisting>Html {
    head = Head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    };
    body = Body {
        Div {
            cssClass = "greeting";
            "Hello World" 
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon" 
        }
    };
}</programlisting>
        
        <para>We're going to use this syntax to define our web page.</para>
        
        <programlisting><![CDATA[import html.*;

doc "A web page that displays a greeting"
page '/hello.html'
public class HelloHtml(Request request) 
        extends Html(request) {

    Hello hello = Hello(request.parameters["name"]);
    
    head = Head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    };
    body = Body {
        Div {
            cssClass = "greeting";
            hello.greeting
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon"
        }
    };

}]]></programlisting>

        <para>This program demonstrates Ceylon's support for defining structured 
        data, in this case, HTML. The <literal>HelloHtml</literal> class extends 
        Ceylon's <literal>Html</literal> class and specified its abstract 
        <literal>head</literal> and <literal>body</literal> attributes. The 
        <literal>page</literal> annotation specifies the URL at which this HTML 
        should be accessible. A single-quoted string literal is used, allowing the 
        format of the URL to be validated by the Ceylon compiler.</para>

    </section>
    
    <section>
        <title>Defining structured data formats</title>
        
        <para>Let's try and define our own structured data format, to personalize
        our program a little. First, we'll create a class to represent people:</para>
        
        <programlisting>doc "Represents a person"
package class Person(String firstName, String lastName, Language lang) {
    package String firstName = firstName;
    package String lastName = lastName;
    package Language lang = lang;
}</programlisting>
        
        <para>Now, we'll create a class with an <emphasis>enumerated list of 
        instances</emphasis>&mdash;almost exactly like a Java 
        <literal>enum</literal>&mdash;to represent the built-in languages that
        our program supports.</para>
        
        <programlisting>doc "Represents a language"
package class Language(String hello) {

    english("Hello"),
    french("Bonjour"),
    spanish("Hola"),
    italian("Ciao")
    ...
    
    doc "The word for \"hello\" in the language"
    package String hello = hello;
    
}</programlisting>

        <para>The use of <literal>...</literal> at the end of the list of enumerated
        instances means that it's possible to create other <literal>Language</literal>s.
        Very important in this case, since our list of languages is definitely not 
        exhaustive! If our list of instances were exhaustive, we would terminate it
        using <literal>;</literal>, thereby preventing other code from instantiating
        additional <literal>Language</literal>s.</para>
        
        <para>Now we can define the set of people known to our application like
        this:</para>
        
        <programlisting>Set&lt;Person&gt; people = {
        Person {
            firstName = "Gavin";
            lastName = "King";
            language = Language.english;
        },
        Person {
            firstName = "Emmanuel";
            lastName = "Bernard";
            lang = Language.french;
        },
        Person {
            firstName = "Pete";
            lastName = "Muir
            lang = Language.english;
        },
        Person {
            firstName = "Andrew";
            lastName = "Haley";
            lang = Language.english;
        }
    };</programlisting>
    
        <para>But where should we put our list of people? Well, just for fun, let's
        specify them using an annotation of <literal>Hello</literal>. First we'll 
        need to learn how to define new annotations.</para>
        
    </section>
    
    <section>
        <title>Defining annotations</title>
        
        <para>In Ceylon, an annotation is just a method that produces an ordinary 
        type. An annotation for specifying a set of people could be defined like 
        this:</para>
        
        <programlisting>doc "An annotation for specifying a list of 
     people"
ofElements(class) withType(#Greeting) 
multiplicity(onceEachType)
package Set&lt;People&gt; people(Person... people) {
    return HashSet(people);
}</programlisting>

        <para>The annotations <literal>ofElements</literal>, <literal>withType</literal>
        and <literal>multiplicity</literal> specify that this annotation can only
        occur an the class <literal>Greeting</literal>, and can only occur once.</para>

        <para>We obtain the annotations of a program element&mdash;in this case, the 
        class <literal>Greeting</literal>&mdash;using reflection upon the metamodel 
        object&mdash;<literal>#Greeting</literal>&mdash;that represents the program 
        element. We must specify the type returned by the annotation, by passing its 
        metamodel object&mdash;in this case, <literal>#Set&lt;People&gt;</literal>.
        Careful, there may be multiple annotations producing the same type of object!</para>
        
        <programlisting>Sequence&lt;Set&lt;People&gt;&gt; annotations = (#Greeting).annotations(#Set&lt;People&gt;);</programlisting>
        
        <para>We're already ready to use our new annotation. Just like with other 
        method invocations, we have the choice between specifying the arguments of 
        an annotation using a positional parameter list surrounded by parenthesis, 
        or using a named parameter list surrounded by braces. In this case, the 
        braces look more visually appealing:</para>
        
        <programlisting>doc "A personalized greeting"
people {
    Person {
        firstName = "Gavin";
        lastName = "King";
        language = Language.english;
    },
    Person {
        firstName = "Emmanuel";
        lastName = "Bernard";
        lang = Language.french;
    },
    Person {
        firstName = "Pete";
        lastName = "Muir
        lang = Language.english;
    },
    Person {
        firstName = "Andrew";
        lastName = "Haley";
        lang = Language.english;
    }
}
class Hello(String? name) {

    Set&lt;People&gt;? annotation = type.annotations(#Set&lt;People&gt;).first
    
    doc "The list of people"
    Set&lt;People&gt; people;
    if (exists annotation) {
        people = annotation;
    }
    else {
        throw Exception("Not annotated people")
    }
    
    doc "The greeting"
    package String greeting {
        if (exists name) {
            Person? person = first (people) 
                    having (Person p) (p.firstName==name);
            if (exists person) {
                return "" person.lang.hello ", " 
                    person.firstName " " person.lastName "!"
            }
            else {
                return "Hello, " name "!";
            }
        }
        else {
            return "Hello, World!";
        }
    }
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}</programlisting>
        
    </section>
    
    <section>
        <title>Generic types and covariance</title>
        
        <para>Programming with generic types is one of the most difficult parts of
        Java. That's still true, to some extent, in Ceylon. But because the Ceylon
        language and SDK were designed for generics from the ground up, Ceylon
        is able to eliminate one of the bits of Java generics that's really 
        hard to get your head around: wildcard types. Wildcard types were Java's
        solution to the problem of <emphasis>covariance</emphasis> in a generic
        type system. Let's first explore the idea of covariance, and then see how
        Ceylon's solution, copied from Scala, works.</para>
        
        <para>It all starts with the intuitive expectation that a collection of
        <literal>Geek</literal>s is a collection of <literal>Person</literal>s.
        That's a reasonable intuition, but in procedural languages, where 
        collections can be mutable, it turns out to be incorrect. Consider the
        following possible definition of <literal>Collection</literal>:</para>
        
        <programlisting>interface Collection&lt;X&gt; {
    Iterator&lt;X&gt; iterator();
    void add(X x);
}</programlisting>

        <para>And let's suppose that <literal>Geek</literal> is a subtype of 
        <literal>Person</literal>.</para>
        
        <para>The intuitive expectation is that the following code should work:</para>
        
        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Collection&lt;Person&gt; people = geeks;   //compiler error
for (Person person in people.iterator()) { ... }</programlisting>
        
        <para>This code is, frankly, perfectly reasonable taken at face value. Yet
        in both Java and Ceylon, this code results in a compiler error at the 
        second line, where the <literal>Collection&lt;Geek&gt;</literal> is assigned 
        to a <literal>Collection&lt;Person&gt;</literal>. Why? Well, because if we 
        let the assignment through, the following code would also compile:</para>
        
        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Collection&lt;Person&gt; people = geeks;   //compiler error
people.add( Person("Fonzie") );</programlisting>

        <para>We can't let that code by&mdash;Fonzie isn't a <literal>Geek</literal>!</para>
        
        <para>Using big words, we say that <literal>Collection</literal> is
        <emphasis>nonvariant</emphasis> in <literal>X</literal>. Or, when we're not
        trying to impress people with opaque terminology, we say that 
        <literal>Collection</literal> both <emphasis>produces</emphasis>&mdash;via the
        <literal>iterator()</literal> method&mdash;and <emphasis>consumes</emphasis>&mdash;via
        the <literal>add()</literal> method&mdash;instances of <literal>X</literal>.</para>
        
        <para>Here's where Java goes off and dives down a rabbit hole, inventing 
        wildcards to try and squeeze a covariant or contravariant type out of a 
        nonvariant type, but mainly succeeding in thoroughly confusing everybody.
        We're not going to follow Java down the hole.</para>
        
        <para>Instead, we're going to refactor <literal>Collection</literal> into
        a pure producer interface and a pure consumer interface:</para>
        
        <programlisting>interface Producer&lt;out X&gt; {
    Iterator&lt;X&gt; iterator();
}</programlisting>

        <programlisting>interface Consumer&lt;in X&gt; {
    void add(X x);
}</programlisting>

        <para>Notice that we've annotated the type parameters of these interfaces.</para>
        
        <itemizedlist>
            <listitem>
                <para>The <literal>out</literal> annotation specifies that 
                <literal>Producer</literal> is <emphasis>covariant</emphasis>
                in <literal>X</literal>; that it produces instances of 
                <literal>X</literal>, but never consumes instances of 
                <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>The <literal>in</literal> annotation specifies that 
                <literal>Consumer</literal> is <emphasis>contravariant</emphasis>
                in <literal>X</literal>; that it consumes instances of 
                <literal>X</literal>, but never produces instances of 
                <literal>X</literal>.</para>
            </listitem>
        </itemizedlist>
        
        
        <para>The Ceylon compiler validates the schema of the type declaration to 
        ensure that the variance annotations are satisfied. If you try to declare 
        an <literal>add()</literal> method on <literal>Producer</literal>, a
        compilation error results. If you try to declare an <literal>iterate()</literal>
        method on <literal>Consumer</literal>, you get a similar compilation 
        error.</para>
        
        <para>Now, let's see what that buys us:</para>
        
        <itemizedlist>
            <listitem>
        <para>Since <literal>Producer</literal> is covariant in its type parameter
        <literal>X</literal>, and since <literal>Geek</literal> is a subtype 
        of <literal>Person</literal>, Ceylon lets you assign
        <literal>Producer&lt;Geek&gt;</literal> to 
        <literal>Producer&lt;Person&gt;</literal>.</para>
            </listitem>
            <listitem>
        <para>Furthermore, 
        since <literal>Consumer</literal> is contravariant in its type parameter
        <literal>X</literal>, and since <literal>Geek</literal> is a subtype 
        of <literal>Person</literal>, Ceylon lets you assign
        <literal>Consumer&lt;Person&gt;</literal> to 
        <literal>Consumer&lt;Geek&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>We can define our <literal>Collection</literal> interface as a
        mixin of <literal>Producer</literal> with <literal>Consumer</literal>.</para>
        
        <programlisting>interface Collection&lt;X&gt; 
        satisfies Producer&lt;X&gt;, Consumer&lt;X&gt; {}</programlisting>
        
        <para>Notice that <literal>Collection</literal> remains nonvariant in
        <literal>X</literal>.</para>
        
        <para>Now, the following code finally compiles:</para>

        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Producer&lt;Person&gt; people = geeks;
for (Person person in people.iterator()) { ... }</programlisting>

        <para>Which matches our original intuition.</para>

        <para>The following code also compiles:</para>
        
        <programlisting>Collection&lt;Person&gt; people = ... ;
Consumer&lt;Geek&gt; geekConsumer = people;
geekConsumer.add( Person("James Gosling") );</programlisting>

        <para>Which is also intuitively correct&mdash;James is most certainly
        a <literal>Person</literal>!</para>
        
        <para>You're unlikely to spend much time writing your own collection
        classes, since the Ceylon SDK has a powerful collections framework
        built in. But you'll still appreciate Ceylon's approach to covariance
        as a user of the built-in collection types.
        The collections framework defines two interfaces for each 
        basic kind of collection. For example, there is an interface 
        <literal>List&lt;X&gt;</literal> which represents a read-only view of
        a list, and is covariant in <literal>X</literal>, and 
        <literal>OpenList&lt;X&gt;</literal>, which represents a mutable list,
        and is nonvariant in <literal>X</literal>.</para>
        
    </section>
    
    <section>
        <title>Testing the type of an object</title>
        
        <para>Ceylon doesn't have C-style typecasts. Instead, we must test and 
        narrow the type of an object in one step, using the special <literal>if (is ... )</literal> 
        construct. This construct is very, very similar to <literal>if (exists ... )</literal>, 
        which we met earlier.</para>
        
        <programlisting>Object object = ... ;
if (is Hello object) {
    object.say();
}</programlisting>
        
        <para>The <literal>switch</literal> statement supports a similar construct:</para>
        
        <programlisting>Object object = ... ;
switch(object)
case (is Hello) {
    object.say();
}
case (is Person) {
    stream.writeLine(object.firstName);
}
else {
    stream.writeLine($object);
}</programlisting>

        <para>These constructs protect us from inadvertantly writing code that 
        would cause a <literal>ClassCastException</literal> in Java, just like
        <literal>if (exists ... )</literal> protects us from writing code that
        would cause a <literal>NullPointerException</literal>.</para>
        
        <para>Another thing that causes problems when working with generic
        types in Java is <emphasis>type erasure</emphasis>. Generic type 
        arguments are discarded by the compiler, and simply aren't available
        at runtime. So the following, perfectly sensible, code fragments 
        simply wouldn't compile in Java:</para>
        
        <programlisting>if (is List&lt;Person&gt; list) { ... }</programlisting>
        <programlisting>if (is T object) { ... }</programlisting>
        <programlisting>Type&lt;T&gt; tType = #T;</programlisting>
        
        <para>(Where <literal>T</literal> is a generic type parameter.)</para>
        
        <para>You'll be pleased to know that in Ceylon, these three code
        fragments compile and function as expected.</para>
        
    </section>
    
    <section>
        <title>Introducing a new type to an object</title>
        
        <para>Ceylon doesn't have multiple inheritance or mixins. If you're used
        to the single-inheritance-with-interfaces model of Java, you'll find
        that inheritance in Ceylon works pretty much the same.</para>
        
        <para>However, Ceylon does have something else, that's usually almost as
        good as, and often better than, true multiple inheritance. An
        <emphasis>extension</emphasis> adds a type, call an <emphasis>introduced</emphasis>
        type, to an existing type, called the <emphasis>extended</emphasis> type.
        An extension doesn't change the original definition of the extended type,
        and it doesn't affect the internal workings of an object of that type in
        any way. But from the point of view of a client of the object, the object
        now has all the attributes and methods of the introduced type, and is
        assignable to the introduced type.</para>
        
        <para>Let's introduce a type onto every object. Ceylon's
        <literal>Object</literal> class defines an attribute named 
        <literal>log</literal> of type <literal>Log</literal> that you can use
        to log stuff. Usually, you use it like this:</para>
        
        <programlisting>log.debug("Hello, I'm a debug message");</programlisting>
        
        <para>But perhaps you don't like having to type the "<literal>log.</literal>"
        bit every time you write out a log message, and suppose you don't expect
        to ever need methods named <literal>info()</literal>, <literal>error()</literal>
        <literal>warn()</literal> or <literal>debug()</literal> in your application.
        If so, wouldn't it be nice to just write:</para>
        
        <programlisting>debug("Do you think anyone ever reads me?");</programlisting>
        
        <para>Obviously, one way to do this would be to copy and paste all the
        <literal>info()</literal>, <literal>error()</literal>
        <literal>warn()</literal> and <literal>debug()</literal> methods from
        <literal>Log</literal> onto <literal>Object</literal>, and have them
        delegate back to <literal>log</literal>. But we don't like copy/paste
        programming here.</para>
        
        <para>Another way might be to make <literal>Object</literal> extend 
        <literal>Log</literal>, but that way <literal>Log</literal>
        would be the logical root of the Ceylon type system, instead of 
        <literal>Object</literal>. That doesn't feel right.</para>
        
        <para>Instead, we're going to introduce <literal>Log</literal> onto
        <literal>Object</literal> using an extension. If we were able to modify 
        the code of <literal>Object</literal>, this would be as easy as adding 
        an <literal>extension</literal> annotation to the <literal>log</literal>,
        attribute like this:</para>
        
        <programlisting>public extension Log log { ... }</programlisting>
        
        <para>But since <literal>Object</literal> is built into the Ceylon SDK, 
        we don't have control over its code, we need to take a different 
        approach. We'll write a toplevel <emphasis>extension method</emphasis>,
        sometimes called a <emphasis>converter</emphasis>:</para>
        
        <programlisting>public extension Log objectToLog(Object o) { return o.log }</programlisting>
        
        <para>Now, we can't just have hundreds of third-party extensions all
        vandalizing <literal>Object</literal> with their own introduced types,
        and polluting the namespace with thousands of introduced methods and
        attributes. So the client code that uses the extension is responsible
        for explicitly activating the extension in the compilation unit where
        it is used.</para>
        
        <programlisting>import com.domain.util.objectToLog;
        
public class Hello(String? name) {

    ...
    
    info(greeting);
    
    ...

}</programlisting>

        <para>The compiler automatically inserts a call to 
        <literal>objectToLog()</literal>. So the above code is equivalent to:</para>

        <programlisting>public class Hello(String? name) {

    ...
    
    objectToLog(this).info(greeting);
    
    ...

}</programlisting>

        <para>A compilation unit that doesn't explicitly import 
        <literal>objectToLog</literal> won't be affected by the extension, and
        won't be able to call the <literal>info()</literal> method without
        explicitly invoking the <literal>log</literal> attribute.</para>
        
        <para>So you might think that extension are just a trivial trick that
        saves a few keystrokes of typing effort. But the history of Java 
        demonstrates why extension are an important feature. Java defines its
        collections framework in terms of various interfaces, for example, 
        <literal>List</literal>, each with very many methods, mostly convenience 
        methods for the benefit of the user of these interfaces. Because 
        implementing the whole interface from scratch is a daunting task, the 
        collections framework includes abstract classes like 
        <literal>AbstractList</literal> that define a smaller contract for
        classes that implement the collection interfaces. But there's no way
        for the collections framework to force you to implement 
        <literal>AbstractList</literal> instead of implementing <literal>List</literal> 
        directly. And, of course, the world is now full of Java code that does
        exactly that. Which means that introducing a new method to the 
        <literal>List</literal> interface is a huge breaking change that affects
        a great deal of working, production code.</para>
        
        <para>Ceylon takes a different approach to its collection types. The 
        basic collection interfaces like <literal>List</literal> define a small
        set of operations. Convenience method for users of the collections 
        framework are defined by built-in extensions. So we can add new convenience 
        methods whenever we like. And so can you!</para>
        
    </section>
    
</chapter>