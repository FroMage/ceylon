<chapter id="introduction">
    <title>Introduction</title>
    
    <para>
    Ceylon is a statically-typed, general-purpose, object-oriented language
    featuring a syntax similar to Java and C#. Ceylon programs execute in any 
    standard Java Virtual Machine and, like Java, take advantage of the memory 
    management and concurrency features of that environment. The Ceylon 
    compiler is able to compile Ceylon code that calls Java classes or 
    interfaces, and Java code that calls Ceylon classes or interfaces. Ceylon 
    improves upon the Java language and type system to reduce verbosity and 
    increase typesafety compared to Java and C#. Ceylon encourages a more 
    functional style of programming, resulting in code which is easier to 
    reason about, and easier to refactor. Moreover, Ceylon provides its 
    own native SDK as a replacement for the Java platform class libraries.
    </para>
    
    <section>
        <title>Language overview</title>
    
    <section>
    <title>The type system</title>
    
    <para>
    Ceylon features a similar inheritance and generic type model to Java. 
    A type is either an <emphasis>interface</emphasis> or a 
    <emphasis>class</emphasis>. An interface may extend an arbitrary number 
    of other interfaces. A class may implement an arbitrary number of interfaces 
    and must extend another class. 
    </para>
    
    <para>
    There are no primitive types or arrays in Ceylon, so all values are
    instances of the type hierarchy root <literal>lang.Object</literal>.
    However, the Ceylon compiler is permitted to optimize certain code to 
    take advantage of the better performance of primitive types on the JVM.
    </para>
    
    <para>
    Ceylon does not support Java-style wildcard type parameters or raw types. 
    Instead, like Scala, a type parameter may be marked as covariant or 
    contravariant by the class or interface that declares the parameter. Type 
    arguments are reified in Ceylon, eliminating many problems related to 
    type erasure in Java. 
    </para>
    
    <para>
    Ceylon supports <emphasis>type aliases</emphasis>, similar to C-style 
    <literal>typedef</literal>.
    </para>
    
    </section>
    
    <section>
    <title>Compiler-enforced naming conventions</title>
    
    <para>
    The Ceylon compiler enforces the traditional Smalltalk naming convention:
    type names begin with an initial uppercase letter&mdash;for example, 
    <literal>Liberty</literal> or <literal>RedWine</literal>&mdash;member names 
    and local names with an initial lowercase letter or underscore&mdash;for
    example, <literal>blonde</literal>, <literal>immanentize()</literal> or 
    <literal>boldlyGo()</literal>. This innovation allows a much cleaner 
    syntax for program element annotations than the syntax found in either Java 
    or C#.
    </para>
    
    </section>
    
    <section>
    <title>Class initialization and instantiation</title>
    
    <para>
    Ceylon does not feature any Java-like constructor declaration and so 
    each Ceylon class has a formal parameter list, and exactly one 
    <emphasis>initializer</emphasis>&mdash;the body of the class. This helps
    reduce verbosity and results in a more regular block structure.
    </para>
    
    <para>
    In place of constructor overloading, Ceylon allows class names to be 
    overloaded. Even better, member classes of a class may be overridden by 
    subclasses. Instantiation is therefore a polymorphic operation in Ceylon, 
    eliminating the need for factory methods.
    </para>
    
    </section>
    
    <section>
    <title>Methods and attributes</title>
    
    <para>
    Ceylon types have members: <emphasis>methods</emphasis> and 
    <emphasis>attributes</emphasis>. Ceylon methods are similar to Java methods. 
    However, Ceylon classes do not contain fields, in the traditional sense. 
    Instead, Ceylon supports only a higher-level construct: polymorphic 
    attributes, which are similar to C# properties. Attributes abstract the
    internal representation of the state of an object.
    </para>
    
    <para>There are no <literal>static</literal> members. Instead, 
    <emphasis>toplevel</emphasis> methods are declared as direct members of a 
    package. This, along with certain other features, gives the language a more 
    regular block structure.
    </para>

    </section>
    
    <section>
    <title>Defaulted parameters</title>
    
    <para>
    As an alternative to method or class overloading, Ceylon supports method 
    and class initialization parameters with default values. 
    </para>
    
    </section>
    
    <section>
    <title>First-class functions</title>
    
    <para>
    Ceylon supports first-class 
    function types and higher-order functions, with minimal extensions to 
    the traditional C syntax. A method declaration may specify a 
    <emphasis>callable parameter</emphasis> that accepts references to 
    other methods with a certain signature. The argument of such a callable 
    parameter may be either a reference to a named method declared elsewhere, 
    or a new method defined inline as part of the method invocation. A method 
    may even return an invocable reference to another method. Finally, nested 
    method declarations receive a closure of immutable values in the 
    surrounding scope.
    </para>
    
    </section>
    
    <section>
    <title>Immutability by default</title>
    
    <para>
    By default, Ceylon classes, attributes and locals are immutable. 
    Mutable classes, attributes and locals must be explicitly declared
    using the <literal>mutable</literal> annotation. An immutable class may 
    not declare <literal>mutable</literal> attributes or extend a 
    <literal>mutable</literal> class. An immutable attribute or local may 
    not be assigned after its initial value is specified.
    </para>
    
    </section>
    
    <section>
    <title>Compile-time safety for optional values and type narrowing</title>
    
    <para>
    By default, Ceylon attributes and locals do not accept null values. 
    Optional locals and attributes must be explicitly declared. Optional 
    expressions are not assignable to non-optional locals or attributes, 
    except via use of the <literal>if (exists ... )</literal> construct. 
    Thus, the Ceylon compiler is able to detect illegal use of a null value 
    at compile time. Therefore, there is no equivalent to Java's 
    <literal>NullPointerException</literal> in Ceylon.
    </para>
    
    <para>
    Ceylon does not feature C-style typecasts. Instead, the 
    <literal>if (is ... )</literal> and 
    <literal>case (is ... )</literal> constructs may be used to narrow
    the type of an object reference without risk of a 
    <literal>ClassCastException</literal>.
    </para>
    
    </section>
    
    <section>
    <title>Control flow</title>
    
    <para>
    Ceylon control flow structures are very similar to the traditional 
    constructs found in C, C# and Java. However, inline methods can be 
    used together with a special Smalltalk-style method invocation protocol 
    to achieve more specialized flow control and other more functional-style 
    constructs such as comprehensions.
    </para>
    
    <para>
    Ceylon features an exceptions model inspired by Java and C#. Checked 
    exceptions are not supported.
    </para>
    
    </section>
    
    <section>
    <title>Operators</title>
    
    <para>
    Ceylon features a rich set of operators, including most of the operators 
    supported by C and Java. True operator overloading is not supported. 
    However, each operator is defined to act upon a certain class or interface 
    type, allowing application of the operator to any class which extends or 
    implements that type. This is called <emphasis>operator polymorphism</emphasis>.
    </para>
    
    </section>
    
    <section>
    <title>Numeric types</title>
    
    <para>Ceylon's numeric type system is much simpler than C, C# or Java, 
    with exactly five built-in numeric types (compared to eight in Java and
    eleven in C#). The built-in types are classes representing natural numbers, 
    integers, floating point numbers, arbitrary precision integers and 
    arbitrary precision decimals. <literal>Natural</literal>, 
    <literal>Integer</literal> and <literal>Float</literal> values are 64 bit 
    by default, and may be optimized for 32 bit architectures via use of the 
    <literal>small</literal> annotation. <!--Unlike Java and C#, Ceylon features
    language-level support for dates and times.--></para>
    
    </section>
    
    <section>
    <title>Extensions</title>
    
    <para>
    True open classes are not supported. However, Ceylon supports 
    <emphasis>extensions</emphasis>, which allow addition of methods and 
    interfaces to existing types, and transparent conversion between types, 
    within a textual scope. Extensions only affect the operations provided 
    by a type, not its state. <!--This facility makes it easy for Ceylon code to 
    transparently interoperate and inter-compile with Java code.-->
    </para>
    
    </section>
    
    <section>
    <title>Structured data</title>
    
    <para>
    Ceylon introduces a set of syntax extensions that support the definition 
    of domain-specific languages and expression of structured data. These 
    extensions include specialized syntax for initializing objects and 
    collections and expressing literal values or user-defined types. The goal 
    of this facility is to replace the use of XML for expressing hierarchical 
    structures such as documents, user interfaces, configuration and serialized 
    data. An especially important application of this facility is Ceylon's 
    built-in support for program element annotations.
    </para>
    
    </section>
    
    <section>
    <title>Metaprogramming</title>
    
    <para>
    Ceylon provides sophisticated support for meta-programming, including 
    a typesafe metamodel and events. This facility is inspired by similar 
    features found in dynamic languages such as Smalltalk, Python and Ruby, 
    and by the much more complex features found in aspect oriented languages
    like Aspect J. Ceylon does not, however, support aspect oriented
    programming as a language feature.
    </para>
    
    </section>
    
    <section>
    <title>Modularity</title>
    
    <para>
    Ceylon features language-level <emphasis>package</emphasis> and 
    <emphasis>module</emphasis> constructs, and language-level access control 
    with five levels of visibility for program elements: block local (the 
    default), <literal>private</literal>, <literal>package</literal>, 
    <literal>module</literal> and <literal>public</literal>. There's no 
    equivalent to Java's <literal>protected</literal>.
    </para>
    
    </section>
    
    </section>
    
    <section>
    <title>A brief tutorial</title>
    
    <section>
        <title>Writing a simple program in Ceylon</title>
        
        <para>
        Here's a classic example, implemented in Ceylon:
        </para>
        
        <programlisting>doc "The classic Hello World program"
public void hello(Process process) {
    process.writeLine("Hello, World!");
}</programlisting>

        <para>
        This code defines a Ceylon method named <literal>hello()</literal>
        with a parameter of type <literal>lang.Process</literal>. The 
        method is annotated <literal>public</literal>, which makes it
        accessible to code in other compilation units. When the method is 
        invoked, it calls the <literal>writeLine()</literal> method of the 
        class <literal>Process</literal>. (This method displays its parameter 
        on the console.) The <literal>doc</literal> annotation contains 
        documentation that is included in the output of the Ceylon 
        documentation compiler.
        </para>
        
        <para>Copy this code into a file named <literal>hello.ceylon</literal>
        and put the file in the <literal>ceylon/source/</literal> directory of 
        your Ceylon SDK installation.</para>
        
        <para>Now, in the <literal>ceylon</literal> directory, run the 
        following command:</para>
        
        <programlisting>ceylon hello</programlisting>
        
        <para>This command compiles the source to bytecode and runs the Java 
        virtual machine. You should see the following output in the console:</para>
        
        <programlisting>Hello World!</programlisting>
        
    </section>
        
    <section>
        <title>Dealing with objects that aren't there</title>
        
        <para>
        This improved version of the program takes a name as input from the 
        command line. We have to account for the case where nothing was
        specified at the command line, which gives us an opportunity to
        explore how null values are treated in Ceylon, which is quite 
        different to what you're probably used to in Java or C#.
        </para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    String? name = process.args.first;
    String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    process.writeLine(greeting);
}]]></programlisting>

        <para>
        The <literal>Process</literal> class has an attribute named 
        <literal>args</literal>, which holds a <literal>List</literal> of the 
        program's command line arguments. The local <literal>name</literal> is 
        initialized with the first of these arguments, if any. This local is 
        declared to have type <literal>String?</literal>, to indicate that it 
        may contain a null value. The <literal>if (exists ...)</literal> control 
        structure is used to initialize the value of the non-null local named 
        <literal>greeting</literal>, interpolating the value of 
        <literal>name</literal> into the message string whenever 
        <literal>name</literal> is not null. Finally, the message is printed
        to the console.
        </para>
        
        <para>Unlike Java, locals, parameters, and attributes that may contain 
        null values must be explicitly declared as being of type 
        <literal>Optional&lt;X&gt;</literal> where <literal>X</literal> is the
        type of value they contain when not holding a null value. Ceylon lets
        us abbreviate the type name <literal>Optional&lt;X&gt;</literal> to
        <literal>X?</literal>. The value <literal>null</literal> is an instance
        of type <literal>Optional&lt;X&gt;</literal>, but it's not an instance 
        of <literal>Object</literal>. So there's simply no way to assign 
        <literal>null</literal> to a local that isn't of type 
        <literal>Optional</literal>. The compiler won't let you.</para>
        
        <para>
        Nor will the Ceylon compiler let you do anything "dangerous" with a 
        value of type <literal>Optional</literal>&mdash;that is, anything that 
        could cause a <literal>NullPointerException</literal> in 
        Java&mdash;without first checking that the value is not null using 
        <literal>if (exists ... )</literal>.
        </para>
        
        <para>If you're worried about the performance implications of wrapping
        values in instances of <literal>Optional</literal>, don't be. 
        <literal>Optional</literal> isn't a <emphasis>reified</emphasis>
        type&mdash;it exists at compile time, when the compiler is validating
        your code for typesafety, but then the compiler eliminates it as part of 
        the compilation process, allowing the resulting bytecode to take advantage 
        of the efficient handling of null values in the virtual machine.</para>
        
        <para>Copy this new version of the program into <literal>hello.ceylon</literal> 
        and run:</para>
        
        <programlisting>ceylon hello everybody</programlisting>
        
        <para>You should see the following output:</para>
        
        <programlisting>Hello everybody!</programlisting>
        
        </section>
        
        <section>
            <title>Creating your own classes</title>

        <para>
        Our method now has too many responsibilities, and is not at all reusable. 
        Let's refactor the code. Ceylon is an object oriented language, so we 
        usually write most of our code in <emphasis>classes</emphasis>. A class
        is a type that packages:
        </para>
        
        <itemizedlist>
            <listitem><para>operations&mdash;called <emphasis>methods</emphasis>,</para></listitem>
            <listitem><para>state&mdash;held by <emphasis>attributes</emphasis>, and,</para></listitem>
            <listitem><para>sometimes, other nested types.</para></listitem>
        </itemizedlist>
          
        <para>
        Types (interfaces, classes, and aliases) have names that begin with uppercase 
        letters. Members (methods and attributes) and locals have names that begin with 
        lowercase letters. This is the rule you're used to from Java. <!--(it's different to, 
        and much prettier than, the naming conventions in C#)--> Unlike Java, the Ceylon 
        compiler enforces these rules. If you try to write <literal>class hello</literal>
        or <literal>String Name</literal>, you'll get a compilation error.
        </para>
        
        <para>
        Just like in Java or C#, a class defines the accessibility of its members 
        using <emphasis>visibility modifier annotations</emphasis>, allowing the 
        class to hide its internal implementation from clients. Unlike Java, members 
        are hidden from code outside the body of the class <emphasis>by 
        default</emphasis>&mdash;only members with explicit visibility modifiers are
        visible to other toplevel types or methods, other compilation units, other 
        packages, or other modules.
        </para>
        
        <para>Our first version of the <literal>Hello</literal> class has a
        single attribute and a single method, both declared to have 
        <literal>package</literal> visibility, making them accessible to other
        code in the same package:</para>
        
        <programlisting><![CDATA[doc "A personalized greeting"
class Hello(String? name) {
    
    doc "The greeting"
    package String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>To understand this code completely, we're going to need to first
            explore the concept of an attribute, and then discuss how object
            initialization works in Ceylon.</para>

        </section>
        
        <section>
            <title>Abstracting state using attributes</title>
            
            <para>The attribute <literal>greeting</literal> is a <emphasis>simple 
            attribute</emphasis>, very similar to a Java field. Its value is
            specified immediately after it is declared. Usually we can declare
            and specify the value of an attribute in a single line of code.</para>
            
            <programlisting>package String greeting = "Hello, " name "!";</programlisting>
        
            <para>An attribute is a bit different to a Java field. It's an abstraction
            of the notion of a value. Some attributes are simple value holders like
            the one we've just seen; others are more like a getter method, or, sometimes, 
            like a getter and setter method pair. Like methods, attributes are 
            polymorphic&mdash;an attribute definition may be overridden by a subclass.</para>
            
            <para>We could rewrite the attribute <literal>greeting</literal> as a 
            <emphasis>getter</emphasis>:</para>

            <programlisting><![CDATA[package String greeting {
    if (exists name) {
        return "Hello, " name "!"
    }
    else {
        return "Hello, World!"
    }
}]]></programlisting>

            <para>Clients of a class never need to know whether the attribute they 
            access holds state directly, or is a getter that derives its value from
            other attributes of the same object or other objects. In Ceylon, you don't 
            need to go around declaring all your attributes <literal>private</literal> 
            and wrapping them in getter and setter methods. Get out of that habit right 
            now!</para>
        
        </section>
        
        <section>
            <title>Understanding object initialization</title>
        
        <para>In Ceylon, classes don't have constructors. Instead:</para>
        
        <itemizedlist>
            <listitem>
                <para>the parameters needed to instantiate the class&mdash;the 
                <emphasis>initialization parameters</emphasis>&mdash;are declared 
                directly after the name of the class, and</para>
            </listitem>
            <listitem>
                <para>code to initialize the new instance  of the class&mdash;the 
                <emphasis>class initializer</emphasis>&mdash;goes directly in the 
                body of the class.</para>
            </listitem>
        </itemizedlist>
        
        <para>Take a close look at the following code fragment:</para>
        
<programlisting>String greeting;
if (exists name) {
    greeting = "Hello, " name "!";
}
else {
    greeting = "Hello, World!";
}</programlisting>

        <para>In Ceylon, this code could appear in the body of a class, where 
        it would be declaring and specifying the value of an immutable attribute, 
        or it could appear in the body of a method definition, where it would be 
        declaring and specifying the value of an immutable local variable. That's
        not the case in Java, where initialization of fields looks very different
        to initialization of local variables! Thus the syntax of Ceylon is more
        <emphasis>regular</emphasis> than Java. Regularity makes a language easy
        to learn and easy to refactor.</para>
        
        <para>Now let's turn our attention to a different possible implementation
        of <literal>greeting</literal>:</para>
        
        <programlisting><![CDATA[class Hello(String? name) {
    
    package String greeting {
        if (exists name) {
            return "Hello, " name "!"
        }
        else {
            return "Hello, World!"
        }
    }
    
    ...
    
}]]></programlisting>

        <para>You might be wondering why we're allowed to use the parameter 
        <literal>name</literal> inside the body of the getter of
        <literal>greeting</literal>. Doesn't the parameter go out of scope 
        as soon as the initializer terminates? Well, that's true, but 
        Ceylon is a language with a very strict block structure, and the 
        scope of declarations is governed by that block structure. In this 
        case, the scope of <literal>name</literal> is the whole body of the 
        class, and the definition of <literal>greeting</literal> sits inside 
        that scope, so <literal>greeting</literal> is permitted to access 
        <literal>name</literal>.</para>
        
        <para>We've just met our first example of 
        <emphasis>closure</emphasis>, a concept from functional programming. 
        We say that method and attribute definitions receive a closure of 
        immutable values defined in the class body to which they belong.
        That's just a fancy way of obfuscating the idea that 
        <literal>greeting</literal> holds onto the value of 
        <literal>name</literal>, even after the initializer completes.</para>
        
        </section>
        
        <section>
            <title>Instantiating classes and overloading their initialization parameters</title>
         
        <para>Oops, I got so excited about attributes and closure that I forgot to show 
        you the code that uses <literal>Hello</literal>!</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    Hello(process.args.first).say(process);
}]]></programlisting>
        
        <para>Our rewritten <literal>hello()</literal> method just creates a new instance
        of <literal>Hello</literal>, and invokes <literal>say()</literal>. Ceylon doesn't 
        need a <literal>new</literal> keyword to know when you're instantiating a class. 
        No, we don't know why Java needs it. You'll have to ask James.</para>
        
        <para>I suppose you're worried that if Ceylon classes don't have constructors,
        then they also can't have multiple constructors. Does that mean we can't overload
        the initialization parameter list of a class? Well, not exactly. Ceylon doesn't
        have constructor overloading, but it does have <emphasis>class overloading</emphasis>.
        Believe it or not, Ceylon lets you write multiple classes with the same name! Let's
        overload <literal>Hello</literal>:</para>
        
        <programlisting><![CDATA[doc "A command line greeting"
class Hello(Process process) 
    extends Hello(process.args.first) {}]]></programlisting>
    
        <para>A class can overload a second class by extending it and declaring different
        initialization parameters. An overloaded class with an empty body is the Ceylon
        approach to "constructor" overloading. Of course, overloaded classes can do much
        more than just this!</para>
        
        <para>Our <literal>hello()</literal> method is now looking <emphasis>really</emphasis>
        simple:</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello(Process process) {
    Hello(process).say(process);
}]]></programlisting>
        
        </section>
        
        <section>
            <title>Inheritance and overriding</title>
        
            <para>In object-oriented programming, we often replace conditionals 
            (<literal>if</literal>, and especially <literal>switch</literal>) with
            subtyping. Let's try refactoring <literal>Hello</literal> into two classes,
            with two different implementations of <literal>greeting</literal>:</para>
            
            <programlisting><![CDATA[doc "A default greeting"
class DefaultHello() {
    
    doc "The greeting"
    package default String greeting = "Hello, World!";
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>Notice that Ceylon forces as to declare attributes or methods that can be 
            overridden by annotating them <literal>default</literal>.</para>
            
            <para>Subclasses specify their superclass using the <literal>extends</literal>
            keyword, followed by the name of the superclass, followed by a list of arguments
            to be sent to the superclass initialization parameters. It looks just like an
            expression that instantiates the superclass:</para>
            
            <programlisting><![CDATA[doc "A personalized greeting"
class PersonalizedHello() extends DefaultHello() {
    
    doc "The personalized greeting"
    override String greeting { 
        return "Hello, " name "!" 
    }
    
}]]></programlisting>

            <para>Ceylon also forces us to declare that an attribute or method overrides an 
            attribute or method of a superclass by annotating it <literal>override</literal>. 
            All this annotating stuff costs a few extra keystrokes, but it helps the compiler
            detect errors. We can't inadvertantly override a member or the superclass, or
            inadvertantly <emphasis>fail</emphasis> to override it.</para>
            
            <para>On the other hand, we don't need to declare the visibility of the attribute
            annotated <literal>override</literal>. The <literal>package</literal> annotation
            is inherited from the attribute it overrides.</para>
            
            <para>There's one problem with what we've just seen. A personalized greeting 
            is not really a kind of default greeting. This is a case for introducing an
            abstract superclass:</para>

            <programlisting><![CDATA[doc "A greeting"
abstract class Hello() {
    
    doc "The (abstract) greeting"
    package String greeting;
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>Ceylon requires us to annotate abstract classes <literal>abstract</literal>,
            just like Java. This annotation specifies that a class cannot be instantiated,
            and can define abstract members. Unlike Java, Ceylon doesn't require us to annotate 
            abstract members&mdash;simply leaving out the implementation of the member is 
            perfectly sufficient for the compiler to realize that it is abstract. An attribute
            which is never initialized is an abstract attribute. Ceylon doesn't have default
            attribute values like Java does.</para>

            <para>One way to define an implementation for an inherited abstract attribute is 
            to simply assign a value to it in the subclass.</para>

            <programlisting><![CDATA[doc "A default greeting"
class DefaultHello() extends Hello() {
    
    greeting = "Hello, World!";
    
}]]></programlisting>

        <para>Of course, we can also define an implementation for an inherited abstract 
        attribute by overriding it.</para>

        <programlisting><![CDATA[doc "A personalized greeting"
class PersonalizedHello() extends Hello() {
    
    doc "The personalized greeting"
    override String greeting { 
        return "Hello, " name "!" 
    }
    
}]]></programlisting>

        </section>
        
        <section>
            <title>Working with mutable state</title>

            <para>Ceylon encourages you to use <emphasis>immutable</emphasis> attributes
            as much as possible. An immutable attribute has its value specified when 
            the object is initialized, and is never reassigned. If we want to be able to
            assign a value to a simple attribute we need to annotate it 
            <literal>mutable</literal>:</para>
            
            <programlisting>package mutable String greeting := "Hello World";
if (exists name) {
    greeting := "Hello, " name "!";
}</programlisting>

            <para>Notice the use of <literal>:=</literal> instead of <literal>=</literal>
            here. This is important! In Ceylon, specification of an immutable value is 
            done using <literal>=</literal>. Assignment to a <literal>mutable</literal> 
            attribute or local is considered a different kind of thing, always performed 
            using the <literal>:=</literal> operator.</para>
            
            <para>To force you to think twice before adding a <literal>mutable</literal>
            attribute to your class, Ceylon requires that classes with mutable attributes
            be explicitly annotated <literal>mutable</literal>. Hopefully, you'll find
            yourself doing this less frequently than you would do it in Java.</para>
            
            <para>If we want to make an attribute with a getter mutable, we need to 
            define a matching <emphasis>setter</emphasis>. Usually this is only useful
            if you have some other internal attribute you're trying to set the value of
            indirectly.</para>
            
            <para>Suppose our class has the following mutable simple attribute, intended
            for internal consumption only:</para>
            
            <programlisting>mutable String grtng := "Hello World";</programlisting>
            
            <para>Then we can abstract the simple attribute using a mutable attribute
            defined as a getter/setter pair:</para>
            
            <programlisting>doc "gets the greeting"
public String greeting { 
    return grtng 
}

doc "sets the greeting"
package assign greeting { 
    grtng = greeting; 
}</programlisting>

            <para>Yes, this is a <emphasis>lot</emphasis> like a Java get/set method pair.
            But since Ceylon attributes are mutable, and since you can redefine a simple
            attribute as a getter or getter/setter pair without affecting clients that
            call the attribute, you rarely need to write this code unless you're doing
            something special in the getter or setter. So here's a more realistic 
            example:</para>
       
            <programlisting>doc "gets the greeting"
public String greeting { 
    return grtng 
}

doc "sets the greeting"
package assign greeting {
    if (empty greeting) {
        throw IllegalArgumentException("greeting can not be empty)
    }
    else {
        grtng = greeting.strip().normalize();
    }
}</programlisting>

            <para>Get used to using <literal>empty</literal> to check that a value of type 
            <literal>String</literal> or <literal>String?</literal> is an actual non-empty
            string of characters. It's much more readable than the equivalent Java idiom
            <literal>!"".equals(greeting)</literal>.</para>
            
        </section>
        
        <section>
            <title>Using numeric types</title>
            
            <para>Ceylon doesn't have anything like Java's primitive types. The types that
            represent numeric values are just ordinary classes. Ceylon has fewer numeric
            types than other C-like languages:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>Natural</literal> represents the unsigned integers 
                    and zero,</para>
                </listitem>
                <listitem>
                    <para><literal>Integer</literal> represents signed integers,</para>
                </listitem>
                <listitem>
                    <para><literal>Float</literal> represents floating point decimal 
                    numbers,</para>
                </listitem>
                <listitem>
                    <para><literal>Whole</literal> represents arbitrary-precision signed 
                    integers, and</para>
                </listitem>
                <listitem>
                    <para><literal>Decimal</literal> represents arbitrary-precision and 
                    arbitrary-scale decimals.</para>
                </listitem>
            </itemizedlist>
            
            <para><literal>Natural</literal>, <literal>Integer</literal> and 
            <literal>Float</literal> have 64-bit precision by default. You can specify that 
            a value has 32-bit precision by annotating it <literal>small</literal>.</para>
            
            <para>There are only two kinds of numeric literals: literals for 
            <literal>Natural</literal>s, and literals for <literal>Float</literal>s:</para>
            
            <programlisting>Natural one = 1;</programlisting>
            <programlisting>Float oneHundredth = 0.01;</programlisting>
            <programlisting>Float oneMillion = 1.0E+6;</programlisting>
            
            <para>Widening type conversions are implicit, since the <literal>lang</literal> 
            package defines a set of built-in <emphasis>extensions</emphasis> (a concept 
            we'll meet later) that take care of this:</para>
            
            <programlisting>Decimal oneTenth = 0.1;</programlisting>
            <programlisting>Whole zero = 0;</programlisting>            
            <programlisting>Integer minusOne = -1;</programlisting>
            
            <para>To perform a narrowing type conversion, you need to call one of the 
            operations (well, they're attributes, actually) defined by the interface
            <literal>Number</literal>:</para>
            
            <programlisting>Natural one = 1.003.natural;</programlisting>
            <programlisting>Integer int = whole.integer;</programlisting>
            
            <para>Of course, a narrowing conversion can result in an exception at run 
            time, so take care!</para>
            
            <para>You can use all the operators you're used to from other C-style languages
            with the numeric types. You can also use the <literal>**</literal> operator to
            raise a number to a power:</para>
            
            <programlisting>Float diagonal = sqrt(length**2+width**2);</programlisting>
            
            <para>Of course, if you want to use the increment <literal>++</literal> operator,
            decrement <literal>--</literal> operator, or one of the compound assignment
            operators such as <literal>+=</literal>, you'll have to declare the value 
            <literal>mutable</literal>.</para>
            
            <programlisting>module class Counter() {
            
    mutable Natural count := 0;

    module Natural next() {
        return ++count
    }

}</programlisting>
            
            <para>You can even apply the bitwise and, or, xor, and complement operators
            to the type <literal>Natural</literal>:</para>
            
            <programlisting>Natural result = color&amp;mask;</programlisting>
            
            <para>Operators in Ceylon are, in principle, just abbreviations for some expression
            involving a method call. So the numeric types all implement the <literal>Numeric</literal> 
            interface, which declares the methods <literal>plus()</literal>, <literal>minus()</literal>,
            <literal>times()</literal>, <literal>divided()</literal> and <literal>power()</literal>.
            The numeric operators are defined in terms of these methods of <literal>Numeric</literal>.
            And <literal>Natural</literal> gets its bitwise operations from the <literal>Bits</literal>
            interface.</para>
            
            <para>But don't worry about the performance implications of this&mdash;in practice, 
            the compiler is permitted to optimize away the method invocations. In fact, the compiler
            is permitted to optimize the built-in numeric types down to the virtual machine's native
            numeric types.</para>
            
            <para>The real value of <literal>Numeric</literal> is that you can implement the
            interface yourself, to introduce your own, more specialized numeric type. And you'll
            be able to apply all the usual numeric operators to it. This is what we call 
            <emphasis>operator polymorphism</emphasis>.
            <!--It's not quite the same thing as operator
            overloading, which refers to the ability to assign any arbitrary meaning to any symbol
            on the keyboard.--></para>
            
        </section>

        <section>
            <title>A quick overview of collections</title>
            
            <para>The collections package is one of the best features of Ceylon. Let's briefly 
            meet some of the main characters.</para>
            
            <para>There's no arrays in Ceylon, but you can write the following code:</para>
            
            <programlisting>String[] voyage = { "Melbourne", "San Francisco", "Atlanta", "Guanajuato" };
String? sf = voyage[2];
String[] usLeg = voyage[1..2];
String[] longerVoyage := voyage + { "Rome", "Paris", "Edinburgh" };</programlisting>
            
            <para>The syntax <literal>String[]</literal> is just an abbreviation for the 
            type <literal>Sequence&lt;String&gt;</literal>. Don't be scared by the fancy 
            syntax&mdash;it's just sugar. There's actually nothing much special about the 
            interface <literal>Sequence</literal> from the point of view of the type system. 
            But sequences of values are a common occurrence in computing, so Ceylon provides 
            a streamlined syntax for dealing with them.</para>
            
            <para>Just like in Java, the collection types are <emphasis>parameterized</emphasis> 
            or <emphasis>generic</emphasis> types. Unlike Java, there are no raw types&mdash;if
            a type declares type parameters, a type argument for each parameter is required
            everywhere the type is used. For example, the following declaration is not legal:</para>
            
            <programlisting>Sequence voyage = { "Atlanta", "Boston", "San Francisco" };  //error! missing type argument</programlisting>
            
            <para>The closest thing to a raw type, in this case, would be to use a <literal>Sequence&lt;Object&gt;</literal>.</para>
            
            <programlisting>Sequence&lt;Object&gt; voyage = { "Atlanta", "Boston", "San Francisco" };</programlisting>
            
            <para>Which we could abbreviate, of course:</para>
            
            <programlisting>Object[] voyage = { "Atlanta", "Boston", "San Francisco" };</programlisting>
            
            <para>Sequences of ordinal values are especially common, so there's an
            operator for constructing them, called the <emphasis>range</emphasis>
            operator:</para>
            
            <programlisting>Natural[] from1To10 = 1..10;</programlisting>
            <programlisting>Integer[] fromNegative10To10 = -10..10;</programlisting>
            <programlisting>Character[] fromAToZ = @A..@Z;</programlisting>

            <para>We can iterate a <literal>Sequence</literal> like this:</para>
            
            <programlisting>for (String city in voyage) {
    stream.writeLine(city):
}</programlisting>

            <para>If, for some reason, we need access to the index of each element, we can
            write the following:</para>
            
            <programlisting>for (Natural i -> String city in voyage) {
    stream.writeLine($i + ": " + city):
}</programlisting>

            <para>(The <literal>$</literal> operator converts an object to a string.)</para>
            
            <para>Sometimes the keys of our collection elements aren't natural numbers, 
            so we need something other than a <literal>Sequence</literal>:</para>
            
            <programlisting>Correspondence&lt;String,String&gt; cities = { "Emmanuel"->"Paris",
                                           "Andrew"->"Cambridge", 
                                             "Pete"->"Edinburgh",
                                            "Gavin"->"Guanajuato" };</programlisting>
                              
            <para>We can extract values from a <literal>Correspondence</literal> by key 
            using the lookup operator:</para>

            <programlisting>String? paris = cities["Emmanuel"];</programlisting>
            
            <para>Notice that the lookup operator returns an <literal>Optional</literal>
            result, to account for the possibility that there is no value defined for
            the given key.</para>

            <para>We can iterate a <literal>Correspondence</literal> like this:</para>

            <programlisting>for (Entry&lt;String,String&gt; entry in cities) {
    stream.writeLine(entry.key + " lives in " + entry.value);
}</programlisting>

            <para>Or, much more commonly:</para>
            
            <programlisting>for (String person -> String city in cities) {
    stream.writeLine(name + " lives in " + city):
}</programlisting>

            <para>So far we haven't met anything from the collections package proper. 
            <literal>Sequence</literal> and <literal>Correspondence</literal> are part 
            of the package <literal>lang</literal>. They're there to abstract away the
            nice syntax we've just met from the (relatively) gory details of the collections 
            package.</para>
            
            <para>Inside the collections package you'll find some interfaces with pretty
            familiar names: <literal>Collection</literal>, <literal>Set</literal>, 
            <literal>List</literal> and <literal>Map</literal>. (There's even a
            <literal>Bag</literal>.) But these interfaces aren't quite what you're used 
            to from Java. Most importantly, none of them provide operations to change
            the elements of the collection. If you need to mutate a collection, you'll
            need one of their evil twins: <literal>OpenCollection</literal>, 
            <literal>OpenSet</literal>, <literal>OpenList</literal> and 
            <literal>OpenMap</literal> (and we can't forget <literal>OpenBag</literal>).</para>
            
            <para>A <literal>Map</literal> is the most important kind of 
            <literal>Correspondence</literal>. We can add or override entries in an 
            <literal>OpenMap</literal> using the assignment operator:</para>
            
            <programlisting><![CDATA[OpenMap<String,String> cities = {}
cities["Gavin"] := "Guanajuato";
cities["Emmanuel"] := "Paris";
cities["Pete"] := "Edinburgh";
cities["Andrew"] := "Cambridge";]]></programlisting>
            
            <para>It's even possible to define multiple entries at once:</para>
            
            <programlisting><![CDATA[OpenMap<String,String> cities = {}
cities.define("Emmanuel"->"Paris",
                 "Gavin"->"Guanajuato",
                  "Pete"->"Edinburgh",
                "Andrew"->"Cambridge");]]></programlisting>
            
            <para>The <literal>-></literal> operator constructs an <literal>Entry</literal>
            from its operands. A <literal>Map</literal> is a <literal>Collection</literal> 
            of <literal>Entry</literal>s.</para>
            
            <para>A <literal>List</literal> is the most important kind of 
            <literal>Sequence</literal>. We usually add entries to an 
            <literal>OpenList</literal> using the <literal>append()</literal> method:</para>
            
            <programlisting><![CDATA[OpenList<String> voyage = {}
voyage.append("Melbourne");
voyage.append("San Francisco");
voyage.append("Atlanta);]]></programlisting>
            
            <para>It's even possible to add multiple elements at once:</para>
            
            <programlisting><![CDATA[OpenList<String> voyage = {}
voyage.append("Melbourne", "San Francisco", "Atlanta");]]></programlisting>

            <para>We can also change the value at a particular index in an 
            <literal>OpenList</literal>:</para>
            
            <programlisting><![CDATA[voyage[1] := "Los Angeles";]]></programlisting>
            
            <para>Splitting the collection interfaces into a "read-only" view and a
            "writable" view has several advantages, but the most important is that you
            now don't need to worry about exposing collections as part of the public 
            contract of your classes. In Java, it's always difficult for a client to 
            know if you're returning a copy of your internal list, a reference to your
            internal list (which you might have done inadvertantly), or a reference 
            wrapped in an <literal>immutableList()</literal>&mdash;you know, that wonderful 
            beastie which helpfully throws exceptions at runtime to let you know that it 
            is supposed to be "read-only". In Ceylon, you can protect the state of your 
            internal data structures by simply not returning the "writable" view to 
            clients. Send them back a <literal>List</literal>, and they know what they're 
            allowed to do with it.</para>
        
        </section>
        
        <section>
            <title>Taking advantage of functional-style programming</title>
        
        <para>Let's go back, once again, to the attribute <literal>greeting</literal> 
        of <literal>Hello</literal>:</para>
        
        <programlisting><![CDATA[package String greeting {
    if (exists name) {
        return "Hello, " name "!"
    }
    else {
        return "Hello, World!"
    }
}]]></programlisting>

        <para>This definition works
        well enough, but it's quite procedural, with two <literal>return</literal>
        statements. That's not usually considered good style in Ceylon, though
        there are certainly times when it's necessary. Instead, Ceylon lets you
        write code like this using a more functional style.</para>
        
        <para>In procedural
        programming we usually pass a list of values to a method, which performs 
        computations using those values, and returns another value. In functional
        programming, we can pass an operation to a method, which calls our
        operation, and returns a value, or, perhaps, a different operation.</para>
        
        <para>For example, the Ceylon standard librares define a method called
        <literal>ifExists()</literal> that accepts an object and two 
        <emphasis>callable objects</emphasis>. (A method parameter that accepts 
        a callable objects is called a <emphasis>callable parameter</emphasis>.)
        If the object is not null, <literal>ifExists()</literal> invokes the first
        method. Otherwise, <literal>ifExists()</literal> invokes the second method.
        We can use <literal>ifExists()</literal> to rewrite 
        <literal>greeting</literal>:</para>

<programlisting><![CDATA[package String greeting {
    String helloName() { return "Hello, " name "!" }
    String helloWorld() { return "Hello, World!" }
    return ifExists(name, helloName, helloWorld)
}]]></programlisting>

        <para>Well, that's certainly more functional, but it's also a lot more
        verbose. But this is not the way <literal>ifExists()</literal> is really
        intended to be used. Ceylon provides a special method argument syntax
        for defining a method that is passed to another method inline, as part
        of the invocation. An inline method definition is called an
        <emphasis>inline callable argument</emphasis>. Inline callable arguments 
        follow the normal parenthesized argument list.</para>
        
        <para>As a first step, we could rewrite <literal>greeting</literal> 
        as follows, to make it really clear that we're defining methods that are 
        passed as arguments to the callable parameters <literal>then</literal> 
        and <literal>otherwise</literal>.</para>

<programlisting><![CDATA[package String greeting {
    return ifExists(name)
        //first inline callable argument
        then () {
            return "Hello, " name "!"
        }
        //second inline callable argument
        otherwise () {
            return "Hello, World!"
        }
}]]></programlisting>

        <para>Note that there are three <literal>return</literal> statements
        here. The nested <literal>return</literal> statements specify the 
        return values of the two inline methods. They do not end the execution
        of <literal>greeting</literal>!</para>

        <para>This syntax was chosen to make it possible to define new
        control structures that closely mimic the syntactic form of the
        traditional C-style built-in control structures.</para>
        
        <para>Usually, we would abbreviate the above code by:</para>
        
        <itemizedlist>
            <listitem>
                <para>eliminating the empty formal parameter lists&mdash;we 
                can leave off the <literal>()</literal>, and</para>
            </listitem>
            <listitem>
                <para>specifying the method return values in parentheses, 
                instead of writing <literal>return</literal> statements
                surrounded by braces&mdash;we're allowed to write
                <literal>("Hello, World!")</literal> instead of 
                <literal>{ return "Hello, World!" }</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The abbreviated code looks like this:</para>

<programlisting><![CDATA[package String greeting {
    return ifExists(name) 
        then ("Hello, " name "!")
        otherwise ("Hello, World!")
}]]></programlisting>
        
        <para>This syntax might look a little unfamiliar at first, but 
        you'll soon get used to it. In Ceylon, we use method invocations 
        with inline callable arguments to express things that are difficult
        to express without specialized syntax in other languages, for
        example:</para>
        
        <itemizedlist>
            <listitem>
                <para><emphasis>assertion</emphasis>, such as: 
                <literal>assert() that (x==0.0);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>comprehension</emphasis>, such as:
                <literal>String[] names = from (people) select (Person p) (p.name);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>quantification</emphasis>, such as:
                <literal>Boolean adults = forAll (people) every (Person p) (p.age>=18);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>repetition</emphasis>, such as:
                <literal>repeat (3) times { stream.writeLine("Hello!"); }</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>Look at each of these examples, and ask yourself:</para>
        
        <itemizedlist>
            <listitem>
                <para>What is the name of the method that is being called?</para>
            </listitem>
            <listitem>
                <para>Are there any ordinary arguments? Which are they?</para>
            </listitem>
            <listitem>
                <para>Which is the inline callable argument? What is its name?</para>
            </listitem>
            <listitem>
                <para>Are there any formal parameters of the inline callable argument? 
                What are the parameter names?</para>
            </listitem>
            <listitem>
                <para>Where is the implementation of the inline callable argument?
                What happens when the inline callable argument is invoked?</para>
            </listitem>
        </itemizedlist>
        
        <para>By the way, there's an even easier way to define 
        <literal>greeting</literal>, using the <literal>?</literal>
        operator.</para>
        
<programlisting><![CDATA[package String greeting {
    return "Hello, " (name ? "World") "!"
}]]></programlisting>
    
        </section>
        
        <section>
            <title>Defining user interfaces declaratively</title>

        <para>Finally, lets create a web-based user interface for our
        program.</para>
        
        <para>We've seen lots of examples of invoking a method or instantiating
        a class using the traditional C-style argument list where arguments are
        surrounded in parentheses and separated by commas. Arguments are matched
        to parameters by their position in the list. Using this syntax, we could
        create a tree of objects as follows:</para>
        
        <programlisting>Html(
    Head('hello.css', "Hello World"),
    Body(
        Div("greeting", "Hello World"),
        Div("footer", "Powered by Ceylon")
    )
)</programlisting>

        <para>However, Ceylon provides an alternative way of writing
        argument lists that makes it much more natural to define heirarchical
        structures. A <emphasis>named argument list</emphasis> is a list of 
        arguments surrounded by braces and separated by semicolons. Varargs 
        parameters in a named argument list don't need names, and are 
        separated by commas. For example:</para>

        <programlisting>Html {
    head = Head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    };
    body = Body {
        Div {
            cssClass = "greeting";
            "Hello World" 
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon" 
        }
    };
}</programlisting>
        
        <para>We're going to use this syntax to define our web page.</para>
        
        <programlisting><![CDATA[import html.*;

doc "A web page that displays a greeting"
page '/hello.html'
public class HelloHtml(Request request) 
        extends Html(request) {

    Hello hello = Hello(request.parameters["name"]);
    
    head = Head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    };
    body = Body {
        Div {
            cssClass = "greeting";
            hello.greeting
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon"
        }
    };

}]]></programlisting>

        <para>This program demonstrates Ceylon's support for defining structured 
        data, in this case, HTML. The <literal>HelloHtml</literal> class extends 
        Ceylon's <literal>Html</literal> class and specified its abstract 
        <literal>head</literal> and <literal>body</literal> attributes. The 
        <literal>page</literal> annotation specifies the URL at which this HTML 
        should be accessible. A single-quoted string literal is used, allowing the 
        format of the URL to be validated by the Ceylon compiler.</para>

    </section>
    
    <section>
        <title>Defining structured data formats</title>
        
        <para>Let's try and define our own structured data format, to personalize
        our program a little. First, we'll create a class to represent people:</para>
        
        <programlisting>doc "Represents a person"
package class Person(String firstName, String lastName, Language lang) {
    package String firstName = firstName;
    package String lastName = lastName;
    package Language lang = lang;
}</programlisting>
        
        <para>Now, we'll create a class with an <emphasis>enumerated list of 
        instances</emphasis>&mdash;almost exactly like a Java 
        <literal>enum</literal>&mdash;to represent the built-in languages that
        our program supports.</para>
        
        <programlisting>doc "Represents a language"
package class Language(String hello) {

    english("Hello"),
    french("Bonjour"),
    spanish("Hola"),
    italian("Ciao")
    ...
    
    doc "The word for \"hello\" in the language"
    package String hello = hello;
    
}</programlisting>

        <para>The use of <literal>...</literal> at the end of the list of enumerated
        instances means that it's possible to create other <literal>Language</literal>s.
        Very important in this case, since our list of languages is definitely not 
        exhaustive! If our list of instances were exhaustive, we would terminate it
        using <literal>;</literal>, thereby preventing other code from instantiating
        additional <literal>Language</literal>s.</para>
        
        <para>Now we can define the set of people known to our application like
        this:</para>
        
        <programlisting>Set&lt;Person&gt; people = {
        Person {
            firstName = "Gavin";
            lastName = "King";
            language = Language.english;
        },
        Person {
            firstName = "Emmanuel";
            lastName = "Bernard";
            lang = Language.french;
        },
        Person {
            firstName = "Pete";
            lastName = "Muir
            lang = Language.english;
        },
        Person {
            firstName = "Andrew";
            lastName = "Haley";
            lang = Language.english;
        }
    };</programlisting>
    
        <para>But where should we put our list of people? Well, just for fun, let's
        specify them using an annotation of <literal>Hello</literal>. First we'll 
        need to learn how to define new annotations.</para>
        
    </section>
    
    <section>
        <title>Defining annotations</title>
        
        <para>In Ceylon, an annotation is just a method that produces an ordinary 
        type. An annotation for specifying a set of people could be defined like 
        this:</para>
        
        <programlisting>doc "An annotation for specifying a list of 
     people"
annotation { 
    of = classes; 
    withType = #Greeting; 
    occurs = onceEachType; 
}
package Set&lt;People&gt; people(Person... people) {
    return HashSet(people);
}</programlisting>

        <para>The meta-annotation <literal>annotation</literal> specifies that this 
        annotation can only occur an the class <literal>Greeting</literal>, and can 
        only occur once.</para>

        <para>We obtain the annotations of a program element&mdash;in this case, the 
        class <literal>Greeting</literal>&mdash;using reflection upon the metamodel 
        object&mdash;<literal>#Greeting</literal>&mdash;that represents the program 
        element. We must specify the type returned by the annotation, by passing its 
        metamodel object&mdash;in this case, <literal>#Set&lt;People&gt;</literal>.
        Careful, there may be multiple annotations producing the same type of object!</para>
        
        <programlisting>Set&lt;People&gt;[] annotations = (#Greeting).annotations(#Set&lt;People&gt;);</programlisting>
        
        <para>We're already ready to use our new annotation. Just like with other 
        method invocations, we have the choice between specifying the arguments of 
        an annotation using a positional parameter list surrounded by parenthesis, 
        or using a named parameter list surrounded by braces. In this case, the 
        braces look more visually appealing:</para>
        
        <programlisting>doc "A personalized greeting"
people {
    Person {
        firstName = "Gavin";
        lastName = "King";
        language = Language.english;
    },
    Person {
        firstName = "Emmanuel";
        lastName = "Bernard";
        lang = Language.french;
    },
    Person {
        firstName = "Pete";
        lastName = "Muir
        lang = Language.english;
    },
    Person {
        firstName = "Andrew";
        lastName = "Haley";
        lang = Language.english;
    }
}
class Hello(String? name) {

    Set&lt;People&gt;? annotation = type.annotations(#Set&lt;People&gt;).first
    
    doc "The list of people"
    Set&lt;People&gt; people;
    if (exists annotation) {
        people = annotation;
    }
    else {
        throw Exception("Not annotated people")
    }
    
    doc "The greeting"
    package String greeting {
        if (exists name) {
            Person? person = first (people) 
                    having (Person p) (p.firstName==name);
            if (exists person) {
                return "" person.lang.hello ", " 
                    person.firstName " " person.lastName "!"
            }
            else {
                return "Hello, " name "!";
            }
        }
        else {
            return "Hello, World!";
        }
    }
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}</programlisting>
        
    </section>
    
    <section>
        <title>Generic types and covariance</title>
        
        <para>Programming with generic types is one of the most difficult parts of
        Java. That's still true, to some extent, in Ceylon. But because the Ceylon
        language and SDK were designed for generics from the ground up, Ceylon
        is able to eliminate one of the bits of Java generics that's really 
        hard to get your head around: wildcard types. Wildcard types were Java's
        solution to the problem of <emphasis>covariance</emphasis> in a generic
        type system. Let's first explore the idea of covariance, and then see how
        Ceylon's solution, copied from Scala, works.</para>
        
        <para>It all starts with the intuitive expectation that a collection of
        <literal>Geek</literal>s is a collection of <literal>Person</literal>s.
        That's a reasonable intuition, but in procedural languages, where 
        collections can be mutable, it turns out to be incorrect. Consider the
        following possible definition of <literal>Collection</literal>:</para>
        
        <programlisting>interface Collection&lt;X&gt; {
    Iterator&lt;X&gt; iterator();
    void add(X x);
}</programlisting>

        <para>And let's suppose that <literal>Geek</literal> is a subtype of 
        <literal>Person</literal>.</para>
        
        <para>The intuitive expectation is that the following code should work:</para>
        
        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Collection&lt;Person&gt; people = geeks;   //compiler error
for (Person person in people.iterator()) { ... }</programlisting>
        
        <para>This code is, frankly, perfectly reasonable taken at face value. Yet
        in both Java and Ceylon, this code results in a compiler error at the 
        second line, where the <literal>Collection&lt;Geek&gt;</literal> is assigned 
        to a <literal>Collection&lt;Person&gt;</literal>. Why? Well, because if we 
        let the assignment through, the following code would also compile:</para>
        
        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Collection&lt;Person&gt; people = geeks;   //compiler error
people.add( Person("Fonzie") );</programlisting>

        <para>We can't let that code by&mdash;Fonzie isn't a <literal>Geek</literal>!</para>
        
        <para>Using big words, we say that <literal>Collection</literal> is
        <emphasis>nonvariant</emphasis> in <literal>X</literal>. Or, when we're not
        trying to impress people with opaque terminology, we say that 
        <literal>Collection</literal> both <emphasis>produces</emphasis>&mdash;via the
        <literal>iterator()</literal> method&mdash;and <emphasis>consumes</emphasis>&mdash;via
        the <literal>add()</literal> method&mdash;instances of <literal>X</literal>.</para>
        
        <para>Here's where Java goes off and dives down a rabbit hole, inventing 
        wildcards to try and squeeze a covariant or contravariant type out of a 
        nonvariant type, but mainly succeeding in thoroughly confusing everybody.
        We're not going to follow Java down the hole.</para>
        
        <para>Instead, we're going to refactor <literal>Collection</literal> into
        a pure producer interface and a pure consumer interface:</para>
        
        <programlisting>interface Producer&lt;out X&gt; {
    Iterator&lt;X&gt; iterator();
}</programlisting>

        <programlisting>interface Consumer&lt;in X&gt; {
    void add(X x);
}</programlisting>

        <para>Notice that we've annotated the type parameters of these interfaces.</para>
        
        <itemizedlist>
            <listitem>
                <para>The <literal>out</literal> annotation specifies that 
                <literal>Producer</literal> is <emphasis>covariant</emphasis>
                in <literal>X</literal>; that it produces instances of 
                <literal>X</literal>, but never consumes instances of 
                <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>The <literal>in</literal> annotation specifies that 
                <literal>Consumer</literal> is <emphasis>contravariant</emphasis>
                in <literal>X</literal>; that it consumes instances of 
                <literal>X</literal>, but never produces instances of 
                <literal>X</literal>.</para>
            </listitem>
        </itemizedlist>
        
        
        <para>The Ceylon compiler validates the schema of the type declaration to 
        ensure that the variance annotations are satisfied. If you try to declare 
        an <literal>add()</literal> method on <literal>Producer</literal>, a
        compilation error results. If you try to declare an <literal>iterate()</literal>
        method on <literal>Consumer</literal>, you get a similar compilation 
        error.</para>
        
        <para>Now, let's see what that buys us:</para>
        
        <itemizedlist>
            <listitem>
        <para>Since <literal>Producer</literal> is covariant in its type parameter
        <literal>X</literal>, and since <literal>Geek</literal> is a subtype 
        of <literal>Person</literal>, Ceylon lets you assign
        <literal>Producer&lt;Geek&gt;</literal> to 
        <literal>Producer&lt;Person&gt;</literal>.</para>
            </listitem>
            <listitem>
        <para>Furthermore, 
        since <literal>Consumer</literal> is contravariant in its type parameter
        <literal>X</literal>, and since <literal>Geek</literal> is a subtype 
        of <literal>Person</literal>, Ceylon lets you assign
        <literal>Consumer&lt;Person&gt;</literal> to 
        <literal>Consumer&lt;Geek&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>We can define our <literal>Collection</literal> interface as a
        mixin of <literal>Producer</literal> with <literal>Consumer</literal>.</para>
        
        <programlisting>interface Collection&lt;X&gt; 
        satisfies Producer&lt;X&gt;, Consumer&lt;X&gt; {}</programlisting>
        
        <para>Notice that <literal>Collection</literal> remains nonvariant in
        <literal>X</literal>.</para>
        
        <para>Now, the following code finally compiles:</para>

        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Producer&lt;Person&gt; people = geeks;
for (Person person in people.iterator()) { ... }</programlisting>

        <para>Which matches our original intuition.</para>

        <para>The following code also compiles:</para>
        
        <programlisting>Collection&lt;Person&gt; people = ... ;
Consumer&lt;Geek&gt; geekConsumer = people;
geekConsumer.add( Geek("James Gosling") );</programlisting>

        <para>Which is also intuitively correct&mdash;James is most certainly
        a <literal>Person</literal>!</para>
        
        <para>You're unlikely to spend much time writing your own collection
        classes, since the Ceylon SDK has a powerful collections framework
        built in. But you'll still appreciate Ceylon's approach to covariance
        as a user of the built-in collection types. The collections framework 
        defines two interfaces for each basic kind of collection. For example, 
        there is an interface <literal>List&lt;X&gt;</literal> which represents 
        a read-only view of a list, and is covariant in <literal>X</literal>, 
        and <literal>OpenList&lt;X&gt;</literal>, which represents a mutable 
        list, and is nonvariant in <literal>X</literal>.</para>
        
    </section>
    
    <section>
        <title>Testing the type of an object</title>
        
        <para>Ceylon doesn't have C-style typecasts. Instead, we must test and 
        narrow the type of an object in one step, using the special <literal>if (is ... )</literal> 
        construct. This construct is very, very similar to <literal>if (exists ... )</literal>, 
        which we met earlier.</para>
        
        <programlisting>Object object = ... ;
if (is Hello object) {
    object.say();
}</programlisting>
        
        <para>The <literal>switch</literal> statement supports a similar construct:</para>
        
        <programlisting>Object object = ... ;
switch(object)
case (is Hello) {
    object.say();
}
case (is Person) {
    stream.writeLine(object.firstName);
}
else {
    stream.writeLine($object);
}</programlisting>

        <para>These constructs protect us from inadvertantly writing code that 
        would cause a <literal>ClassCastException</literal> in Java, just like
        <literal>if (exists ... )</literal> protects us from writing code that
        would cause a <literal>NullPointerException</literal>.</para>
        
        <para>Another thing that causes problems when working with generic
        types in Java is <emphasis>type erasure</emphasis>. Generic type 
        arguments are discarded by the compiler, and simply aren't available
        at runtime. So the following, perfectly sensible, code fragments 
        simply wouldn't compile in Java:</para>
        
        <programlisting>if (is List&lt;Person&gt; list) { ... }</programlisting>
        <programlisting>if (is T object) { ... }</programlisting>
        <programlisting>Type&lt;T&gt; tType = #T;</programlisting>
        
        <para>(Where <literal>T</literal> is a generic type parameter.)</para>
        
        <para>You'll be pleased to know that in Ceylon, these three code
        fragments compile and function as expected.</para>
        
    </section>
    
    <section>
        <title>Introducing a new type to an object</title>
        
        <para>Ceylon doesn't have multiple inheritance or mixins. If you're used
        to the single-inheritance-with-interfaces model of Java, you'll find
        that inheritance in Ceylon works pretty much the same.</para>
        
        <para>However, Ceylon does have something else, that's usually almost as
        good as, and often better than, true multiple inheritance. An
        <emphasis>extension</emphasis> adds a type, call an <emphasis>introduced</emphasis>
        type, to an existing type, called the <emphasis>extended</emphasis> type.
        An extension doesn't change the original definition of the extended type,
        and it doesn't affect the internal workings of an object of that type in
        any way. But from the point of view of a client of the object, the object
        now has all the attributes and methods of the introduced type, and is
        assignable to the introduced type.</para>
        
        <para>Let's introduce a type onto every object. Ceylon's
        <literal>Object</literal> class defines an attribute named 
        <literal>log</literal> of type <literal>Log</literal> that you can use
        to log stuff. Usually, you use it like this:</para>
        
        <programlisting>log.debug("Hello, I'm a debug message");</programlisting>
        
        <para>But perhaps you don't like having to type the "<literal>log.</literal>"
        bit every time you write out a log message, and suppose you don't expect
        to ever need methods named <literal>info()</literal>, <literal>error()</literal>
        <literal>warn()</literal> or <literal>debug()</literal> in your application.
        If so, wouldn't it be nice to just write:</para>
        
        <programlisting>debug("Do you think anyone ever reads me?");</programlisting>
        
        <para>Obviously, one way to do this would be to copy and paste all the
        <literal>info()</literal>, <literal>error()</literal>
        <literal>warn()</literal> and <literal>debug()</literal> methods from
        <literal>Log</literal> onto <literal>Object</literal>, and have them
        delegate back to <literal>log</literal>. But we don't like copy/paste
        programming here.</para>
        
        <para>Another way might be to make <literal>Object</literal> extend 
        <literal>Log</literal>, but that way <literal>Log</literal>
        would be the logical root of the Ceylon type system, instead of 
        <literal>Object</literal>. That doesn't feel right.</para>
        
        <para>Instead, we're going to introduce <literal>Log</literal> onto
        <literal>Object</literal> using an extension. If we were able to modify 
        the code of <literal>Object</literal>, this would be as easy as adding 
        an <literal>extension</literal> annotation to the <literal>log</literal>,
        attribute like this:</para>
        
        <programlisting>public extension Log log { ... }</programlisting>
        
        <para>But since <literal>Object</literal> is built into the Ceylon SDK, 
        we don't have control over its code, and so we need to take a different 
        approach. We'll write a toplevel <emphasis>extension method</emphasis>,
        sometimes called a <emphasis>converter</emphasis>:</para>
        
        <programlisting>public extension Log objectToLog(Object o) { return o.log }</programlisting>
        
        <para>The extended type is the type of the parameter of the converter.
        The introduced type is the return type of the converter.</para>
        
        <para>Now, we can't just have hundreds of third-party extensions all
        vandalizing <literal>Object</literal> with their own introduced types,
        and polluting the namespace with thousands of introduced methods and
        attributes. So the client code that uses the extension is responsible
        for explicitly activating the extension in the compilation unit where
        it is used. To activate an extension we <literal>import</literal> 
        it.</para>
        
        <programlisting>import com.domain.util.objectToLog;
        
public class Hello(String? name) {

    ...
    
    info(greeting);
    
    ...

}</programlisting>

        <para>The compiler automatically inserts a call to 
        <literal>objectToLog()</literal>. So the above code is equivalent to:</para>

        <programlisting>public class Hello(String? name) {

    ...
    
    objectToLog(this).info(greeting);
    
    ...

}</programlisting>

        <para>A compilation unit that doesn't explicitly import 
        <literal>objectToLog</literal> won't be affected by the extension, and
        won't be able to call the <literal>info()</literal> method without
        explicitly invoking the <literal>log</literal> attribute.</para>
        
        <para>So you might think that extension are just a trivial trick that
        saves a few keystrokes of typing effort. But the history of Java 
        demonstrates why extensions are an important feature. Java defines its
        collections framework in terms of various interfaces, for example, 
        <literal>List</literal>, each with very many methods, mostly convenience 
        methods for the benefit of the user of these interfaces. Because 
        implementing the whole interface from scratch is a daunting task, the 
        collections framework includes abstract classes like 
        <literal>AbstractList</literal> that define a smaller contract for
        classes that implement the collection interfaces. But there's no way
        for the collections framework to force you to implement 
        <literal>AbstractList</literal> instead of implementing <literal>List</literal> 
        directly. And, of course, the world is now full of Java code that does
        implement <literal>List</literal> directly. Which means that introducing 
        a new method to the <literal>List</literal> interface is a huge breaking 
        change that affects a great deal of working, production code.</para>
        
        <para>Ceylon takes a different approach to its collection types. The 
        basic collection interfaces like <literal>List</literal> define a small
        set of operations. Convenience methods for users of the collections 
        framework are defined by built-in extensions. So we can add new convenience 
        methods whenever we like. And so can you!</para>
        
    </section>
    
    </section>
    
</chapter>