<chapter id="introduction">
    <title>Introduction</title>
    
    <para>This document defines the syntax and semantics of the Ceylon language.
    The intended audience includes compiler implementors, interested parties
    who wish to contribute to the evolution of the language, and experienced 
    developers seeking a precise definition of language constructs. However, in
    light of the newness of the language, we will begin with an overview of the
    main features of the language and SDK and a brief introduction to programming 
    in the language.</para>
    
    <section id="languageoverview">
        <title>Language overview</title>
    
    <para>
    Ceylon is a general-purpose, statically-typed, object-oriented, imperative, 
    higher-order language featuring a syntax similar to Java and C#. Ceylon 
    programs execute in any standard Java Virtual Machine and, like Java, take 
    advantage of the memory management and concurrency features of that 
    environment. The Ceylon compiler is able to compile Ceylon code that calls 
    Java classes or interfaces, and Java code that calls Ceylon classes or 
    interfaces. Ceylon improves upon the Java language and type system to 
    reduce verbosity and increase typesafety compared to Java and C#. Ceylon 
    encourages a more functional style of programming, resulting in code which 
    is easier to reason about, and easier to refactor. Moreover, Ceylon 
    provides its own native SDK as a replacement for the Java platform class 
    libraries.
    </para>
    
    <section id="thetypesystem">
    <title>The type system</title>
    
    <para>
    Ceylon features a similar inheritance and generic type model to Java. A type 
    is either an <emphasis>interface</emphasis>, a <emphasis>class</emphasis>, or
    a <emphasis>type parameter</emphasis>. An interface may extend an arbitrary 
    number of other interfaces. A class may implement an arbitrary number of 
    interfaces and must extend another class. A class or interface may declare 
    type parameters. A type parameter abstracts the definition of a class or 
    interface over all types which can be substituted for the type parameter.
    </para>
    
    <para>
    There are no primitive types or arrays in Ceylon&mdash;every Ceylon type can 
    be represented within the language itself. So all values are instances of the 
    type hierarchy root <literal>lang.Void</literal>. However, the Ceylon compiler 
    is permitted to optimize certain code to take advantage of the optimized 
    performance of primitive types on the JVM.
    </para>
    
    <para>
    Ceylon does not support Java-style wildcard type parameters or raw types. 
    Instead, like Scala, a type parameter may be marked as covariant or 
    contravariant by the class or interface that declares the parameter. Type 
    arguments are reified in Ceylon, eliminating many problems related to 
    type erasure in Java. 
    </para>
    
    <para>
    Ceylon supports <emphasis>type aliases</emphasis>, similar to C-style 
    <literal>typedef</literal>.
    </para>
    
    </section>
    
    <section id="compilerenforcednamingconventions">
    <title>Compiler-enforced naming conventions</title>
    
    <para>
    The Ceylon compiler enforces the traditional Smalltalk naming convention:
    type names begin with an initial uppercase letter&mdash;for example, 
    <literal>Liberty</literal> or <literal>RedWine</literal>&mdash;member names 
    and local names with an initial lowercase letter or underscore&mdash;for
    example, <literal>blonde</literal>, <literal>immanentize()</literal> or 
    <literal>boldlyGo()</literal>. This innovation allows a much cleaner 
    syntax for program element annotations than the syntax found in either Java 
    or C#.
    </para>
    
    </section>
    
    <section id="initializationandinstantiation">
    <title>Class initialization and instantiation</title>
    
    <para>
    Ceylon does not feature any Java-like constructor declaration and so 
    each Ceylon class has a formal parameter list, and exactly one 
    <emphasis>initializer</emphasis>&mdash;the body of the class. This helps
    reduce verbosity and results in a more regular block structure.
    </para>
    
    <para>
    In place of constructor overloading, Ceylon allows class names to be 
    overloaded. Even better, member classes of a class may be overridden by 
    subclasses. Instantiation is therefore a polymorphic operation in Ceylon, 
    eliminating the need for factory methods.
    </para>
    
    <para>
    Ceylon provides a streamlined syntax for defining an anonymous class which 
    is only instantiated in exactly the place it is defined. Among other uses,
    the <literal>object</literal> declaration is useful for creating singleton 
    objects or method-local interface implementations. 
    </para>
    
    </section>
    
    <section id="methodsandattributes">
    <title>Methods and attributes</title>
    
    <para>
    Ceylon types have members: <emphasis>methods</emphasis> and 
    <emphasis>attributes</emphasis>. Ceylon methods are similar to Java methods. 
    However, Ceylon classes do not contain fields, in the traditional sense. 
    Instead, Ceylon supports only a higher-level construct: polymorphic 
    attributes, which are similar to C# properties. Attributes abstract the
    internal representation of the state of an object.
    </para>
    
    <para>There are no <literal>static</literal> members. Instead, 
    <emphasis>toplevel</emphasis> methods and attributes are declared as direct 
    members of a package. This, along with certain other features, gives the 
    language a more regular block structure.
    </para>

    </section>
    
    <section id="defaultparameters">
    <title>Defaulted parameters</title>
    
    <para>
    As an alternative to method or class overloading, Ceylon supports method 
    and class initializer parameters with default values. 
    </para>
    
    </section>
    
    <section id="mixininheritance">
    <title>"Mixin" inheritance</title>

    <para>
    Ceylon interfaces may define concrete members, allowing a restricted form of
    multiple inheritance, but may not hold state (references to other objects)
    or initialization logic, which eliminates the problems traditionally 
    associated with multiple inheritance.
    </para>
    
    </section>
    
    <section id="firstclassfunctions">
    <title>First-class functions and higher-order programming</title>
    
    <para>
    Ceylon supports first-class function types and higher-order functions, 
    with minimal extensions to the traditional C syntax. A method declaration 
    may specify a <emphasis>callable parameter</emphasis> that accepts 
    references to other methods with a certain signature. The argument of such 
    a callable parameter may be either a reference to a named method declared 
    elsewhere, or a new method defined inline as part of the method invocation. 
    A method may even return an invocable reference to another method. Finally, 
    nested method declarations receive a closure of immutable values in the 
    surrounding scope.
    </para>
    
    </section>
    
    <section id="lazyevaluationpassbyreference">
    <title>Lazy evaluation and pass by reference</title>
    
    <para>
    Using a "trick" in the Ceylon type system, it's possible to take advantage 
    of lazy evaluation of expressions and pass by reference for attributes.
    </para>
    
    </section>
    
    <section id="immutability">
    <title>Immutability by default</title>
    
    <para>
    By default, Ceylon classes, attributes and locals are immutable. 
    Mutable classes, attributes and locals must be explicitly declared
    using the <literal>mutable</literal> annotation. An immutable class may 
    not declare <literal>mutable</literal> attributes or extend a 
    <literal>mutable</literal> class. An immutable attribute or local may 
    not be assigned after its initial value is specified.
    </para>
    
    </section>
    
    <section id="compiletimesafety">
    <title>Compile-time safety for optional values and type narrowing</title>
    
    <para>
    By default, Ceylon attributes and locals do not accept null values. 
    Optional locals and attributes must be explicitly declared. Optional 
    expressions are not assignable to non-optional locals or attributes, 
    except via use of the <literal>if (exists ... )</literal> construct. 
    Thus, the Ceylon compiler is able to detect illegal use of a null value 
    at compile time. Therefore, there is no equivalent to Java's 
    <literal>NullPointerException</literal> in Ceylon.
    </para>
    
    <para>
    Ceylon does not feature C-style typecasts. Instead, the 
    <literal>if (is ... )</literal> and <literal>case (is ... )</literal> 
    constructs may be used to narrow the type of an object reference 
    without risk of a <literal>ClassCastException</literal>.
    </para>
    
    </section>
    
    <section id="controlflow">
    <title>Control flow</title>
    
    <para>
    Ceylon's built in control flow structures are very similar to the 
    traditional constructs found in C, C# and Java. However, inline methods 
    can be used together with a special Smalltalk-style method invocation 
    protocol to achieve more specialized flow control and other 
    functional-style constructs such as comprehensions.
    </para>
    
    <para>
    Ceylon features an exceptions model inspired by Java and C#. Checked 
    exceptions are not supported.
    </para>
    
    </section>
    
    <section id="operatorsandoperatorpolymorphism">
    <title>Operators and operator polymorphism</title>
    
    <para>
    Ceylon features a rich set of operators, including most of the operators 
    supported by C and Java. True operator overloading is not supported. 
    However, each operator is defined to act upon a certain class or interface 
    type, allowing application of the operator to any class which extends or 
    implements that type. This is called <emphasis>operator polymorphism</emphasis>.
    </para>
    
    </section>
    
    <section id="numerictypes">
    <title>Numeric types</title>
    
    <para>Ceylon's numeric type system is much simpler than C, C# or Java, 
    with exactly five built-in numeric types (compared to eight in Java and
    eleven in C#). The built-in types are classes representing natural numbers, 
    integers, floating point numbers, arbitrary precision integers and 
    arbitrary precision decimals. <literal>Natural</literal>, 
    <literal>Integer</literal> and <literal>Float</literal> values are 64 bit 
    by default, and may be optimized for 32 bit architectures via use of the 
    <literal>small</literal> annotation.</para>
    
    </section>
    
    <!-- 
    <section id="dimensioned types">
    <title>Dimensioned types</title>
    
    <para>Ceylon supports <emphasis>dimensional type parameters</emphasis>,
    allowing types with fixed dimensions such as vectors or matrices to be
    represented within the type system, and enabling compile-time bounds 
    checking of indexing operations.</para>
    
    </section>
    -->
    
    <section id="typeextensions">
    <title>Type extensions</title>
    
    <para>
    True open classes are not supported. However, Ceylon supports 
    <emphasis>extensions</emphasis>, which allow addition of methods and 
    interfaces to existing types, and transparent conversion between types, 
    within a textual scope. Extensions only affect the operations provided 
    by a type, not its state. <!--This facility makes it easy for Ceylon code to 
    transparently interoperate and inter-compile with Java code.-->
    </para>
    
    </section>
    
    <section id="structureddata">
    <title>Structured data</title>
    
    <para>
    Ceylon introduces a set of syntax extensions that support the definition 
    of domain-specific languages and expression of structured data. These 
    extensions include specialized syntax for initializing objects and 
    collections and expressing literal values or user-defined types. The goal 
    of this facility is to replace the use of XML for expressing hierarchical 
    structures such as documents, user interfaces, configuration and serialized 
    data. An especially important application of this facility is Ceylon's 
    built-in support for program element annotations.
    </para>
    
    </section>
    
    <section id="metaprogramming">
    <title>Metaprogramming</title>
    
    <para>
    Ceylon provides sophisticated support for meta-programming, including 
    a typesafe metamodel and events. This facility is inspired by similar 
    features found in dynamic languages such as Smalltalk, Python and Ruby, 
    and by the much more complex features found in aspect oriented languages
    like Aspect J. Ceylon does not, however, support aspect oriented
    programming as a language feature.
    </para>
    
    <para>
    Even better, Ceylon features Haskell-style <emphasis>type classes</emphasis>,
    allowing an even more exotic form of generic programing using polymorphic 
    abstraction over metatypes.
    </para>
    
    </section>
    
    <section id="modularity">
    <title>Modularity</title>
    
    <para>
    Ceylon features language-level <emphasis>package</emphasis> and 
    <emphasis>module</emphasis> constructs, and language-level access control 
    with four levels of visibility for program elements: block local (the 
    default), <!--<literal>private</literal>,--> <literal>package</literal>, 
    <literal>module</literal> and <literal>public</literal>. There's no 
    equivalent to Java's <literal>protected</literal>.
    </para>
    
    </section>
    
    </section>
    
    <section id="sdkmodules">
        <title>Modules included in the SDK</title>
    
    <para>The Ceylon SDK includes the following important modules:</para>
    
    <itemizedlist>
        <listitem>
            <para><literal>ceylon.language</literal> - basic types provided to support
            built-in language features</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.module</literal> - the module runtime (based on
            JBoss Modules)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.collection</literal> - the collections framework
            (with the underlying implementation provided by the Java collections
            framework)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.datetime</literal> - support for representing
            dates and times (based on JSR-310)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.security</literal> - the security API</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.io</literal> - the I/O facility (based on 
            <literal>java.io</literal>)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.concurrent</literal> - the concurrency API (based
            on JSR-166)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.http</literal> - the HTTP client and server (based 
            on JBoss Netty)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.transaction</literal> - the transaction server (based 
            on JBoss Transactions)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.rdbc</literal> - relational database connectivity 
            (based on JDBC)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.message</literal> - the message server (based 
            on JBoss HornetQ)</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.xml</literal> - the XML parser</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.html</literal> - the HTML construction kit</para>
        </listitem>
        <listitem>
            <para><literal>ceylon.compiler</literal> - a compiler for Ceylon source
            code</para>
        </listitem>
    </itemizedlist>
    
    <section id="parsingceylon">
        <title>Parsing and compiling the Ceylon language</title>
        
        <para>The Ceylon language has been shown to be lexable and parseable using 
        an ANTRL grammar with no hand-coded special cases. Where lookahead was 
        necessary, this was handled using syntactic predicates.</para>
        
        <para>Ceylon is a language for the Java Virtual Machine, therefore Ceylon
        programs compile to a set of platform-independent <literal>.class</literal> 
        files that comply with the published specification for the Java class file 
        format.</para>
        
    </section>
    
    </section>
    
    <section id="brieftutorial">
    <title>A brief tutorial</title>
    
    <para>The following tutorial assumes some background in Java or a a Java-like
    language such as C#. Ceylon has very much in common with Java, but here we 
    emphasize how and why Ceylon differs from Java.</para>
    
    <section>
        <title>Writing a simple program in Ceylon</title>
        
        <para>
        Here's a classic example, implemented in Ceylon:
        </para>
        
        <programlisting>doc "The classic Hello World program"
public void hello() {
    process.writeLine("Hello, World!");
}</programlisting>

        <para>
        This code defines a method named <literal>hello()</literal>. The 
        method is annotated <literal>public</literal>, which makes it 
        accessible to code in other packages. When the method is executed, 
        it calls the <literal>writeLine()</literal> method of an object 
        named <literal>process</literal>. (This method displays its 
        parameter on the console.)
        </para>
        
        <para>
        The <literal>doc</literal> annotation contains documentation 
        that is included in the output of the Ceylon documentation compiler.
        </para>
        
        <para>Copy this code into a file named <literal>hello.ceylon</literal>
        and put the file in the <literal>ceylon/source/</literal> directory of 
        your Ceylon SDK installation.</para>
        
        <para>Now, in the <literal>ceylon</literal> directory, run the 
        following command:</para>
        
        <programlisting>ceylon hello</programlisting>
        
        <para>This command compiles the source to bytecode and runs the Java 
        virtual machine. You should see the following output in the console:</para>
        
        <programlisting>Hello World!</programlisting>
        
    </section>
        
    <section>
        <title>Dealing with objects that aren't there</title>
        
        <para>
        This improved version of the program takes a name as input from the 
        command line. We have to account for the case where nothing was
        specified at the command line, which gives us an opportunity to
        explore how null values are treated in Ceylon, which is quite 
        different to what you're probably used to in Java or C#.
        </para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello() {
    String? name = process.args.first;
    String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    process.writeLine(greeting);
}]]></programlisting>

        <para>The <literal>process</literal> object has an attribute named 
        <literal>args</literal>, which holds a <literal>List</literal> of the 
        program's command line arguments. The local <literal>name</literal> is 
        initialized with the first of these arguments, if any. This local is 
        declared to have type <literal>String?</literal>, to indicate that it 
        may contain a null value. The <literal>if (exists ...)</literal> control 
        structure is used to initialize the value of the non-null local named 
        <literal>greeting</literal>, interpolating the value of 
        <literal>name</literal> into the message string whenever 
        <literal>name</literal> is not null. Finally, the message is printed
        to the console.</para>
        
        <para>Unlike Java, locals, parameters, and attributes that may contain 
        null values must be explicitly declared as being of type 
        <literal>Optional&lt;X&gt;</literal> where <literal>X</literal> is the
        type of value they contain when not holding a null value. Ceylon lets
        us abbreviate the type name <literal>Optional&lt;X&gt;</literal> to
        <literal>X?</literal>. The value <literal>null</literal> is an instance
        of type <literal>Optional&lt;X&gt;</literal>, but it's not an instance 
        of <literal>Object</literal>. So there's simply no way to assign 
        <literal>null</literal> to a local that isn't of type 
        <literal>Optional</literal>. The compiler won't let you.</para>
        
        <para>Nor will the Ceylon compiler let you do anything "dangerous" with 
        a value of type <literal>Optional</literal>&mdash;that is, anything that 
        could cause a <literal>NullPointerException</literal> in 
        Java&mdash;without first checking that the value is not null using 
        <literal>if (exists ... )</literal>.</para>
        
        <para>In fact, it's not even possible to use the equality operator 
        <literal>==</literal> with an expression of type <literal>Optional</literal>.
        You can't write <literal>if (x==null)</literal> like you can in Java. 
        This helps avoid the undesirable behavior of <literal>==</literal> in Java
        where <literal>x==y</literal> evaluates to <literal>true</literal> if
        <literal>x</literal> and <literal>y</literal> both evaluate to 
        <literal>null</literal>.</para>
        
        <para>If you're worried about the performance implications of wrapping
        values in instances of <literal>Optional</literal>, don't be. 
        <literal>Optional</literal> isn't a <emphasis>reified</emphasis>
        type&mdash;it exists at compile time, when the compiler is validating
        your code for typesafety, but then the compiler eliminates it as part of 
        the compilation process, allowing the resulting bytecode to take advantage 
        of the efficient handling of null values in the virtual machine.</para>
        
        <para>It's possible to declare the local <literal>name</literal> inside
        the <literal>if (exists ... )</literal> condition:</para>
        
        <programlisting><![CDATA[String greeting;
if (exists String name = process.args.first) {
    greeting = "Hello, " name "!";
}
else {
    greeting = "Hello, World!";
}
process.writeLine(greeting);]]></programlisting>
        
        <para>This is the prefered style most of the time, since we can't actually
        use <literal>name</literal> for anything useful outside of the 
        <literal>if (exists ... )</literal> construct.</para>
        
        <para>Copy this new version of the program into <literal>hello.ceylon</literal> 
        and run, as before:</para>
        
        <programlisting>ceylon hello</programlisting>
        
        <para>You should see the same output as before:</para>
        
        <programlisting>Hello, World!</programlisting>
        
        <para>Now, run the program again, with a command-line argument:</para>
        
        <programlisting>ceylon hello everybody</programlisting>
        
        <para>You should see the following output:</para>
        
        <programlisting>Hello everybody!</programlisting>
        
        <!-- 
        <para>There's also a postfix operator named <literal>exists</literal>. The
        <literal>exists</literal> operator simply evaluates to a <literal>Boolean</literal>
        value. It doesn't narrow its argument to a non-<literal>Optional</literal>
        type.</para>
        -->
         
        </section>
        
        <section>
            <title>Creating your own classes</title>

        <para>
        Our method now has too many responsibilities, and is not at all reusable. 
        Let's refactor the code. Ceylon is an object oriented language, so we 
        usually write most of our code in <emphasis>classes</emphasis>. A class
        is a type that packages:
        </para>
        
        <itemizedlist>
            <listitem><para>operations&mdash;called <emphasis>methods</emphasis>,</para></listitem>
            <listitem><para>state&mdash;held by <emphasis>attributes</emphasis>, and,</para></listitem>
            <listitem><para>sometimes, other nested types.</para></listitem>
        </itemizedlist>
          
        <para>
        Types (interfaces, classes, and aliases) have names that begin with uppercase 
        letters. Members (methods and attributes) and locals have names that begin with 
        lowercase letters. This is the rule you're used to from Java. <!--(it's different to, 
        and much prettier than, the naming conventions in C#)--> Unlike Java, the Ceylon 
        compiler enforces these rules. If you try to write <literal>class hello</literal>
        or <literal>String Name</literal>, you'll get a compilation error.
        </para>
        
        <para>
        Just like in Java or C#, a class defines the accessibility of its members 
        using <emphasis>visibility modifier annotations</emphasis>, allowing the 
        class to hide its internal implementation from clients. Unlike Java, members 
        are hidden from code outside the body of the class <emphasis>by 
        default</emphasis>&mdash;only members with explicit visibility modifiers are
        visible to other toplevel types or methods, other compilation units, other 
        packages, or other modules.
        </para>
        
        <para>
        And, of course, a class itself may be hidden from other code. By default,
        a toplevel class is visible only inside the package in which it is defined.
        To make it visible to other packages or modules, an explicit visibility
        modifier is required. 
        </para>
        
        <para>The visibility modifiers are: <literal>package</literal>,
        <literal>module</literal>, and <literal>public</literal>. Ceylon doesn't
        have anything like Java's <literal>protected</literal>. On the other hand,
        Java doesn't have anything like Ceylon's <literal>module</literal> since 
        Java has no standard module architecture.</para>
        
        <para>Our first version of the <literal>Hello</literal> class has a
        single attribute and a single method, both declared to have 
        <literal>package</literal> visibility, making them accessible to other
        code in the same package:</para>
        
        <programlisting><![CDATA[doc "A personalized greeting"
class Hello(String? name) {
    
    doc "The greeting"
    package String greeting;
    if (exists name) {
        greeting = "Hello, " name "!";
    }
    else {
        greeting = "Hello, World!";
    }
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>To understand this code completely, we're going to need to first
            explore the concept of an attribute, and then discuss how object
            initialization works in Ceylon.</para>

        </section>
        
        <section>
            <title>Abstracting state using attributes</title>
            
            <para>The attribute <literal>greeting</literal> is a <emphasis>simple 
            attribute</emphasis>, the closest thing Ceylon has to a Java field. Its 
            value is specified immediately after it is declared. Usually we can declare
            and specify the value of an attribute in a single line of code.</para>
            
            <programlisting>package String greeting = "Hello, " name "!";</programlisting>
        
            <para>An attribute is a bit different to a Java field. It's an abstraction
            of the notion of a value. Some attributes are simple value holders like
            the one we've just seen; others are more like a getter method, or, sometimes, 
            like a getter and setter method pair. Like methods, attributes are 
            polymorphic&mdash;an attribute definition may be overridden by a subclass.</para>
            
            <para>We could rewrite the attribute <literal>greeting</literal> as a 
            <emphasis>getter</emphasis>:</para>

            <programlisting><![CDATA[package String greeting {
    if (exists name) {
        return "Hello, " name "!"
    }
    else {
        return "Hello, World!"
    }
}]]></programlisting>

            <para>Notice that the syntax of a getter declaration looks a lot like a 
            method declaration with no formal parameter list.</para>

            <para>Clients of a class never need to know whether the attribute they 
            access holds state directly, or is a getter that derives its value from
            other attributes of the same object or other objects. In Ceylon, you don't 
            need to go around declaring all your attributes <literal>private</literal> 
            and wrapping them in getter and setter methods. Get out of that habit right 
            now!</para>
        
        </section>
        
        <section>
            <title>Understanding object initialization</title>
        
        <para>In Ceylon, classes don't have constructors. Instead:</para>
        
        <itemizedlist>
            <listitem>
                <para>the parameters needed to instantiate the class&mdash;the 
                <emphasis>initializer parameters</emphasis>&mdash;are declared 
                directly after the name of the class, and</para>
            </listitem>
            <listitem>
                <para>code to initialize the new instance  of the class&mdash;the 
                <emphasis>class initializer</emphasis>&mdash;goes directly in the 
                body of the class.</para>
            </listitem>
        </itemizedlist>
        
        <para>Take a close look at the following code fragment:</para>
        
<programlisting>String greeting;
if (exists name) {
    greeting = "Hello, " name "!";
}
else {
    greeting = "Hello, World!";
}</programlisting>

        <para>In Ceylon, this code could appear in the body of a class, where 
        it would be declaring and specifying the value of an immutable attribute, 
        or it could appear in the body of a method definition, where it would be 
        declaring and specifying the value of an immutable local variable. That's
        not the case in Java, where initialization of fields looks very different
        to initialization of local variables! Thus the syntax of Ceylon is more
        <emphasis>regular</emphasis> than Java. Regularity makes a language easy
        to learn and easy to refactor.</para>
        
        <para>Now let's turn our attention to a different possible implementation
        of <literal>greeting</literal>:</para>
        
        <programlisting><![CDATA[class Hello(String? name) {
    
    package String greeting {
        if (exists name) {
            return "Hello, " name "!"
        }
        else {
            return "Hello, World!"
        }
    }
    
    ...
    
}]]></programlisting>

        <para>You might be wondering why we're allowed to use the parameter 
        <literal>name</literal> inside the body of the getter of
        <literal>greeting</literal>. Doesn't the parameter go out of scope as 
        soon as the initializer terminates? Well, that's true, but Ceylon is 
        a language with a very strict block structure, and the scope of 
        declarations is governed by that block structure. In this case, the 
        scope of <literal>name</literal> is the whole body of the class, and 
        the definition of <literal>greeting</literal> sits inside that scope, 
        so <literal>greeting</literal> is permitted to access 
        <literal>name</literal>.</para>
        
        <para>We've just met our first example of <emphasis>closure</emphasis>, 
        a concept from functional programming. We say that method and attribute 
        definitions receive a closure of immutable values defined in the class 
        body to which they belong. That's just a fancy way of obfuscating the 
        idea that <literal>greeting</literal> holds onto the value of 
        <literal>name</literal>, even after the initializer completes.</para>
        
        <para>In fact, one way to look at the whole notion of a class in Ceylon 
        is to think of it as a function which returns a closure of its own local 
        variables. This helps explain why the syntax of class declarations is so 
        similar to the syntax of method declarations (a class declaration looks a 
        lot like a method declaration where the return type and the name of the 
        method are the same).</para>
        
        </section>
        
        <section>
            <title>Instantiating classes and overloading their initializer parameters</title>
         
        <para>Oops, I got so excited about attributes and closure that I forgot to show 
        you the code that uses <literal>Hello</literal>!</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello() {
    Hello(process.args.first).say(process);
}]]></programlisting>
        
        <para>Our rewritten <literal>hello()</literal> method just creates a new instance
        of <literal>Hello</literal>, and invokes <literal>say()</literal>. Ceylon doesn't 
        need a <literal>new</literal> keyword to know when you're instantiating a class. 
        No, we don't know why Java needs it. You'll have to ask James.</para>
        
        <para>I suppose you're worried that if Ceylon classes don't have constructors,
        then they also can't have multiple constructors. Does that mean we can't overload
        the initialization parameter list of a class? Well, not exactly. Ceylon doesn't
        have constructor overloading, but it does have <emphasis>class overloading</emphasis>.
        Believe it or not, Ceylon lets you write multiple classes with the same name! Let's
        overload <literal>Hello</literal>:</para>
        
        <programlisting><![CDATA[doc "A command line greeting"
class Hello() 
    extends Hello(process.args.first) {}]]></programlisting>
    
        <para>A class can overload a second class by extending it and declaring different
        initializer parameters. An overloaded class with an empty body is the Ceylon
        approach to "constructor" overloading. Of course, overloaded classes can do much
        more than just this!</para>
        
        <para>Our <literal>hello()</literal> method is now looking <emphasis>really</emphasis>
        simple:</para>
        
        <programlisting><![CDATA[doc "Print a personalized greeting"
public void hello() {
    Hello().say(process);
}]]></programlisting>
        
        </section>
        
        <section>
            <title>Inheritance and overriding</title>
        
            <para>In object-oriented programming, we often replace conditionals 
            (<literal>if</literal>, and especially <literal>switch</literal>) with
            subtyping. Let's try refactoring <literal>Hello</literal> into two classes,
            with two different implementations of <literal>greeting</literal>:</para>
            
            <programlisting><![CDATA[doc "A default greeting"
class DefaultHello() {
    
    doc "The greeting"
    package default String greeting = "Hello, World!";
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>Notice that Ceylon forces as to declare attributes or methods that can be 
            overridden by annotating them <literal>default</literal>.</para>
            
            <para>Subclasses specify their superclass using the <literal>extends</literal>
            keyword, followed by the name of the superclass, followed by a list of arguments
            to be sent to the superclass initializer parameters. It looks just like an
            expression that instantiates the superclass:</para>
            
            <programlisting><![CDATA[doc "A personalized greeting"
class PersonalizedHello(String name) extends DefaultHello() {
    
    doc "The personalized greeting"
    override String greeting { 
        return "Hello, " name "!" 
    }
    
}]]></programlisting>

            <para>Ceylon also forces us to declare that an attribute or method overrides an 
            attribute or method of a superclass by annotating it <literal>override</literal>. 
            All this annotating stuff costs a few extra keystrokes, but it helps the compiler
            detect errors. We can't inadvertantly override a member or the superclass, or
            inadvertantly <emphasis>fail</emphasis> to override it.</para>
            
            <para>On the other hand, we don't need to declare the visibility of the attribute
            annotated <literal>override</literal>. The <literal>package</literal> annotation
            is inherited from the attribute it overrides.</para>
            
            <para>There's one problem with what we've just seen. A personalized greeting 
            is not really a kind of default greeting. This is a case for introducing an
            abstract superclass:</para>

            <programlisting><![CDATA[doc "A greeting"
abstract class Hello() {
    
    doc "The (abstract) greeting"
    package abstract String greeting;
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}]]></programlisting>

            <para>Ceylon requires us to annotate abstract classes <literal>abstract</literal>,
            just like Java. This annotation specifies that a class cannot be instantiated,
            and can define abstract members. Like Java, Ceylon also requires us to annotate 
            abstract members. Note that an attribute that is never initialized is
            <emphasis>always</emphasis> an <literal>abstract</literal> attribute&mdash;Ceylon
            doesn't initialize attributes to zero unless you explicitly tell it to!</para>

            <para>One way to define an implementation for an inherited abstract attribute is 
            to simply assign a value to it in the subclass.</para>

            <programlisting><![CDATA[doc "A default greeting"
class DefaultHello() extends Hello() {
    
    greeting = "Hello, World!";
    
}]]></programlisting>

        <para>Of course, we can also define an implementation for an inherited abstract 
        attribute by overriding it.</para>

        <programlisting><![CDATA[doc "A personalized greeting"
class PersonalizedHello(String name) extends Hello() {
    
    doc "The personalized greeting"
    override String greeting { 
        return "Hello, " name "!" 
    }
    
}]]></programlisting>

        </section>
        
        <section>
            <title>Interfaces and "mixin" inheritance</title>
            
            <para>From time to time we come across a case where a class needs to inherit
            functionality from more than one supertype. Java's inheritance model doesn't
            support this, since an interface can never define a member with a concrete
            implementation. Interfaces in Ceylon are a little more flexible. An interface
            may define concrete methods, attribute getters, and attribute setters. It may
            not define simple attributes or initialization logic. Let's take advantage of
            this to define a reusable <literal>Writer</literal> interface for Ceylon.</para>
            
            <programlisting><![CDATA[public interface Writer {
    
    Formatter formatter;
    
    void write(String string);
    
    void writeLine(String string) {
        write(string);
        write(process.newLine);
    }
    
    void writeFormattedLine(String formatString, Object... args) {
        writeLine( formatter.format(formatString, args) );
    }
    
}]]></programlisting>
            
            <para>All members of an interface are either <literal>abstract</literal> or 
            <literal>default</literal>, and they all inherit the same visibility modifier
            as the interface. Therefore, we don't need to annotate the members explicitly.</para>
            
            <para>Note that we can't define a concrete value for the <literal>formatter</literal>
            attribute, since an interface may not define a simple attribute, and may not 
            hold a reference to another object.</para>
            
            <para>Now let's define a concrete implementation of this interface.</para>
            
            <programlisting>public class ConsoleWriter() satisfies Writer {
    
    formatter = StringFormatter();
    
    override void write(String string) {
        process.write(string);
    }
    
}</programlisting>
            
            <para>The <literal>satisfies</literal> keyword is used to specify that an 
            interface extends another interface or that a class implements an interface.
            Unlike an <literal>extends</literal> declaration, a <literal>satisfies</literal>
            declaration does not specify arguments, since interfaces do not have formal
            parameters or initialization logic. Furthermore, the <literal>satisfies</literal>
            declaration can specify more than one interface.</para>
            
            <para>Ceylon's approach to interfaces eliminates a common pattern in Java
            where a separate abstract class defines a default implementation of some of 
            the members of an interface. In Ceylon, the default implementations can be
            specified by the interface itself. Even better, it's possible to add a new
            member to an interface without breaking existsing implementations of the
            interface.</para>
            
        </section>
    
    <section>
        <title>Anonymous classes</title>
        
        <para>If a class has no formal parameters, it's often possible to use a shortcut 
        declaration which defines a named instance of the class, without providing any 
        actual name for the class itself. This is usually most useful when we're extending
        an abstract class or implementing an interface.</para>
        
        <programlisting><![CDATA[doc "A default greeting"
object defaultHello extends Hello() {
    greeting = "Hello, World!";
}]]></programlisting>
        
            <programlisting>public object consoleWriter satisfies Writer {
    formatter = StringFormatter();
    override void write(String string) {
        process.write(string);
    }
}</programlisting>
        
        <para>The downside to an <literal>object</literal> declaration is that we can't
        write code that refers to the concrete type of <literal>defaultHello</literal> 
        or <literal>consoleWriter</literal>, only to the named instances.</para>
        
        <para>A toplevel <literal>object</literal> declaration defines a singleton. An
        <literal>object</literal> declaration nested inside a class defines an object
        per instance of the containing class. An <literal>object</literal> declaration
        nested inside a method, getter, or setter results in an new object each time the 
        method, getter, or setter is executed.</para>
        
        <programlisting><![CDATA[public Subscription register(Subscriber s) {
    subscribers.append(s);
    object subscription satisfies Subscription {
        override void cancel() {
            subscribers.remove(s);
        }
    }
    return subscription
}]]></programlisting>
        
        <para>Notice how this code example makes clever use of the fact that the nested
        <literal>object</literal> declaration recieves a closure of the locals defined 
        in the containing method declaration!</para>
        
    </section>
        
    <section>
        <title>Testing the type of an object</title>
        
        <para>In any language with subtyping there is the hopefully occasional need 
        to perform narrowing conversions. Ceylon doesn't have C-style typecasts.
        Instead, we must test and narrow the type of an object reference in one step, 
        using the special <literal>if (is ... )</literal> construct. This construct 
        is very, very similar to <literal>if (exists ... )</literal>, which we met 
        earlier.</para>
        
        <programlisting>Object obj = ... ;
if (is Hello obj) {
    obj.say();
}</programlisting>
        
        <para>The <literal>switch</literal> statement can be used in a similar 
        way:</para>
        
        <programlisting>Object obj = ... ;
switch(obj)
case (is Hello) {
    obj.say();
}
case (is Person) {
    stream.writeLine(obj.firstName);
}
else {
    stream.writeLine($obj);
}</programlisting>

        <para>These constructs protect us from inadvertantly writing code that 
        would cause a <literal>ClassCastException</literal> in Java, just like
        <literal>if (exists ... )</literal> protects us from writing code that
        would cause a <literal>NullPointerException</literal>.</para>
        
        <para>Oh, the <literal>$</literal> operator just formats an object to 
        a printable string.</para>
        
        <!--
        <para>There's also a binary operator named <literal>is</literal>. The
        <literal>is</literal> operator simply evaluates to a 
        <literal>Boolean</literal> value. It does not narrow its argument to a 
        different type.</para>
        
        <programlisting>Boolean electronicPayment {
    return payment is CreditCardPayment 
        || payment is DebitCardPayment 
        || payment is DirectDebitPayment
}</programlisting>
                
        -->
        
        <para>Usually, the Ceylon compiler forces us to write an <literal>else</literal>
        clause in a <literal>switch</literal>, to remind us that there might be
        additional cases which we have not handled. If we want to write an 
        <emphasis>exhaustive</emphasis> list of cases in a switch statement, and 
        have the compiler check that we really did provide for every possibility, 
        we need to define an abstract type with an enumerated list of cases.</para>
        
        <programlisting>abstract class Hello() 
        of defaultHello, PersonalizedHello
        extends Case() {
    ...
}</programlisting>
        
        <para>When a type definition specifies an <literal>of</literal> clause,
        the compiler prevents us declaring any additional subtypes of the type.
        Therefore, we can write <literal>switch</literal> statements without an
        <literal>else</literal> clause:</para>
        
        <programlisting>Hello hello = ... ;
switch(hello)
case (defaultHello) {
    process.writeLine("What's your name?");
}
case (is PersonalizedHello) {
    process.writeLine("Nice to hear from you again!");
}</programlisting>
        
        <para>This is Ceylon's version of a Java <literal>enum</literal>:</para>
        
        <programlisting>public class Suit() 
        of hearts, diamonds, clubs, spades 
        extends Case() {}
        
public object hearts extends Suit() {}
public object diamonds extends Suit() {}
public object clubs extends Suit() {}
public object spades extends Suit() {}</programlisting>
        
        <para>Of course, this is significantly more verbose than Java's version.
        But Ceylon's <literal>of</literal> clause is also a lot more flexible 
        than Java's <literal>enum</literal>, since it allows both classes and
        values in the enumerated list of subtypes.</para>
        
    </section>
    
       <section>
           <title>Named arguments</title>
           
           <para>Consider the following declaration:</para>
           
           <programlisting>void printf(OutputStream to, String format, Object... values) { ... }</programlisting>
           
           <para>(The last formal parameter is a <emphasis>sequenced parameter</emphasis> 
           which accepts multiple arguments, just like a Java "varargs" parameter.)</para>
           
           <para>We've seen lots of examples of invoking a method or instantiating
           a class using a familiar C-style syntax where arguments are delimited by 
           in parentheses and separated by commas. Arguments are matched to parameters 
           by their position in the list. Let's see just one more example, just in 
           case:</para>
                      
           <programlisting>printf(process, "Thanks, %s. You have been charged %.2f. Your confirmation number is %d.", 
        user.name, order.total, order.confimationNumber);</programlisting>
           
           <para>This works fine, I suppose. However, Ceylon provides an alternative 
           method invocation protocol that is usually easier to read when there are 
           more than one or two arguments:</para>
           
           <programlisting>printf { 
    to = process; 
    format = "Thanks, %s. You have been charged %.2f. Your confirmation number is %d."; 
    user.name, order.total, order.confimationNumber 
};</programlisting>
                      
           <para>This invocation protocol is called a <emphasis>named argument 
           list</emphasis>. We can recognize a named argument list by the use of 
           braces as delimiters instead of parentheses. Notice that arguments are 
           separated by semicolons, except for arguments to the sequenced parameter,
           which are separated by commas. We explicitly specify the name of each
           parameter, except for the sequenced parameter, whose arguments always
           appear at the end of the named parameter list.</para>
           
           <para>Named arguments are very commonly used for building graphs of
           objects. Therefore, Ceylon provides a special abbreviated syntax that
           simplifies the declaration of an attribute getter, named parameter, or 
           method that builds an object by specifying named arguments to the 
           class initializer.</para>
           
           <para>We're allowed to abbreviate an attribute definition of the 
           following form:</para>
           
           <programlisting>Payment payment = Payment {
    method = user.paymentMethod;
    currency = order.currency;
    amount = order.total;
};</programlisting>
    
           <para>or a named argument specification of this form:</para>
           
           <programlisting>payment = Payment {
    method = user.paymentMethod;
    currency = order.currency;
    amount = order.total;
};</programlisting>
           
           <para>to the following more declarative (and less redundant) style:</para> 
           
           <programlisting>Payment payment {
    method = user.paymentMethod;
    currency = order.currency;
    amount = order.total;
}</programlisting>

           <para>We're even allowed to write a method of the following form:</para>
        
           <programlisting>Payment createPayment(Order order) {
    return Payment {
        method = user.paymentMethod;
        currency = order.currency;
        amount = order.total;
    }
}</programlisting>
        
           <para>using the following abbreviated syntax:</para>

           <programlisting>Payment createPayment(Order order) {
    method = user.paymentMethod;
    currency = order.currency;
    amount = order.total;
}</programlisting>
        
           <para>We'll have much more to say on the topic of named argument lists 
           later. For now, all we need to know is that there are two different 
           syntaxes for calling a method or instantiating a class. </para>
                       
       </section>

        <section>
            <title>Working with mutable state</title>

            <para>Ceylon encourages you to use <emphasis>immutable</emphasis> attributes
            as much as possible. An immutable attribute has its value specified when the 
            object is initialized, and is never reassigned. If we want to be able to
            assign a value to a simple attribute we need to annotate it 
            <literal>mutable</literal>:</para>
            
            <programlisting>package mutable String greeting := "Hello World";
if (exists name) {
    greeting := "Hello, " name "!";
}</programlisting>

            <para>Notice the use of <literal>:=</literal> instead of <literal>=</literal>
            here. This is important! In Ceylon, specification of an immutable value is 
            done using <literal>=</literal>. Assignment to a <literal>mutable</literal> 
            attribute or local is considered a different kind of thing, always performed 
            using the <literal>:=</literal> operator.</para>
            
            <para>To force you to think twice before adding a <literal>mutable</literal>
            attribute to your class, Ceylon requires that classes with mutable attributes
            be explicitly annotated <literal>mutable</literal>. Hopefully, you'll find
            yourself doing this less frequently than you would do it in Java.</para>
            
            <para>If we want to make an attribute with a getter mutable, we need to 
            define a matching <emphasis>setter</emphasis>. Usually this is only useful if 
            you have some other internal attribute you're trying to set the value of
            indirectly.</para>
            
            <para>Suppose our class has the following mutable simple attribute, intended
            for internal consumption only:</para>
            
            <programlisting>mutable String grtng := "Hello World";</programlisting>
            
            <para>Then we can abstract the simple attribute using a mutable attribute
            defined as a getter/setter pair:</para>
            
            <programlisting>doc "gets the greeting"
public String greeting { 
    return grtng 
}

doc "sets the greeting"
package assign greeting { 
    grtng := greeting; 
}</programlisting>

            <para>Yes, this is a <emphasis>lot</emphasis> like a Java get/set method pair.
            But since Ceylon attributes are polymorphic, and since you can redefine a simple
            attribute as a getter or getter/setter pair without affecting clients that call 
            the attribute, you rarely need to write this code unless you're doing something 
            special in the getter or setter. So here's a more realistic example:</para>
       
            <programlisting>doc "gets the greeting"
public String greeting { 
    return grtng 
}

doc "sets the greeting"
package assign greeting {
    if (nonempty greeting) {
        grtng := greeting.strip().normalize();
    }
    else {
        throw IllegalArgumentException("greeting can not be empty)
    }
}</programlisting>

            <para>Get used to using the <literal>nonempty</literal> operator to check that 
            a value of type <literal>String</literal> or <literal>String?</literal> is an 
            actual non-empty string of characters. It's much more readable than the 
            equivalent Java idiom <literal>!"".equals(greeting)</literal>.</para>
            
        </section>
        
        <section>
            <title>On overview of the built-in types</title>
            
            <para>Just like Java, Ceylon has a class named <literal>Object</literal>. But
            in Ceylon, <literal>Object</literal> isn't the root of the type system. An
            expression of type <literal>Object</literal> has a definite, well-defined, 
            non-null value. As we've seen, the Ceylon type system can also represent some
            more exotic types, for example <literal>Optional&lt;T&gt;</literal>, which
            represents a value that may be null. A second example of a type that doesn't
            extend <literal>Object</literal> is <literal>Gettable&lt;T&gt;</literal>, 
            which represents a value that has not yet been evaluated.</para>
            
            <para>Therefore, Ceylon's <literal>Object</literal> has a superclass, named 
            <literal>Void</literal>. All Ceylon types are assignable to <literal>Void</literal>.
            Expressions of type <literal>Void</literal> aren't useful for very much, 
            since <literal>Void</literal> has no members or operators. You can't even narrow 
            an expression of type <literal>Void</literal> to a different type. The one useful 
            thing you <emphasis>can</emphasis> do with <literal>Void</literal> is use it to 
            represent the signature of a method when you don't care about the return type, 
            since a method declared <literal>void</literal> is considered to have return type
            <literal>Void</literal>.</para>
            
            <para>The exotic types we just mentioned&mdash;<literal>Optional</literal> and
            <literal>Gettable</literal>&mdash;directly extend <literal>Void</literal>. All 
            types that represent well-defined values extend <literal>Object</literal>,
            including:</para>
            
            <itemizedlist>
                <listitem>
                    <para>user-written classes,</para>
                </listitem>
                <listitem>
                    <para>all interfaces, and</para>
                </listitem>
                <listitem>
                    <para>the types that are considered primitive in Java, such as
                    <literal>Integer</literal>, <literal>Float</literal> and 
                    <literal>Character</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Since an expression of type <literal>Object</literal> always evaluates to
            a definite, well-defined value, it's possible to obtain the runtime type of an
            <literal>Object</literal>, or narrow an expression of type <literal>Object</literal> 
            to a more specific type.</para>
            
            <para>Since <literal>Object</literal> is a supertype of types like <literal>Float</literal>
            which are passed by value at the level of the Java virtual machine, you can't use 
            the <literal>===</literal> operator to test the identity of two values of type
            <literal>Object</literal>. Instead, there is a subclass of <literal>Object</literal>,
            named <literal>IdentifiableObject</literal>, which represents a type which is always 
            passed by reference. The <literal>===</literal> operator accepts expressions of 
            type <literal>IdentifiableObject</literal>. It's possible for a user-written class to 
            directly extend <literal>Object</literal>, but most of the classes you write will be
            subclasses of <literal>IdentifiableObject</literal>. All <literal>mutable</literal>
            classes must extend <literal>IdentifiableObject</literal>.</para>
            
            <para><literal>IdentifiableObject</literal> defines a default implementation of the
            interface <literal>Equals&lt;IdentifiableObject&gt;</literal>, which is very similar
            to the <literal>equals()</literal> and <literal>hashCode()</literal> methods defined
            by <literal>java.lang.Object</literal>. Just like in Java, you can override this
            default implementation in your own classes. This is the normal way to get a customized 
            behavior for the <literal>==</literal> operator, the only constraint being, that for
            subtypes of <literal>IdentifiableObject</literal>, <literal>x==y</literal> should
            imply <literal>x===y</literal>&mdash;equality should be consistent with identity.</para>
            
            <para>Occasionally that's not what we want. For example, for numeric types, I don't
            care whether a value is of class <literal>Natural</literal>, <literal>Integer</literal>, 
            or <literal>Whole</literal> when comparing it to <literal>0</literal>. Therefore, 
            numeric types must extend <literal>Object</literal> directly. Indeed, all the built in
            numeric types do directly extend <literal>Object</literal>. The built-in numeric types
            also implement the interface <literal>Numeric&lt;T&gt;</literal>, which extends 
            <literal>Equals&lt;T&gt;</literal>. This captures the notion that equality for numeric
            types is fundamentally different to equality for objects with well-defined identity.
            It's not possible to compare an <literal>Integer</literal> with an <literal>Order</literal>
            using <literal>==</literal> (at least not if you expect to have a symmetrical 
            <literal>==</literal> operator).</para>
            
            <para>Thus, Ceylon is able to capture within the type system much of the behavior that 
            Java introduces by fiat special-case rules in the language definition.</para>
            
            <para>Finally, the <literal>BaseObject</literal> class&mdash;which is the class you extend
            by default if you don't specify a superclass explicitly in the <literal>extends</literal>
            declaration&mdash;is a subclass of <literal>Object</literal> that implements support for
            using the <literal>id</literal> annotation to override <literal>equals()</literal>, 
            <literal>hash</literal> and <literal>string</literal>, as we're about to see.</para>
            
        </section>
        
        <section>
            <title>Operator polymorphism</title>
            
            <para>Ceylon discourages the creation of intriguing executable ASCII art. 
            Therefore, true operator overloading is not supported by the language. Instead,
            almost every operator (every one except the primitive <literal>.</literal>,
            <literal>()</literal>, <literal>is</literal>, and <literal>:=</literal> operators) 
            is considered a shortcut way of writing some more complex expression involving
            other operators and ordinary method calls. For example, the <literal>&lt;</literal>
            operator is defined in terms of the interface <literal>Comparable&lt;T&gt;</literal>, 
            which has a method named <literal>smallerThan()</literal>, which is in turn defined
            in terms of another method named <literal>compare()</literal>.</para>
            
            <programlisting>x&lt;y</programlisting>
            
            <para>means, by definition,</para>
            
            <programlisting>x.smallerThan(y)</programlisting>
            
            <para>The equality operator <literal>==</literal> is defined in terms of the 
            interface <literal>Equals&lt;T&gt;</literal>, which has a method named 
            <literal>equals()</literal>.</para>
            
            <programlisting>x==y</programlisting>
            
            <para>means, by definition,</para>
            
            <programlisting>x.equals(y)</programlisting>
            
            <para>Therefore, it's easy to customize operators like <literal>&lt;</literal> 
            and <literal>==</literal> with specific behavior for our own classes, just by 
            implementing or overriding methods like <literal>compare()</literal> and 
            <literal>equals()</literal>. Thus, we say that operators are 
            <emphasis>polymorphic</emphasis> in Ceylon.</para>
            
        <programlisting><![CDATA[doc "A greeting"
abstract class Hello() {
    
    doc "The (abstract) greeting"
    package abstract String greeting;
    
    override Boolean equals(IdentifiableObject that) {
        if (is Hello that) {
            if (this.type!=that.type) {
                return false
            }
            else {
                return that.greeting==this.greeting
            }
        } 
        else {
            return false
        }
    }
    
    override Integer hash = greeting.hash;
    
    override String string { 
        return greeting 
    }
    
    ...
    
}]]></programlisting>

            <para>If we override <literal>equals()</literal>, we're required to also override
            the <literal>hash</literal> attribute.</para>
            
            <para>Since it's very common to override <literal>equals()</literal>, <literal>hash</literal>
            and <literal>string</literal> at the same time, there's an easy way to do it using
            the <literal>id</literal> annotation. The previous code is equivalent to this much
            shorter version:</para>
            
        <programlisting><![CDATA[doc "A greeting"
abstract class Hello() {
    
    id
    doc "The (abstract) greeting"
    package abstract String greeting;
    
    ...
        
}]]></programlisting>
            
            <para>Check out the <literal>default</literal> implementation of <literal>equals()</literal>, 
            <literal>hash</literal> and <literal>string</literal> in <literal>BaseObject</literal>
            to see exactly how this works.</para>
            
            <para>Apart from <literal>Comparable</literal> and <literal>Equals</literal>, 
            which provide the underlying definition of comparison and equality operators,
            the following interfaces are also important in the definition of Ceylon's
            polymorphic operators:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>Numeric</literal> supports arithmetic operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Slots</literal> supports bitwise operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Comparable</literal> supports the comparison operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Container</literal> and <literal>Category</literal>
                    support the <literal>nonempty</literal> and <literal>in</literal> 
                    operators, respectively,</para>
                </listitem>
                <listitem>
                    <para><literal>Correspondence</literal> and <literal>Sequence</literal>
                    support indexing and subrange operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Boolean</literal> is the basis of the logical operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Optional</literal> supports the <literal>exists</literal>
                    and <literal>?</literal> operators,</para>
                </listitem>
                <listitem>
                    <para><literal>Callable</literal> supports invocation, and</para>
                </listitem>
                <listitem>
                    <para><literal>Settable</literal> supports assignnment and compound
                    assigment operators.</para>
                </listitem>
            </itemizedlist>
            
        </section>
        
        <section>
            <title>Using numeric types</title>
            
            <para>Ceylon doesn't have anything like Java's primitive types. The types that
            represent numeric values are just ordinary classes. Ceylon has fewer numeric
            types than other C-like languages:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>Natural</literal> represents the unsigned integers 
                    and zero,</para>
                </listitem>
                <listitem>
                    <para><literal>Integer</literal> represents signed integers,</para>
                </listitem>
                <listitem>
                    <para><literal>Float</literal> represents floating point decimal 
                    numbers,</para>
                </listitem>
                <listitem>
                    <para><literal>Whole</literal> represents arbitrary-precision signed 
                    integers, and</para>
                </listitem>
                <listitem>
                    <para><literal>Decimal</literal> represents arbitrary-precision and 
                    arbitrary-scale decimals.</para>
                </listitem>
            </itemizedlist>
            
            <para><literal>Natural</literal>, <literal>Integer</literal> and 
            <literal>Float</literal> have 64-bit precision by default. You can specify that 
            a value has 32-bit precision by annotating it <literal>small</literal>. But note 
            that this annotation is really just a hint that the compiler is free to ignore.</para>
            
            <para>There are only two kinds of numeric literals: literals for 
            <literal>Natural</literal>s, and literals for <literal>Float</literal>s:</para>
            
            <programlisting>Natural one = 1;</programlisting>
            <programlisting>Float oneHundredth = 0.01;</programlisting>
            <programlisting>Float oneMillion = 1.0E+6;</programlisting>
            
            <para>Widening type conversions are implicit, since the <literal>ceylon.language</literal> 
            package defines a set of built-in <emphasis>extensions</emphasis> (a concept 
            we'll meet later) that take care of this:</para>
            
            <programlisting>Decimal oneTenth = 0.1;</programlisting>
            <programlisting>Whole zero = 0;</programlisting>            
            <programlisting>Integer minusOne = -1;</programlisting>
            
            <para>To perform a narrowing type conversion, you need to call one of the 
            operations (well, they're attributes, actually) defined by the interface
            <literal>Number</literal>:</para>
            
            <programlisting>Natural one = 1.003.natural;</programlisting>
            <programlisting>Integer int = whole.integer;</programlisting>
            
            <para>Of course, a narrowing conversion can result in an exception at run 
            time, so take care!</para>
            
            <para>You can use all the operators you're used to from other C-style languages
            with the numeric types. You can also use the <literal>**</literal> operator to
            raise a number to a power:</para>
            
            <programlisting>Float diagonal = (length**2+width**2)**0.5;</programlisting>
            
            <para>Of course, if you want to use the increment <literal>++</literal> operator,
            decrement <literal>--</literal> operator, or one of the compound assignment
            operators such as <literal>+=</literal>, you'll have to declare the value 
            <literal>mutable</literal>.</para>
            
            <programlisting>module class Counter() {
            
    mutable Natural count := 0;

    module Natural next() {
        return ++count
    }

}</programlisting>
            
            <!--
            <para>You can even apply the slotwise and, or, xor, and complement operators
            to the type <literal>Natural</literal>:</para>
            
            <programlisting>Natural result = color&amp;mask;</programlisting>
            -->
            
            <para>Operators in Ceylon are, in principle, just abbreviations for some expression
            involving a method call. So the numeric types all implement the <literal>Numeric</literal> 
            interface, which declares the methods <literal>plus()</literal>, <literal>minus()</literal>,
            <literal>times()</literal>, <literal>divided()</literal> and <literal>power()</literal>.
            The numeric operators are defined in terms of these methods of <literal>Numeric</literal>.</para>
            
            <para>But don't worry about the performance implications of this&mdash;in practice, 
            the compiler is permitted to optimize away the method invocations. In fact, the compiler
            is permitted to optimize the built-in numeric types down to the virtual machine's native
            numeric types.</para>
            
            <para>The real value of <literal>Numeric</literal>&mdash;apart from eliminating special 
            cases in the language definition and type checker&mdash;is that you can implement the
            interface yourself, to introduce your own, more specialized numeric type. And you'll be 
            able to apply all the usual numeric operators to it. That's why we've been making a big
            deal out of operator polymorphism.</para>
            
        </section>
        
        <section>
            <title>Language-level collection types</title>
            
            <para>The collections module is one of the best features of Ceylon. However,
            collections are not considered part of the core language. Instead, the language 
            module defines a number of important interfaces which are extended by types in 
            the collections module, and Ceylon defines some useful operators and control
            structures in terms of these interfaces.</para> 
            
            <itemizedlist>
                <listitem>
                    <para>The most abstract types related to collections are the interfaces 
                    <literal>Container</literal>, <literal>Category</literal> and 
                    <literal>Iterable</literal>. They define the most basic capabilities of
                    an object that contains other objects.</para>
                </listitem>
                <listitem>
                    <para>The types <literal>Correspondence</literal> and 
                    <literal>Sequence</literal> define the ability to access an element by
                    key or index.</para>
                </listitem>
            </itemizedlist>
            
            <para>These are very simple interfaces, so many different types extend or implement 
            them.</para>
            
            <para>A <literal>Container</literal> is an object that might be empty. Any 
            <literal>Container</literal> can be the subject of the <literal>nonempty</literal>
            operator or of the <literal>if (nonempty ...)</literal> construct.</para>
            
            <programlisting>Container con = .... ;
if (nonempty con) { .... }</programlisting>
            
            <para>A <literal>Category</literal> is an object to which other objects
            belong. Any <literal>Category</literal> can be the second argument of the 
            <literal>in</literal> operator.</para>
            
            <programlisting>Category cat = .... ;
if (obj in cat) { .... }</programlisting>

            <para>An <literal>Iterable&lt;T&gt;</literal> is an object which can produce an 
            <literal>Iterator&lt;T&gt;</literal>. An <literal>Iterable</literal> object can 
            be used in a <literal>for</literal> loop.</para>
            
            <programlisting>Iterable&lt;Person&gt; people = ... ;
for (Person p in people) { ... }</programlisting>
            
            <para>Much less abstract are the interfaces <literal>Correspondence</literal> and 
            <literal>Sequence</literal>. Let's start with <literal>Sequence</literal>, even 
            though a sequence is just a special type of <literal>Correspondence</literal>.</para>
              
            <para>There's no arrays in Ceylon, but you can write the following code:</para>
            
            <programlisting>String[] voyage = { "Melbourne", "San Francisco", "Boston", "Atlanta", "Guanajuato" };
String? sf = voyage[2];
String[] usLeg = voyage[1..3];
String[] longerVoyage := voyage + { "Rome", "Paris", "Edinburgh" };</programlisting>
            
            <para>The syntax <literal>String[]</literal> is just an abbreviation for the 
            type <literal>Sequence&lt;String&gt;</literal>. Don't be scared by the fancy 
            syntax&mdash;it's just sugar. There's actually nothing much special about the 
            interface <literal>Sequence</literal> from the point of view of the type system. 
            But sequences of values are a common occurrence in computing, so Ceylon provides 
            a streamlined syntax for dealing with them. Let's break down this code.</para>
            
            <programlisting>String[] voyage = { "Melbourne", "San Francisco", "Boston", "Atlanta", "Guanajuato" };</programlisting>
            
            <para>We can instantiate a <literal>Sequence</literal> using a streamlined syntax
            where the elements of the sequence are enclosed in braces.</para>
            
            <programlisting>String? sf = voyage[2];</programlisting>
            
            <para>The expression <literal>voyage[2]</literal> evaluates to the third item in 
            the sequence (the item with index <literal>2</literal>). Note that the lookup
            operator returns an optional type, in this case <literal>String?</literal>, to
            account for the possibility that the given index was outside of the range of
            indexes of the sequence. As we'll soon see, the lookup operator works with more 
            than just sequences.</para>
            
            <programlisting>String[] usLeg = voyage[1..3];</programlisting>
            
            <para>The range expression <literal>voyage[1..3]</literal> evaluates to the 
            subsequence from the lower index <literal>1</literal> to the upper index 
            <literal>3</literal> (a subsequence containing the second, third, and fourth items 
            of the sequence). The range operator only works for sequences.</para> 
            
            <programlisting>String[] longerVoyage := voyage + { "Rome", "Paris", "Edinburgh" };</programlisting>
            
            <para>The <literal>+</literal> operator joins two sequences together. This
            <literal>+</literal> operator has absolutely nothing to do with addition of 
            numeric values. Rather, this is the single example of an overloaded operator in 
            Ceylon.</para>
            
            <para>Just like in Java, the collection types are <emphasis>parameterized</emphasis> 
            or <emphasis>generic</emphasis> types. Unlike Java, there are no raw types&mdash;if
            a type declares type parameters, a type argument for each parameter is required
            everywhere the type is used. For example, the following declaration is not legal:</para>
            
            <programlisting>Sequence voyage = Sequence { "Atlanta", "Boston", "San Francisco" };  //error! missing type argument</programlisting>
            
            <para>The closest thing to a raw type, in this case, would be a 
            <literal>Sequence&lt;Object&gt;</literal>.</para>
            
            <programlisting>Sequence&lt;Object&gt; voyage = Sequence { "Atlanta", "Boston", "San Francisco" };</programlisting>
            
            <para>Which Ceylon lets us abbreviate like this:</para>
            
            <programlisting>Object[] voyage = { "Atlanta", "Boston", "San Francisco" };</programlisting>
            
            <para>Sequences of ordinal values are especially common, so there's an
            operator for constructing them, called the <emphasis>range</emphasis>
            operator:</para>
            
            <programlisting>Natural[] from1To10 = 1..10;</programlisting>
            <programlisting>Integer[] fromNegative10To10 = -10..10;</programlisting>
            <programlisting>Character[] alphanum = (`A`..`Z`) + (`0`..`9`);</programlisting>

            <para>The <literal>Sequence</literal> interface extends <literal>Iterable</literal>,
            so we can iterate a <literal>Sequence</literal> using a <literal>for</literal>
            loop:</para>
            
            <programlisting>for (String city in voyage) {
    stream.writeLine(city);
}</programlisting>

            <para>If, for some reason, we need access to the index of each element, 
            we can also do the following:</para>
            
            <programlisting>for (Natural i -> String city in voyage) {
    stream.writeLine($i + ": " + city);
}</programlisting>

            <para>This works because there's a built-in extension method (a concept we'll
            meet later) that produces an <literal>Iterable&lt;Entry&lt;Natural,X&gt;&gt;</literal>
            for any <literal>Sequence&lt;X&gt;</literal>.</para>
            
            <para>A <literal>Sequence</literal> is a <literal>Category</literal>, so we can 
            use the <literal>in</literal> operator with sequences:</para>
            
            <programlisting>if ("Paris" in voyage) { ... }</programlisting>

            <para>Sometimes the keys of our collection elements aren't natural numbers, 
            so we need something other than a <literal>Sequence</literal>. A
            <literal>Correspondence&lt;U,V&gt;</literal> is a mapping from keys of type
            <literal>U</literal> to values of type <literal>V</literal>. In fact, a 
            <literal>Sequence</literal> is just a special case of a 
            <literal>Correspondence</literal> where the keys are <literal>Natural</literal> 
            numbers. <literal>Sequence&lt;X&gt;</literal> is a subtype of 
            <literal>Correspondence&lt;Natural, X&gt;</literal>.</para>
            
            <para>We often use the class <literal>Entry</literal>, which represents a 
            key/value pair, when working with <literal>Correspndences</literal>. The
            operator <literal>-></literal> constructs a new <literal>Entry</literal>.</para>
            
            <programlisting>Entry&lt;String,Person&gt; entry = person.name->person;</programlisting>
            
            <para>We can instantiate a <literal>Correspondence</literal> using a similar
            syntax to the one we used for sequences:</para>
                              
            <programlisting>Correspondence&lt;String,String&gt; cities = 
        Correspondence { "Emmanuel"->"Paris",
                           "Andrew"->"Cambridge", 
                             "Pete"->"Edinburgh",
                            "Gavin"->"Guanajuato" };</programlisting>
            
            <para>We can extract values from a <literal>Correspondence</literal> by key 
            using the lookup operator:</para>

            <programlisting>String? paris = cities["Emmanuel"];</programlisting>
            
            <para>Again, notice that the lookup operator returns an <literal>Optional</literal>
            result, to account for the possibility that there is no value defined for
            the given key.</para>
            
            <para>So far we haven't met anything from the collections module proper. 
            <literal>Sequence</literal> and <literal>Correspondence</literal> are part 
            of the module <literal>ceylon.language</literal>. They're there to abstract away 
            the nice syntax we've just met from the (relatively) gory details of the 
            collections package.</para>
            
        </section>
        
        <section>
            <title>The collections module</title>
            
            <para>Inside the collections module you'll find some interfaces with pretty
            familiar names: <literal>Collection</literal>, <literal>Set</literal>, 
            <literal>List</literal> and <literal>Map</literal>. (There's even a
            <literal>Bag</literal>.) But these interfaces aren't quite what you're used 
            to from Java. Most importantly, none of them provide operations to change
            the elements of the collection. If you need to mutate a collection, you'll
            need one of their evil twins: <literal>OpenCollection</literal>, 
            <literal>OpenSet</literal>, <literal>OpenList</literal> and 
            <literal>OpenMap</literal> (and we can't forget <literal>OpenBag</literal>).</para>
            
            <para>Splitting the collection interfaces into a "read-only" view and a
            "writable" view has several advantages, but the most important is that you
            now don't need to worry about exposing collections as part of the public 
            contract of your classes. In Java, it's always difficult for a client to 
            know if you're returning a copy of your internal list, a reference to your
            internal list (which you might have done inadvertantly), or a reference 
            wrapped in an <literal>immutableList()</literal>&mdash;you know, that wonderful 
            beastie which helpfully throws exceptions at runtime to let you know that it 
            is supposed to be "read-only". In Ceylon, you can protect the state of your 
            internal data structures by simply not returning the "writable" view to 
            clients. Send them back a <literal>List</literal>, and they know what they're 
            allowed to do with it.</para>
        
            <para>A <literal>Map</literal> is the most important kind of 
            <literal>Correspondence</literal>. We can add or override entries in an 
            <literal>OpenMap</literal> using the assignment operator:</para>
            
            <programlisting><![CDATA[OpenMap<String,String> cities = none;
cities["Gavin"] := "Guanajuato";
cities["Emmanuel"] := "Paris";
cities["Pete"] := "Edinburgh";
cities["Andrew"] := "Cambridge";]]></programlisting>
            
            <para>It's even possible to define multiple entries at once:</para>
            
            <programlisting><![CDATA[OpenMap<String,String> cities = none;
cities.define("Emmanuel"->"Paris",
                 "Gavin"->"Guanajuato",
                  "Pete"->"Edinburgh",
                "Andrew"->"Cambridge");]]></programlisting>
            
            <para>A <literal>Map</literal> is a collection of entries, a 
            <literal>Collection&lt;Entry&gt;</literal>. This is a big improvement over 
            Java where, unaccountably, a <literal>Map</literal> isn't actually a 
            <literal>Collection</literal>!</para>
            
            <para>Since <literal>Collection</literal>s are <literal>Iterable</literal>, 
            we can iterate a <literal>Map</literal> like this:</para>

            <programlisting>for (Entry&lt;String,String&gt; entry in cities) {
    stream.writeLine(entry.key + " lives in " + entry.value);
}</programlisting>

            <para>Or, much more commonly:</para>
            
            <programlisting>for (String person -> String city in cities) {
    stream.writeLine(person + " lives in " + city);
}</programlisting>
            
            <para>(Note that in this case, the <literal>-&gt;</literal> symbol isn't
            really the entry construction operator we saw above. In this case it's
            actually part of the syntax of the <literal>for</literal> loop.)</para>
            
            <para>A <literal>List</literal> is the most important kind of 
            <literal>Sequence</literal>. We usually add entries to an 
            <literal>OpenList</literal> using the <literal>append()</literal> 
            method:</para>
            
            <programlisting><![CDATA[OpenList<String> voyage = none;
voyage.append("Melbourne");
voyage.append("San Francisco");
voyage.append("Atlanta);]]></programlisting>
            
            <para>It's even possible to add multiple elements at once:</para>
            
            <programlisting><![CDATA[OpenList<String> voyage = none;
voyage.append("Melbourne", "San Francisco", "Atlanta");]]></programlisting>

            <para>We can also change the value at a particular index in an 
            <literal>OpenList</literal>:</para>
            
            <programlisting><![CDATA[voyage[1] := "Los Angeles";]]></programlisting>
            
            <para>Finally, <literal>Set</literal> represents the most important kind
            of collection in mathematics. The most important thing we can do with
            a <literal>Set</literal> is ask if an object belongs to it. We usually
            use the <literal>in</literal> operator, since <literal>Set</literal>, 
            like all collections, is a suptype of <literal>Category</literal>:</para>
            
            <programlisting>Set&lt;String&gt; names = ... ;
if ("gavin" in names) { ... }</programlisting>
            
            <para>Set union and intersection closely resemble bitwise or and bitwise and. 
            Therefore, Ceylon generalizes the traditional bitwise operators to 
            <literal>Set</literal>s.</para>
            
            <programlisting>Set&lt;String&gt; someSet = ... ;
Set&lt;String&gt; someOtherSet = ... ;
Set&lt;String&gt; union = someSet | someOtherSet;
Set&lt;String&gt; intersection = someSet &amp; someOtherSet;
Set&lt;String&gt; complement = someSet ~ someOtherSet;</programlisting>
                        
        </section>
        
        <section>
            <title>Understanding first-class functions</title>
            
            <para>Ceylon isn't a functional language: it has mutable locals and mutable 
            attributes and so methods can have side effects. But Ceylon does let you use 
            functions as values, which makes the language a kind of hybrid of the functional 
            and procedural. There's nothing very new about this idea&mdash;Smalltalk, one of 
            the first and still one of the cleanest object oriented languages, was the same kind 
            of hybrid. Ceylon, like Smalltalk and a number of other object oriented languages, 
            lets you treat a function as an object and pass it around the system. Unlike most 
            of these languages, Ceylon doesn't have a special syntax for declaring anonymous 
            functions (often called lambda expressions). Instead, Ceylon has something else, 
            which is just as good, but fits more cleanly with a traditional C-like syntax.</para>
            
            <para>Before we get to that, first, let's see how we can define:</para> 
            
            <itemizedlist>
                <listitem>
                    <para>a method which accepts a function as a parameter, and then</para>
                </listitem>
                <listitem>
                    <para>a method which returns a function.</para>
                </listitem>
            </itemizedlist>
            
            <para>Suppose we have some kind of user interface component which can be 
            observed by other objects in the system. We could use something like Java's
            <literal>Observer</literal>/<literal>Observable</literal> pattern:</para>
            
            <programlisting>public interface Observer {
    void observe(Event event);
}</programlisting>
            
            <programlisting>public abstract class Component() {
            
    OpenList&lt;Observer&gt; observers = none;
    
    void addObserver(Observer o) {
        observers.append(o);
    }
    
    void fire(Event event) {
        for (Observer o in observers) {
            o.observe(event);
        }
    }
    
}</programlisting>
            
            <para>But now all event observers have to implement the interface 
            <literal>Observer</literal>, which has just one method. Why don't
            we cut out the interface, and let event observers just register a
            function object as their event listener? In the following code,
            we define the <literal>addObserver()</literal> method to accept
            a function as a formal parameter.</para>

            <programlisting>public abstract class Component() {
            
    OpenList&lt;Callable&lt;Void,Event&gt;&gt; observers = none;
    
    void addObserver(void observe(Event event)) {
        observers.append(observe);
    }
    
    void fire(Event event) {
        for (void observe(Event event) in observers) {
            observe(event);
        }
    }
    
}</programlisting>

            <para>In this example, we can see two different ways of specifying
            the type of the function:</para>
            
            <itemizedlist>
                <listitem>
                    <para><literal>void observe(Event event)</literal> is more
                    readable in formal parameter lists, where <literal>observe</literal>
                    is the name of the formal parameter, but</para>
                </listitem>
                <listitem>
                    <para><literal>Callable&lt;Void,Event&gt;</literal> is useful
                    as a generic type argument.</para>
                </listitem>
            </itemizedlist>
            
            <para>Now, any event observer can just pass a reference to one of its
            own methods to <literal>addObserver()</literal>:</para>
            
            <programlisting>public class Listener(Component component) {
        
        void onEvent(Event e) {
            //respond to the event
            ...
        }
        
        component.addObserver(onEvent);
        
        ...
        
}</programlisting>

            <para>When the name of a method appears in an expression without a
            list of arguments after it, it is a <emphasis>reference</emphasis> to
            the method, not an invocation of the method. Here, the expression
            <literal>onEvent</literal> is an expression of type 
            <literal>Callable&lt;Void,Event&gt;</literal> that refers to the
            method <literal>onEvent()</literal>.</para>
            
            <para>It's also possible to declare a method that returns a function.
            A method that returns a function has multiple formal parameter lists.
            The following method returns a function which increments its argument
            by <literal>n</literal>:</para>
            
            <programlisting>Natural incrementor(Natural n)(Natural arg) {
    Natural increment(Natural arg) {
        return n+arg
    }
    return increment
}</programlisting>

            <para>Here, we define a method <literal>increment()</literal> inside
            the body of the <literal>incrementor()</literal> method, and return
            a reference to the inner method from the outer method. The inner method, 
            <literal>increment()</literal> can't be called directly from outside 
            the body of the <literal>incrementor()</literal> method, since it is a 
            block local declaration. But the reference to 
            <literal>increment()</literal> returned by <literal>incrementor()</literal>
            can be called by any code that obtains the reference.</para>

            <para>Notice that <literal>increment()</literal> is able to use the 
            parameter <literal>n</literal> of <literal>incrementor()</literal>. 
            We say that the inner method receives a closure of the 
            non-<literal>mutable</literal> locals and parameters of the outer 
            method&mdash;just like a method of a class receives a closure of the
            class initialization parameters and non-<literal>mutable</literal> 
            locals of the class initializer. In general, any inner class, method, 
            or attribute declaration always receives the closure of the 
            non-<literal>mutable</literal> values of the class, method, or attribute 
            declaration in which it is enclosed. This is an example of how regular
            the language is.</para>
            
            <para>We could invoke our method like this:</para>
            
            <programlisting>Natural five = incrementor(3)(2);</programlisting>
            
            <para>But if we were planning to use the method in this way, there 
            would be no good reason for giving it two formal parameter lists.
            It's much more likely that we're planning to store or pass the 
            reference to the inner method somewhere before invoking it.</para>

            <programlisting>Natural inc(Natural arg) = incrementor(3);
Natural five = inc(2);</programlisting>

            <para>The first line demonstrates how a method can be defined using
            a <literal>=</literal> specification statement, just like a simple 
            attribute definition. The second line of code simply invokes the returned 
            reference to <literal>increment()</literal>.</para> 
            
            <para>We've already seen how an attribute can be defined using a block of 
            code. Now we see that a method can be defined using a specifier. So, if 
            you like, you can start thinking of a method as an attribute of type 
            <literal>Callable</literal>&mdash;an attribute with parameters. Or if you 
            prefer, you can think of an attribute as member with zero formal parameter 
            lists, and of a method as a member with one or more formal parameter lists. 
            Either kind of member can be defined by reference, using <literal>=</literal>, 
            or directly, by specifying a block of code to be executed.</para>
                        
            <para>There are two alternative, shorter ways to write the 
            <literal>incrementor()</literal> function. Here's the first 
            alternative:</para>
            
            <programlisting>Natural incrementor(Natural n)(Natural arg) {
    return n.plus
}</programlisting>

            <para>In this case, we simply return a reference to the <literal>plus()</literal>
            method of the <literal>Natural</literal> instance <literal>n</literal>. This 
            method accepts a single parameter of type <literal>Natural</literal> and 
            returns a <literal>Natural</literal>, so its type is compatible with the
            return type of <literal>incrementor()</literal>&mdash;that is to say, its
            type is <literal>Callable&lt;Natural,Natural&gt;</literal>. In case you're
            wondering, the type of the method <literal>incrementor()</literal> is
            <literal>Callable&lt;Callable&lt;Natural,Natural&gt;,Natural&gt;</literal>.</para>

            <para>And here's the second alternative:</para>

            <programlisting>Natural incrementor(Natural n)(Natural arg) {
    return n+arg
}</programlisting>

            <para>In this case, the compiler does the job of automatically inferring 
            the definition of the inner method named <literal>increment()</literal>
            above. The body of the method is not executed until the second argument
            list has been specified&mdash;that is, until the returned function is
            invoked.</para>
            
            <!-- 
            <para>Finally, here's a third alternative, that makes use of a built-in
            extension to "curry" the first parameter of a method:</para>
            
            <programlisting>Natural add(Natural n, Natural m) {
    return n+m
}

Natural inc(Natural arg) = add.partial(3);</programlisting>
            -->
            
            <para>As you've probably noticed, all the functions we've defined so far 
            have been declared with a name, using a traditional C-like syntax. Now 
            let's see what Ceylon has instead of anonymous functions.</para>
            
        </section>

        <section>
            <title>Taking advantage of functional-style programming</title>
        
        <para>Let's go back, once again, to the attribute <literal>greeting</literal> 
        of <literal>Hello</literal>:</para>
        
        <programlisting><![CDATA[package String greeting {
    if (exists name) {
        return "Hello, " name "!"
    }
    else {
        return "Hello, World!"
    }
}]]></programlisting>

        <para>This definition works well enough, but it's quite procedural, with two 
        <literal>return</literal> statements. That's not usually considered good style 
        in Ceylon, though there are certainly times when it's necessary. Instead, Ceylon 
        lets you write code like this using a more functional style.</para>
        
        <para>In procedural programming we usually pass a list of values to a method, 
        which performs computations using those values, and returns another value. In 
        functional programming, we can pass an operation to a method, which calls our
        operation, and returns a value, or, perhaps, a different operation.</para>
        
        <para>For example, the Ceylon standard librares define a method called
        <literal>ifExists()</literal> that accepts an object and two <emphasis>callable 
        objects</emphasis>. (A method parameter that accepts a callable objects is called 
        a <emphasis>callable parameter</emphasis>.) If the object is not null, 
        <literal>ifExists()</literal> invokes the first method. Otherwise, 
        <literal>ifExists()</literal> invokes the second method. We can use 
        <literal>ifExists()</literal> to rewrite <literal>greeting</literal>:</para>

<programlisting><![CDATA[package String greeting {
    String helloName() { return "Hello, " name "!" }
    String helloWorld() { return "Hello, World!" }
    return ifExists(name, helloName, helloWorld)
}]]></programlisting>

        <para>Well, that's certainly more functional, but it's also a lot more verbose. 
        But this is not the way <literal>ifExists()</literal> is really intended to be
        used. Ceylon provides a special method argument syntax for defining a method 
        that is passed to another method inline, as part of the invocation. An inline 
        method definition is called an <emphasis>inline callable argument</emphasis>. 
        Inline callable arguments follow the normal parenthesized argument list.</para>
        
        <para>As a first step, we could rewrite <literal>greeting</literal> as follows, 
        to make it really clear that we're defining methods that are passed as arguments 
        to the callable parameters <literal>then</literal> and 
        <literal>otherwise</literal>.</para>

<programlisting><![CDATA[package String greeting {
    return ifExists(name)
        //first inline callable argument
        then () {
            return "Hello, " name "!"
        }
        //second inline callable argument
        otherwise () {
            return "Hello, World!"
        }
}]]></programlisting>

        <para>Note that there are three <literal>return</literal> statements here. The 
        nested <literal>return</literal> statements specify the return values of the two 
        inline methods. They do not end the execution of <literal>greeting</literal>!</para>

        <para>This syntax was chosen to make it possible to define new control structures 
        that closely mimic the syntactic form of the traditional C-style built-in control 
        structures.</para>
        
        <para>Usually, we would abbreviate the above code by:</para>
        
        <itemizedlist>
            <listitem>
                <para>eliminating the empty formal parameter lists&mdash;we 
                can leave off the <literal>()</literal>, and</para>
            </listitem>
            <listitem>
                <para>specifying the method return values in parentheses, 
                instead of writing <literal>return</literal> statements
                surrounded by braces&mdash;we're allowed to write
                <literal>("Hello, World!")</literal> instead of 
                <literal>{ return "Hello, World!" }</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>The abbreviated code looks like this:</para>

<programlisting><![CDATA[package String greeting {
    return ifExists(name) 
        then ("Hello, " name "!")
        otherwise ("Hello, World!")
}]]></programlisting>
        
        <para>This syntax might look a little unfamiliar at first, but you'll soon get 
        used to it. In Ceylon, we use method invocations with inline callable arguments 
        to express things that are difficult to express without specialized syntax in 
        other languages, for example:</para>
        
        <itemizedlist>
            <listitem>
                <para><emphasis>assertion</emphasis>, such as: 
                <literal>assert("x must be zero") that (x&equals;0.0);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>comprehension</emphasis>, such as:
                <literal>String[] names = from (people) select (Person p) (p.name);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>quantification</emphasis>, such as:
                <literal>Boolean adults = forAll (people) every (Person p) (p.age>=18);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>folds</emphasis>, such as:
                <literal>Float total = fold (items) with (Float sum, Item item) (sum + item.quantity*item.product.price);</literal></para>
            </listitem>
            <listitem>
                <para><emphasis>repetition</emphasis>, such as:
                <literal>repeat (3) times { stream.writeLine("Hello!"); }</literal></para>
            </listitem>
        </itemizedlist>
        
        <para>Look at each of these examples, and ask yourself:</para>
        
        <itemizedlist>
            <listitem>
                <para>What is the name of the method that is being called?</para>
            </listitem>
            <listitem>
                <para>Are there any ordinary arguments? Which are they?</para>
            </listitem>
            <listitem>
                <para>Which is the inline callable argument? What is its name?</para>
            </listitem>
            <listitem>
                <para>Are there any formal parameters of the inline callable argument? 
                What are the parameter names?</para>
            </listitem>
            <listitem>
                <para>Where is the implementation of the inline callable argument?
                What happens when the inline callable argument is invoked?</para>
            </listitem>
        </itemizedlist>
        
        <para>Well, if you thought you were starting to feel comfortable with this new 
        syntax, I've got something extra to throw at you! A method parameter can be 
        declared as an <emphasis>iterator</emphasis> method, which allows us to move 
        the declaration of the formal parameters of the inline callable arguments. For 
        example, the <literal>ceylon.language</literal> package defines a <literal>from()</literal> 
        method that is intended to be called like this:</para>
        
        <programlisting>String[] names = from (Person p in people) select (p.name) where (p.age>18);</programlisting>
        
        <para>Which is exactly equivalent to, but much more readable than, the
        following:</para>
        
        <programlisting>String[] names = from (people) select (Person p) (p.name) where (Person p) (p.age>18);</programlisting>
        
        <para>We won't go into the details how to declare an iterator method here 
        (it's just a couple of annotations). It's much more important to be able
        to <emphasis>use</emphasis> iterator methods than actually write them
        yourself.</para>
        
        <para>Oh, by the way, there's an even easier way to define 
        <literal>greeting</literal>, using the <literal>?</literal>
        operator.</para>
        
<programlisting><![CDATA[package String greeting {
    return "Hello, " (name ? "World") "!"
}]]></programlisting>
    
        </section>
        
       <section>
           <title>Named arguments revisited</title>
           
           <para>The following classes define a data structure for building
           tables:</para>
           
           <programlisting>class Table(String title, Natural rows, Border border, Column... columns) { ... }
class Column(String heading, Natural width, String content(Natural row)) { ... }
class Border(Natural padding, Natural weight) { ... }</programlisting>
           
           <para>Of course, we could built a <literal>Table</literal> using 
           positional argument lists:</para>
                      
           <programlisting>Table table = Table("Squares", 5, Border(2,1)
        Column("x",10) content (Natural row) ($row), 
        Column("x**2",12) content (Natural row) ($row**2));</programlisting>
           
           <para>However, it's far more common to use named arguments to build 
           a complex graph of objects. In this section we're going to meet some 
           new features of named argument lists, that make it especially 
           convenient to build object graphs.</para>
           
           <para>First, note that the syntax we've already seen for specifying
           a named argument value looks exactly like the syntax for overriding
           an abstract attribute. If you think about it, taking into account
           that a method parameter may accept references to other methods, the 
           whole problem of specifying values for named parameters starts to
           look a lot like the problem of overriding abstract members. Therefore,
           Ceylon let's us reuse much of the member declaration syntax inside a
           named argument list, including:</para>
           
           <itemizedlist>
               <listitem>
                   <para>method declarations&mdash;specify the "value" of a
                   parameter that accepts a method,</para>
               </listitem>    
               <listitem>
                   <para><literal>object</literal> (anonymous class) 
                   declarations&mdash;are most useful for specifing the value 
                   of a parameter whose type is an interface or abstract class,
                   and</para>
               </listitem>    
               <listitem>
                   <para>getter declarations&mdash;let us compute the value of
                   an argument inline.</para>
               </listitem>    
           </itemizedlist>
           
           <para>This helps explain why named argument lists are delimited by
           braces: the fully general syntax for a named argument list is very, 
           very close to the syntax for a class, method, or attribute body.</para>
           
           <para>So we could rewrite the code that builds a <literal>Table</literal>
           as follows:</para>
           
           <programlisting>Table table = Table { 
    title="Squares"; 
    rows=5;
    border = Border {
        padding=2;
        weight=1;
    };
    Column { 
        heading="x"; 
        width=10;
        String content(Natural row) {
            return $row
        }
    }, 
    Column { 
        heading="x**2"; 
        width=12;
        String content(Natural row) {
            return $row**2
        }
    }
};</programlisting>

           <para>Notice that we've specified the value of the parameter named
           <literal>content</literal> using the usual syntax for declaring a
           method.</para>
           
           <para>Even better, our example can be abbreviated like this:</para>
           
           <programlisting>Table table { 
    title="Squares"; 
    rows=5;
    Border border {
        padding=2;
        weight=1;
    }
    Column { 
        title="x"; 
        width=10; 
        String content(Natural row) {
            return $row
        }
    }, 
    Column { 
        title="x**2"; 
        width=10; 
        String content(Natural row) {
            return $row**2
        }
    } 
}</programlisting>
            
            <para>Notice how we've transformed our code from a form which 
            emphasized <emphasis>invocation</emphasis> into a form that 
            emphasizes <emphasis>declaration</emphasis> or a hierarchical
            structure. Semantically, the two forms are equivalent. But in
            terms of readability, they are very different.</para>
            
            <para>Now let's see an example of a named argument list with 
            an inline getter declaration:</para>
            
            <programlisting>public Payment(PaymentMethod method, Currency currency, Float amount) { ... }</programlisting>
            
            <programlisting>Payment payment {
    method = user.paymentMethod;
    currency = order.currency;
    Float amount { 
        mutable Float total := 0.0;
        for (Item item in order.items) {
            total += item.quantity * item.product.unitPrice;
        }
        return total
    }
}</programlisting>
            
            <para>Finally, here's an example of a named argument list with 
            an inline <literal>object</literal> declaration:</para>
            
            <programlisting><![CDATA[public void addObserver<T>(Observer<T> observer) { ... }]]></programlisting>
            
            <programlisting><![CDATA[observable.addObserver {
    object observer satisfies Observer<UpdateEvent> {
        override void on(UpdateEvent e) {
            log.info("Update:" + $e);
        }
    }
};]]></programlisting>
            
            <para>Of course, a better way to solve this problem is to 
            eliminate the <literal>Observer</literal> interface and pass a 
            method directly:</para>
            
            <programlisting><![CDATA[public void addObserver<T>(void on(T e)) { ... }]]></programlisting>
            
            <programlisting><![CDATA[observable.addObserver {
    void on(UpdateEvent e) {
        log.info("Update:" + $e);
    }
};]]></programlisting>
            
       </section>

        <section>
            <title>Defining user interfaces declaratively</title>

        <para>Finally, lets create a web-based user interface for our
        program. We're going to use the module <literal>ceylon.html</literal>,
        which defines an API for specifying HTML pages as a tree of
        objects.</para>
        
        <para>Of course, we could create a tree of objects as follows:</para>
        
        <programlisting>Html(
    Head('hello.css', "Hello World"),
    Body(
        Div("greeting", "Hello World"),
        Div("footer", "Powered by Ceylon")
    )
)</programlisting>

        <para>But by now you'll realize that a named argument list is a much more 
        natural to define a heirarchical structure like this. We could rewrite
        the expression above as follows:</para>

        <programlisting>Html {
    head = Head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    };
    body = Body {
        Div {
            cssClass = "greeting";
            "Hello World" 
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon" 
        }
    };
}</programlisting>

        <para>Or, even better, we could further simplify the syntax to the 
        following:</para>
        
        <programlisting>Html {
    Head head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    }
    Body body {
        Div {
            cssClass = "greeting";
            "Hello World" 
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon" 
        }
    }
}</programlisting>

        <para>We're going to use this syntax to define our web page.</para>
        
        <programlisting><![CDATA[import ceylon.html.*;

doc "A web page that displays a greeting"
page '/hello.html'
Html hello(Request request) {
    
    Head head { 
        title = "Hello World";
        cssStyleSheet = 'hello.css';
    }
    
    Body body {
        Div {
            cssClass = "greeting";
            Hello( request.parameters["name"] ).greeting
        },
        Div {
            cssClass = "footer";
            "Powered by Ceylon"
        }
    }

}]]></programlisting>

        <para>The <literal>page</literal> annotation specifies the URL at which 
        this HTML should be accessible. A single-quoted string literal is used, 
        allowing the format of the URL to be validated at compile time.</para>
        
    </section>
    
    <section>
        <title>Defining structured data formats</title>
        
        <para>Let's try and define our own structured data format, to personalize
        our program a little. First, we'll create a class to represent people:</para>
        
        <programlisting>doc "Represents a person"
class Person(String firstName, String lastName, Language lang) {
    package String firstName = firstName;
    package String lastName = lastName;
    package Language language = lang;
}</programlisting>
        
        <para>Now, we'll create an interface which enumerates its cases&mdash;almost 
        exactly like a Java <literal>enum</literal>&mdash;to represent the built-in 
        languages that our program supports.</para>
        
        <programlisting>interface Language of english, french, spanish, italian;

object english extends Case("English") satisfies Language;
object french extends Case("French") satisfies Language;
object spanish extends Case("Spanish") satisfies Language;
object italian extends Case("Italian") satisfies Language;</programlisting>

<!--
        <para>The use of <literal>...</literal> at the end of the list of enumerated
        instances means that it's possible to create other <literal>Language</literal>s.
        Very important in this case, since our list of languages is definitely not 
        exhaustive! If our list of instances were exhaustive, we would terminate it
        using <literal>;</literal>, thereby preventing other code from instantiating
        additional <literal>Language</literal>s.</para>
-->

        <para>Now we can define the set of people known to our application like
        this:</para>
        
        <programlisting>Set&lt;Person&gt; people = {
        Person {
            firstName = "Gavin";
            lastName = "King";
            language = english;
        },
        Person {
            firstName = "Emmanuel";
            lastName = "Bernard";
            language = french;
        },
        Person {
            firstName = "Pete";
            lastName = "Muir
            language = english;
        },
        Person {
            firstName = "Andrew";
            lastName = "Haley";
            language = english;
        }
    };</programlisting>
    
        <para>But where should we put our list of people? Well, just for fun, let's
        specify them using an annotation of <literal>Hello</literal>. First we'll 
        need to learn how to define new annotations.</para>
        
    </section>
    
    <section>
        <title>Defining annotations</title>
        
        <para>In Ceylon, an annotation is just a method that produces an ordinary 
        type. An annotation for specifying a set of people could be defined like 
        this:</para>
        
        <programlisting>doc "An annotation for specifying a list of 
     people"
annotation { 
    of = classes; 
    withType = Greeting;
    occurs = onceEachType; 
}
package Set&lt;People&gt; people(Person... people) {
    return HashSet(people);
}</programlisting>

        <para>The meta-annotation <literal>annotation</literal> specifies that this 
        annotation can only occur an the class <literal>Greeting</literal>, and can 
        only occur once.</para>
        
        <para>Ceylon provides a typesafe <emphasis>metamodel</emphasis> for types, 
        classes, interfaces, methods and attributes. This is Ceylon's version of
        Java's reflection API, but it's much, much easier to use and much more 
        powerful. We'll need to use the metamodel to gain access to program element
        annotations at runtime.</para>
        
        <para>We're not going to go into all the details of the metamodel here. All
        you need to know is that in the code we're about to see, the expression 
        <literal>Greeting</literal> evaluates to the metamodel object of type 
        <literal>Class&lt;Greeting&gt;</literal>. We could write:</para>
        
        <programlisting>Class&lt;Greeting&gt; greetingClass = Greeting;</programlisting>
        
        <para>Similarly, the expression <literal>Set&lt;Person&gt;</literal> evaluates 
        to the metamodel object of type <literal>Type&lt;Set&lt;Person&gt;&gt;</literal>.
        We could write:</para>
        
        <programlisting>Type&lt;Set&lt;Person&gt;&gt; personSetType = Set&lt;Person&gt;;</programlisting>

        <para>We obtain the annotations of a program element&mdash;in this case, the 
        class <literal>Greeting</literal>&mdash;using reflection upon the metamodel 
        object that represents the program element. We must specify the type returned by 
        the annotation&mdash;in this case, <literal>Set&lt;People&gt;</literal>&mdash;by 
        passing its metamodel object.</para>
        
        <programlisting>Set&lt;Person&gt;[] annotations = Greeting.annotations(Set&lt;Person&gt;);</programlisting>
        
        <para>Careful, there may be multiple annotations producing the same type of 
        object!</para>
        
        <para>We're already ready to use our new annotation. Just like with other 
        method invocations, we have the choice between specifying the arguments of 
        an annotation using a positional argument list surrounded by parenthesis, 
        or using a named argument list surrounded by braces. In this case, the 
        braces look more visually appealing:</para>
        
        <programlisting>doc "A personalized greeting"
people {
    Person {
        firstName = "Gavin";
        lastName = "King";
        language = english;
    },
    Person {
        firstName = "Emmanuel";
        lastName = "Bernard";
        language = french;
    },
    Person {
        firstName = "Pete";
        lastName = "Muir
        language = english;
    },
    Person {
        firstName = "Andrew";
        lastName = "Haley";
        language = english;
    }
}
class Hello(String? name) {

    doc "The list of people"
    Set&lt;Person&gt; people;
    if (exists Set&lt;Person&gt; annotation = 
            type.annotations(Set&lt;Person&gt;).first) {
        people = annotation;
    }
    else {
        throw Exception("Not annotated people")
    }
    
    doc "The word for \"Hello\" in the given 
         language"
    String word(Language language) {
        switch (language) {
            case (english) { return "Hello" }
            case (spanish) { return "Hola" }
            case (french) { return "Bonjour" }
            case (italian) { return "Ciao" }
        }
    }
    
    doc "The greeting"
    package String greeting {
        if (exists name) {
            if (exists Person person = 
                    first (Person p in people) 
                        where (p.firstName &equals; name)) {
                return "" word(p.language) ", " person.firstName " " person.lastName "!"
            }
            else {
                return "Hello, " name "!";
            }
        }
        else {
            return "Hello, World!";
        }
    }
    
    doc "Print the greeting"
    package void say(OutputStream stream) { 
        stream.writeLine(greeting); 
    }
    
}</programlisting>
        
    </section>
    
    <section>
        <title>Defining generic types</title>
    
        <para>Programming with generic types is one of the most difficult parts of
        Java. That's still true, to some extent, in Ceylon. But because the Ceylon
        language and SDK were designed for generics from the ground up, Ceylon is
        able to alleviate the most painful aspects of Java's bolted-on-later model.</para>
        
        <para>Just like in Java, type parameters are listed before ordinary formal
        parameters, enclosed in angle brackets.</para>
        
        <programlisting>interface Collection&lt;X&gt; { ... }</programlisting>  
        <programlisting>class Array&lt;T&gt;(T... elements) satisfies T[] { ... }</programlisting>
        <programlisting>T[] singleton&lt;T&gt;(T element) { .... }</programlisting>
        
        <para>We usually don't need to explicitly specify type arguments in method
        invocations or class instantiations (the type arguments can very often be 
        inferred from the ordinary arguments), but, unlike Java, we always do need 
        to specify type arguments in a type declaration (there are no raw types in 
        Ceylon).</para>
        
        <programlisting>Array&lt;String&gt; strings = Array("Hello", "World");</programlisting>
        <programlisting>Person[] onlyMe = singleton(me);</programlisting>
        <programlisting>Collection&lt;Order&gt; orders = getOrders();</programlisting>
        
        <para>The root cause of very many problems when working with generic types 
        in Java is <emphasis>type erasure</emphasis>. Generic type parameters and
        arguments are discarded by the compiler, and simply aren't available at 
        runtime. So the following, perfectly sensible, code fragments just wouldn't 
        compile in Java:</para>
        
        <programlisting>if (is List&lt;Person&gt; list) { ... }</programlisting>
        <programlisting>if (is T obj) { ... }</programlisting>
        <programlisting>Type&lt;T&gt; tType = T;</programlisting>
        
        <para>(Where <literal>T</literal> is a generic type parameter.)</para>
        
        <para>You'll be pleased to know that in Ceylon, these three code fragments 
        compile and function as expected. Like Java, the Ceylon compiler performs
        erasure, discarding type parameters from the schema of the generic type.
        But unlike Java, type arguments are <emphasis>reified</emphasis> (available 
        at runtime). Of course, generic type arguments aren't checked for typesafety 
        by the underlying virtual machine at runtime, but type arguments are at least 
        available at runtime to code that wants to make use of them explicitly. You
        can even use reflection to discover the type arguments of an instance of a 
        generic type.</para>
        
        <programlisting>String[] strings = { "Gavin", "Andrew", "Gary" };
Object[] objects = strings;
Type&lt;Object[]&gt; otype = objects.type;
assert() that (otype.arguments.first == String);  //assertion succeeds</programlisting>
                
        <para>Furthermore, Ceylon is able to eliminate one of the bits of Java 
        generics that's really hard to get your head around: wildcard types. 
        Wildcard types were Java's solution to the problem of <emphasis>covariance</emphasis> 
        in a generic type system. Let's first explore the idea of covariance, and 
        then see how Ceylon's solution, copied from Scala, works.</para>
        
    </section>
    
    <section>
        <title>Covariance and contravariance</title>
        
        <para>It all starts with the intuitive expectation that a collection of
        <literal>Geek</literal>s is a collection of <literal>Person</literal>s.
        That's a reasonable intuition, but in procedural languages, where 
        collections can be mutable, it turns out to be incorrect. Consider the
        following possible definition of <literal>Collection</literal>:</para>
        
        <programlisting>interface Collection&lt;X&gt; {
    Iterator&lt;X&gt; iterator();
    void add(X x);
}</programlisting>

        <para>And let's suppose that <literal>Geek</literal> is a subtype of 
        <literal>Person</literal>.</para>
        
        <para>The intuitive expectation is that the following code should work:</para>
        
        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Collection&lt;Person&gt; people = geeks;   //compiler error
for (Person person in people) { ... }</programlisting>
        
        <para>This code is, frankly, perfectly reasonable taken at face value. Yet
        in both Java and Ceylon, this code results in a compiler error at the 
        second line, where the <literal>Collection&lt;Geek&gt;</literal> is assigned 
        to a <literal>Collection&lt;Person&gt;</literal>. Why? Well, because if we 
        let the assignment through, the following code would also compile:</para>
        
        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Collection&lt;Person&gt; people = geeks;   //compiler error
people.add( Person("Fonzie") );</programlisting>

        <para>We can't let that code by&mdash;Fonzie isn't a <literal>Geek</literal>!</para>
        
        <para>Using big words, we say that <literal>Collection</literal> is
        <emphasis>nonvariant</emphasis> in <literal>X</literal>. Or, when we're not
        trying to impress people with opaque terminology, we say that 
        <literal>Collection</literal> both <emphasis>produces</emphasis>&mdash;via the
        <literal>iterator()</literal> method&mdash;and <emphasis>consumes</emphasis>&mdash;via
        the <literal>add()</literal> method&mdash;instances of <literal>X</literal>.</para>
        
        <para>Here's where Java goes off and dives down a rabbit hole, inventing 
        wildcards to try and squeeze a covariant or contravariant type out of a 
        nonvariant type, but mainly succeeding in thoroughly confusing everybody.
        We're not going to follow Java down the hole.</para>
        
        <para>Instead, we're going to refactor <literal>Collection</literal> into
        a pure producer interface and a pure consumer interface:</para>
        
        <programlisting>interface Producer&lt;out X&gt; {
    Iterator&lt;X&gt; iterator();
}</programlisting>

        <programlisting>interface Consumer&lt;in X&gt; {
    void add(X x);
}</programlisting>

        <para>Notice that we've annotated the type parameters of these interfaces.</para>
        
        <itemizedlist>
            <listitem>
                <para>The <literal>out</literal> annotation specifies that 
                <literal>Producer</literal> is <emphasis>covariant</emphasis>
                in <literal>X</literal>; that it produces instances of 
                <literal>X</literal>, but never consumes instances of 
                <literal>X</literal>.</para>
            </listitem>
            <listitem>
                <para>The <literal>in</literal> annotation specifies that 
                <literal>Consumer</literal> is <emphasis>contravariant</emphasis>
                in <literal>X</literal>; that it consumes instances of 
                <literal>X</literal>, but never produces instances of 
                <literal>X</literal>.</para>
            </listitem>
        </itemizedlist>
        
        
        <para>The Ceylon compiler validates the schema of the type declaration to 
        ensure that the variance annotations are satisfied. If you try to declare 
        an <literal>add()</literal> method on <literal>Producer</literal>, a
        compilation error results. If you try to declare an <literal>iterate()</literal>
        method on <literal>Consumer</literal>, you get a similar compilation 
        error.</para>
        
        <para>Now, let's see what that buys us:</para>
        
        <itemizedlist>
            <listitem>
        <para>Since <literal>Producer</literal> is covariant in its type parameter
        <literal>X</literal>, and since <literal>Geek</literal> is a subtype 
        of <literal>Person</literal>, Ceylon lets you assign
        <literal>Producer&lt;Geek&gt;</literal> to 
        <literal>Producer&lt;Person&gt;</literal>.</para>
            </listitem>
            <listitem>
        <para>Furthermore, 
        since <literal>Consumer</literal> is contravariant in its type parameter
        <literal>X</literal>, and since <literal>Geek</literal> is a subtype 
        of <literal>Person</literal>, Ceylon lets you assign
        <literal>Consumer&lt;Person&gt;</literal> to 
        <literal>Consumer&lt;Geek&gt;</literal>.</para>
            </listitem>
        </itemizedlist>
        
        <para>We can define our <literal>Collection</literal> interface as a
        mixin of <literal>Producer</literal> with <literal>Consumer</literal>.</para>
        
        <programlisting>interface Collection&lt;X&gt; 
        satisfies Producer&lt;X&gt;, Consumer&lt;X&gt; {}</programlisting>
        
        <para>Notice that <literal>Collection</literal> remains nonvariant in
        <literal>X</literal>.</para>
        
        <para>Now, the following code finally compiles:</para>

        <programlisting>Collection&lt;Geek&gt; geeks = ... ;
Producer&lt;Person&gt; people = geeks;
for (Person person in people) { ... }</programlisting>

        <para>Which matches our original intuition.</para>

        <para>The following code also compiles:</para>
        
        <programlisting>Collection&lt;Person&gt; people = ... ;
Consumer&lt;Geek&gt; geekConsumer = people;
geekConsumer.add( Geek("James Gosling") );</programlisting>

        <para>Which is also intuitively correct&mdash;James is most certainly
        a <literal>Person</literal>!</para>
        
        <para>You're unlikely to spend much time writing your own collection
        classes, since the Ceylon SDK has a powerful collections framework
        built in. But you'll still appreciate Ceylon's approach to covariance
        as a user of the built-in collection types. The collections framework 
        defines two interfaces for each basic kind of collection. For example, 
        there is an interface <literal>List&lt;X&gt;</literal> which represents 
        a read-only view of a list, and is covariant in <literal>X</literal>, 
        and <literal>OpenList&lt;X&gt;</literal>, which represents a mutable 
        list, and is nonvariant in <literal>X</literal>.</para>
        
    </section>
    
    <section>
        <title>Generic type constraints</title>
        
        <para>Very commonly, when we write a parameterized type, we want to be
        able to invoke methods or evaluate attributes upon instances of the
        type parameter. For example, if we were writing a parameterized type
        <literal>Set&lt;T&gt;</literal>, we would need to be able to compare
        instances of <literal>T</literal> using <literal>==</literal> to see if 
        a certain instance of <literal>T</literal> is contained in the
        <literal>Set</literal>. Since <literal>==</literal> is only defined for 
        expressions of type <literal>Equals</literal>, we need some way to 
        assert that <literal>T</literal> is a subtype of 
        <literal>Equals&lt;T&gt;</literal>. This is an example of a
        <emphasis>type constraint</emphasis>&mdash;in fact, it's an example of 
        the most common kind of type constraint, a <emphasis>lower 
        bound</emphasis>.</para>
        
        <programlisting>public class Set&lt;out T&gt;(T... elements)
        given T satisfies Equals&lt;T&gt; {
    ...
        
    public Boolean contains(Object obj) {
        if (is T obj) {
            return forAny (T t in bucket(obj.hash)) 
                        some (t==obj)
        }
        else {
            return false
        }
    }

}</programlisting>
        
        <para>A type argument to <literal>T</literal> must be a type that
        extends or implements <literal>Equals&lt;T&gt;</literal>.</para>
        
        <programlisting>Set&lt;String&gt; set = Set("C", "Java", "Ceylon");  //ok</programlisting>
        <programlisting>Set&lt;Character[]&gt; set = Set("C", "Java", "Ceylon"); //compile error</programlisting>

        <para>In Ceylon, a generic type parameter is considered a proper type,
        so a type constraint looks a lot like a class or interface declaration.
        This is another way in which Ceylon is more regular than some other
        C-like languages.</para>
        
        <para>A lower bound lets us call methods and attributes of the bound, 
        but it doesn't let us instantiate new instances of <literal>T</literal>.  
        The second-most common kind of type constraint in Ceylon is an 
        <emphasis>initialization parameter specification</emphasis>.</para>
        
        <programlisting>public class Factory&lt;out T&gt;() 
        given T(String s) {
        
    public T produce(String string) {
        return T(string)
    }
    
}</programlisting>

        <para>A type argument to <literal>T</literal> must be a class with a 
        single initialization parameter of type <literal>String</literal>.</para>
        
        <programlisting>Factory&lt;Hello&gt; = Factory&lt;PersonalizedHello&gt;();  //ok</programlisting>
        <programlisting>Factory&lt;Hello&gt; = Factory&lt;DefaultHello&gt;();  //compile error</programlisting>

        <para>Finally, the third kind of type constraint, which is much less
        common, and which most people find much more confusing, is an 
        <emphasis>upper bound</emphasis>. An upper bound is the opposite of a 
        lower bound. It says that a type parameter is a supertype of some other 
        type. There's only really one situation where this is useful. Consider 
        adding a <literal>union()</literal> operation to our <literal>Set</literal> 
        interface. We might try the following:</para>
        
        <programlisting>public class Set&lt;out T&gt;(T... elements)
        given T satisfies Equals&lt;T&gt; {
    ...
    
    public Set&lt;T&gt; union(Set&lt;T&gt; set) {   //compile error
        return ....
    }
    
}</programlisting>

        <para>This doesn't compile because we can't use the covariant type 
        parameter <literal>T</literal> in the type declaration of a method
        parameter. The following declaration would compile:</para>
        
        <programlisting>public class Set&lt;out T&gt;(T... elements)
        given T satisfies Equals&lt;T&gt; {
    ...
    
    public Set&lt;Object&gt; union(Set&lt;Object&gt; set) {
        return ....
    }
    
}</programlisting>
        
        <para>But, unfortunately, we get back a <literal>Set&lt;Object&gt;</literal>
        no matter what kind of set we pass in. A lower bound is the solution
        to our dilemma:</para>
        
        <programlisting>public class Set&lt;out T&gt;(T... elements)
        given T satisfies Equals&lt;T&gt; {
    ...
    
    public Set&lt;X&gt; union(Set&lt;X&gt; set) 
            given X abstracts T {
        return ....
    }
    
}</programlisting>
        
        <para>The compiler chooses an appropriate <literal>X</literal> for
        the given argument to <literal>union()</literal>:</para>
        
        <programlisting>Set&lt;String&gt; strings = Set("abc", "xyz") ;
Set&lt;String&gt; moreStrings = Set("foo", "bar", "baz");
Set&lt;String&gt; allTheStrings = strings.union(moreStrings);</programlisting>
        
        <programlisting>Set&lt;Decimal&gt; decimals = Set(1.2.decimal, 3.67.decimal) ;
Set&lt;Float&gt; floats = Set(0.33, 22.0, 6.4);
Set&lt;Number&gt; allTheNumbers = decimals.union(floats);</programlisting>
        
        <programlisting>Set&lt;Hello&gt; hellos = Set( DefaultHello(), PersonalizedHello(name) );
Set&lt;Object&gt; objects = Set("Gavin", 12, `%`, true);
Set&lt;Object&gt; allTheObjects = hellos.union(objects);</programlisting>
        
    </section>
    
    <section>
        <title>Sequenced type parameters</title>
        
            <para>Most static type systems have problems representing the type of a 
            function, because a single generic type parameter can't capture a variable 
            number of parameter types. Other statically typed languages feature a 
            variety of ways of working around this problem, but Ceylon's unique solution 
            is cleaner and ultimately more powerful.</para>
            
            <para>Ceylon, like Java, lets you write a method with a parameter that accepts 
            multiple arguments, for example:</para>
            
            <programlisting>void print(String... strings) {
    for (String s in strings) {
        process.write(s);
    }
    process.writeLine();
}</programlisting>
            
            <para>In Ceylon, we call this a <emphasis>sequenced parameter</emphasis>.</para>
            
            <para>By analogy, a <emphasis>sequenced type parameter</emphasis> is a type 
            parameter that accepts multiple type arguments. A sequenced type paramet is
            written as <literal>P...</literal> in the type parameter list of a generic
            type. Here's how Ceylon represents the type of a function:</para>
            
            <programlisting><![CDATA[public interface Callable<out R, P...> { 
            
    R call(P... args);
    
    ...
}]]></programlisting>
            
            <para>For example:</para>
            
            <itemizedlist>
                <listitem>
                    <para>A function which accepts a <literal>String</literal> and returns 
                    a <literal>Decimal</literal> is a 
                    <literal>Callable&lt;Decimal,String&gt;</literal>. Its 
                    <literal>call()</literal> method has the signature 
                    <literal>Decimal call(String arg)</literal>.</para>
                </listitem>
                <listitem>
                    <para>A function which accepts two <literal>Integer</literal>s and 
                    returns an <literal>Integer</literal> is a 
                    <literal>Callable&lt;Integer,Integer,Integer&gt;</literal>. Its 
                    <literal>call()</literal> method has the signature 
                    <literal>Integer call(Integer arg1, Integer arg2)</literal>.</para>
                </listitem>
            </itemizedlist>
            
            <para>Thus, sequenced type parameters let us write types that abstract over 
            methods with arbitrary signatures in a typesafe way.</para>
            
            <para>Going back to our earlier example, we could write:</para>
            
            <programlisting>Hello hello = DefaultHello();
Callable&lt;Void,OutputStream&gt; say = hello.say;
say(stream);</programlisting>
            
            <para>Sequenced type parameters are the foundation of Ceylon's unique 
            statically typesafe metamodel (Ceylon's version of Java's reflection API).
            A metamodel type like <literal>Class</literal> and <literal>Method</literal>
            is a generic type with a sequenced type parameter representing the formal 
            parameter types of the class or method.</para>
            
            <programlisting>Class&lt;DefaultHello&gt; dh = DefaultHello;</programlisting>
            <programlisting>Class&lt;PersonalizedHello,String&gt; ph = PersonalizedHello;</programlisting>
            <programlisting>Method&lt;Hello,Void,OutputStream&gt; hsay = Hello.say;</programlisting>
            
            <para>We can invoke a <literal>Class</literal> or <literal>Method</literal>
            object (since both types extend <literal>Callable</literal>). The following:</para>
            
            <programlisting>Class&lt;PersonalizedHello,String&gt; ph = PersonalizedHello;
Method&lt;Hello,Void,OutputStream&gt; hsay = Hello.say;
Hello hello = dh("gavin");
void say(OutputStream stream) = hsay(hello);
say(outputStream);</programlisting>

            <para>is equivalent to:</para>
        
            <programlisting>Hello hello = PersonalizedHello("gavin");
void say(OutputStream stream) = hello.say;
say(outputStream);</programlisting>

    </section>
    
    <section>
        <title>Introducing a new type to an object</title>
        
        <para>Ceylon doesn't have multiple inheritance or mixins. If you're used
        to the single-inheritance-with-interfaces model of Java, you'll find
        yourself pretty much right at home with inheritance in Ceylon.</para>
        
        <para>However, Ceylon does have something else, that's usually almost as
        good as, and often better than, true multiple inheritance. An
        <emphasis>extension</emphasis> adds a type, call an <emphasis>introduced</emphasis>
        type, to an existing type, called the <emphasis>extended</emphasis> type.
        An extension doesn't change the original definition of the extended type,
        and it doesn't affect the internal workings of an object of that type in
        any way. But from the point of view of a client of the object, the object
        now has all the attributes and methods of the introduced type, and is
        assignable to the introduced type.</para>
        
        <para>Let's introduce a type onto every object. Ceylon's
        <literal>Object</literal> class defines an attribute named 
        <literal>log</literal> of type <literal>Log</literal> that you can use
        to log stuff. Usually, you use it like this:</para>
        
        <programlisting>log.debug("Hello, I'm a debug message");</programlisting>
        
        <para>But perhaps you don't like having to type the "<literal>log.</literal>"
        bit every time you write out a log message, and suppose you don't expect
        to ever need methods named <literal>info()</literal>, <literal>error()</literal>
        <literal>warn()</literal> or <literal>debug()</literal> in your application.
        If so, wouldn't it be nice to just write:</para>
        
        <programlisting>debug("Do you think anyone ever reads me?");</programlisting>
        
        <para>Obviously, one way to do this would be to copy and paste all the
        <literal>info()</literal>, <literal>error()</literal>
        <literal>warn()</literal> and <literal>debug()</literal> methods from
        <literal>Log</literal> onto <literal>Object</literal>, and have them
        delegate back to <literal>log</literal>. But we don't like copy/paste
        programming here.</para>
        
        <para>Another way might be to make <literal>Object</literal> extend 
        <literal>Log</literal>, but that way <literal>Log</literal>
        would be the logical root of the Ceylon type system, instead of 
        <literal>Object</literal>. That doesn't feel right.</para>
        
        <para>Instead, we're going to introduce <literal>Log</literal> onto
        <literal>Object</literal> using an extension. If we were able to modify 
        the code of <literal>Object</literal>, this would be as easy as adding 
        an <literal>extension</literal> annotation to the <literal>log</literal>
        attribute like this:</para>
        
        <programlisting>public extension Log log { ... }</programlisting>
        
        <para>But since <literal>Object</literal> is built into the Ceylon SDK, 
        we don't have control over its code, and so we need to take a different 
        approach. We'll write a toplevel <emphasis>extension method</emphasis>,
        sometimes called a <emphasis>converter</emphasis>:</para>
        
        <programlisting>public extension Log objectToLog(Object this) { 
    return this.log
}</programlisting>
        
        <para>The extended type is the type of the parameter of the converter.
        The introduced type is the return type of the converter.</para>
        
        <para>Now, we can't just have hundreds of third-party extensions all
        vandalizing <literal>Object</literal> with their own introduced types,
        and polluting the namespace with thousands of introduced methods and
        attributes. So the client code that uses the extension is responsible
        for explicitly activating the extension in the compilation unit where
        it is used. To activate an extension we <literal>import</literal> 
        it.</para>
        
        <programlisting>import implicit com.domain.util.objectToLog;
        
class Hello(String? name) {

    ...
    
    info(greeting);
    
    ...

}</programlisting>

        <para>The compiler automatically inserts a call to <literal>objectToLog()</literal>. 
        So the above code is equivalent to:</para>

        <programlisting>import com.domain.util.objectToLog;
        
class Hello(String? name) {

    ...
    
    if (is Log this) {
        this.info(greeting);
    }
    else {
        objectToLog(this).info(greeting);
    }
    
    ...

}</programlisting>

        <para>A compilation unit that doesn't explicitly import 
        <literal>objectToLog</literal> won't be affected by the extension, and
        won't be able to call the <literal>info()</literal> method without
        explicitly invoking the <literal>log</literal> attribute.</para>
        
        <para>In the next sections, we're going to see a two very different 
        applications of extensions.</para>
        
    </section>
    
    <section>
        <title>String interpolation and the format operator</title>
        
        <para>We've already seen a couple of of examples of 
        <emphasis>string interpolation</emphasis>:</para>
        
        <programlisting>"Hello, " name "!"</programlisting>
        
        <para>And of the <emphasis>format operator</emphasis>, the prefix 
        <literal>$</literal>:</para>
        
        <programlisting>stream.writeLine($obj);</programlisting>
        
        <para>You might have wondered earlier exactly what expression types are 
        permitted in an interpolated string or as arguments to the format operator. 
        The answer is that the expression must be of type <literal>Format</literal>.
        The only built-in type that directly implements <literal>Format</literal>
        is <literal>String</literal>. That might seem pretty limiting at first glance.
        After all, shouldn't we at very least be able to use numeric expressings in an 
        interpolated string?</para>
        
        <para>Well, the problem is that we don't always want to use exactly the same
        formatting rules for printing out objects or numeric values. For example, in
        in log and assertion messages, it's normal to represent a null value as the 
        string <literal>"null"</literal>, and a complex object as a list of its named 
        property values. On the other hand, in a HTML page, it probably makes more
        sense to represent a null value as an empty string, and a complex object by 
        its unique business key. Likewise, in many, but not all, contexts it makes
        sense to truncate floating point values to a certain fixed number of decimal
        places.</para>
        
        <para>Therefore, it is normal to define a format in a separate class, for
        example:</para>
        
        <programlisting>public class FloatFormat(Float float) 
        satisfies Format {
    override String formatted {
        return ... 
    }
}</programlisting>
        
        <para>Now, of course, one option we have is to explicitly wrap each object 
        we're printing out in an instance of the appropriate <literal>Format</literal>.</para>
        
        <programlisting>stream.writeLine("2 / 3 = " + $FloatFormat(2.0/3))</programlisting>
        
        <para>But this gets verbose and boring. So we can define our format as an 
        extension, for example:</para>
        
        <programlisting>public extension class FloatFormat(Float float) 
        satisfies Format {
    override String formatted {
        return ... 
    }
}</programlisting>
        
        <para>And we can enable the appropriate default format by 
        <literal>import</literal>ing the extension:</para>
        
        <programlisting>import implicit org.mycompany.format.FloatFormat;</programlisting>
        
        <para>And now, when we don't explicitly specify a format, the format defaults
        to the extension format:</para>
        
        <programlisting>stream.writeLine("2 / 3 = " + $(2.0/3))</programlisting>
        
        <para>Ceylon includes a built-in extension, 
        <literal>ceylon.language.util.DebugFormat</literal> that formats any expression 
        assignable to <literal>Object?</literal> to an appropriate representation for 
        log and assertion messages, delegating back to <literal>Object.string</literal>
        for non-null values.</para>
        
    </section>
    
    <section>
        <title>Single quoted literals</title>
        
        <para>Ceylon doesn't have a built-in literal syntax for any of the following 
        types of object commonly encountered in procedural or declarative code:</para>
        
        <itemizedlist>
            <listitem>
                <para>dates, times, and durations,</para>
            </listitem>
            <listitem>
                <para>hexadecimal and binary numbers,</para>
            </listitem>
            <listitem>
                <para>regular expressions,</para>
            </listitem>
            <listitem>
                <para>URLs and URIs,</para>
            </listitem>
            <listitem>
                <para>email addresses, and</para>
            </listitem>
            <listitem>
                <para>cron expressions.</para>
            </listitem>
        </itemizedlist>
        
        <para>All of these are examples of special-purpose "mini-languages" with their
        own parsing and validation rules that are not encoded into the Ceylon compiler.
        In many other programming languages, it is common practice to embed mini-languages
        in strings, resulting in code that can't be validated for syntactic correctness
        at compile time.</para>
        
        <para>In Ceylon, we embed mini-languages using single-quoted literals. For
        example:</para>
        
        <programlisting>Datetime datetime = Datetime('25/03/2005', '12:00 AM PST');</programlisting>
        <programlisting>public pattern('^\w+@((\w+)\.)+$') mutable String emailAddress; </programlisting>
        <programlisting>Button { color = 'FF3B66'; label = "Click me"; }</programlisting>
        <programlisting>A { href = 'http://jboss.org/ceylon'; "Ceylon site" }</programlisting>
        
        <para>A single quoted literal is an expression of type <literal>Quoted</literal>.
        We write an extension to convert an instance of <literal>Quoted</literal> to a
        more semantic type, for example:</para>
        
        <programlisting>public extension Color hexToColor(Quoted hex) { return ... }</programlisting>
        
        <para>The Ceylon compiler treats extensions with the extended type 
        <literal>Quoted</literal> as a very special case. Unlike other extensions, an 
        extension of <literal>Quoted</literal> is called by the compiler at compile time.
        If the extension throws an exception, a compilation error results. Thus, it's 
        possible to validate the syntax of embedded mini-languages are compile-time.</para>
        
        <para>The Ceylon SDK includes built-in support for quoted literals representing
        dates, times, URLs, hexadecimal and binary numbers, and PERL-style regular 
        expressions.</para>
        
    </section>
    
    </section>
    
</chapter>