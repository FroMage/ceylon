#!/usr/bin/env python

import glob
import os
import subprocess
import sys

class TestHarness:
    def __init__(self, basedir):
        self.basedir = basedir
        self.antlr_jarfile = os.path.join(
            self.basedir, "lib/antlrworks-1.3.1.jar")
        self.javac_srcdir = os.path.join(
            self.basedir, "langtools/src/share/classes")
        self.runtime_srcdir = os.path.join(self.basedir, "runtime")
        self.runtime_builddir = os.path.join(self.basedir, "build/classes")
        self.testdir = os.path.join(self.basedir, "test")

    """The classpath required to run the Ceylon compiler
    """
    def classpath(self, *extras):
        return ":".join((self.runtime_builddir,
                         self.javac_srcdir,
                         self.antlr_jarfile) + extras)

    """Make sure the runtime classes are up to date.  It would
    be preferable if this were done using Ant, but to avoid an
    complete rebuild each time would require a rewritten javac
    task, which is currently written assuming that all source
    files have the same extension.  Extending it to allow source
    files with two different extensions would take far longer
    than it took me to write this little hack.
    """
    def update_runtime(self):
        todo = []
        for srcdir, dirs, files in os.walk(self.runtime_srcdir):
            assert srcdir.startswith(self.runtime_srcdir)
            dstdir = self.runtime_builddir + srcdir[len(self.runtime_srcdir):]
            for file in files:
                file = file.split(".")
                ext = file.pop()
                if ext in ("java", "ceylon"):
                    file = ".".join(file)
                    src = os.path.join(srcdir, file + "." + ext)
                    dst = os.path.join(dstdir, file + ".class")
                    if os.path.exists(dst):
                        if os.path.getmtime(src) < os.path.getmtime(dst):
                            continue
                    todo.append(src)
        if todo:
            sp = subprocess.Popen(
                ["java",
                 "-ea",
                 "-cp", self.classpath(self.runtime_srcdir),
                 "com.redhat.ceylon.compiler.Main",
                 "-d", self.runtime_builddir,
                 "-src", self.runtime_srcdir] + todo,
                stdout = subprocess.PIPE,
                stderr = subprocess.PIPE)
            out, err = sp.communicate()
            if sp.returncode != 0:
                sys.stdout.write(out)
                sys.stdout.write(err)
                sys.exit(sp.returncode)

    def find_test_cases(self):
        paths = []
        for dir, dirs, files in os.walk(self.testdir):
            if "expect.out" in files:
                paths.append(dir)
        paths.sort()
        return paths

    def run(self, cases = None):
        self.update_runtime()
        if not cases:
            cases = self.find_test_cases()
        self.success = self.failure = self.error = 0
        for case in cases:
            TestCase(case).run(self)
        print
        print ", ".join(map(self.report, ("success", "failure", "error")))

    def report(self, what):
        count = getattr(self, what)
        if count != 1:
            if what.endswith("s"):
                what += "e"
            what += "s"
        return "%d %s" % (count, what)

    def log(self, dir, what):
        setattr(self, what, getattr(self, what) + 1)
        if what == "success":
            print dir
        else:
            print "%-48s %s" % (dir, {"failure": "FAIL",
                                      "error": "ERROR"}[what])
        sys.stdout.flush()

class TestCase:
    def __init__(self, path):
        if os.path.exists(path) and not os.path.isdir(path):
            path = os.path.dirname(path)
        self.dir = path
        self.expectfile = os.path.join(self.dir, "expect.out")
        self.actualfile = os.path.join(self.dir, "actual.out")

    def run(self, harness):
        paths = []
        for dir, dirs, files in os.walk(self.dir):
            for file in files:
                ext = file.split(".")[-1]
                if ext in ("java", "ceylon"):
                    paths.append(os.path.join(dir, file))
        if not paths:
            self.log_error("", "nothing to compile\n")
            return
        paths.sort()
        sp = subprocess.Popen(
            ["java",
             "-ea",
             "-cp", harness.classpath(),
             "com.redhat.ceylon.compiler.Main"] + paths,
            stdout = subprocess.PIPE,
            stderr = subprocess.PIPE)
        out, err = sp.communicate()
        if sp.returncode == 0:
            open(self.actualfile, "w").write(out)
            sp = subprocess.Popen(
                ["diff", "-ubBw", self.expectfile, self.actualfile],
                stdout = subprocess.PIPE,
                stderr = subprocess.PIPE)
            out, err = sp.communicate()
            if sp.returncode == 0:
                self.handle_success(harness)
            elif sp.returncode == 1:
                self.handle_failure(harness)
            else:
                self.handle_error(harness, out, err)
        else:
            self.handle_error(harness, out, err)

    def handle_success(self, harness):
        harness.log(self.dir, "success")
        os.unlink(self.actualfile)
        for path in glob.glob(os.path.join(self.dir, "*.class")):
            os.unlink(path)

    def handle_failure(self, harness):
        harness.log(self.dir, "failure")

    def handle_error(self, harness, out, err):
        harness.log(self.dir, "error")
        sys.stdout.write(out)
        sys.stdout.write(err)

if __name__ == "__main__":
    basedir = os.path.dirname(os.path.dirname(os.path.realpath(sys.argv[0])))
    TestHarness(basedir).run(sys.argv[1:])
