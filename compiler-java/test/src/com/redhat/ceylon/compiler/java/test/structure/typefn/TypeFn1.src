package com.redhat.ceylon.compiler.java.test.structure.typefn;

@.com.redhat.ceylon.compiler.java.metadata.Ceylon(major = 8)
@.com.redhat.ceylon.compiler.java.metadata.Method
final class pipe_ {
    
    private pipe_() {
    }
    
    @.com.redhat.ceylon.compiler.java.metadata.TypeInfo("Any")
    @.com.redhat.ceylon.compiler.java.metadata.TypeParameters({@.com.redhat.ceylon.compiler.java.metadata.TypeParameter(
            value = "Any",
            variance = .com.redhat.ceylon.compiler.java.metadata.Variance.NONE,
            satisfies = {},
            caseTypes = {})})
    static <Any>Any pipe(@.com.redhat.ceylon.compiler.java.metadata.Ignore
    final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor $reified$Any, @.com.redhat.ceylon.compiler.java.metadata.Name("anything")
    @.com.redhat.ceylon.compiler.java.metadata.TypeInfo("Any")
    final Any anything) {
        return anything;
    }
}
@.com.redhat.ceylon.compiler.java.metadata.Ceylon(major = 8)
@.com.redhat.ceylon.compiler.java.metadata.Method
final class add_ {
    
    private add_() {
    }
    
    @.com.redhat.ceylon.compiler.java.metadata.TypeInfo(
            value = "Number",
            erased = true)
    @.com.redhat.ceylon.compiler.java.metadata.TypeParameters({@.com.redhat.ceylon.compiler.java.metadata.TypeParameter(
            value = "Number",
            variance = .com.redhat.ceylon.compiler.java.metadata.Variance.NONE,
            satisfies = {"ceylon.language::Summable<Number>"},
            caseTypes = {})})
    static <Number extends .ceylon.language.Summable<Number>>Number add(@.com.redhat.ceylon.compiler.java.metadata.Ignore
    final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor $reified$Number, @.com.redhat.ceylon.compiler.java.metadata.Name("x")
    @.com.redhat.ceylon.compiler.java.metadata.TypeInfo(
            value = "Number",
            erased = true)
    final Number x, @.com.redhat.ceylon.compiler.java.metadata.Name("y")
    @.com.redhat.ceylon.compiler.java.metadata.TypeInfo(
            value = "Number",
            erased = true)
    final Number y) {
        return ((Number)x).plus((Number)y);
    }
}
@.com.redhat.ceylon.compiler.java.metadata.Ceylon(major = 8)
@.com.redhat.ceylon.compiler.java.metadata.Attribute
@.com.redhat.ceylon.compiler.java.metadata.Name("pipeRef")
final class pipeRef_ {
    
    private pipeRef_() {
    }
    private static final .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor value;
    private static volatile boolean $init$value = false;
    private static final .java.lang.Throwable $initException$;
    static {
        try {
            value = (
                let
                {
                    
                    class Anonymous#pipe<Any> extends .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor implements .com.redhat.ceylon.compiler.java.runtime.model.ReifiedType {
                        
                        Anonymous#pipe() {
                            super("<Any> => Any(Any)");
                        }
                        
                        @.java.lang.Override
                        @.com.redhat.ceylon.compiler.java.metadata.Ignore
                        public .ceylon.language.Callable apply(final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor[] applied) {
                            return $apply$(applied);
                        }
                        
                        @.com.redhat.ceylon.compiler.java.metadata.Ignore
                        private .ceylon.language.Callable<? extends Any> $apply$(final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor[] applied) {
                            final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor $reified$Any = applied[0];
                            return new .com.redhat.ceylon.compiler.java.language.AbstractCallable<Any>($reified$Any, .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.tuple(false, false, -1, $reified$Any), "Any(Any)", (short)-1){
                                
                                @.java.lang.Override
                                @.com.redhat.ceylon.compiler.java.metadata.Ignore
                                public Any $call$(final .java.lang.Object $param$0) {
                                    final Any $ceylontmp$anything = (Any)$param$0;
                                    return .com.redhat.ceylon.compiler.java.test.structure.typefn.pipe_.<Any>pipe(applied[0], $ceylontmp$anything);
                                }
                            };
                        }
                        
                        @.java.lang.Override
                        @.com.redhat.ceylon.compiler.java.metadata.Ignore
                        public .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor $getType$() {
                            return (
                                let
                                {
                                    .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.TypeParameter $reified$Any = .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.typeParameter("Any", .com.redhat.ceylon.compiler.java.metadata.Variance.NONE);
                                }
                                returning .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.typeConstructor("Anonymous#pipe", new .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.TypeParameter[]{$reified$Any}, .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.ceylon.language.Callable.class, $reified$Any, .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.tuple(false, false, -1, $reified$Any)));
                            );
                        }
                    }
                }
                returning new Anonymous#pipe();
            );
            $initException$ = null;
            $init$value = true;
        } catch (.java.lang.Throwable x) {
            $initException$ = x;
            value = null;
            $init$value = false;
        }
    }
    
    @.com.redhat.ceylon.compiler.java.metadata.TypeInfo(
            value = "<Any> => Any(Any)",
            erased = true)
    public static .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor get_() {
        if (pipeRef_.$init$value) {
            return value;
        } else {
            if ($initException$ != null) .com.redhat.ceylon.compiler.java.Util.rethrow($initException$);
            throw new .ceylon.language.InitializationError("Cyclic initialization trying to read the value of \'pipeRef\' before it was set");
        }
    }
}
@.com.redhat.ceylon.compiler.java.metadata.Ceylon(major = 8)
@.com.redhat.ceylon.compiler.java.metadata.Attribute
@.com.redhat.ceylon.compiler.java.metadata.Name("addRef")
final class addRef_ {
    
    private addRef_() {
    }
    private static final .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor value;
    private static volatile boolean $init$value = false;
    private static final .java.lang.Throwable $initException$;
    static {
        try {
            value = (.com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor)(.com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor)(
                let
                {
                    
                    class Anonymous#add<Number extends .ceylon.language.Summable<Number>> extends .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor implements .com.redhat.ceylon.compiler.java.runtime.model.ReifiedType {
                        
                        Anonymous#add() {
                            super("<Number> given Number satisfies Summable<Number> => Number(Number, Number)");
                        }
                        
                        @.java.lang.Override
                        @.com.redhat.ceylon.compiler.java.metadata.Ignore
                        public .ceylon.language.Callable apply(final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor[] applied) {
                            return $apply$(applied);
                        }
                        
                        @.com.redhat.ceylon.compiler.java.metadata.Ignore
                        private .ceylon.language.Callable<? extends Number> $apply$(final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor[] applied) {
                            final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor $reified$Number = applied[0];
                            return new .com.redhat.ceylon.compiler.java.language.AbstractCallable<Number>($reified$Number, .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.tuple(false, false, -1, $reified$Number, $reified$Number), "Number(Number, Number)", (short)-1){
                                
                                @.java.lang.Override
                                @.com.redhat.ceylon.compiler.java.metadata.Ignore
                                public Number $call$(final .java.lang.Object $param$0, final .java.lang.Object $param$1) {
                                    final Number $ceylontmp$x = (Number)$param$0;
                                    final Number $ceylontmp$y = (Number)$param$1;
                                    return (Number).com.redhat.ceylon.compiler.java.test.structure.typefn.add_.<Number>add(applied[0], $ceylontmp$x, $ceylontmp$y);
                                }
                            };
                        }
                        
                        @.java.lang.Override
                        @.com.redhat.ceylon.compiler.java.metadata.Ignore
                        public .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor $getType$() {
                            return (
                                let
                                {
                                    .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.TypeParameter $reified$Number = .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.typeParameter("Number", .com.redhat.ceylon.compiler.java.metadata.Variance.NONE);
                                    $reified$Number.setSatisfiedTypes(new .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor[]{.com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.ceylon.language.Summable.class, $reified$Number)});
                                }
                                returning .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.typeConstructor("Anonymous#add", new .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.TypeParameter[]{$reified$Number}, .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.ceylon.language.Callable.class, $reified$Number, .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.tuple(false, false, -1, $reified$Number, $reified$Number)));
                            );
                        }
                    }
                }
                returning new Anonymous#add();
            );
            $initException$ = null;
            $init$value = true;
        } catch (.java.lang.Throwable x) {
            $initException$ = x;
            value = null;
            $init$value = false;
        }
    }
    
    @.com.redhat.ceylon.compiler.java.metadata.TypeInfo(
            value = "<Number> given Number satisfies ceylon.language::Summable<Number> => Number(Number, Number)",
            erased = true)
    public static .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor get_() {
        if (addRef_.$init$value) {
            return value;
        } else {
            if ($initException$ != null) .com.redhat.ceylon.compiler.java.Util.rethrow($initException$);
            throw new .ceylon.language.InitializationError("Cyclic initialization trying to read the value of \'addRef\' before it was set");
        }
    }
}
@.com.redhat.ceylon.compiler.java.metadata.Ceylon(major = 8)
@.com.redhat.ceylon.compiler.java.metadata.Attribute
@.com.redhat.ceylon.compiler.java.metadata.Name("pairRef")
final class pairRef_ {
    
    private pairRef_() {
    }
    private static final .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor value;
    private static volatile boolean $init$value = false;
    private static final .java.lang.Throwable $initException$;
    static {
        try {
            value = (
                let
                {
                    
                    class Anonymous#Entry<Key, Item> extends .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor implements .com.redhat.ceylon.compiler.java.runtime.model.ReifiedType {
                        
                        Anonymous#Entry() {
                            super("<out Key, out Item> given Key satisfies Object => <Key->Item>(Key, Item)");
                        }
                        
                        @.java.lang.Override
                        @.com.redhat.ceylon.compiler.java.metadata.Ignore
                        public .ceylon.language.Callable apply(final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor[] applied) {
                            return $apply$(applied);
                        }
                        
                        @.com.redhat.ceylon.compiler.java.metadata.Ignore
                        private .ceylon.language.Callable<? extends .ceylon.language.Entry<? extends Key, ? extends Item>> $apply$(final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor[] applied) {
                            final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor $reified$Key = applied[0];
                            final .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor $reified$Item = applied[1];
                            return new .com.redhat.ceylon.compiler.java.language.AbstractCallable<.ceylon.language.Entry<? extends Key, ? extends Item>>(.com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.ceylon.language.Entry.class, $reified$Key, $reified$Item), .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.tuple(false, false, -1, $reified$Key, $reified$Item), "<Key->Item>(Key, Item)", (short)-1){
                                
                                @.java.lang.Override
                                @.com.redhat.ceylon.compiler.java.metadata.Ignore
                                public .ceylon.language.Entry<? extends Key, ? extends Item> $call$(final .java.lang.Object $param$0, final .java.lang.Object $param$1) {
                                    final Key $ceylontmp$key = (Key)$param$0;
                                    final Item $ceylontmp$item = (Item)$param$1;
                                    return new .ceylon.language.Entry<Key, Item>(applied[0], applied[1], $ceylontmp$key, $ceylontmp$item);
                                }
                            };
                        }
                        
                        @.java.lang.Override
                        @.com.redhat.ceylon.compiler.java.metadata.Ignore
                        public .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor $getType$() {
                            return (
                                let
                                {
                                    .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.TypeParameter $reified$Key = .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.typeParameter("Key", .com.redhat.ceylon.compiler.java.metadata.Variance.OUT);
                                    $reified$Key.setSatisfiedTypes(new .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor[]{.ceylon.language.Object.$TypeDescriptor$});
                                    .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.TypeParameter $reified$Item = .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.typeParameter("Item", .com.redhat.ceylon.compiler.java.metadata.Variance.OUT);
                                }
                                returning .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.typeConstructor("Anonymous#Entry", new .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.TypeParameter[]{
                                        $reified$Key,
                                        $reified$Item}, .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.ceylon.language.Callable.class, .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.klass(.ceylon.language.Entry.class, $reified$Key, $reified$Item), .com.redhat.ceylon.compiler.java.runtime.model.TypeDescriptor.tuple(false, false, -1, $reified$Key, $reified$Item)));
                            );
                        }
                    }
                }
                returning new Anonymous#Entry();
            );
            $initException$ = null;
            $init$value = true;
        } catch (.java.lang.Throwable x) {
            $initException$ = x;
            value = null;
            $init$value = false;
        }
    }
    
    @.com.redhat.ceylon.compiler.java.metadata.TypeInfo(
            value = "<First, Second> given First satisfies ceylon.language::Object => <First->Second>(First, Second)",
            erased = true)
    public static .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor get_() {
        if (pairRef_.$init$value) {
            return value;
        } else {
            if ($initException$ != null) .com.redhat.ceylon.compiler.java.Util.rethrow($initException$);
            throw new .ceylon.language.InitializationError("Cyclic initialization trying to read the value of \'pairRef\' before it was set");
        }
    }
}
@.com.redhat.ceylon.compiler.java.metadata.Ceylon(major = 8)
@.com.redhat.ceylon.compiler.java.metadata.Attribute
@.com.redhat.ceylon.compiler.java.metadata.Name("pairRef2")
final class pairRef2_ {
    
    private pairRef2_() {
    }
    private static final .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor value;
    private static volatile boolean $init$value = false;
    private static final .java.lang.Throwable $initException$;
    static {
        try {
            value = (.com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor)(.com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor).com.redhat.ceylon.compiler.java.test.structure.typefn.pairRef_.get_();
            $initException$ = null;
            $init$value = true;
        } catch (.java.lang.Throwable x) {
            $initException$ = x;
            value = null;
            $init$value = false;
        }
    }
    
    @.com.redhat.ceylon.compiler.java.metadata.TypeInfo(
            value = "<First, Second> given First satisfies ceylon.language::Object given Second satisfies ceylon.language::Object => <First->Second>(First, Second)",
            erased = true)
    public static .com.redhat.ceylon.compiler.java.language.AbstractTypeConstructor get_() {
        if (pairRef2_.$init$value) {
            return value;
        } else {
            if ($initException$ != null) .com.redhat.ceylon.compiler.java.Util.rethrow($initException$);
            throw new .ceylon.language.InitializationError("Cyclic initialization trying to read the value of \'pairRef2\' before it was set");
        }
    }
}