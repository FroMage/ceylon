package com.redhat.ceylon.compiler.java.language;


import ceylon.language.Boolean;
import ceylon.language.Callable;
import ceylon.language.Comparison;
import ceylon.language.Entry;
import ceylon.language.Integer;
import ceylon.language.Iterable;
import ceylon.language.Iterable$impl;
import ceylon.language.Map;
import ceylon.language.Sequence;
import ceylon.language.exhausted_;

import com.redhat.ceylon.compiler.java.metadata.Class;
import com.redhat.ceylon.compiler.java.metadata.Ignore;
import com.redhat.ceylon.compiler.java.metadata.SatisfiedTypes;

/** A non-user-visible class that's useful to create Iterables in generated bytecode.
 * The getIterator() method should return a new instance in every call.
 * 
 * @author Enrique Zamudio
 */
@Ignore
@Class(extendsType="ceylon.language.Object")
@SatisfiedTypes("ceylon.language.Iterable<Element>")
public abstract class AbstractIterable<Element> implements Iterable<Element> {

    @Override
    public boolean getEmpty() {
        return getIterator().next() == exhausted_.getExhausted();
    }

    @Override
    @Ignore
    public Iterable<? extends Element> getSequence() {
        return Iterable$impl._getSequence(this);
    }
    
    @Override
    @Ignore
    public Element getFirst() {
    	return Iterable$impl._getFirst(this);
    }
    @Override @Ignore public Element getLast() {
        return Iterable$impl._getLast(this);
    }

    @Override
    @Ignore
    public Iterable<? extends Element> getRest() {
    	return Iterable$impl._getRest(this);
    }

    @Override
    public <Result> Iterable<? extends Result> map(
            Callable<? extends Result> collecting) {
        return new MapIterable<Element, Result>(this, collecting);
    }

    @Override
    public Iterable<? extends Element> filter(
            Callable<? extends Boolean> selecting) {
        return new FilterIterable<Element>(this, selecting);
    }

    @Override
    @Ignore
    public <Result> Result fold(Result initial,
            Callable<? extends Result> accumulating) {
        return Iterable$impl._fold(this, initial, accumulating);
    }

    @Override @Ignore
    public Element find(Callable<? extends Boolean> selecting) {
        return Iterable$impl._find(this, selecting);
    }

    @Override @Ignore
    public Element findLast(Callable<? extends Boolean> selecting) {
        return Iterable$impl._findLast(this, selecting);
    }

    @Override 
    @Ignore
    public Iterable<? extends Element> sort(Callable<? extends Comparison> f) { 
        return Iterable$impl._sort(this, f); 
    }
    @Override @Ignore
    public <Result> Iterable<? extends Result> collect(Callable<? extends Result> f) {
        return Iterable$impl._collect(this, f);
    }
    @Override @Ignore
    public Iterable<? extends Element> select(Callable<? extends Boolean> f) {
        return Iterable$impl._select(this, f);
    }
    @Override @Ignore
    public boolean any(Callable<? extends Boolean> f) {
        return Iterable$impl._any(this, f);
    }
    @Override @Ignore
    public boolean every(Callable<? extends Boolean> f) {
        return Iterable$impl._every(this, f);
    }
    @Override @Ignore
    public Iterable<? extends Element> skipping(long skip) {
        return Iterable$impl._skipping(this, skip);
    }
    @Override @Ignore
    public Iterable<? extends Element> taking(long take) {
        return Iterable$impl._taking(this, take);
    }
    @Override @Ignore
    public Iterable<? extends Element> by(long step) {
        return Iterable$impl._by(this, step);
    }
    @Override @Ignore
    public long count(Callable<? extends Boolean> selecting) {
        return Iterable$impl._count(this, selecting);
    }
    @Override @Ignore
    public Iterable<? extends Element> getCoalesced() {
        return Iterable$impl._getCoalesced(this);
    }
    @Override @Ignore
    public Iterable<? extends Entry<? extends Integer, ? extends Element>> getIndexed() {
        return Iterable$impl._getIndexed(this);
    }
    @Override @Ignore @SuppressWarnings("rawtypes")
    public <Other>Iterable chain(Iterable<? extends Other> other) {
        return Iterable$impl._chain(this, other);
    }
    @Override @Ignore
    public <Key> Map<? extends Key, ? extends Sequence<? extends Element>> group(Callable<? extends Key> grouping) {
        return Iterable$impl._group(this, grouping);
    }

}
