doc "Represents the range of totally ordered, ordinal values 
     generated by two endpoints of type `Ordinal` and 
     `Comparable`. If the first value is smaller than the
     last value, the range is increasing. If the first value
     is larger than the last value, the range is decreasing.
     If the two values are equal, the range contains exactly
     one element. The range is always nonempty, containing 
     at least one value."
by "Gavin"
shared class Range<Element>(Element first, Element last) 
        extends Object() 
        satisfies Sequence<Element> & Category & Equality
        given Element satisfies Ordinal<Element> & 
                                Comparable<Element> { 
    
    doc "The start of the range."
    shared actual Element first = first;
    
    doc "The end of the range."
    shared actual Element last = last;

    shared actual String string {
        return first.string + ".." + last.string;
    }
    
    doc "Determines if the range is decreasing."
    shared Boolean decreasing { 
        return last<first; 
    }
    
    Element next(Element x) {
        return decreasing then x.predecessor 
                else x.successor;
    }

    variable Natural index:=0;
    variable Element x:=first;
    while (x!=last) {
        ++index;
        x:=next(x);
    }
    
    doc "The nonzero number of elements in the range."
    shared actual Natural size = index+1;
    
    doc "The index of the end of the range."
    shared actual Natural lastIndex { 
        return index; 
    }
    
    doc "The rest of the range, without the start of the
         range."
    shared actual Element[] rest {
        Element n = next(first);
        return n==last then {} else Range<Element>(n,last);
    }
    
    doc "The element of the range that occurs `n` values after
         the start of the range. Note that this operation 
         is inefficient for large ranges."
    shared actual Element? item(Natural n) {
        //optimize this for numbers!
        variable Natural index:=0;
        variable Element x:=first;
        while (index<n) {
            if (x==last) {
                return null;
            }
            else {
                ++index;
                x:=next(x);
            }
        }
        return x;
    }
    
    doc "An iterator for the elements of the range."
    shared actual Iterator<Element> iterator {
        class RangeIterator(Element current) 
                satisfies Iterator<Element> {
            shared actual Element head { 
                return current;
            }
            shared actual Iterator<Element>? tail {
                return current==last then null
                        else RangeIterator(x);
            }
        }
        return RangeIterator(first);
    }
    
    doc "Determines if the range includes the given object."
    shared actual Boolean contains(Equality element) {
        if (is Element element) {
            return includes(element);
        }
        else {
            return false;
        }
    }
    
    doc "Determines if the range includes the given value."
    shared Boolean includes(Element x) {
        return decreasing then x<=first && x>=last
                else x>=first && x<=last;
    }
    
    /*shared Element[] excludingLast {
        throw; //todo!
    }*/

    doc "Return a sequence of values in the range, beginning 
         at the first value, and incrementing by a constant 
         step size, until a value outside the range is 
         reached. In the case of a decreasing range, the
         sequence is generated using decrements of the step
         size. The step size must be nonzero."
    shared Sequence<Element> by(Natural stepSize) {
        //todo: should we just give Range a step size? Or
        //      add a subclass, perhaps?
        if (stepSize.zero) {
            throw Exception("step size must be nonzero");
        }
        if (first==last || stepSize.unit) {
            return this;
        }
        value builder = SequenceAppender<Element>({first});
        variable Element x := next(first);
        value steps = 1..stepSize;
        while (decreasing then x>=last else x<=last) {
            builder.append(x);
            for (i in steps) {
                x := next(x);
            }
        }
        return builder.sequence;
    }

    /*shared Natural? index(Element x) {
    if (!includes(x)) {
        return null;
    }
    else {
        //optimize this for numbers!
        variable Natural index:=0;
        variable Element value:=first;
        while (value<x) {
            ++index;
            ++value;
        }
        return index;
    }
    }*/

    doc "Determines if two ranges are the same by comparing
         their endpoints."
    shared actual Boolean equals(Equality that) {
        if (is Range<Element> that) {
            return that.first==first && that.last==last;
        }
        else {
            return false;
        }
    }
    
    shared actual Integer hash {
        return first.hash/2 + last.hash/2; //todo: really should be xor
    }
    
    doc "Returns the range itself, since ranges are 
         immutable."
    shared actual Range<Element> clone {
        return this;
    }
    
    /*shared actual Set<Element> elements {
        throw; //todo!
    }*/
    
    shared actual Element[] segment(Natural from, 
                                    Natural length) {
        throw; //todo!
    }
    
    shared actual Element[] span(Natural from, Natural? to) {
        throw; //todo
    }
    
}