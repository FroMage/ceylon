doc "Represents the range of totally ordered, ordinal values 
     generated by two endpoints of type `Ordinal` and 
     `Comparable`. If the first value is smaller than the
     last value, the range is increasing. If the first value
     is larger than the last value, the range is decreasing.
     If the two values are equal, the range contains exactly
     one element. The range is always nonempty, containing 
     at least one value."
by "Gavin"
shared class Range<Element>(first, last) 
        extends Object() 
        satisfies Sequence<Element> & Category
        given Element satisfies Ordinal<Element> & 
                                Comparable<Element> { 
    
    doc "The start of the range."
    shared actual Element first;
    
    doc "The end of the range."
    shared actual Element last;

    shared actual String string {
        return first.string + ".." + last.string;
    }
    
    doc "Determines if the range is decreasing."
    shared Boolean decreasing { 
        return last<first; 
    }
    
    Element next(Element x) {
        return decreasing then x.predecessor 
                else x.successor;
    }

    variable Integer index:=0;
    variable Element x:=first;
    while (x!=last) {
        ++index;
        x:=next(x);
    }
    
    doc "The nonzero number of elements in the range."
    shared actual Integer size = index+1;
    
    doc "The index of the end of the range."
    shared actual Integer lastIndex { 
        return index; 
    }
    
    doc "The rest of the range, without the start of the
         range."
    shared actual Element[] rest {
        Element n = next(first);
        return n==last then {} else Range<Element>(n,last);
    }
    
    doc "The element of the range that occurs `n` values after
         the start of the range. Note that this operation 
         is inefficient for large ranges."
    shared actual Element? item(Integer n) {
        //optimize this for numbers!
        variable Integer index:=0;
        variable Element x:=first;
        while (index<n) {
            if (x==last) {
                return null;
            }
            else {
                ++index;
                x:=next(x);
            }
        }
        return x;
    }
    
    doc "An iterator for the elements of the range."
    shared actual Iterator<Element> iterator {
        class RangeIterator()
                satisfies Iterator<Element> {
            variable Element|Finished current := first;
            shared actual Element|Finished next() {
                Element|Finished result = current;
                if (is Element curr = current) {
                    if (curr == last) {
                        current := exhausted;
                    } 
                    else {
                        current := outer.next(curr);
                    }
                }
                return result;
            }
            shared actual String string {
                return "RangeIterator";
            }
        }
        return RangeIterator();
    }
    
    doc "Determines if the range includes the given object."
    shared actual Boolean contains(Object element) {
        if (is Element element) {
            return includes(element);
        }
        else {
            return false;
        }
    }
    
    shared actual Integer count(Object element) {
        return contains(element) then 1 else 0;
    }
    
    doc "Determines if the range includes the given value."
    shared Boolean includes(Element x) {
        return decreasing then x<=first && x>=last
                else x>=first && x<=last;
    }
    
    /*shared Element[] excludingLast {
        throw; //todo!
    }*/

    doc "Return a sequence of values in the range, beginning 
         at the first value, and incrementing by a constant 
         step size, until a value outside the range is 
         reached. In the case of a decreasing range, the
         sequence is generated using decrements of the step
         size. The step size must be nonzero."
    shared Sequence<Element> by(Integer stepSize) {
        //todo: should we just give Range a step size? Or
        //      add a subclass, perhaps?
        if (stepSize.zero) {
            throw Exception("step size must be nonzero");
        }
        if (first==last || stepSize.unit) {
            return this;
        }
        value builder = SequenceAppender<Element>({first});
        variable Element x := next(first);
        value steps = 1..stepSize;
        while (decreasing then x>=last else x<=last) {
            builder.append(x);
            for (i in steps) {
                x := next(x);
            }
        }
        return builder.sequence;
    }

    /*shared Integer? index(Element x) {
    if (!includes(x)) {
        return null;
    }
    else {
        //optimize this for numbers!
        variable Integer index:=0;
        variable Element value:=first;
        while (value<x) {
            ++index;
            ++value;
        }
        return index;
    }
    }*/

    doc "Determines if two ranges are the same by comparing
         their endpoints."
    shared actual Boolean equals(Object that) {
        if (is Range<Element> that) {
            //optimize for another Range
            return that.first==first && that.last==last;
        }
        else {
            //it might be another sort of List
            return that.equals(this);
        }
    }
    
    doc "Returns the range itself, since ranges are 
         immutable."
    shared actual Range<Element> clone {
        return this;
    }
    
    /*shared actual Set<Element> elements {
        throw; //todo!
    }*/
    
    shared actual Element[] segment(Integer from, 
                                    Integer length) {
        throw; //todo!
    }
    
    shared actual Element[] span(Integer from, Integer? to) {
        throw; //todo
    }
    
}